/* Phaser v2.18.0 - http://phaser.io - @photonstorm - (c) 2016 Photon Storm Ltd. */

function dualQuat() {
    this.real = quat.create(), this.real[Q_W] = 0, this.imaginary = quat.create(), this.imaginary[Q_W] = 0, this.tmpQ1 = quat.create()
}

function MeshBone(t, e, i, s) {
    this.key = t, this.world_rest_angle = 0, this.rest_parent_mat = mat4.create(), this.rest_parent_inv_mat = mat4.create(), this.rest_world_mat = mat4.create(), this.rest_world_inv_mat = mat4.create(), this.bind_world_mat = mat4.create(), this.bind_world_inv_mat = mat4.create(), this.parent_world_mat = mat4.create(), this.parent_world_inv_mat = mat4.create(), this.local_rest_start_pt = null, this.local_rest_end_pt = null, this.setRestParentMat(s, null), this.setLocalRestStartPt(e), this.setLocalRestEndPt(i), this.setParentWorldInvMat(mat4.create()), this.setParentWorldMat(mat4.create()), this.local_binormal_dir = vec3.fromValues(0, 0, 1), this.tag_id = 0, this.children = []
}

function MeshRenderRegion(t, e, i, s, n, r, a) {
    this.store_indices = t, this.store_rest_pts = e, this.store_uvs = i, this.use_local_displacements = !1, this.use_post_displacements = !1, this.use_uv_warp = !1, this.uv_warp_local_offset = vec2.fromValues(0, 0), this.uv_warp_global_offset = vec2.fromValues(0, 0), this.uv_warp_scale = vec2.fromValues(1, 1), this.opacity = 100, this.start_pt_index = s, this.end_pt_index = n, this.start_index = r, this.end_index = a, this.main_bone = null, this.local_displacements = [], this.post_displacements = [], this.uv_warp_ref_uvs = [], this.normal_weight_map = {}, this.fast_normal_weight_map = [], this.fast_bones_map = [], this.relevant_bones_indices = [], this.use_dq = !0, this.tag_id = -1, this.initUvWarp()
}

function MeshRenderBoneComposition() {
    this.root_bone = null, this.bones_map = {}, this.regions = [], this.regions_map = {}
}

function MeshBoneCache(t) {
    this.key = t
}

function MeshDisplacementCache(t) {
    this.key = t, this.local_displacements = [], this.post_displacements = []
}

function MeshUVWarpCache(t) {
    this.uv_warp_global_offset = vec2.create(), this.uv_warp_local_offset = vec2.create(), this.uv_warp_scale = vec2.fromValues(-1, -1), this.key = t, this.enabled = !1
}

function MeshOpacityCache(t) {
    this.opacity = 100, this.key = t
}

function MeshBoneCacheManager() {
    this.is_ready = !1, this.bone_cache_table = null, this.bone_cache_data_ready = null, this.bone_cache_table = [], this.bone_cache_data_ready = []
}

function MeshDisplacementCacheManager() {
    this.is_ready = !1, this.displacement_cache_table = null, this.displacement_cache_data_ready = null, this.displacement_cache_table = [], this.displacement_cache_data_ready = []
}

function MeshUVWarpCacheManager() {
    this.is_ready = !1, this.uv_cache_table = null, this.uv_cache_data_ready = null, this.uv_cache_table = [], this.uv_cache_data_ready = []
}

function MeshOpacityCacheManager() {
    this.is_ready = !1, this.opacity_cache_table = null, this.opacity_cache_data_ready = null, this.opacity_cache_table = [], this.opacity_cache_data_ready = []
}

function CreatureUVSwapPacket(t, e, i, s) {
    this.local_offset = t, this.global_offset = e, this.scale = i, this.tag = s
}

function Creature(t, e) {
    this.InitDefaultData(), e ? this.LoadFromDataFlat(t) : this.LoadFromData(t)
}

function CreatureAnimation(t, e, i) {
    this.initDefaultData(e), i ? this.LoadFromDataFlat(e, t.dataAnimation()) : this.LoadFromData(e, t)
}

function CreatureFrameCallback() {
    this.callback = null, this.name = "", this.animClipName = "", this.frame = 0, this.triggered = !1
}

function CreatureGameController(t) {
    this.meta_asset = t, this.event_callbacks = [], this.run_time = 0
}

function CreatureMetaData() {
    this.skin_swaps = {}, this.anim_events_map = {}
}

function CreatureManager(t) {
    this.target_creature = t, this.is_playing = !1, this.run_time = 0, this.time_scale = 30, this.blending_factor = 0, this.should_loop = !0, this.use_custom_time_range = !1, this.custom_start_time = 0, this.custom_end_time = 0, this.animations = {}, this.bones_override_callback = null, this.blend_render_pts = [], this.blend_render_pts.push([]), this.blend_render_pts.push([]), this.do_blending = !1, this.active_blend_animation_names = [], this.active_blend_animation_names.push(""), this.active_blend_animation_names.push(""), this.do_auto_blending = !1, this.auto_blend_delta = 0, this.auto_blend_names = [], this.auto_blend_names.push(""), this.auto_blend_names.push(""), this.active_blend_run_times = {}
}

function isDictEmpty(t) {
    for (var e in t) return !1;
    return !0
}! function(t, e) {
    if ("object" == typeof exports && "object" == typeof module) module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
        var i = e();
        for (var s in i)("object" == typeof exports ? exports : t)[s] = i[s]
    }
}(this, function() {
    return function(t) {
        function e(s) {
            if (i[s]) return i[s].exports;
            var n = i[s] = {
                exports: {},
                id: s,
                loaded: !1
            };
            return t[s].call(n.exports, n, n.exports, e), n.loaded = !0, n.exports
        }
        var i = {};
        return e.m = t, e.c = i, e.p = "", e(0)
    }([function(t, e, i) {
        e.glMatrix = i(1), e.mat2 = i(2), e.mat2d = i(3), e.mat3 = i(4), e.mat4 = i(5), e.quat = i(6), e.vec2 = i(9), e.vec3 = i(7), e.vec4 = i(8)
    }, function(t, e) {
        var i = {};
        i.EPSILON = 1e-6, i.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, i.RANDOM = Math.random, i.ENABLE_SIMD = !1, i.SIMD_AVAILABLE = i.ARRAY_TYPE === this.Float32Array && "SIMD" in this, i.USE_SIMD = i.ENABLE_SIMD && i.SIMD_AVAILABLE, i.setMatrixArrayType = function(t) {
            i.ARRAY_TYPE = t
        };
        var s = Math.PI / 180;
        i.toRadian = function(t) {
            return t * s
        }, i.equals = function(t, e) {
            return Math.abs(t - e) <= i.EPSILON * Math.max(1, Math.abs(t), Math.abs(e))
        }, t.exports = i
    }, function(t, e, i) {
        var s = i(1),
            n = {};
        n.create = function() {
            var t = new s.ARRAY_TYPE(4);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(4);
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
        }, n.identity = function(t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, n.fromValues = function(t, e, i, n) {
            var r = new s.ARRAY_TYPE(4);
            return r[0] = t, r[1] = e, r[2] = i, r[3] = n, r
        }, n.set = function(t, e, i, s, n) {
            return t[0] = e, t[1] = i, t[2] = s, t[3] = n, t
        }, n.transpose = function(t, e) {
            if (t === e) {
                var i = e[1];
                t[1] = e[2], t[2] = i
            } else t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3];
            return t
        }, n.invert = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = i * r - n * s;
            return a ? (a = 1 / a, t[0] = r * a, t[1] = -s * a, t[2] = -n * a, t[3] = i * a, t) : null
        }, n.adjoint = function(t, e) {
            var i = e[0];
            return t[0] = e[3], t[1] = -e[1], t[2] = -e[2], t[3] = i, t
        }, n.determinant = function(t) {
            return t[0] * t[3] - t[2] * t[1]
        }, n.multiply = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = i[0],
                h = i[1],
                l = i[2],
                u = i[3];
            return t[0] = s * o + r * h, t[1] = n * o + a * h, t[2] = s * l + r * u, t[3] = n * l + a * u, t
        }, n.mul = n.multiply, n.rotate = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = Math.sin(i),
                h = Math.cos(i);
            return t[0] = s * h + r * o, t[1] = n * h + a * o, t[2] = s * -o + r * h, t[3] = n * -o + a * h, t
        }, n.scale = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = i[0],
                h = i[1];
            return t[0] = s * o, t[1] = n * o, t[2] = r * h, t[3] = a * h, t
        }, n.fromRotation = function(t, e) {
            var i = Math.sin(e),
                s = Math.cos(e);
            return t[0] = s, t[1] = i, t[2] = -i, t[3] = s, t
        }, n.fromScaling = function(t, e) {
            return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t
        }, n.str = function(t) {
            return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
        }, n.frob = function(t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2))
        }, n.LDU = function(t, e, i, s) {
            return t[2] = s[2] / s[0], i[0] = s[0], i[1] = s[1], i[3] = s[3] - t[2] * i[1], [t, e, i]
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t[3] = e[3] - i[3], t
        }, n.sub = n.subtract, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = t[2],
                a = t[3],
                o = e[0],
                h = e[1],
                l = e[2],
                u = e[3];
            return Math.abs(i - o) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(n - h) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(r - l) <= s.EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(a - u) <= s.EPSILON * Math.max(1, Math.abs(a), Math.abs(u))
        }, n.multiplyScalar = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t
        }, n.multiplyScalarAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t[3] = e[3] + i[3] * s, t
        }, t.exports = n
    }, function(t, e, i) {
        var s = i(1),
            n = {};
        n.create = function() {
            var t = new s.ARRAY_TYPE(6);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(6);
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
        }, n.identity = function(t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
        }, n.fromValues = function(t, e, i, n, r, a) {
            var o = new s.ARRAY_TYPE(6);
            return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = r, o[5] = a, o
        }, n.set = function(t, e, i, s, n, r, a) {
            return t[0] = e, t[1] = i, t[2] = s, t[3] = n, t[4] = r, t[5] = a, t
        }, n.invert = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                h = i * r - s * n;
            return h ? (h = 1 / h, t[0] = r * h, t[1] = -s * h, t[2] = -n * h, t[3] = i * h, t[4] = (n * o - r * a) * h, t[5] = (s * a - i * o) * h, t) : null
        }, n.determinant = function(t) {
            return t[0] * t[3] - t[1] * t[2]
        }, n.multiply = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = i[0],
                u = i[1],
                c = i[2],
                d = i[3],
                p = i[4],
                f = i[5];
            return t[0] = s * l + r * u, t[1] = n * l + a * u, t[2] = s * c + r * d, t[3] = n * c + a * d, t[4] = s * p + r * f + o, t[5] = n * p + a * f + h, t
        }, n.mul = n.multiply, n.rotate = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = Math.sin(i),
                u = Math.cos(i);
            return t[0] = s * u + r * l, t[1] = n * u + a * l, t[2] = s * -l + r * u, t[3] = n * -l + a * u, t[4] = o, t[5] = h, t
        }, n.scale = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = i[0],
                u = i[1];
            return t[0] = s * l, t[1] = n * l, t[2] = r * u, t[3] = a * u, t[4] = o, t[5] = h, t
        }, n.translate = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = i[0],
                u = i[1];
            return t[0] = s, t[1] = n, t[2] = r, t[3] = a, t[4] = s * l + r * u + o, t[5] = n * l + a * u + h, t
        }, n.fromRotation = function(t, e) {
            var i = Math.sin(e),
                s = Math.cos(e);
            return t[0] = s, t[1] = i, t[2] = -i, t[3] = s, t[4] = 0, t[5] = 0, t
        }, n.fromScaling = function(t, e) {
            return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t[4] = 0, t[5] = 0, t
        }, n.fromTranslation = function(t, e) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = e[0], t[5] = e[1], t
        }, n.str = function(t) {
            return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")"
        }, n.frob = function(t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + 1)
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t[4] = e[4] + i[4], t[5] = e[5] + i[5], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t[3] = e[3] - i[3], t[4] = e[4] - i[4], t[5] = e[5] - i[5], t
        }, n.sub = n.subtract, n.multiplyScalar = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * i, t[5] = e[5] * i, t
        }, n.multiplyScalarAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t[3] = e[3] + i[3] * s, t[4] = e[4] + i[4] * s, t[5] = e[5] + i[5] * s, t
        }, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = t[2],
                a = t[3],
                o = t[4],
                h = t[5],
                l = e[0],
                u = e[1],
                c = e[2],
                d = e[3],
                p = e[4],
                f = e[5];
            return Math.abs(i - l) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(n - u) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(r - c) <= s.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(a - d) <= s.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(o - p) <= s.EPSILON * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(h - f) <= s.EPSILON * Math.max(1, Math.abs(h), Math.abs(f))
        }, t.exports = n
    }, function(t, e, i) {
        var s = i(1),
            n = {};
        n.create = function() {
            var t = new s.ARRAY_TYPE(9);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, n.fromMat4 = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(9);
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
        }, n.fromValues = function(t, e, i, n, r, a, o, h, l) {
            var u = new s.ARRAY_TYPE(9);
            return u[0] = t, u[1] = e, u[2] = i, u[3] = n, u[4] = r, u[5] = a, u[6] = o, u[7] = h, u[8] = l, u
        }, n.set = function(t, e, i, s, n, r, a, o, h, l) {
            return t[0] = e, t[1] = i, t[2] = s, t[3] = n, t[4] = r, t[5] = a, t[6] = o, t[7] = h, t[8] = l, t
        }, n.identity = function(t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, n.transpose = function(t, e) {
            if (t === e) {
                var i = e[1],
                    s = e[2],
                    n = e[5];
                t[1] = e[3], t[2] = e[6], t[3] = i, t[5] = e[7], t[6] = s, t[7] = n
            } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
            return t
        }, n.invert = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                h = e[6],
                l = e[7],
                u = e[8],
                c = u * a - o * l,
                d = -u * r + o * h,
                p = l * r - a * h,
                f = i * c + s * d + n * p;
            return f ? (f = 1 / f, t[0] = c * f, t[1] = (-u * s + n * l) * f, t[2] = (o * s - n * a) * f, t[3] = d * f, t[4] = (u * i - n * h) * f, t[5] = (-o * i + n * r) * f, t[6] = p * f, t[7] = (-l * i + s * h) * f, t[8] = (a * i - s * r) * f, t) : null
        }, n.adjoint = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                h = e[6],
                l = e[7],
                u = e[8];
            return t[0] = a * u - o * l, t[1] = n * l - s * u, t[2] = s * o - n * a, t[3] = o * h - r * u, t[4] = i * u - n * h, t[5] = n * r - i * o, t[6] = r * l - a * h, t[7] = s * h - i * l, t[8] = i * a - s * r, t
        }, n.determinant = function(t) {
            var e = t[0],
                i = t[1],
                s = t[2],
                n = t[3],
                r = t[4],
                a = t[5],
                o = t[6],
                h = t[7],
                l = t[8];
            return e * (l * r - a * h) + i * (-l * n + a * o) + s * (h * n - r * o)
        }, n.multiply = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = e[6],
                u = e[7],
                c = e[8],
                d = i[0],
                p = i[1],
                f = i[2],
                m = i[3],
                g = i[4],
                v = i[5],
                y = i[6],
                _ = i[7],
                x = i[8];
            return t[0] = d * s + p * a + f * l, t[1] = d * n + p * o + f * u, t[2] = d * r + p * h + f * c, t[3] = m * s + g * a + v * l, t[4] = m * n + g * o + v * u, t[5] = m * r + g * h + v * c, t[6] = y * s + _ * a + x * l, t[7] = y * n + _ * o + x * u, t[8] = y * r + _ * h + x * c, t
        }, n.mul = n.multiply, n.translate = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = e[6],
                u = e[7],
                c = e[8],
                d = i[0],
                p = i[1];
            return t[0] = s, t[1] = n, t[2] = r, t[3] = a, t[4] = o, t[5] = h, t[6] = d * s + p * a + l, t[7] = d * n + p * o + u, t[8] = d * r + p * h + c, t
        }, n.rotate = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = e[6],
                u = e[7],
                c = e[8],
                d = Math.sin(i),
                p = Math.cos(i);
            return t[0] = p * s + d * a, t[1] = p * n + d * o, t[2] = p * r + d * h, t[3] = p * a - d * s, t[4] = p * o - d * n, t[5] = p * h - d * r, t[6] = l, t[7] = u, t[8] = c, t
        }, n.scale = function(t, e, i) {
            var s = i[0],
                n = i[1];
            return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = n * e[3], t[4] = n * e[4], t[5] = n * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t
        }, n.fromTranslation = function(t, e) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t
        }, n.fromRotation = function(t, e) {
            var i = Math.sin(e),
                s = Math.cos(e);
            return t[0] = s, t[1] = i, t[2] = 0, t[3] = -i, t[4] = s, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, n.fromScaling = function(t, e) {
            return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t
        }, n.fromMat2d = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t
        }, n.fromQuat = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = i + i,
                o = s + s,
                h = n + n,
                l = i * a,
                u = s * a,
                c = s * o,
                d = n * a,
                p = n * o,
                f = n * h,
                m = r * a,
                g = r * o,
                v = r * h;
            return t[0] = 1 - c - f, t[3] = u - v, t[6] = d + g, t[1] = u + v, t[4] = 1 - l - f, t[7] = p - m, t[2] = d - g, t[5] = p + m, t[8] = 1 - l - c, t
        }, n.normalFromMat4 = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                h = e[6],
                l = e[7],
                u = e[8],
                c = e[9],
                d = e[10],
                p = e[11],
                f = e[12],
                m = e[13],
                g = e[14],
                v = e[15],
                y = i * o - s * a,
                _ = i * h - n * a,
                x = i * l - r * a,
                b = s * h - n * o,
                T = s * l - r * o,
                S = n * l - r * h,
                w = u * m - c * f,
                M = u * g - d * f,
                C = u * v - p * f,
                P = c * g - d * m,
                E = c * v - p * m,
                A = d * v - p * g,
                I = y * A - _ * E + x * P + b * C - T * M + S * w;
            return I ? (I = 1 / I, t[0] = (o * A - h * E + l * P) * I, t[1] = (h * C - a * A - l * M) * I, t[2] = (a * E - o * C + l * w) * I, t[3] = (n * E - s * A - r * P) * I, t[4] = (i * A - n * C + r * M) * I, t[5] = (s * C - i * E - r * w) * I, t[6] = (m * S - g * T + v * b) * I, t[7] = (g * x - f * S - v * _) * I, t[8] = (f * T - m * x + v * y) * I, t) : null
        }, n.str = function(t) {
            return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")"
        }, n.frob = function(t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2))
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t[4] = e[4] + i[4], t[5] = e[5] + i[5], t[6] = e[6] + i[6], t[7] = e[7] + i[7], t[8] = e[8] + i[8], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t[3] = e[3] - i[3], t[4] = e[4] - i[4], t[5] = e[5] - i[5], t[6] = e[6] - i[6], t[7] = e[7] - i[7], t[8] = e[8] - i[8], t
        }, n.sub = n.subtract, n.multiplyScalar = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * i, t
        }, n.multiplyScalarAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t[3] = e[3] + i[3] * s, t[4] = e[4] + i[4] * s, t[5] = e[5] + i[5] * s, t[6] = e[6] + i[6] * s, t[7] = e[7] + i[7] * s, t[8] = e[8] + i[8] * s, t
        }, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = t[2],
                a = t[3],
                o = t[4],
                h = t[5],
                l = t[6],
                u = t[7],
                c = t[8],
                d = e[0],
                p = e[1],
                f = e[2],
                m = e[3],
                g = e[4],
                v = e[5],
                y = t[6],
                _ = e[7],
                x = e[8];
            return Math.abs(i - d) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(n - p) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(r - f) <= s.EPSILON * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(a - m) <= s.EPSILON * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(o - g) <= s.EPSILON * Math.max(1, Math.abs(o), Math.abs(g)) && Math.abs(h - v) <= s.EPSILON * Math.max(1, Math.abs(h), Math.abs(v)) && Math.abs(l - y) <= s.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - _) <= s.EPSILON * Math.max(1, Math.abs(u), Math.abs(_)) && Math.abs(c - x) <= s.EPSILON * Math.max(1, Math.abs(c), Math.abs(x))
        }, t.exports = n
    }, function(t, e, i) {
        var s = i(1),
            n = {
                scalar: {},
                SIMD: {}
            };
        n.create = function() {
            var t = new s.ARRAY_TYPE(16);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(16);
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
        }, n.fromValues = function(t, e, i, n, r, a, o, h, l, u, c, d, p, f, m, g) {
            var v = new s.ARRAY_TYPE(16);
            return v[0] = t, v[1] = e, v[2] = i, v[3] = n, v[4] = r, v[5] = a, v[6] = o, v[7] = h, v[8] = l, v[9] = u, v[10] = c, v[11] = d, v[12] = p, v[13] = f, v[14] = m, v[15] = g, v
        }, n.set = function(t, e, i, s, n, r, a, o, h, l, u, c, d, p, f, m, g) {
            return t[0] = e, t[1] = i, t[2] = s, t[3] = n, t[4] = r, t[5] = a, t[6] = o, t[7] = h, t[8] = l, t[9] = u, t[10] = c, t[11] = d, t[12] = p, t[13] = f, t[14] = m, t[15] = g, t
        }, n.identity = function(t) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.scalar.transpose = function(t, e) {
            if (t === e) {
                var i = e[1],
                    s = e[2],
                    n = e[3],
                    r = e[6],
                    a = e[7],
                    o = e[11];
                t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = i, t[6] = e[9], t[7] = e[13], t[8] = s, t[9] = r, t[11] = e[14], t[12] = n, t[13] = a, t[14] = o
            } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
            return t
        }, n.SIMD.transpose = function(t, e) {
            var i, s, n, r, a, o, h, l, u, c;
            return i = SIMD.Float32x4.load(e, 0), s = SIMD.Float32x4.load(e, 4), n = SIMD.Float32x4.load(e, 8), r = SIMD.Float32x4.load(e, 12), a = SIMD.Float32x4.shuffle(i, s, 0, 1, 4, 5), o = SIMD.Float32x4.shuffle(n, r, 0, 1, 4, 5), h = SIMD.Float32x4.shuffle(a, o, 0, 2, 4, 6), l = SIMD.Float32x4.shuffle(a, o, 1, 3, 5, 7), SIMD.Float32x4.store(t, 0, h), SIMD.Float32x4.store(t, 4, l), a = SIMD.Float32x4.shuffle(i, s, 2, 3, 6, 7), o = SIMD.Float32x4.shuffle(n, r, 2, 3, 6, 7), u = SIMD.Float32x4.shuffle(a, o, 0, 2, 4, 6), c = SIMD.Float32x4.shuffle(a, o, 1, 3, 5, 7), SIMD.Float32x4.store(t, 8, u), SIMD.Float32x4.store(t, 12, c), t
        }, n.transpose = s.USE_SIMD ? n.SIMD.transpose : n.scalar.transpose, n.scalar.invert = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                h = e[6],
                l = e[7],
                u = e[8],
                c = e[9],
                d = e[10],
                p = e[11],
                f = e[12],
                m = e[13],
                g = e[14],
                v = e[15],
                y = i * o - s * a,
                _ = i * h - n * a,
                x = i * l - r * a,
                b = s * h - n * o,
                T = s * l - r * o,
                S = n * l - r * h,
                w = u * m - c * f,
                M = u * g - d * f,
                C = u * v - p * f,
                P = c * g - d * m,
                E = c * v - p * m,
                A = d * v - p * g,
                I = y * A - _ * E + x * P + b * C - T * M + S * w;
            return I ? (I = 1 / I, t[0] = (o * A - h * E + l * P) * I, t[1] = (n * E - s * A - r * P) * I, t[2] = (m * S - g * T + v * b) * I, t[3] = (d * T - c * S - p * b) * I, t[4] = (h * C - a * A - l * M) * I, t[5] = (i * A - n * C + r * M) * I, t[6] = (g * x - f * S - v * _) * I, t[7] = (u * S - d * x + p * _) * I, t[8] = (a * E - o * C + l * w) * I, t[9] = (s * C - i * E - r * w) * I, t[10] = (f * T - m * x + v * y) * I, t[11] = (c * x - u * T - p * y) * I, t[12] = (o * M - a * P - h * w) * I, t[13] = (i * P - s * M + n * w) * I, t[14] = (m * _ - f * b - g * y) * I, t[15] = (u * b - c * _ + d * y) * I, t) : null
        }, n.SIMD.invert = function(t, e) {
            var i, s, n, r, a, o, h, l, u, c, d = SIMD.Float32x4.load(e, 0),
                p = SIMD.Float32x4.load(e, 4),
                f = SIMD.Float32x4.load(e, 8),
                m = SIMD.Float32x4.load(e, 12);
            return a = SIMD.Float32x4.shuffle(d, p, 0, 1, 4, 5), s = SIMD.Float32x4.shuffle(f, m, 0, 1, 4, 5), i = SIMD.Float32x4.shuffle(a, s, 0, 2, 4, 6), s = SIMD.Float32x4.shuffle(s, a, 1, 3, 5, 7), a = SIMD.Float32x4.shuffle(d, p, 2, 3, 6, 7), r = SIMD.Float32x4.shuffle(f, m, 2, 3, 6, 7), n = SIMD.Float32x4.shuffle(a, r, 0, 2, 4, 6), r = SIMD.Float32x4.shuffle(r, a, 1, 3, 5, 7), a = SIMD.Float32x4.mul(n, r), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), o = SIMD.Float32x4.mul(s, a), h = SIMD.Float32x4.mul(i, a), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), o = SIMD.Float32x4.sub(SIMD.Float32x4.mul(s, a), o), h = SIMD.Float32x4.sub(SIMD.Float32x4.mul(i, a), h), h = SIMD.Float32x4.swizzle(h, 2, 3, 0, 1), a = SIMD.Float32x4.mul(s, n), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), o = SIMD.Float32x4.add(SIMD.Float32x4.mul(r, a), o), u = SIMD.Float32x4.mul(i, a), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), o = SIMD.Float32x4.sub(o, SIMD.Float32x4.mul(r, a)), u = SIMD.Float32x4.sub(SIMD.Float32x4.mul(i, a), u), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), a = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s, 2, 3, 0, 1), r), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), n = SIMD.Float32x4.swizzle(n, 2, 3, 0, 1), o = SIMD.Float32x4.add(SIMD.Float32x4.mul(n, a), o), l = SIMD.Float32x4.mul(i, a), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), o = SIMD.Float32x4.sub(o, SIMD.Float32x4.mul(n, a)), l = SIMD.Float32x4.sub(SIMD.Float32x4.mul(i, a), l), l = SIMD.Float32x4.swizzle(l, 2, 3, 0, 1), a = SIMD.Float32x4.mul(i, s), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), l = SIMD.Float32x4.add(SIMD.Float32x4.mul(r, a), l), u = SIMD.Float32x4.sub(SIMD.Float32x4.mul(n, a), u), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), l = SIMD.Float32x4.sub(SIMD.Float32x4.mul(r, a), l), u = SIMD.Float32x4.sub(u, SIMD.Float32x4.mul(n, a)), a = SIMD.Float32x4.mul(i, r), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), h = SIMD.Float32x4.sub(h, SIMD.Float32x4.mul(n, a)), l = SIMD.Float32x4.add(SIMD.Float32x4.mul(s, a), l), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), h = SIMD.Float32x4.add(SIMD.Float32x4.mul(n, a), h), l = SIMD.Float32x4.sub(l, SIMD.Float32x4.mul(s, a)), a = SIMD.Float32x4.mul(i, n), a = SIMD.Float32x4.swizzle(a, 1, 0, 3, 2), h = SIMD.Float32x4.add(SIMD.Float32x4.mul(r, a), h), u = SIMD.Float32x4.sub(u, SIMD.Float32x4.mul(s, a)), a = SIMD.Float32x4.swizzle(a, 2, 3, 0, 1), h = SIMD.Float32x4.sub(h, SIMD.Float32x4.mul(r, a)), u = SIMD.Float32x4.add(SIMD.Float32x4.mul(s, a), u), c = SIMD.Float32x4.mul(i, o), c = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c, 2, 3, 0, 1), c), c = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(c, 1, 0, 3, 2), c), a = SIMD.Float32x4.reciprocalApproximation(c), c = SIMD.Float32x4.sub(SIMD.Float32x4.add(a, a), SIMD.Float32x4.mul(c, SIMD.Float32x4.mul(a, a))), (c = SIMD.Float32x4.swizzle(c, 0, 0, 0, 0)) ? (SIMD.Float32x4.store(t, 0, SIMD.Float32x4.mul(c, o)), SIMD.Float32x4.store(t, 4, SIMD.Float32x4.mul(c, h)), SIMD.Float32x4.store(t, 8, SIMD.Float32x4.mul(c, l)), SIMD.Float32x4.store(t, 12, SIMD.Float32x4.mul(c, u)), t) : null
        }, n.invert = s.USE_SIMD ? n.SIMD.invert : n.scalar.invert, n.scalar.adjoint = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = e[4],
                o = e[5],
                h = e[6],
                l = e[7],
                u = e[8],
                c = e[9],
                d = e[10],
                p = e[11],
                f = e[12],
                m = e[13],
                g = e[14],
                v = e[15];
            return t[0] = o * (d * v - p * g) - c * (h * v - l * g) + m * (h * p - l * d), t[1] = -(s * (d * v - p * g) - c * (n * v - r * g) + m * (n * p - r * d)), t[2] = s * (h * v - l * g) - o * (n * v - r * g) + m * (n * l - r * h), t[3] = -(s * (h * p - l * d) - o * (n * p - r * d) + c * (n * l - r * h)), t[4] = -(a * (d * v - p * g) - u * (h * v - l * g) + f * (h * p - l * d)), t[5] = i * (d * v - p * g) - u * (n * v - r * g) + f * (n * p - r * d), t[6] = -(i * (h * v - l * g) - a * (n * v - r * g) + f * (n * l - r * h)), t[7] = i * (h * p - l * d) - a * (n * p - r * d) + u * (n * l - r * h), t[8] = a * (c * v - p * m) - u * (o * v - l * m) + f * (o * p - l * c), t[9] = -(i * (c * v - p * m) - u * (s * v - r * m) + f * (s * p - r * c)), t[10] = i * (o * v - l * m) - a * (s * v - r * m) + f * (s * l - r * o), t[11] = -(i * (o * p - l * c) - a * (s * p - r * c) + u * (s * l - r * o)), t[12] = -(a * (c * g - d * m) - u * (o * g - h * m) + f * (o * d - h * c)), t[13] = i * (c * g - d * m) - u * (s * g - n * m) + f * (s * d - n * c), t[14] = -(i * (o * g - h * m) - a * (s * g - n * m) + f * (s * h - n * o)), t[15] = i * (o * d - h * c) - a * (s * d - n * c) + u * (s * h - n * o), t
        }, n.SIMD.adjoint = function(t, e) {
            var i, s, n, r, a, o, h, l, u, c, d, p, f;
            return i = SIMD.Float32x4.load(e, 0), s = SIMD.Float32x4.load(e, 4), n = SIMD.Float32x4.load(e, 8), r = SIMD.Float32x4.load(e, 12), u = SIMD.Float32x4.shuffle(i, s, 0, 1, 4, 5), o = SIMD.Float32x4.shuffle(n, r, 0, 1, 4, 5), a = SIMD.Float32x4.shuffle(u, o, 0, 2, 4, 6), o = SIMD.Float32x4.shuffle(o, u, 1, 3, 5, 7), u = SIMD.Float32x4.shuffle(i, s, 2, 3, 6, 7), l = SIMD.Float32x4.shuffle(n, r, 2, 3, 6, 7), h = SIMD.Float32x4.shuffle(u, l, 0, 2, 4, 6), l = SIMD.Float32x4.shuffle(l, u, 1, 3, 5, 7), u = SIMD.Float32x4.mul(h, l), u = SIMD.Float32x4.swizzle(u, 1, 0, 3, 2), c = SIMD.Float32x4.mul(o, u), d = SIMD.Float32x4.mul(a, u), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), c = SIMD.Float32x4.sub(SIMD.Float32x4.mul(o, u), c), d = SIMD.Float32x4.sub(SIMD.Float32x4.mul(a, u), d), d = SIMD.Float32x4.swizzle(d, 2, 3, 0, 1), u = SIMD.Float32x4.mul(o, h), u = SIMD.Float32x4.swizzle(u, 1, 0, 3, 2), c = SIMD.Float32x4.add(SIMD.Float32x4.mul(l, u), c), f = SIMD.Float32x4.mul(a, u), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), c = SIMD.Float32x4.sub(c, SIMD.Float32x4.mul(l, u)), f = SIMD.Float32x4.sub(SIMD.Float32x4.mul(a, u), f), f = SIMD.Float32x4.swizzle(f, 2, 3, 0, 1), u = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(o, 2, 3, 0, 1), l), u = SIMD.Float32x4.swizzle(u, 1, 0, 3, 2), h = SIMD.Float32x4.swizzle(h, 2, 3, 0, 1), c = SIMD.Float32x4.add(SIMD.Float32x4.mul(h, u), c), p = SIMD.Float32x4.mul(a, u), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), c = SIMD.Float32x4.sub(c, SIMD.Float32x4.mul(h, u)), p = SIMD.Float32x4.sub(SIMD.Float32x4.mul(a, u), p), p = SIMD.Float32x4.swizzle(p, 2, 3, 0, 1), u = SIMD.Float32x4.mul(a, o), u = SIMD.Float32x4.swizzle(u, 1, 0, 3, 2), p = SIMD.Float32x4.add(SIMD.Float32x4.mul(l, u), p), f = SIMD.Float32x4.sub(SIMD.Float32x4.mul(h, u), f), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), p = SIMD.Float32x4.sub(SIMD.Float32x4.mul(l, u), p), f = SIMD.Float32x4.sub(f, SIMD.Float32x4.mul(h, u)), u = SIMD.Float32x4.mul(a, l), u = SIMD.Float32x4.swizzle(u, 1, 0, 3, 2), d = SIMD.Float32x4.sub(d, SIMD.Float32x4.mul(h, u)), p = SIMD.Float32x4.add(SIMD.Float32x4.mul(o, u), p), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), d = SIMD.Float32x4.add(SIMD.Float32x4.mul(h, u), d), p = SIMD.Float32x4.sub(p, SIMD.Float32x4.mul(o, u)), u = SIMD.Float32x4.mul(a, h), u = SIMD.Float32x4.swizzle(u, 1, 0, 3, 2), d = SIMD.Float32x4.add(SIMD.Float32x4.mul(l, u), d), f = SIMD.Float32x4.sub(f, SIMD.Float32x4.mul(o, u)), u = SIMD.Float32x4.swizzle(u, 2, 3, 0, 1), d = SIMD.Float32x4.sub(d, SIMD.Float32x4.mul(l, u)), f = SIMD.Float32x4.add(SIMD.Float32x4.mul(o, u), f), SIMD.Float32x4.store(t, 0, c), SIMD.Float32x4.store(t, 4, d), SIMD.Float32x4.store(t, 8, p), SIMD.Float32x4.store(t, 12, f), t
        }, n.adjoint = s.USE_SIMD ? n.SIMD.adjoint : n.scalar.adjoint, n.determinant = function(t) {
            var e = t[0],
                i = t[1],
                s = t[2],
                n = t[3],
                r = t[4],
                a = t[5],
                o = t[6],
                h = t[7],
                l = t[8],
                u = t[9],
                c = t[10],
                d = t[11],
                p = t[12],
                f = t[13],
                m = t[14],
                g = t[15];
            return (e * a - i * r) * (c * g - d * m) - (e * o - s * r) * (u * g - d * f) + (e * h - n * r) * (u * m - c * f) + (i * o - s * a) * (l * g - d * p) - (i * h - n * a) * (l * m - c * p) + (s * h - n * o) * (l * f - u * p)
        }, n.SIMD.multiply = function(t, e, i) {
            var s = SIMD.Float32x4.load(e, 0),
                n = SIMD.Float32x4.load(e, 4),
                r = SIMD.Float32x4.load(e, 8),
                a = SIMD.Float32x4.load(e, 12),
                o = SIMD.Float32x4.load(i, 0),
                h = SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(o, 0, 0, 0, 0), s), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(o, 1, 1, 1, 1), n), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(o, 2, 2, 2, 2), r), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(o, 3, 3, 3, 3), a))));
            SIMD.Float32x4.store(t, 0, h);
            var l = SIMD.Float32x4.load(i, 4),
                u = SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(l, 0, 0, 0, 0), s), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(l, 1, 1, 1, 1), n), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(l, 2, 2, 2, 2), r), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(l, 3, 3, 3, 3), a))));
            SIMD.Float32x4.store(t, 4, u);
            var c = SIMD.Float32x4.load(i, 8),
                d = SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c, 0, 0, 0, 0), s), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c, 1, 1, 1, 1), n), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c, 2, 2, 2, 2), r), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(c, 3, 3, 3, 3), a))));
            SIMD.Float32x4.store(t, 8, d);
            var p = SIMD.Float32x4.load(i, 12),
                f = SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(p, 0, 0, 0, 0), s), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(p, 1, 1, 1, 1), n), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(p, 2, 2, 2, 2), r), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(p, 3, 3, 3, 3), a))));
            return SIMD.Float32x4.store(t, 12, f), t
        }, n.scalar.multiply = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = e[4],
                h = e[5],
                l = e[6],
                u = e[7],
                c = e[8],
                d = e[9],
                p = e[10],
                f = e[11],
                m = e[12],
                g = e[13],
                v = e[14],
                y = e[15],
                _ = i[0],
                x = i[1],
                b = i[2],
                T = i[3];
            return t[0] = _ * s + x * o + b * c + T * m, t[1] = _ * n + x * h + b * d + T * g, t[2] = _ * r + x * l + b * p + T * v, t[3] = _ * a + x * u + b * f + T * y, _ = i[4], x = i[5], b = i[6], T = i[7], t[4] = _ * s + x * o + b * c + T * m, t[5] = _ * n + x * h + b * d + T * g, t[6] = _ * r + x * l + b * p + T * v, t[7] = _ * a + x * u + b * f + T * y, _ = i[8], x = i[9], b = i[10], T = i[11], t[8] = _ * s + x * o + b * c + T * m, t[9] = _ * n + x * h + b * d + T * g, t[10] = _ * r + x * l + b * p + T * v, t[11] = _ * a + x * u + b * f + T * y, _ = i[12], x = i[13], b = i[14], T = i[15], t[12] = _ * s + x * o + b * c + T * m, t[13] = _ * n + x * h + b * d + T * g, t[14] = _ * r + x * l + b * p + T * v, t[15] = _ * a + x * u + b * f + T * y, t
        }, n.multiply = s.USE_SIMD ? n.SIMD.multiply : n.scalar.multiply, n.mul = n.multiply, n.scalar.translate = function(t, e, i) {
            var s, n, r, a, o, h, l, u, c, d, p, f, m = i[0],
                g = i[1],
                v = i[2];
            return e === t ? (t[12] = e[0] * m + e[4] * g + e[8] * v + e[12], t[13] = e[1] * m + e[5] * g + e[9] * v + e[13], t[14] = e[2] * m + e[6] * g + e[10] * v + e[14], t[15] = e[3] * m + e[7] * g + e[11] * v + e[15]) : (s = e[0], n = e[1], r = e[2], a = e[3], o = e[4], h = e[5], l = e[6], u = e[7], c = e[8], d = e[9], p = e[10], f = e[11], t[0] = s, t[1] = n, t[2] = r, t[3] = a, t[4] = o, t[5] = h, t[6] = l, t[7] = u, t[8] = c, t[9] = d, t[10] = p, t[11] = f, t[12] = s * m + o * g + c * v + e[12], t[13] = n * m + h * g + d * v + e[13], t[14] = r * m + l * g + p * v + e[14], t[15] = a * m + u * g + f * v + e[15]), t
        }, n.SIMD.translate = function(t, e, i) {
            var s = SIMD.Float32x4.load(e, 0),
                n = SIMD.Float32x4.load(e, 4),
                r = SIMD.Float32x4.load(e, 8),
                a = SIMD.Float32x4.load(e, 12),
                o = SIMD.Float32x4(i[0], i[1], i[2], 0);
            e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11]), s = SIMD.Float32x4.mul(s, SIMD.Float32x4.swizzle(o, 0, 0, 0, 0)), n = SIMD.Float32x4.mul(n, SIMD.Float32x4.swizzle(o, 1, 1, 1, 1)), r = SIMD.Float32x4.mul(r, SIMD.Float32x4.swizzle(o, 2, 2, 2, 2));
            var h = SIMD.Float32x4.add(s, SIMD.Float32x4.add(n, SIMD.Float32x4.add(r, a)));
            return SIMD.Float32x4.store(t, 12, h), t
        }, n.translate = s.USE_SIMD ? n.SIMD.translate : n.scalar.translate, n.scalar.scale = function(t, e, i) {
            var s = i[0],
                n = i[1],
                r = i[2];
            return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * r, t[9] = e[9] * r, t[10] = e[10] * r, t[11] = e[11] * r, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
        }, n.SIMD.scale = function(t, e, i) {
            var s, n, r, a = SIMD.Float32x4(i[0], i[1], i[2], 0);
            return s = SIMD.Float32x4.load(e, 0), SIMD.Float32x4.store(t, 0, SIMD.Float32x4.mul(s, SIMD.Float32x4.swizzle(a, 0, 0, 0, 0))), n = SIMD.Float32x4.load(e, 4), SIMD.Float32x4.store(t, 4, SIMD.Float32x4.mul(n, SIMD.Float32x4.swizzle(a, 1, 1, 1, 1))), r = SIMD.Float32x4.load(e, 8), SIMD.Float32x4.store(t, 8, SIMD.Float32x4.mul(r, SIMD.Float32x4.swizzle(a, 2, 2, 2, 2))), t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
        }, n.scale = s.USE_SIMD ? n.SIMD.scale : n.scalar.scale, n.rotate = function(t, e, i, n) {
            var r, a, o, h, l, u, c, d, p, f, m, g, v, y, _, x, b, T, S, w, M, C, P, E, A = n[0],
                I = n[1],
                R = n[2],
                D = Math.sqrt(A * A + I * I + R * R);
            return Math.abs(D) < s.EPSILON ? null : (D = 1 / D, A *= D, I *= D, R *= D, r = Math.sin(i), a = Math.cos(i), o = 1 - a, h = e[0], l = e[1], u = e[2], c = e[3], d = e[4], p = e[5], f = e[6], m = e[7], g = e[8], v = e[9], y = e[10], _ = e[11], x = A * A * o + a, b = I * A * o + R * r, T = R * A * o - I * r, S = A * I * o - R * r, w = I * I * o + a, M = R * I * o + A * r, C = A * R * o + I * r, P = I * R * o - A * r, E = R * R * o + a, t[0] = h * x + d * b + g * T, t[1] = l * x + p * b + v * T, t[2] = u * x + f * b + y * T, t[3] = c * x + m * b + _ * T, t[4] = h * S + d * w + g * M, t[5] = l * S + p * w + v * M, t[6] = u * S + f * w + y * M, t[7] = c * S + m * w + _ * M, t[8] = h * C + d * P + g * E, t[9] = l * C + p * P + v * E, t[10] = u * C + f * P + y * E, t[11] = c * C + m * P + _ * E, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t)
        }, n.scalar.rotateX = function(t, e, i) {
            var s = Math.sin(i),
                n = Math.cos(i),
                r = e[4],
                a = e[5],
                o = e[6],
                h = e[7],
                l = e[8],
                u = e[9],
                c = e[10],
                d = e[11];
            return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = r * n + l * s, t[5] = a * n + u * s, t[6] = o * n + c * s, t[7] = h * n + d * s, t[8] = l * n - r * s, t[9] = u * n - a * s, t[10] = c * n - o * s, t[11] = d * n - h * s, t
        }, n.SIMD.rotateX = function(t, e, i) {
            var s = SIMD.Float32x4.splat(Math.sin(i)),
                n = SIMD.Float32x4.splat(Math.cos(i));
            e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
            var r = SIMD.Float32x4.load(e, 4),
                a = SIMD.Float32x4.load(e, 8);
            return SIMD.Float32x4.store(t, 4, SIMD.Float32x4.add(SIMD.Float32x4.mul(r, n), SIMD.Float32x4.mul(a, s))), SIMD.Float32x4.store(t, 8, SIMD.Float32x4.sub(SIMD.Float32x4.mul(a, n), SIMD.Float32x4.mul(r, s))), t
        }, n.rotateX = s.USE_SIMD ? n.SIMD.rotateX : n.scalar.rotateX, n.scalar.rotateY = function(t, e, i) {
            var s = Math.sin(i),
                n = Math.cos(i),
                r = e[0],
                a = e[1],
                o = e[2],
                h = e[3],
                l = e[8],
                u = e[9],
                c = e[10],
                d = e[11];
            return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = r * n - l * s, t[1] = a * n - u * s, t[2] = o * n - c * s, t[3] = h * n - d * s, t[8] = r * s + l * n, t[9] = a * s + u * n, t[10] = o * s + c * n, t[11] = h * s + d * n, t
        }, n.SIMD.rotateY = function(t, e, i) {
            var s = SIMD.Float32x4.splat(Math.sin(i)),
                n = SIMD.Float32x4.splat(Math.cos(i));
            e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
            var r = SIMD.Float32x4.load(e, 0),
                a = SIMD.Float32x4.load(e, 8);
            return SIMD.Float32x4.store(t, 0, SIMD.Float32x4.sub(SIMD.Float32x4.mul(r, n), SIMD.Float32x4.mul(a, s))), SIMD.Float32x4.store(t, 8, SIMD.Float32x4.add(SIMD.Float32x4.mul(r, s), SIMD.Float32x4.mul(a, n))), t
        }, n.rotateY = s.USE_SIMD ? n.SIMD.rotateY : n.scalar.rotateY, n.scalar.rotateZ = function(t, e, i) {
            var s = Math.sin(i),
                n = Math.cos(i),
                r = e[0],
                a = e[1],
                o = e[2],
                h = e[3],
                l = e[4],
                u = e[5],
                c = e[6],
                d = e[7];
            return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = r * n + l * s, t[1] = a * n + u * s, t[2] = o * n + c * s, t[3] = h * n + d * s, t[4] = l * n - r * s, t[5] = u * n - a * s, t[6] = c * n - o * s, t[7] = d * n - h * s, t
        }, n.SIMD.rotateZ = function(t, e, i) {
            var s = SIMD.Float32x4.splat(Math.sin(i)),
                n = SIMD.Float32x4.splat(Math.cos(i));
            e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]);
            var r = SIMD.Float32x4.load(e, 0),
                a = SIMD.Float32x4.load(e, 4);
            return SIMD.Float32x4.store(t, 0, SIMD.Float32x4.add(SIMD.Float32x4.mul(r, n), SIMD.Float32x4.mul(a, s))), SIMD.Float32x4.store(t, 4, SIMD.Float32x4.sub(SIMD.Float32x4.mul(a, n), SIMD.Float32x4.mul(r, s))), t
        }, n.rotateZ = s.USE_SIMD ? n.SIMD.rotateZ : n.scalar.rotateZ, n.fromTranslation = function(t, e) {
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t
        }, n.fromScaling = function(t, e) {
            return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.fromRotation = function(t, e, i) {
            var n, r, a, o = i[0],
                h = i[1],
                l = i[2],
                u = Math.sqrt(o * o + h * h + l * l);
            return Math.abs(u) < s.EPSILON ? null : (u = 1 / u, o *= u, h *= u, l *= u, n = Math.sin(e), r = Math.cos(e), a = 1 - r, t[0] = o * o * a + r, t[1] = h * o * a + l * n, t[2] = l * o * a - h * n, t[3] = 0, t[4] = o * h * a - l * n, t[5] = h * h * a + r, t[6] = l * h * a + o * n, t[7] = 0, t[8] = o * l * a + h * n, t[9] = h * l * a - o * n, t[10] = l * l * a + r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t)
        }, n.fromXRotation = function(t, e) {
            var i = Math.sin(e),
                s = Math.cos(e);
            return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = s, t[6] = i, t[7] = 0, t[8] = 0, t[9] = -i, t[10] = s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.fromYRotation = function(t, e) {
            var i = Math.sin(e),
                s = Math.cos(e);
            return t[0] = s, t[1] = 0, t[2] = -i, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = i, t[9] = 0, t[10] = s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.fromZRotation = function(t, e) {
            var i = Math.sin(e),
                s = Math.cos(e);
            return t[0] = s, t[1] = i, t[2] = 0, t[3] = 0, t[4] = -i, t[5] = s, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.fromRotationTranslation = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = s + s,
                h = n + n,
                l = r + r,
                u = s * o,
                c = s * h,
                d = s * l,
                p = n * h,
                f = n * l,
                m = r * l,
                g = a * o,
                v = a * h,
                y = a * l;
            return t[0] = 1 - (p + m), t[1] = c + y, t[2] = d - v, t[3] = 0, t[4] = c - y, t[5] = 1 - (u + m), t[6] = f + g, t[7] = 0, t[8] = d + v, t[9] = f - g, t[10] = 1 - (u + p), t[11] = 0, t[12] = i[0], t[13] = i[1], t[14] = i[2], t[15] = 1, t
        }, n.getTranslation = function(t, e) {
            return t[0] = e[12], t[1] = e[13], t[2] = e[14], t
        }, n.getRotation = function(t, e) {
            var i = e[0] + e[5] + e[10],
                s = 0;
            return i > 0 ? (s = 2 * Math.sqrt(i + 1), t[3] = .25 * s, t[0] = (e[6] - e[9]) / s, t[1] = (e[8] - e[2]) / s, t[2] = (e[1] - e[4]) / s) : e[0] > e[5] & e[0] > e[10] ? (s = 2 * Math.sqrt(1 + e[0] - e[5] - e[10]), t[3] = (e[6] - e[9]) / s, t[0] = .25 * s, t[1] = (e[1] + e[4]) / s, t[2] = (e[8] + e[2]) / s) : e[5] > e[10] ? (s = 2 * Math.sqrt(1 + e[5] - e[0] - e[10]), t[3] = (e[8] - e[2]) / s, t[0] = (e[1] + e[4]) / s, t[1] = .25 * s, t[2] = (e[6] + e[9]) / s) : (s = 2 * Math.sqrt(1 + e[10] - e[0] - e[5]), t[3] = (e[1] - e[4]) / s, t[0] = (e[8] + e[2]) / s, t[1] = (e[6] + e[9]) / s, t[2] = .25 * s), t
        }, n.fromRotationTranslationScale = function(t, e, i, s) {
            var n = e[0],
                r = e[1],
                a = e[2],
                o = e[3],
                h = n + n,
                l = r + r,
                u = a + a,
                c = n * h,
                d = n * l,
                p = n * u,
                f = r * l,
                m = r * u,
                g = a * u,
                v = o * h,
                y = o * l,
                _ = o * u,
                x = s[0],
                b = s[1],
                T = s[2];
            return t[0] = (1 - (f + g)) * x, t[1] = (d + _) * x, t[2] = (p - y) * x, t[3] = 0, t[4] = (d - _) * b, t[5] = (1 - (c + g)) * b, t[6] = (m + v) * b, t[7] = 0, t[8] = (p + y) * T, t[9] = (m - v) * T, t[10] = (1 - (c + f)) * T, t[11] = 0, t[12] = i[0], t[13] = i[1], t[14] = i[2], t[15] = 1, t
        }, n.fromRotationTranslationScaleOrigin = function(t, e, i, s, n) {
            var r = e[0],
                a = e[1],
                o = e[2],
                h = e[3],
                l = r + r,
                u = a + a,
                c = o + o,
                d = r * l,
                p = r * u,
                f = r * c,
                m = a * u,
                g = a * c,
                v = o * c,
                y = h * l,
                _ = h * u,
                x = h * c,
                b = s[0],
                T = s[1],
                S = s[2],
                w = n[0],
                M = n[1],
                C = n[2];
            return t[0] = (1 - (m + v)) * b, t[1] = (p + x) * b, t[2] = (f - _) * b, t[3] = 0, t[4] = (p - x) * T, t[5] = (1 - (d + v)) * T, t[6] = (g + y) * T, t[7] = 0, t[8] = (f + _) * S, t[9] = (g - y) * S, t[10] = (1 - (d + m)) * S, t[11] = 0, t[12] = i[0] + w - (t[0] * w + t[4] * M + t[8] * C), t[13] = i[1] + M - (t[1] * w + t[5] * M + t[9] * C), t[14] = i[2] + C - (t[2] * w + t[6] * M + t[10] * C), t[15] = 1, t
        }, n.fromQuat = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = i + i,
                o = s + s,
                h = n + n,
                l = i * a,
                u = s * a,
                c = s * o,
                d = n * a,
                p = n * o,
                f = n * h,
                m = r * a,
                g = r * o,
                v = r * h;
            return t[0] = 1 - c - f, t[1] = u + v, t[2] = d - g, t[3] = 0, t[4] = u - v, t[5] = 1 - l - f, t[6] = p + m, t[7] = 0, t[8] = d + g, t[9] = p - m, t[10] = 1 - l - c, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
        }, n.frustum = function(t, e, i, s, n, r, a) {
            var o = 1 / (i - e),
                h = 1 / (n - s),
                l = 1 / (r - a);
            return t[0] = 2 * r * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * r * h, t[6] = 0, t[7] = 0, t[8] = (i + e) * o, t[9] = (n + s) * h, t[10] = (a + r) * l, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * r * 2 * l, t[15] = 0, t
        }, n.perspective = function(t, e, i, s, n) {
            var r = 1 / Math.tan(e / 2),
                a = 1 / (s - n);
            return t[0] = r / i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = (n + s) * a, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = 2 * n * s * a, t[15] = 0, t
        }, n.perspectiveFromFieldOfView = function(t, e, i, s) {
            var n = Math.tan(e.upDegrees * Math.PI / 180),
                r = Math.tan(e.downDegrees * Math.PI / 180),
                a = Math.tan(e.leftDegrees * Math.PI / 180),
                o = Math.tan(e.rightDegrees * Math.PI / 180),
                h = 2 / (a + o),
                l = 2 / (n + r);
            return t[0] = h, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = l, t[6] = 0, t[7] = 0, t[8] = -(a - o) * h * .5, t[9] = (n - r) * l * .5, t[10] = s / (i - s), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = s * i / (i - s), t[15] = 0, t
        }, n.ortho = function(t, e, i, s, n, r, a) {
            var o = 1 / (e - i),
                h = 1 / (s - n),
                l = 1 / (r - a);
            return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * h, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + i) * o, t[13] = (n + s) * h, t[14] = (a + r) * l, t[15] = 1, t
        }, n.lookAt = function(t, e, i, r) {
            var a, o, h, l, u, c, d, p, f, m, g = e[0],
                v = e[1],
                y = e[2],
                _ = r[0],
                x = r[1],
                b = r[2],
                T = i[0],
                S = i[1],
                w = i[2];
            return Math.abs(g - T) < s.EPSILON && Math.abs(v - S) < s.EPSILON && Math.abs(y - w) < s.EPSILON ? n.identity(t) : (d = g - T, p = v - S, f = y - w, m = 1 / Math.sqrt(d * d + p * p + f * f), d *= m, p *= m, f *= m, a = x * f - b * p, o = b * d - _ * f, h = _ * p - x * d, (m = Math.sqrt(a * a + o * o + h * h)) ? (a *= m = 1 / m, o *= m, h *= m) : (a = 0, o = 0, h = 0), l = p * h - f * o, u = f * a - d * h, c = d * o - p * a, (m = Math.sqrt(l * l + u * u + c * c)) ? (l *= m = 1 / m, u *= m, c *= m) : (l = 0, u = 0, c = 0), t[0] = a, t[1] = l, t[2] = d, t[3] = 0, t[4] = o, t[5] = u, t[6] = p, t[7] = 0, t[8] = h, t[9] = c, t[10] = f, t[11] = 0, t[12] = -(a * g + o * v + h * y), t[13] = -(l * g + u * v + c * y), t[14] = -(d * g + p * v + f * y), t[15] = 1, t)
        }, n.str = function(t) {
            return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")"
        }, n.frob = function(t) {
            return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2) + Math.pow(t[9], 2) + Math.pow(t[10], 2) + Math.pow(t[11], 2) + Math.pow(t[12], 2) + Math.pow(t[13], 2) + Math.pow(t[14], 2) + Math.pow(t[15], 2))
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t[4] = e[4] + i[4], t[5] = e[5] + i[5], t[6] = e[6] + i[6], t[7] = e[7] + i[7], t[8] = e[8] + i[8], t[9] = e[9] + i[9], t[10] = e[10] + i[10], t[11] = e[11] + i[11], t[12] = e[12] + i[12], t[13] = e[13] + i[13], t[14] = e[14] + i[14], t[15] = e[15] + i[15], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t[3] = e[3] - i[3], t[4] = e[4] - i[4], t[5] = e[5] - i[5], t[6] = e[6] - i[6], t[7] = e[7] - i[7], t[8] = e[8] - i[8], t[9] = e[9] - i[9], t[10] = e[10] - i[10], t[11] = e[11] - i[11], t[12] = e[12] - i[12], t[13] = e[13] - i[13], t[14] = e[14] - i[14], t[15] = e[15] - i[15], t
        }, n.sub = n.subtract, n.multiplyScalar = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * i, t[9] = e[9] * i, t[10] = e[10] * i, t[11] = e[11] * i, t[12] = e[12] * i, t[13] = e[13] * i, t[14] = e[14] * i, t[15] = e[15] * i, t
        }, n.multiplyScalarAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t[3] = e[3] + i[3] * s, t[4] = e[4] + i[4] * s, t[5] = e[5] + i[5] * s, t[6] = e[6] + i[6] * s, t[7] = e[7] + i[7] * s, t[8] = e[8] + i[8] * s, t[9] = e[9] + i[9] * s, t[10] = e[10] + i[10] * s, t[11] = e[11] + i[11] * s, t[12] = e[12] + i[12] * s, t[13] = e[13] + i[13] * s, t[14] = e[14] + i[14] * s, t[15] = e[15] + i[15] * s, t
        }, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = t[2],
                a = t[3],
                o = t[4],
                h = t[5],
                l = t[6],
                u = t[7],
                c = t[8],
                d = t[9],
                p = t[10],
                f = t[11],
                m = t[12],
                g = t[13],
                v = t[14],
                y = t[15],
                _ = e[0],
                x = e[1],
                b = e[2],
                T = e[3],
                S = e[4],
                w = e[5],
                M = e[6],
                C = e[7],
                P = e[8],
                E = e[9],
                A = e[10],
                I = e[11],
                R = e[12],
                D = e[13],
                O = e[14],
                F = e[15];
            return Math.abs(i - _) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(_)) && Math.abs(n - x) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(x)) && Math.abs(r - b) <= s.EPSILON * Math.max(1, Math.abs(r), Math.abs(b)) && Math.abs(a - T) <= s.EPSILON * Math.max(1, Math.abs(a), Math.abs(T)) && Math.abs(o - S) <= s.EPSILON * Math.max(1, Math.abs(o), Math.abs(S)) && Math.abs(h - w) <= s.EPSILON * Math.max(1, Math.abs(h), Math.abs(w)) && Math.abs(l - M) <= s.EPSILON * Math.max(1, Math.abs(l), Math.abs(M)) && Math.abs(u - C) <= s.EPSILON * Math.max(1, Math.abs(u), Math.abs(C)) && Math.abs(c - P) <= s.EPSILON * Math.max(1, Math.abs(c), Math.abs(P)) && Math.abs(d - E) <= s.EPSILON * Math.max(1, Math.abs(d), Math.abs(E)) && Math.abs(p - A) <= s.EPSILON * Math.max(1, Math.abs(p), Math.abs(A)) && Math.abs(f - I) <= s.EPSILON * Math.max(1, Math.abs(f), Math.abs(I)) && Math.abs(m - R) <= s.EPSILON * Math.max(1, Math.abs(m), Math.abs(R)) && Math.abs(g - D) <= s.EPSILON * Math.max(1, Math.abs(g), Math.abs(D)) && Math.abs(v - O) <= s.EPSILON * Math.max(1, Math.abs(v), Math.abs(O)) && Math.abs(y - F) <= s.EPSILON * Math.max(1, Math.abs(y), Math.abs(F))
        }, t.exports = n
    }, function(t, e, i) {
        var s = i(1),
            n = i(4),
            r = i(7),
            a = i(8),
            o = {};
        o.create = function() {
            var t = new s.ARRAY_TYPE(4);
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, o.rotationTo = function() {
            var t = r.create(),
                e = r.fromValues(1, 0, 0),
                i = r.fromValues(0, 1, 0);
            return function(s, n, a) {
                var h = r.dot(n, a);
                return h < -.999999 ? (r.cross(t, e, n), r.length(t) < 1e-6 && r.cross(t, i, n), r.normalize(t, t), o.setAxisAngle(s, t, Math.PI), s) : h > .999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (r.cross(t, n, a), s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = 1 + h, o.normalize(s, s))
            }
        }(), o.setAxes = function() {
            var t = n.create();
            return function(e, i, s, n) {
                return t[0] = s[0], t[3] = s[1], t[6] = s[2], t[1] = n[0], t[4] = n[1], t[7] = n[2], t[2] = -i[0], t[5] = -i[1], t[8] = -i[2], o.normalize(e, o.fromMat3(e, t))
            }
        }(), o.clone = a.clone, o.fromValues = a.fromValues, o.copy = a.copy, o.set = a.set, o.identity = function(t) {
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t
        }, o.setAxisAngle = function(t, e, i) {
            i *= .5;
            var s = Math.sin(i);
            return t[0] = s * e[0], t[1] = s * e[1], t[2] = s * e[2], t[3] = Math.cos(i), t
        }, o.getAxisAngle = function(t, e) {
            var i = 2 * Math.acos(e[3]),
                s = Math.sin(i / 2);
            return 0 != s ? (t[0] = e[0] / s, t[1] = e[1] / s, t[2] = e[2] / s) : (t[0] = 1, t[1] = 0, t[2] = 0), i
        }, o.add = a.add, o.multiply = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = i[0],
                h = i[1],
                l = i[2],
                u = i[3];
            return t[0] = s * u + a * o + n * l - r * h, t[1] = n * u + a * h + r * o - s * l, t[2] = r * u + a * l + s * h - n * o, t[3] = a * u - s * o - n * h - r * l, t
        }, o.mul = o.multiply, o.scale = a.scale, o.rotateX = function(t, e, i) {
            i *= .5;
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = Math.sin(i),
                h = Math.cos(i);
            return t[0] = s * h + a * o, t[1] = n * h + r * o, t[2] = r * h - n * o, t[3] = a * h - s * o, t
        }, o.rotateY = function(t, e, i) {
            i *= .5;
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = Math.sin(i),
                h = Math.cos(i);
            return t[0] = s * h - r * o, t[1] = n * h + a * o, t[2] = r * h + s * o, t[3] = a * h - n * o, t
        }, o.rotateZ = function(t, e, i) {
            i *= .5;
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3],
                o = Math.sin(i),
                h = Math.cos(i);
            return t[0] = s * h + n * o, t[1] = n * h - s * o, t[2] = r * h + a * o, t[3] = a * h - r * o, t
        }, o.calculateW = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2];
            return t[0] = i, t[1] = s, t[2] = n, t[3] = Math.sqrt(Math.abs(1 - i * i - s * s - n * n)), t
        }, o.dot = a.dot, o.lerp = a.lerp, o.slerp = function(t, e, i, s) {
            var n, r, a, o, h, l = e[0],
                u = e[1],
                c = e[2],
                d = e[3],
                p = i[0],
                f = i[1],
                m = i[2],
                g = i[3];
            return (r = l * p + u * f + c * m + d * g) < 0 && (r = -r, p = -p, f = -f, m = -m, g = -g), 1 - r > 1e-6 ? (n = Math.acos(r), a = Math.sin(n), o = Math.sin((1 - s) * n) / a, h = Math.sin(s * n) / a) : (o = 1 - s, h = s), t[0] = o * l + h * p, t[1] = o * u + h * f, t[2] = o * c + h * m, t[3] = o * d + h * g, t
        }, o.sqlerp = function() {
            var t = o.create(),
                e = o.create();
            return function(i, s, n, r, a, h) {
                return o.slerp(t, s, a, h), o.slerp(e, n, r, h), o.slerp(i, t, e, 2 * h * (1 - h)), i
            }
        }(), o.invert = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = i * i + s * s + n * n + r * r,
                o = a ? 1 / a : 0;
            return t[0] = -i * o, t[1] = -s * o, t[2] = -n * o, t[3] = r * o, t
        }, o.conjugate = function(t, e) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t
        }, o.length = a.length, o.len = o.length, o.squaredLength = a.squaredLength, o.sqrLen = o.squaredLength, o.normalize = a.normalize, o.fromMat3 = function(t, e) {
            var i, s = e[0] + e[4] + e[8];
            if (s > 0) i = Math.sqrt(s + 1), t[3] = .5 * i, i = .5 / i, t[0] = (e[5] - e[7]) * i, t[1] = (e[6] - e[2]) * i, t[2] = (e[1] - e[3]) * i;
            else {
                var n = 0;
                e[4] > e[0] && (n = 1), e[8] > e[3 * n + n] && (n = 2);
                var r = (n + 1) % 3,
                    a = (n + 2) % 3;
                i = Math.sqrt(e[3 * n + n] - e[3 * r + r] - e[3 * a + a] + 1), t[n] = .5 * i, i = .5 / i, t[3] = (e[3 * r + a] - e[3 * a + r]) * i, t[r] = (e[3 * r + n] + e[3 * n + r]) * i, t[a] = (e[3 * a + n] + e[3 * n + a]) * i
            }
            return t
        }, o.str = function(t) {
            return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
        }, o.exactEquals = a.exactEquals, o.equals = a.equals, t.exports = o
    }, function(t, e, i) {
        var s = i(1),
            n = {};
        n.create = function() {
            var t = new s.ARRAY_TYPE(3);
            return t[0] = 0, t[1] = 0, t[2] = 0, t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(3);
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
        }, n.fromValues = function(t, e, i) {
            var n = new s.ARRAY_TYPE(3);
            return n[0] = t, n[1] = e, n[2] = i, n
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
        }, n.set = function(t, e, i, s) {
            return t[0] = e, t[1] = i, t[2] = s, t
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t
        }, n.sub = n.subtract, n.multiply = function(t, e, i) {
            return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t[2] = e[2] * i[2], t
        }, n.mul = n.multiply, n.divide = function(t, e, i) {
            return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t[2] = e[2] / i[2], t
        }, n.div = n.divide, n.ceil = function(t, e) {
            return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t
        }, n.floor = function(t, e) {
            return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t
        }, n.min = function(t, e, i) {
            return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t[2] = Math.min(e[2], i[2]), t
        }, n.max = function(t, e, i) {
            return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t[2] = Math.max(e[2], i[2]), t
        }, n.round = function(t, e) {
            return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t
        }, n.scale = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t
        }, n.scaleAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t
        }, n.distance = function(t, e) {
            var i = e[0] - t[0],
                s = e[1] - t[1],
                n = e[2] - t[2];
            return Math.sqrt(i * i + s * s + n * n)
        }, n.dist = n.distance, n.squaredDistance = function(t, e) {
            var i = e[0] - t[0],
                s = e[1] - t[1],
                n = e[2] - t[2];
            return i * i + s * s + n * n
        }, n.sqrDist = n.squaredDistance, n.length = function(t) {
            var e = t[0],
                i = t[1],
                s = t[2];
            return Math.sqrt(e * e + i * i + s * s)
        }, n.len = n.length, n.squaredLength = function(t) {
            var e = t[0],
                i = t[1],
                s = t[2];
            return e * e + i * i + s * s
        }, n.sqrLen = n.squaredLength, n.negate = function(t, e) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t
        }, n.inverse = function(t, e) {
            return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t
        }, n.normalize = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = i * i + s * s + n * n;
            return r > 0 && (r = 1 / Math.sqrt(r), t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r), t
        }, n.dot = function(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
        }, n.cross = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = i[0],
                o = i[1],
                h = i[2];
            return t[0] = n * h - r * o, t[1] = r * a - s * h, t[2] = s * o - n * a, t
        }, n.lerp = function(t, e, i, s) {
            var n = e[0],
                r = e[1],
                a = e[2];
            return t[0] = n + s * (i[0] - n), t[1] = r + s * (i[1] - r), t[2] = a + s * (i[2] - a), t
        }, n.hermite = function(t, e, i, s, n, r) {
            var a = r * r,
                o = a * (2 * r - 3) + 1,
                h = a * (r - 2) + r,
                l = a * (r - 1),
                u = a * (3 - 2 * r);
            return t[0] = e[0] * o + i[0] * h + s[0] * l + n[0] * u, t[1] = e[1] * o + i[1] * h + s[1] * l + n[1] * u, t[2] = e[2] * o + i[2] * h + s[2] * l + n[2] * u, t
        }, n.bezier = function(t, e, i, s, n, r) {
            var a = 1 - r,
                o = a * a,
                h = r * r,
                l = o * a,
                u = 3 * r * o,
                c = 3 * h * a,
                d = h * r;
            return t[0] = e[0] * l + i[0] * u + s[0] * c + n[0] * d, t[1] = e[1] * l + i[1] * u + s[1] * c + n[1] * d, t[2] = e[2] * l + i[2] * u + s[2] * c + n[2] * d, t
        }, n.random = function(t, e) {
            e = e || 1;
            var i = 2 * s.RANDOM() * Math.PI,
                n = 2 * s.RANDOM() - 1,
                r = Math.sqrt(1 - n * n) * e;
            return t[0] = Math.cos(i) * r, t[1] = Math.sin(i) * r, t[2] = n * e, t
        }, n.transformMat4 = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = i[3] * s + i[7] * n + i[11] * r + i[15];
            return a = a || 1, t[0] = (i[0] * s + i[4] * n + i[8] * r + i[12]) / a, t[1] = (i[1] * s + i[5] * n + i[9] * r + i[13]) / a, t[2] = (i[2] * s + i[6] * n + i[10] * r + i[14]) / a, t
        }, n.transformMat3 = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2];
            return t[0] = s * i[0] + n * i[3] + r * i[6], t[1] = s * i[1] + n * i[4] + r * i[7], t[2] = s * i[2] + n * i[5] + r * i[8], t
        }, n.transformQuat = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = i[0],
                o = i[1],
                h = i[2],
                l = i[3],
                u = l * s + o * r - h * n,
                c = l * n + h * s - a * r,
                d = l * r + a * n - o * s,
                p = -a * s - o * n - h * r;
            return t[0] = u * l + p * -a + c * -h - d * -o, t[1] = c * l + p * -o + d * -a - u * -h, t[2] = d * l + p * -h + u * -o - c * -a, t
        }, n.rotateX = function(t, e, i, s) {
            var n = [],
                r = [];
            return n[0] = e[0] - i[0], n[1] = e[1] - i[1], n[2] = e[2] - i[2], r[0] = n[0], r[1] = n[1] * Math.cos(s) - n[2] * Math.sin(s), r[2] = n[1] * Math.sin(s) + n[2] * Math.cos(s), t[0] = r[0] + i[0], t[1] = r[1] + i[1], t[2] = r[2] + i[2], t
        }, n.rotateY = function(t, e, i, s) {
            var n = [],
                r = [];
            return n[0] = e[0] - i[0], n[1] = e[1] - i[1], n[2] = e[2] - i[2], r[0] = n[2] * Math.sin(s) + n[0] * Math.cos(s), r[1] = n[1], r[2] = n[2] * Math.cos(s) - n[0] * Math.sin(s), t[0] = r[0] + i[0], t[1] = r[1] + i[1], t[2] = r[2] + i[2], t
        }, n.rotateZ = function(t, e, i, s) {
            var n = [],
                r = [];
            return n[0] = e[0] - i[0], n[1] = e[1] - i[1], n[2] = e[2] - i[2], r[0] = n[0] * Math.cos(s) - n[1] * Math.sin(s), r[1] = n[0] * Math.sin(s) + n[1] * Math.cos(s), r[2] = n[2], t[0] = r[0] + i[0], t[1] = r[1] + i[1], t[2] = r[2] + i[2], t
        }, n.forEach = function() {
            var t = n.create();
            return function(e, i, s, n, r, a) {
                var o, h;
                for (i || (i = 3), s || (s = 0), h = n ? Math.min(n * i + s, e.length) : e.length, o = s; o < h; o += i) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], r(t, t, a), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2];
                return e
            }
        }(), n.angle = function(t, e) {
            var i = n.fromValues(t[0], t[1], t[2]),
                s = n.fromValues(e[0], e[1], e[2]);
            n.normalize(i, i), n.normalize(s, s);
            var r = n.dot(i, s);
            return r > 1 ? 0 : Math.acos(r)
        }, n.str = function(t) {
            return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
        }, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = t[2],
                a = e[0],
                o = e[1],
                h = e[2];
            return Math.abs(i - a) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(n - o) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(r - h) <= s.EPSILON * Math.max(1, Math.abs(r), Math.abs(h))
        }, t.exports = n
    }, function(t, e, i) {
        var s = i(1),
            n = {};
        n.create = function() {
            var t = new s.ARRAY_TYPE(4);
            return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(4);
            return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
        }, n.fromValues = function(t, e, i, n) {
            var r = new s.ARRAY_TYPE(4);
            return r[0] = t, r[1] = e, r[2] = i, r[3] = n, r
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
        }, n.set = function(t, e, i, s, n) {
            return t[0] = e, t[1] = i, t[2] = s, t[3] = n, t
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t[3] = e[3] + i[3], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t[3] = e[3] - i[3], t
        }, n.sub = n.subtract, n.multiply = function(t, e, i) {
            return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t[2] = e[2] * i[2], t[3] = e[3] * i[3], t
        }, n.mul = n.multiply, n.divide = function(t, e, i) {
            return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t[2] = e[2] / i[2], t[3] = e[3] / i[3], t
        }, n.div = n.divide, n.ceil = function(t, e) {
            return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t
        }, n.floor = function(t, e) {
            return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t
        }, n.min = function(t, e, i) {
            return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t[2] = Math.min(e[2], i[2]), t[3] = Math.min(e[3], i[3]), t
        }, n.max = function(t, e, i) {
            return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t[2] = Math.max(e[2], i[2]), t[3] = Math.max(e[3], i[3]), t
        }, n.round = function(t, e) {
            return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t[3] = Math.round(e[3]), t
        }, n.scale = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t
        }, n.scaleAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t[3] = e[3] + i[3] * s, t
        }, n.distance = function(t, e) {
            var i = e[0] - t[0],
                s = e[1] - t[1],
                n = e[2] - t[2],
                r = e[3] - t[3];
            return Math.sqrt(i * i + s * s + n * n + r * r)
        }, n.dist = n.distance, n.squaredDistance = function(t, e) {
            var i = e[0] - t[0],
                s = e[1] - t[1],
                n = e[2] - t[2],
                r = e[3] - t[3];
            return i * i + s * s + n * n + r * r
        }, n.sqrDist = n.squaredDistance, n.length = function(t) {
            var e = t[0],
                i = t[1],
                s = t[2],
                n = t[3];
            return Math.sqrt(e * e + i * i + s * s + n * n)
        }, n.len = n.length, n.squaredLength = function(t) {
            var e = t[0],
                i = t[1],
                s = t[2],
                n = t[3];
            return e * e + i * i + s * s + n * n
        }, n.sqrLen = n.squaredLength, n.negate = function(t, e) {
            return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t
        }, n.inverse = function(t, e) {
            return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t
        }, n.normalize = function(t, e) {
            var i = e[0],
                s = e[1],
                n = e[2],
                r = e[3],
                a = i * i + s * s + n * n + r * r;
            return a > 0 && (a = 1 / Math.sqrt(a), t[0] = i * a, t[1] = s * a, t[2] = n * a, t[3] = r * a), t
        }, n.dot = function(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3]
        }, n.lerp = function(t, e, i, s) {
            var n = e[0],
                r = e[1],
                a = e[2],
                o = e[3];
            return t[0] = n + s * (i[0] - n), t[1] = r + s * (i[1] - r), t[2] = a + s * (i[2] - a), t[3] = o + s * (i[3] - o), t
        }, n.random = function(t, e) {
            return e = e || 1, t[0] = s.RANDOM(), t[1] = s.RANDOM(), t[2] = s.RANDOM(), t[3] = s.RANDOM(), n.normalize(t, t), n.scale(t, t, e), t
        }, n.transformMat4 = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = e[3];
            return t[0] = i[0] * s + i[4] * n + i[8] * r + i[12] * a, t[1] = i[1] * s + i[5] * n + i[9] * r + i[13] * a, t[2] = i[2] * s + i[6] * n + i[10] * r + i[14] * a, t[3] = i[3] * s + i[7] * n + i[11] * r + i[15] * a, t
        }, n.transformQuat = function(t, e, i) {
            var s = e[0],
                n = e[1],
                r = e[2],
                a = i[0],
                o = i[1],
                h = i[2],
                l = i[3],
                u = l * s + o * r - h * n,
                c = l * n + h * s - a * r,
                d = l * r + a * n - o * s,
                p = -a * s - o * n - h * r;
            return t[0] = u * l + p * -a + c * -h - d * -o, t[1] = c * l + p * -o + d * -a - u * -h, t[2] = d * l + p * -h + u * -o - c * -a, t[3] = e[3], t
        }, n.forEach = function() {
            var t = n.create();
            return function(e, i, s, n, r, a) {
                var o, h;
                for (i || (i = 4), s || (s = 0), h = n ? Math.min(n * i + s, e.length) : e.length, o = s; o < h; o += i) t[0] = e[o], t[1] = e[o + 1], t[2] = e[o + 2], t[3] = e[o + 3], r(t, t, a), e[o] = t[0], e[o + 1] = t[1], e[o + 2] = t[2], e[o + 3] = t[3];
                return e
            }
        }(), n.str = function(t) {
            return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")"
        }, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = t[2],
                a = t[3],
                o = e[0],
                h = e[1],
                l = e[2],
                u = e[3];
            return Math.abs(i - o) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(n - h) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(r - l) <= s.EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(a - u) <= s.EPSILON * Math.max(1, Math.abs(a), Math.abs(u))
        }, t.exports = n
    }, function(t, e, i) {
        var s = i(1),
            n = {};
        n.create = function() {
            var t = new s.ARRAY_TYPE(2);
            return t[0] = 0, t[1] = 0, t
        }, n.clone = function(t) {
            var e = new s.ARRAY_TYPE(2);
            return e[0] = t[0], e[1] = t[1], e
        }, n.fromValues = function(t, e) {
            var i = new s.ARRAY_TYPE(2);
            return i[0] = t, i[1] = e, i
        }, n.copy = function(t, e) {
            return t[0] = e[0], t[1] = e[1], t
        }, n.set = function(t, e, i) {
            return t[0] = e, t[1] = i, t
        }, n.add = function(t, e, i) {
            return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
        }, n.subtract = function(t, e, i) {
            return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
        }, n.sub = n.subtract, n.multiply = function(t, e, i) {
            return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
        }, n.mul = n.multiply, n.divide = function(t, e, i) {
            return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
        }, n.div = n.divide, n.ceil = function(t, e) {
            return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t
        }, n.floor = function(t, e) {
            return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t
        }, n.min = function(t, e, i) {
            return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
        }, n.max = function(t, e, i) {
            return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
        }, n.round = function(t, e) {
            return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t
        }, n.scale = function(t, e, i) {
            return t[0] = e[0] * i, t[1] = e[1] * i, t
        }, n.scaleAndAdd = function(t, e, i, s) {
            return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t
        }, n.distance = function(t, e) {
            var i = e[0] - t[0],
                s = e[1] - t[1];
            return Math.sqrt(i * i + s * s)
        }, n.dist = n.distance, n.squaredDistance = function(t, e) {
            var i = e[0] - t[0],
                s = e[1] - t[1];
            return i * i + s * s
        }, n.sqrDist = n.squaredDistance, n.length = function(t) {
            var e = t[0],
                i = t[1];
            return Math.sqrt(e * e + i * i)
        }, n.len = n.length, n.squaredLength = function(t) {
            var e = t[0],
                i = t[1];
            return e * e + i * i
        }, n.sqrLen = n.squaredLength, n.negate = function(t, e) {
            return t[0] = -e[0], t[1] = -e[1], t
        }, n.inverse = function(t, e) {
            return t[0] = 1 / e[0], t[1] = 1 / e[1], t
        }, n.normalize = function(t, e) {
            var i = e[0],
                s = e[1],
                n = i * i + s * s;
            return n > 0 && (n = 1 / Math.sqrt(n), t[0] = e[0] * n, t[1] = e[1] * n), t
        }, n.dot = function(t, e) {
            return t[0] * e[0] + t[1] * e[1]
        }, n.cross = function(t, e, i) {
            var s = e[0] * i[1] - e[1] * i[0];
            return t[0] = t[1] = 0, t[2] = s, t
        }, n.lerp = function(t, e, i, s) {
            var n = e[0],
                r = e[1];
            return t[0] = n + s * (i[0] - n), t[1] = r + s * (i[1] - r), t
        }, n.random = function(t, e) {
            e = e || 1;
            var i = 2 * s.RANDOM() * Math.PI;
            return t[0] = Math.cos(i) * e, t[1] = Math.sin(i) * e, t
        }, n.transformMat2 = function(t, e, i) {
            var s = e[0],
                n = e[1];
            return t[0] = i[0] * s + i[2] * n, t[1] = i[1] * s + i[3] * n, t
        }, n.transformMat2d = function(t, e, i) {
            var s = e[0],
                n = e[1];
            return t[0] = i[0] * s + i[2] * n + i[4], t[1] = i[1] * s + i[3] * n + i[5], t
        }, n.transformMat3 = function(t, e, i) {
            var s = e[0],
                n = e[1];
            return t[0] = i[0] * s + i[3] * n + i[6], t[1] = i[1] * s + i[4] * n + i[7], t
        }, n.transformMat4 = function(t, e, i) {
            var s = e[0],
                n = e[1];
            return t[0] = i[0] * s + i[4] * n + i[12], t[1] = i[1] * s + i[5] * n + i[13], t
        }, n.forEach = function() {
            var t = n.create();
            return function(e, i, s, n, r, a) {
                var o, h;
                for (i || (i = 2), s || (s = 0), h = n ? Math.min(n * i + s, e.length) : e.length, o = s; o < h; o += i) t[0] = e[o], t[1] = e[o + 1], r(t, t, a), e[o] = t[0], e[o + 1] = t[1];
                return e
            }
        }(), n.str = function(t) {
            return "vec2(" + t[0] + ", " + t[1] + ")"
        }, n.exactEquals = function(t, e) {
            return t[0] === e[0] && t[1] === e[1]
        }, n.equals = function(t, e) {
            var i = t[0],
                n = t[1],
                r = e[0],
                a = e[1];
            return Math.abs(i - r) <= s.EPSILON * Math.max(1, Math.abs(i), Math.abs(r)) && Math.abs(n - a) <= s.EPSILON * Math.max(1, Math.abs(n), Math.abs(a))
        }, t.exports = n
    }])
});
var Q_X = 0,
    Q_Y = 1,
    Q_Z = 2,
    Q_W = 3;
dualQuat.prototype.reset = function() {
    quat.identity(this.real), this.real[Q_W] = 0, quat.identity(this.imaginary), this.imaginary[Q_W] = 0, quat.identity(this.tmpQ1)
}, dualQuat.prototype.createFromData = function(t, e) {
    this.real = t, this.imaginary = quat.create(), this.imaginary[Q_W] = -.5 * (e[Q_X] * t[Q_X] + e[Q_Y] * t[Q_Y] + e[Q_Z] * t[Q_Z]), this.imaginary[Q_X] = .5 * (e[Q_X] * t[Q_W] + e[Q_Y] * t[Q_Z] - e[Q_Z] * t[Q_Y]), this.imaginary[Q_Y] = .5 * (-e[Q_X] * t[Q_Z] + e[Q_Y] * t[Q_W] + e[Q_Z] * t[Q_X]), this.imaginary[Q_Z] = .5 * (e[Q_X] * t[Q_Y] - e[Q_Y] * t[Q_X] + e[Q_Z] * t[Q_W])
}, dualQuat.prototype.add = function(t, e, i) {
    quat.copy(this.tmpQ1, t.real), quat.scale(this.tmpQ1, this.tmpQ1, e), quat.add(this.real, this.tmpQ1, this.real), quat.copy(this.tmpQ1, t.imaginary), quat.scale(this.tmpQ1, this.tmpQ1, i), quat.add(this.imaginary, this.tmpQ1, this.imaginary)
}, dualQuat.prototype.normalize = function() {
    var t = quat.length(this.real);
    this.real = quat.scale(this.real, this.real, 1 / t), this.imaginary = quat.scale(this.imaginary, this.imaginary, 1 / t)
};
var v0 = vec3.create(),
    ve = vec3.create(),
    trans = vec3.create(),
    tmpVec1 = vec3.create(),
    tmpVec2 = vec3.create(),
    tmpVec0 = vec3.create(),
    aVec = vec3.create(),
    rot = vec3.create();
dualQuat.prototype.transform = function(t) {
    return v0[Q_X] = this.real[Q_X], v0[Q_Y] = this.real[Q_Y], v0[Q_Z] = this.real[Q_Z], ve[Q_X] = this.imaginary[Q_X], ve[Q_Y] = this.imaginary[Q_Y], ve[Q_Z] = this.imaginary[Q_Z], tmpVec1 = vec3.scale(tmpVec1, v0, this.imaginary[Q_W]), tmpVec2 = vec3.cross(tmpVec2, v0, ve), tmpVec0 = vec3.scale(tmpVec0, ve, this.real[Q_W]), aVec = vec3.subtract(aVec, tmpVec0, tmpVec1), trans = vec3.add(trans, aVec, tmpVec2), trans = vec3.scale(trans, trans, 2), rot = vec3.transformQuat(rot, t, this.real), rot = vec3.add(rot, rot, trans)
};
var Utils = {};
Utils.setAxisMatrix = function(t, e, i) {
    var s = mat4.create();
    return s[0] = t[Q_X], s[4] = t[Q_Y], s[8] = t[Q_Z], s[1] = e[Q_X], s[5] = e[Q_Y], s[9] = e[Q_Z], s[2] = i[Q_X], s[6] = i[Q_Y], s[10] = i[Q_Z], s[12] = 0, s[13] = 0, s[14] = 0, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, s = mat4.transpose(s, s)
}, Utils.matrixToQuat = function(t) {
    var e, i = quat.create(),
        s = t,
        n = s[0],
        r = s[4],
        a = s[8],
        o = s[1],
        h = s[5],
        l = s[9],
        u = s[2],
        c = s[6],
        d = s[10],
        p = n + h + d;
    return p > 0 ? (e = .5 / Math.sqrt(p + 1), i[Q_W] = .25 / e, i[Q_X] = (c - l) * e, i[Q_Y] = (a - u) * e, i[Q_Z] = (o - r) * e) : n > h && n > d ? (e = 2 * Math.sqrt(1 + n - h - d), i[Q_W] = (c - l) / e, i[Q_X] = .25 * e, i[Q_Y] = (r + o) / e, i[Q_Z] = (a + u) / e) : h > d ? (e = 2 * Math.sqrt(1 + h - n - d), i[Q_W] = (a - u) / e, i[Q_X] = (r + o) / e, i[Q_Y] = .25 * e, i[Q_Z] = (l + c) / e) : (e = 2 * Math.sqrt(1 + d - n - h), i[Q_W] = (o - r) / e, i[Q_X] = (a + u) / e, i[Q_Y] = (l + c) / e, i[Q_Z] = .25 * e), i
}, Utils.rotateVec_90 = function(t) {
    return vec3.fromValues(-t[Q_Y], t[Q_X], t[Q_Z])
}, Utils.calcRotateMat = function(t) {
    var e = vec3.clone(t);
    e = vec3.normalize(e, e);
    var i = Utils.rotateVec_90(e),
        s = vec3.fromValues(e[Q_X], e[Q_Y], 0),
        n = vec3.fromValues(i[Q_X], i[Q_Y], 0),
        r = vec3.fromValues(0, 0, 1);
    mat4.create();
    return Utils.setAxisMatrix(s, n, r)
}, Utils.getMatTranslate = function(t) {
    var e = vec3.create();
    return e[Q_X] = t[12], e[Q_Y] = t[13], e[Q_Z] = t[14], e
}, Utils.addMat = function(t, e) {
    for (var i = mat4.create(), s = 0; s < 16; s++) i[s] = t[s] + e[s];
    return i
}, Utils.mulMat = function(t, e) {
    for (var i = mat4.create(), s = 0; s < 16; s++) i[s] = t[s] * e;
    return i
}, Utils.clamp = function(t, e, i) {
    return t < e ? e : t > i ? i : t
};
var newVec1 = vec3.create(),
    newVec2 = vec3.create();
Utils.vecInterp = function(t, e, i) {
    newVec1 = vec3.scale(newVec1, t, 1 - i), newVec2 = vec3.scale(newVec2, e, i);
    var s = vec3.create();
    return s = vec3.add(s, newVec1, newVec2)
}, Utils.vec2Interp = function(t, e, i) {
    var s = vec2.create(),
        n = vec2.create();
    s = vec2.scale(s, t, 1 - i), n = vec2.scale(n, e, i);
    var r = vec2.create();
    return r = vec2.add(r, s, n)
}, Utils.ptsInterp = function(t, e, i) {
    for (var s = [], n = 0; n < t.length; n++) s.push(Utils.vec2Interp(t[n], e[n], i));
    return s
}, Utils.scalarInterp = function(t, e, i) {
    return (1 - i) * t + i * e
}, MeshBone.prototype.setRestParentMat = function(t, e) {
    this.rest_parent_mat = t, null == e ? (this.rest_parent_inv_mat = mat4.clone(this.rest_parent_mat), mat4.invert(this.rest_parent_inv_mat, this.rest_parent_inv_mat)) : this.rest_parent_inv_mat = mat4.clone(e)
}, MeshBone.prototype.setParentWorldMat = function(t) {
    this.parent_world_mat = t
}, MeshBone.prototype.setParentWorldInvMat = function(t) {
    this.parent_world_inv_mat = t
}, MeshBone.prototype.getLocalRestStartPt = function() {
    return this.local_rest_start_pt
}, MeshBone.prototype.getLocalRestEndPt = function() {
    return this.local_rest_end_pt
}, MeshBone.prototype.setLocalRestStartPt = function(t) {
    this.local_rest_start_pt = vec3.create(), this.local_rest_start_pt = vec3.transformMat4(this.local_rest_start_pt, t, this.rest_parent_inv_mat), this.calcRestData()
}, MeshBone.prototype.setLocalRestEndPt = function(t) {
    this.local_rest_end_pt = vec3.create(), this.local_rest_end_pt = vec3.transformMat4(this.local_rest_end_pt, t, this.rest_parent_inv_mat), this.calcRestData()
}, MeshBone.prototype.calcRestData = function() {
    if (null != this.local_rest_start_pt && null != this.local_rest_end_pt) {
        var t = this.computeDirs(this.local_rest_start_pt, this.local_rest_end_pt);
        this.local_rest_dir = t.first, this.local_rest_normal_dir = t.second, this.computeRestLength()
    }
}, MeshBone.prototype.setWorldStartPt = function(t) {
    this.world_start_pt = t
}, MeshBone.prototype.setWorldEndPt = function(t) {
    this.world_end_pt = t
}, MeshBone.prototype.fixDQs = function(t) {
    quat.dot(this.world_dq.real, t.real) < 0 && (this.world_dq.real = quat.scale(this.world_dq.real, this.world_dq.real, -1), this.world_dq.imaginary = quat.scale(this.world_dq.imaginary, this.world_dq.imaginary, -1));
    for (var e = 0; e < this.children.length; e++) this.children[e].fixDQs(this.world_dq)
}, MeshBone.prototype.initWorldPts = function() {
    this.setWorldStartPt(this.getWorldRestStartPt()), this.setWorldEndPt(this.getWorldRestEndPt());
    for (var t = 0; t < this.children.length; t++) this.children[t].initWorldPts()
}, MeshBone.prototype.getWorldRestStartPt = function() {
    var t = this.rest_parent_mat,
        e = vec3.create();
    return e = vec3.transformMat4(e, this.local_rest_start_pt, t)
}, MeshBone.prototype.getWorldRestEndPt = function() {
    var t = this.rest_parent_mat,
        e = vec3.create();
    return e = vec3.transformMat4(e, this.local_rest_end_pt, t)
}, MeshBone.prototype.getWorldRestAngle = function() {
    return this.world_rest_angle
}, MeshBone.prototype.getWorldRestPos = function() {
    return this.world_rest_pos
}, MeshBone.prototype.getWorldStartPt = function() {
    return this.world_start_pt
}, MeshBone.prototype.getWorldEndPt = function() {
    return this.world_end_pt
}, MeshBone.prototype.getRestParentMat = function() {
    return this.rest_parent_mat
}, MeshBone.prototype.getRestWorldMat = function() {
    return this.rest_world_mat
}, MeshBone.prototype.getWorldDeltaMat = function() {
    return this.world_delta_mat
}, MeshBone.prototype.getParentWorldMat = function() {
    return this.parent_world_mat
}, MeshBone.prototype.getParentWorldInvMat = function() {
    return this.parent_world_inv_mat
}, MeshBone.prototype.getWorldDq = function() {
    return this.world_dq
}, MeshBone.prototype.computeRestParentTransforms = function() {
    var t = vec3.fromValues(this.local_rest_dir[Q_X], this.local_rest_dir[Q_Y], 0),
        e = vec3.fromValues(this.local_binormal_dir[Q_X], this.local_binormal_dir[Q_Y], this.local_binormal_dir[Q_Z]),
        i = vec3.fromValues(this.local_rest_normal_dir[Q_X], this.local_rest_normal_dir[Q_Y], 0),
        s = mat4.create();
    mat4.translate(s, s, this.local_rest_end_pt);
    var n = mat4.create();
    n = Utils.setAxisMatrix(t, i, e);
    var r = mat4.create();
    r = mat4.multiply(r, s, n), this.rest_world_mat = mat4.create(), this.rest_world_mat = mat4.multiply(this.rest_world_mat, this.rest_parent_mat, r), this.rest_world_inv_mat = mat4.clone(this.rest_world_mat), this.rest_world_inv_mat = mat4.invert(this.rest_world_inv_mat, this.rest_world_inv_mat);
    var a = vec3.clone(this.getWorldRestEndPt());
    a = vec3.subtract(a, a, this.getWorldRestStartPt()), a = vec3.normalize(a, a), this.world_rest_pos = this.getWorldRestStartPt();
    var o = mat4.create();
    o = mat4.translate(o, o, this.getWorldRestStartPt());
    var h = vec3.create();
    h = vec3.sub(h, this.getWorldRestEndPt(), this.getWorldRestStartPt());
    var l = Utils.calcRotateMat(h),
        u = mat4.create();
    u = mat4.multiply(u, o, l), this.bind_world_mat = mat4.clone(u), this.bind_world_inv_mat = mat4.clone(this.bind_world_mat), this.bind_world_inv_mat = mat4.invert(this.bind_world_inv_mat, this.bind_world_inv_mat);
    for (var c = 0; c < this.children.length; c++) {
        var d = this.children[c];
        d.setRestParentMat(this.rest_world_mat, this.rest_world_inv_mat), d.computeRestParentTransforms()
    }
}, MeshBone.prototype.computeParentTransforms = function() {
    var t = mat4.create();
    t = mat4.translate(t, t, this.getWorldEndPt());
    var e = vec3.create();
    e = vec3.subtract(e, this.getWorldEndpt(), this.getWorldStartPt());
    var i = Utils.calcRotateMat(e),
        s = mat4.create();
    s = mat4.multiply(s, t, i);
    var n = mat4.clone(s);
    n = mat4.invert(n, n);
    for (var r = 0; r < children.length; r++) {
        var a = children[r];
        a.setParentWorldMat(s), a.setParentWorldInvMat(n), a.computeParentTransforms()
    }
}, MeshBone.prototype.computeWorldDeltaTransforms = function() {
    var t = this.computeDirs(this.world_start_pt, this.world_end_pt),
        e = vec3.fromValues(t.first[Q_X], t.first[Q_Y], 0),
        i = vec3.fromValues(t.second[Q_X], t.second[Q_Y], 0),
        s = vec3.fromValues(this.local_binormal_dir[Q_X], this.local_binormal_dir[Q_Y], this.local_binormal_dir[Q_Z]),
        n = mat4.create();
    n = Utils.setAxisMatrix(e, i, s);
    var r = mat4.create();
    r = mat4.translate(r, r, this.world_start_pt), this.world_delta_mat = mat4.create(), this.world_delta_mat = mat4.multiply(this.world_delta_mat, r, n), this.world_delta_mat = mat4.multiply(this.world_delta_mat, this.world_delta_mat, this.bind_world_inv_mat);
    var a = Utils.matrixToQuat(this.world_delta_mat),
        o = Utils.getMatTranslate(this.world_delta_mat);
    this.world_dq = new dualQuat, this.world_dq.createFromData(a, o);
    for (var h = 0; h < this.children.length; h++) this.children[h].computeWorldDeltaTransforms()
}, MeshBone.prototype.addChild = function(t) {
    t.setRestParentMat(this.rest_world_mat, this.rest_world_inv_mat), this.children.push(t)
}, MeshBone.prototype.getChildren = function() {
    return this.children
}, MeshBone.prototype.hasBone = function(t) {
    for (var e = 0; e < this.children.length; e++)
        if (this.children[e] == t) return !0;
    return !1
}, MeshBone.prototype.getChildByKey = function(t) {
    if (this.key === t) return this;
    for (var e = null, i = 0; i < this.children.length; i++) {
        var s = this.children[i].getChildByKey(t);
        if (null != s) {
            e = s;
            break
        }
    }
    return e
}, MeshBone.prototype.getKey = function() {
    return this.key
}, MeshBone.prototype.getAllBoneKeys = function() {
    var t = [];
    t.push(this.getKey());
    for (var e = 0; e < this.children.length; e++) {
        var i = this.children[e].getAllBoneKeys();
        t = t.concat(i)
    }
    return t
}, MeshBone.prototype.getAllChildren = function() {
    var t = [];
    t.push(this);
    for (var e = 0; e < this.children.length; e++) {
        var i = this.children[e].getAllChildren();
        t = t.concat(i)
    }
    return t
}, MeshBone.prototype.getBoneDepth = function(t, e) {
    if (t == this) return e;
    for (var i = 0; i < this.children.length; i++) {
        var s = this.children[i].getBoneDepth(t, e + 1);
        if (-1 != s) return s
    }
    return -1
}, MeshBone.prototype.isLeaf = function() {
    return 0 == this.children.length
}, MeshBone.prototype.deleteChildren = function() {
    for (var t = 0; t < this.children.length; t++) this.children[t].deleteChildren();
    this.children = []
}, MeshBone.prototype.setTagId = function(t) {
    this.tag_id = t
}, MeshBone.prototype.getTagId = function() {
    return this.tag_id
}, MeshBone.prototype.computeDirs = function(t, e) {
    var i = vec3.create();
    i = vec3.subtract(i, e, t), i = vec3.normalize(i, i);
    var s = Utils.rotateVec_90(i),
        n = {};
    return n.first = i, n.second = s, n
}, MeshBone.prototype.computeRestLength = function() {
    var t = vec3.create();
    t = vec3.subtract(t, this.local_rest_end_pt, this.local_rest_start_pt), this.rest_length = vec3.length(t)
}, MeshRenderRegion.prototype.getIndicesIndex = function() {
    return this.start_index
}, MeshRenderRegion.prototype.getRestPtsIndex = function() {
    return 3 * this.start_pt_index
}, MeshRenderRegion.prototype.getUVsIndex = function() {
    return 2 * this.start_pt_index
}, MeshRenderRegion.prototype.getNumPts = function() {
    return this.end_pt_index - this.start_pt_index + 1
}, MeshRenderRegion.prototype.getStartPtIndex = function() {
    return this.start_pt_index
}, MeshRenderRegion.prototype.getEndPtIndex = function() {
    return this.end_pt_index
}, MeshRenderRegion.prototype.getNumIndices = function() {
    return this.end_index - this.start_index + 1
}, MeshRenderRegion.prototype.getStartIndex = function() {
    return this.start_index
}, MeshRenderRegion.prototype.getEndIndex = function() {
    return this.end_index
};
var accum_dq = new dualQuat,
    accum_mat = mat4.create(),
    final_pt = vec3.create(),
    tmp1 = vec3.create(),
    tmp2 = vec3.create();
MeshRenderRegion.prototype.poseFinalPts = function(t, e, i) {
    for (var s = this.getRestPtsIndex(), n = e, r = 0; r < 16; r++) accum_mat[r] = 0;
    Object.keys(i).length;
    for (var r = 0, a = this.getNumPts(); r < a; r++) {
        var o = vec3.set(tmp1, this.store_rest_pts[0 + s], this.store_rest_pts[1 + s], this.store_rest_pts[2 + s]);
        1 == this.use_local_displacements && (o[Q_X] += this.local_displacements[r][Q_X], o[Q_Y] += this.local_displacements[r][Q_Y]);
        for (u = 0; u < 16; u++) accum_mat[u] = 0;
        accum_dq.reset();
        for (var h = this.relevant_bones_indices[r], l = h.length, u = 0; u < l; u++) {
            var c = h[u],
                d = this.fast_bones_map[c],
                p = this.fast_normal_weight_map[c][r],
                f = p,
                m = d.getWorldDq();
            accum_dq.add(m, p, f)
        }
        accum_dq.normalize();
        var g = vec3.set(tmp2, o[Q_X], o[Q_Y], o[Q_Z]);
        final_pt = accum_dq.transform(g), 1 == this.use_post_displacements && (final_pt[Q_X] += this.post_displacements[r][Q_X], final_pt[Q_Y] += this.post_displacements[r][Q_Y]), t[0 + n] = final_pt[Q_X], t[1 + n] = final_pt[Q_Y], t[2 + n] = final_pt[Q_Z], s += 3, n += 3
    }
    1 == this.use_uv_warp && this.runUvWarp()
}, MeshRenderRegion.prototype.setMainBoneKey = function(t) {
    this.main_bone_key = t
}, MeshRenderRegion.prototype.determineMainBone = function(t) {
    this.main_bone = t.getChildByKey(this.main_bone_key)
}, MeshRenderRegion.prototype.setUseDq = function(t) {
    this.use_dq = t
}, MeshRenderRegion.prototype.setName = function(t) {
    this.name = t
}, MeshRenderRegion.prototype.getName = function() {
    return this.name
}, MeshRenderRegion.prototype.setUseLocalDisplacements = function(t) {
    if (this.use_local_displacements = t, this.local_displacements.length != this.getNumPts() && this.use_local_displacements) {
        this.local_displacements = [];
        for (var e = 0; e < this.getNumPts(); e++) this.local_displacements.push(vec2.create())
    }
}, MeshRenderRegion.prototype.getUseLocalDisplacements = function() {
    return this.use_local_displacements
}, MeshRenderRegion.prototype.setUsePostDisplacements = function(t) {
    if (this.use_post_displacements = t, this.post_displacements.length != this.getNumPts() && this.use_post_displacements) {
        this.post_displacements = [];
        for (var e = 0; e < this.getNumPts(); e++) this.post_displacements.push(vec2.create())
    }
}, MeshRenderRegion.prototype.getUsePostDisplacements = function() {
    return this.use_post_displacements
}, MeshRenderRegion.prototype.getRestLocalPt = function(t) {
    var e = this.getRestPtsIndex() + 3 * t;
    return vec2.fromValues(this.store_rest_pts[0 + e], this.store_rest_pts[1 + e])
}, MeshRenderRegion.prototype.getLocalIndex = function(t) {
    var e = this.getIndicesIndex() + t;
    return this.store_indices[e]
}, MeshRenderRegion.prototype.clearLocalDisplacements = function() {
    for (var t = 0; t < this.local_displacements.length; t++) this.local_displacements[t] = vec2.create()
}, MeshRenderRegion.prototype.clearPostDisplacements = function() {
    for (var t = 0; t < this.post_displacements.length; t++) this.post_displacements[t] = vec2.create()
}, MeshRenderRegion.prototype.setUseUvWarp = function(t) {
    this.use_uv_warp = t, 0 == this.use_uv_warp && this.restoreRefUv()
}, MeshRenderRegion.prototype.getUseUvWarp = function() {
    return this.use_uv_warp
}, MeshRenderRegion.prototype.setUvWarpLocalOffset = function(t) {
    this.uv_warp_local_offset = t
}, MeshRenderRegion.prototype.setUvWarpGlobalOffset = function(t) {
    this.uv_warp_global_offset = t
}, MeshRenderRegion.prototype.setUvWarpScale = function(t) {
    this.uv_warp_scale = t
}, MeshRenderRegion.prototype.getUvWarpLocalOffset = function() {
    return this.uv_warp_local_offset
}, MeshRenderRegion.prototype.getUvWarpGlobalOffset = function() {
    return this.uv_warp_global_offset
}, MeshRenderRegion.prototype.getUvWarpScale = function() {
    return this.uv_warp_scale
}, MeshRenderRegion.prototype.runUvWarp = function() {
    for (var t = this.getUVsIndex(), e = 0; e < this.uv_warp_ref_uvs.length; e++) {
        var i = vec2.clone(this.uv_warp_ref_uvs[e]);
        (i = vec2.subtract(i, i, this.uv_warp_local_offset))[Q_X] *= this.uv_warp_scale[Q_X], i[Q_Y] *= this.uv_warp_scale[Q_Y], i = vec2.add(i, i, this.uv_warp_global_offset), this.store_uvs[0 + t] = i[Q_X], this.store_uvs[1 + t] = i[Q_Y], t += 2
    }
}, MeshRenderRegion.prototype.restoreRefUv = function() {
    for (var t = this.getUVsIndex(), e = 0; e < this.uv_warp_ref_uvs.length; e++) {
        var i = this.uv_warp_ref_uvs[e];
        this.store_uvs[0 + t] = i[Q_X], this.store_uvs[1 + t] = i[Q_Y], t += 2
    }
}, MeshRenderRegion.prototype.getTagId = function() {
    return this.tag_id
}, MeshRenderRegion.prototype.setTagId = function(t) {
    this.tag_id = t
}, MeshRenderRegion.prototype.initFastNormalWeightMap = function(t) {
    this.relevant_bones_indices = [];
    for (var e in t) {
        var i = this.normal_weight_map[e];
        this.fast_normal_weight_map.push(i)
    }
    for (var s = 0; s < this.getNumPts(); s++) {
        for (var n = [], r = 0; r < this.fast_normal_weight_map.length; r++) this.fast_normal_weight_map[r][s] > .05 && n.push(r);
        this.relevant_bones_indices.push(n)
    }
    for (var e in t) {
        var a = t[e];
        this.fast_bones_map.push(a)
    }
}, MeshRenderRegion.prototype.initUvWarp = function() {
    var t = this.getUVsIndex();
    this.uv_warp_ref_uvs = [];
    for (var e = 0; e < this.getNumPts(); e++) this.uv_warp_ref_uvs.push(vec2.create()), this.uv_warp_ref_uvs[e] = vec2.fromValues(this.store_uvs[t], this.store_uvs[t + 1]), t += 2
}, MeshRenderBoneComposition.prototype.addRegion = function(t) {
    this.regions.push(t)
}, MeshRenderBoneComposition.prototype.setRootBone = function(t) {
    this.root_bone = t
}, MeshRenderBoneComposition.prototype.getRootBone = function() {
    return this.root_bone
}, MeshRenderBoneComposition.prototype.initBoneMap = function() {
    this.bones_map = MeshRenderBoneComposition.genBoneMap(this.root_bone)
}, MeshRenderBoneComposition.prototype.initRegionsMap = function() {
    this.regions_map = {};
    for (var t = 0; t < this.regions.length; t++) cur_key = this.regions[t].getName(), this.regions_map[cur_key] = this.regions[t]
}, MeshRenderBoneComposition.genBoneMap = function(t) {
    for (var e = {}, i = t.getAllBoneKeys(), s = 0; s < i.length; s++) {
        var n = i[s];
        e[n] = t.getChildByKey(n)
    }
    return e
}, MeshRenderBoneComposition.prototype.getBonesMap = function() {
    return this.bones_map
}, MeshRenderBoneComposition.prototype.getRegionsMap = function() {
    return this.regions_map
}, MeshRenderBoneComposition.prototype.getRegions = function() {
    return this.regions
}, MeshRenderBoneComposition.prototype.getRegionWithId = function(t) {
    for (var e = 0; e < this.regions.length; e++) {
        var i = this.regions[e];
        if (i.getTagId() == t) return i
    }
    return null
}, MeshRenderBoneComposition.prototype.resetToWorldRestPts = function() {
    this.getRootBone().initWorldPts()
}, MeshRenderBoneComposition.prototype.updateAllTransforms = function(t) {
    t && this.getRootBone().computeParentTransforms(), this.getRootBone().computeWorldDeltaTransforms(), this.getRootBone().fixDQs(this.getRootBone().getWorldDq())
}, MeshBoneCache.prototype.setWorldStartPt = function(t) {
    this.world_start_pt = t
}, MeshBoneCache.prototype.setWorldEndPt = function(t) {
    this.world_end_pt = t
}, MeshBoneCache.prototype.getWorldStartPt = function() {
    return this.world_start_pt
}, MeshBoneCache.prototype.getWorldEndPt = function() {
    return this.world_end_pt
}, MeshBoneCache.prototype.getKey = function() {
    return this.key
}, MeshDisplacementCache.prototype.setLocalDisplacements = function(t) {
    this.local_displacements = t
}, MeshDisplacementCache.prototype.setPostDisplacements = function(t) {
    this.post_displacements = t
}, MeshDisplacementCache.prototype.getKey = function() {
    return this.key
}, MeshDisplacementCache.prototype.getLocalDisplacements = function() {
    return this.local_displacements
}, MeshDisplacementCache.prototype.getPostDisplacements = function() {
    return this.post_displacements
}, MeshUVWarpCache.prototype.setUvWarpLocalOffset = function(t) {
    this.uv_warp_local_offset = t
}, MeshUVWarpCache.prototype.setUvWarpGlobalOffset = function(t) {
    this.uv_warp_global_offset = t
}, MeshUVWarpCache.prototype.setUvWarpScale = function(t) {
    this.uv_warp_scale = t
}, MeshUVWarpCache.prototype.getUvWarpLocalOffset = function() {
    return this.uv_warp_local_offset
}, MeshUVWarpCache.prototype.getUvWarpGlobalOffset = function() {
    return this.uv_warp_global_offset
}, MeshUVWarpCache.prototype.getUvWarpScale = function() {
    return this.uv_warp_scale
}, MeshUVWarpCache.prototype.getKey = function() {
    return this.key
}, MeshUVWarpCache.prototype.setEnabled = function(t) {
    this.enabled = t
}, MeshUVWarpCache.prototype.getEnabled = function() {
    return this.enabled
}, MeshOpacityCache.prototype.setOpacity = function(t) {
    this.opacity = t
}, MeshOpacityCache.prototype.getOpacity = function() {
    return this.opacity
}, MeshOpacityCache.prototype.getKey = function() {
    return this.key
}, MeshBoneCacheManager.prototype.init = function(t, e) {
    this.start_time = t, this.end_time = e;
    var i = this.end_time - this.start_time + 1;
    this.bone_cache_table = [], this.bone_cache_data_ready = [];
    for (var s = 0; s < i; s++) this.bone_cache_table.push([]), this.bone_cache_data_ready.push(!1);
    this.is_ready = !1
}, MeshBoneCacheManager.prototype.getStartTime = function() {
    return this.start_time
}, MeshBoneCacheManager.prototype.getEndime = function() {
    return this.end_time
}, MeshBoneCacheManager.prototype.getIndexByTime = function(t) {
    var e = t - this.start_time;
    return e = Utils.clamp(e, 0, this.bone_cache_table.length - 1)
}, MeshBoneCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
    var i = this.getIndexByTime(Math.floor(t)),
        s = this.getIndexByTime(Math.ceil(t)),
        n = t - Math.floor(t);
    if (0 != this.bone_cache_data_ready.length && 0 != this.bone_cache_data_ready[i] && 0 != this.bone_cache_data_ready[s])
        for (var r = this.bone_cache_table[i], a = this.bone_cache_table[s], o = 0, h = r.length; o < h; o++) {
            var l = r[o],
                u = a[o],
                c = l.getKey(),
                d = Utils.vecInterp(l.getWorldStartPt(), u.getWorldStartPt(), n),
                p = Utils.vecInterp(l.getWorldEndPt(), u.getWorldEndPt(), n);
            e[c].setWorldStartPt(d), e[c].setWorldEndPt(p)
        }
}, MeshBoneCacheManager.prototype.allReady = function() {
    if (this.is_ready) return !0;
    for (var t = this.end_time - this.start_time + 1, e = 0, i = 0; i < this.bone_cache_data_ready.size(); i++) this.bone_cache_data_ready[i] && e++;
    return e == t && (this.is_ready = !0), this.is_ready
}, MeshBoneCacheManager.prototype.makeAllReady = function() {
    for (var t = 0; t < this.bone_cache_data_ready.length; t++) this.bone_cache_data_ready[t] = !0
}, MeshDisplacementCacheManager.prototype.init = function(t, e) {
    this.start_time = t, this.end_time = e;
    var i = this.end_time - this.start_time + 1;
    this.displacement_cache_table = [], this.displacement_cache_data_ready = [];
    for (var s = 0; s < i; s++) this.displacement_cache_table.push([]), this.displacement_cache_data_ready.push(!1);
    this.is_ready = !1
}, MeshDisplacementCacheManager.prototype.getStartTime = function() {
    return this.start_time
}, MeshDisplacementCacheManager.prototype.getEndime = function() {
    return this.end_time
}, MeshDisplacementCacheManager.prototype.getIndexByTime = function(t) {
    var e = t - this.start_time;
    return e = Utils.clamp(e, 0, this.displacement_cache_table.length - 1)
}, MeshDisplacementCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
    var i = this.getIndexByTime(Math.floor(t)),
        s = this.getIndexByTime(Math.ceil(t)),
        n = t - Math.floor(t);
    if (0 != this.displacement_cache_data_ready.length && 0 != this.displacement_cache_data_ready[i] && 0 != this.displacement_cache_data_ready[s])
        for (var r = this.displacement_cache_table[i], a = this.displacement_cache_table[s], o = 0; o < r.length; o++) {
            var h = r[o],
                l = a[o],
                u = e[h.getKey()];
            if (u.getUseLocalDisplacements()) {
                c = u.local_displacements;
                if (h.getLocalDisplacements().length == c.length && l.getLocalDisplacements().length == c.length)
                    for (p = 0; p < c.length; p++) {
                        d = Utils.vec2Interp(h.getLocalDisplacements()[p], l.getLocalDisplacements()[p], n);
                        c[p] = d
                    } else
                        for (p = 0; p < c.length; p++) c[p] = vec2.create()
            }
            if (u.getUsePostDisplacements()) {
                var c = u.post_displacements;
                if (h.getPostDisplacements().length == c.length && l.getPostDisplacements().length == c.length)
                    for (p = 0; p < c.length; p++) {
                        var d = Utils.vec2Interp(h.getPostDisplacements()[p], l.getPostDisplacements()[p], n);
                        c[p] = d
                    } else
                        for (var p = 0; p < c.length; p++) c[p] = vec2.create()
            }
        }
}, MeshDisplacementCacheManager.prototype.allReady = function() {
    if (this.is_ready) return !0;
    for (var t = this.end_time - this.start_time + 1, e = 0, i = 0; i < this.displacement_cache_data_ready.length; i++) this.displacement_cache_data_ready[i] && e++;
    return e == t && (this.is_ready = !0), this.is_ready
}, MeshDisplacementCacheManager.prototype.makeAllReady = function() {
    for (var t = 0; t < this.displacement_cache_data_ready.length; t++) this.displacement_cache_data_ready[t] = !0
}, MeshUVWarpCacheManager.prototype.init = function(t, e) {
    this.start_time = t, this.end_time = e;
    var i = this.end_time - this.start_time + 1;
    this.uv_cache_table = [], this.uv_cache_data_ready = [];
    for (var s = 0; s < i; s++) this.uv_cache_table.push([]), this.uv_cache_data_ready.push(!1);
    this.is_ready = !1
}, MeshUVWarpCacheManager.prototype.getStartTime = function() {
    return this.start_time
}, MeshUVWarpCacheManager.prototype.getEndime = function() {
    return this.end_time
}, MeshUVWarpCacheManager.prototype.getIndexByTime = function(t) {
    var e = t - this.start_time;
    return e = Utils.clamp(e, 0, this.uv_cache_table.length - 1)
}, MeshUVWarpCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
    var i = this.getIndexByTime(Math.floor(t)),
        s = this.getIndexByTime(Math.ceil(t));
    Math.floor(t);
    if (0 != this.uv_cache_data_ready.length && 0 != this.uv_cache_data_ready[i] && 0 != this.uv_cache_data_ready[s])
        for (var n = this.uv_cache_table[i], r = this.uv_cache_table[s], a = 0; a < n.length; a++) {
            var o = n[a],
                h = (r[a], e[o.getKey()]);
            if (h.getUseUvWarp()) {
                var l = o.getUvWarpLocalOffset(),
                    u = o.getUvWarpGlobalOffset(),
                    c = o.getUvWarpScale();
                h.setUvWarpLocalOffset(l), h.setUvWarpGlobalOffset(u), h.setUvWarpScale(c)
            }
        }
}, MeshUVWarpCacheManager.prototype.allReady = function() {
    if (this.is_ready) return !0;
    for (var t = this.end_time - this.start_time + 1, e = 0, i = 0; i < this.uv_cache_data_ready.length; i++) uv_cache_data_ready[i] && e++;
    return e == t && (this.is_ready = !0), this.is_ready
}, MeshUVWarpCacheManager.prototype.makeAllReady = function() {
    for (var t = 0; t < this.uv_cache_data_ready.length; t++) this.uv_cache_data_ready[t] = !0
}, MeshOpacityCacheManager.prototype.init = function(t, e) {
    this.start_time = t, this.end_time = e;
    var i = this.end_time - this.start_time + 1;
    this.opacity_cache_table = [], this.opacity_cache_data_ready = [];
    for (var s = 0; s < i; s++) this.opacity_cache_table.push([]), this.opacity_cache_data_ready.push(!1);
    this.is_ready = !1
}, MeshOpacityCacheManager.prototype.getStartTime = function() {
    return this.start_time
}, MeshOpacityCacheManager.prototype.getEndime = function() {
    return this.end_time
}, MeshOpacityCacheManager.prototype.getIndexByTime = function(t) {
    var e = t - this.start_time;
    return e = Utils.clamp(e, 0, this.opacity_cache_table.length - 1)
}, MeshOpacityCacheManager.prototype.retrieveValuesAtTime = function(t, e) {
    var i = this.getIndexByTime(Math.floor(t)),
        s = this.getIndexByTime(Math.ceil(t));
    Math.floor(t);
    if (0 != this.opacity_cache_data_ready.length && 0 != this.opacity_cache_data_ready[i] && 0 != this.opacity_cache_data_ready[s])
        for (var n = this.opacity_cache_table[i], r = 0; r < n.length; r++) {
            var a = n[r];
            e[a.getKey()].opacity = a.getOpacity()
        }
}, MeshOpacityCacheManager.prototype.allReady = function() {
    if (this.is_ready) return !0;
    for (var t = this.end_time - this.start_time + 1, e = 0, i = 0; i < this.opacity_cache_data_ready.length; i++) opacity_cache_data_ready[i] && e++;
    return e == t && (this.is_ready = !0), this.is_ready
}, MeshOpacityCacheManager.prototype.makeAllReady = function() {
    for (var t = 0; t < this.opacity_cache_data_ready.length; t++) this.opacity_cache_data_ready[t] = !0
};
var CreatureModuleUtils = {};
CreatureModuleUtils.LoadCreatureFlatData = function(t) {
        var e = new flatbuffers.ByteBuffer(t);
        return CreatureFlatData.rootData.getRootAsrootData(e)
    }, CreatureModuleUtils.BuildCreatureMetaData = function(t) {
        var e = new CreatureMetaData;
        if ("skinSwapList" in t) {
            var i = t.skinSwapList;
            for (var s in i) {
                for (var n = i[s].swap.swap_items, r = {}, a = 0; a < n.length; a++) {
                    var o = n[a];
                    r[o] = o
                }
                e.skin_swaps[s] = r
            }
        }
        if ("eventTriggers" in t) {
            var h = t.eventTriggers;
            for (var l in h) {
                var u = {},
                    c = h[l];
                for (var d in c) {
                    var p = d.event_name;
                    u[Number(d.switch_time)] = p
                }
                e.anim_events_map[l] = u
            }
        }
        return e
    }, CreatureModuleUtils.GetAllAnimationNames = function(t) {
        var e = t.animation,
            i = [];
        for (var s in e) i.push(s);
        return i
    }, CreatureModuleUtils.getFloatArray = function(t) {
        return t
    }, CreatureModuleUtils.getIntArray = function(t) {
        return t
    }, CreatureModuleUtils.ReadPointsArray2DJSON = function(t, e) {
        for (var i = CreatureModuleUtils.getFloatArray(t[e]), s = [], n = i.length / 2, r = 0; r < n; r++) {
            var a = 2 * r;
            s.push(vec2.fromValues(i[0 + a], i[1 + a]))
        }
        return s
    }, CreatureModuleUtils.ReadPointsArray2DFlat = function(t) {
        for (var e = t, i = [], s = e.length / 2, n = 0; n < s; n++) {
            var r = 2 * n;
            i.push(vec2.fromValues(e[0 + r], e[1 + r]))
        }
        return i
    }, CreatureModuleUtils.ReadFloatArray3DJSON = function(t, e) {
        for (var i = CreatureModuleUtils.getFloatArray(t[e]), s = [], n = i.length / 2, r = 0; r < n; r++) {
            var a = 2 * r;
            s.push(i[0 + a]), s.push(i[1 + a]), s.push(0)
        }
        return s
    }, CreatureModuleUtils.ReadFloatArray3DFlat = function(t) {
        for (var e = t, i = [], s = e.length / 2, n = 0; n < s; n++) {
            var r = 2 * n;
            i.push(e[0 + r]), i.push(e[1 + r]), i.push(0)
        }
        return i
    }, CreatureModuleUtils.ReadBoolJSON = function(t, e) {
        return t[e]
    }, CreatureModuleUtils.ReadFloatArrayJSON = function(t, e) {
        return t[e]
    }, CreatureModuleUtils.ReadIntArrayJSON = function(t, e) {
        return t[e]
    }, CreatureModuleUtils.ReadMatrixJSON = function(t, e) {
        for (var i = CreatureModuleUtils.getFloatArray(t[e]), s = mat4.create(), n = 0; n < 16; n++) s[n] = i[n];
        return s
    }, CreatureModuleUtils.ReadMatrixFlat = function(t) {
        for (var e = t, i = mat4.create(), s = 0; s < 16; s++) i[s] = e[s];
        return i
    }, CreatureModuleUtils.ReadVector2JSON = function(t, e) {
        var i = CreatureModuleUtils.getFloatArray(t[e]);
        return vec2.fromValues(i[0], i[1])
    }, CreatureModuleUtils.ReadVector2Flat = function(t) {
        var e = t;
        return vec2.fromValues(e[0], e[1])
    }, CreatureModuleUtils.ReadVector3JSON = function(t, e) {
        var i = CreatureModuleUtils.getFloatArray(t[e]);
        return vec3.fromValues(i[0], i[1], 0)
    }, CreatureModuleUtils.ReadVectorFlat = function(t) {
        var e = t;
        return vec3.fromValues(e[0], e[1], 0)
    }, CreatureModuleUtils.FormBoneHierarchy = function(t, e) {
        var i = null;
        for (var s in e)
            if (s in t == 0) {
                i = (n = e[s]).first;
                break
            }
        for (var s in e)
            for (var n = e[s], r = n.first, a = n.second, o = 0; o < a.length; o++) {
                var h = e[a[o]].first;
                r.addChild(h)
            }
        return i
    }, CreatureModuleUtils.CreateBones = function(t, e) {
        var i = t[e],
            s = {},
            n = {};
        for (var r in i) {
            var a = i[r],
                o = a.id,
                h = CreatureModuleUtils.ReadMatrixJSON(a, "restParentMat"),
                l = CreatureModuleUtils.ReadVector3JSON(a, "localRestStartPt"),
                u = CreatureModuleUtils.ReadVector3JSON(a, "localRestEndPt"),
                c = CreatureModuleUtils.ReadIntArrayJSON(a, "children"),
                d = new MeshBone(r, vec3.create(), vec3.create(), h);
            d.local_rest_start_pt = l, d.local_rest_end_pt = u, d.calcRestData(), d.setTagId(o), s[o] = {
                first: d,
                second: c
            };
            for (var p = 0; p < c.length; p++) {
                var f = c[p];
                n[f] = f
            }
        }
        return this.FormBoneHierarchy(n, s)
    }, CreatureModuleUtils.CreateBonesFlat = function(t) {
        for (var e = {}, i = {}, s = 0; s < t.bonesLength(); s++) {
            var n = t.bones(s),
                r = n.name(),
                a = n.id(),
                o = CreatureModuleUtils.ReadMatrixFlat(n.restParentMatArray()),
                h = CreatureModuleUtils.ReadFloatArray3DFlat(n.localRestStartPtArray()),
                l = CreatureModuleUtils.ReadFloatArray3DFlat(n.localRestEndPtArray()),
                u = CreatureModuleUtils.getIntArray(n.childrenArray()),
                c = new MeshBone(r, vec3.create(), vec3.create(), o);
            c.local_rest_start_pt = h, c.local_rest_end_pt = l, c.calcRestData(), c.setTagId(a), e[a] = {
                first: c,
                second: u
            };
            for (var d = 0; d < u.length; d++) {
                var p = u[d];
                i[p] = p
            }
        }
        return this.FormBoneHierarchy(i, e)
    }, CreatureModuleUtils.CreateRegions = function(t, e, i, s, n) {
        var r = [],
            a = t[e];
        for (var o in a) {
            var h = a[o],
                l = h.id,
                u = new MeshRenderRegion(i, s, n, h.start_pt_index, h.end_pt_index, h.start_index, h.end_index);
            u.setName(o), u.setTagId(l);
            var c = u.normal_weight_map,
                d = h.weights;
            for (var p in d) {
                d[p];
                var f = CreatureModuleUtils.ReadFloatArrayJSON(d, p);
                c[p] = f
            }
            r.push(u)
        }
        return r
    }, CreatureModuleUtils.CreateRegionsFlat = function(t, e, i, s) {
        for (var n = [], r = 0; r < t.regionsLength(); r++) {
            var a = t.regions(r),
                o = a.name(),
                h = a.id(),
                l = new MeshRenderRegion(e, i, s, a.startPtIndex(), a.endPtIndex(), a.startIndex(), a.endIndex());
            l.setName(o), l.setTagId(h);
            for (var u = l.normal_weight_map, c = (a.weights, 0); c < a.weightsLength(); c++) {
                var d = a.weights(c),
                    p = d.name(),
                    f = CreatureModuleUtils.getFloatArray(d.weightsArray());
                u[p] = f
            }
            n.push(l)
        }
        return n
    }, CreatureModuleUtils.GetStartEndTimes = function(t, e) {
        var i = 0,
            s = 0,
            n = !0,
            r = t[e];
        for (var a in r) {
            r[a];
            var o = parseInt(a);
            n ? (i = o, s = o, n = !1) : (o > s && (s = o), o < i && (i = o))
        }
        return {
            first: i,
            second: s
        }
    }, CreatureModuleUtils.GetStartEndTimesFlat = function(t) {
        for (var e = 0, i = 0, s = !0, n = 0; n < t.timeSamplesLength(); n++) {
            var r = t.timeSamples(n).time();
            s ? (e = r, i = r, s = !1) : (r > i && (i = r), r < e && (e = r))
        }
        return {
            first: e,
            second: i
        }
    }, CreatureModuleUtils.FillBoneGapCache = function(t, e, i, s, n) {
        var r = e - t;
        if (r > 1)
            for (var a = s.getIndexByTime(t), o = 1; o < r; o++) {
                for (var h = o / r, l = [], u = 0; u < n.length; u++) {
                    var c = s.bone_cache_table[i][u],
                        d = s.bone_cache_table[a][u],
                        p = new MeshBoneCache(c.getKey());
                    p.setWorldStartPt(Utils.vecInterp(d.getWorldStartPt(), c.getWorldStartPt(), h)), p.setWorldEndPt(Utils.vecInterp(d.getWorldEndPt(), c.getWorldEndPt(), h)), l.push(p)
                }
                s.bone_cache_table[a + o] = l
            }
    }, CreatureModuleUtils.FillBoneCache = function(t, e, i, s, n) {
        var r = t[e];
        n.init(i, s);
        var a = i;
        for (var o in r) {
            var h = r[o];
            cache_list = [];
            for (var l in h) {
                var u = h[l],
                    c = CreatureModuleUtils.ReadVector3JSON(u, "start_pt"),
                    d = CreatureModuleUtils.ReadVector3JSON(u, "end_pt"),
                    p = new MeshBoneCache(l);
                p.setWorldStartPt(c), p.setWorldEndPt(d), cache_list.push(p)
            }
            var f = n.getIndexByTime(o);
            n.bone_cache_table[f] = cache_list, CreatureModuleUtils.FillBoneGapCache(a, o, f, n, cache_list), a = o
        }
        n.makeAllReady()
    }, CreatureModuleUtils.FillBoneCacheFlat = function(t, e, i, s) {
        s.init(e, i);
        for (var n = e, r = 0; r < t.timeSamplesLength(); r++) {
            var a = t.timeSamples(r),
                o = a.time();
            cache_list = [];
            for (var h = 0; h < a.bonesLength(); h++) {
                var l = a.bones(h),
                    u = l.name(),
                    c = CreatureModuleUtils.ReadFloatArray3DFlat(l.startPtArray()),
                    d = CreatureModuleUtils.ReadFloatArray3DFlat(l.endPtArray()),
                    p = new MeshBoneCache(u);
                p.setWorldStartPt(c), p.setWorldEndPt(d), cache_list.push(p)
            }
            var f = s.getIndexByTime(o);
            s.bone_cache_table[f] = cache_list, CreatureModuleUtils.FillBoneGapCache(n, o, f, s, cache_list), n = o
        }
        s.makeAllReady()
    }, CreatureModuleUtils.FillDeformationGapCache = function(t, e, i, s, n) {
        var r = e - t;
        if (r > 1)
            for (var a = s.getIndexByTime(t), o = 1; o < r; o++) {
                for (var h = o / r, l = [], u = 0; u < n.length; u++) {
                    var c = s.displacement_cache_table[i][u],
                        d = s.displacement_cache_table[a][u],
                        p = new MeshDisplacementCache(c.getKey());
                    c.getLocalDisplacements().length > 0 ? p.setLocalDisplacements(Utils.ptsInterp(d.getLocalDisplacements(), c.getLocalDisplacements(), h)) : p.setPostDisplacements(Utils.ptsInterp(d.getPostDisplacements(), c.getPostDisplacements(), h)), l.push(p)
                }
                s.displacement_cache_table[a + o] = l
            }
    }, CreatureModuleUtils.FillDeformationCache = function(t, e, i, s, n) {
        var r = t[e];
        n.init(i, s);
        var a = i;
        for (var o in r) {
            var h = r[o],
                l = [];
            for (var u in h) {
                var c = h[u],
                    d = new MeshDisplacementCache(u),
                    p = CreatureModuleUtils.ReadBoolJSON(c, "use_local_displacements"),
                    f = CreatureModuleUtils.ReadBoolJSON(c, "use_post_displacements");
                if (1 == p) {
                    m = CreatureModuleUtils.ReadPointsArray2DJSON(c, "local_displacements");
                    d.setLocalDisplacements(m)
                }
                if (1 == f) {
                    var m = CreatureModuleUtils.ReadPointsArray2DJSON(c, "post_displacements");
                    d.setPostDisplacements(m)
                }
                l.push(d)
            }
            var g = n.getIndexByTime(o);
            n.displacement_cache_table[g] = l, CreatureModuleUtils.FillDeformationGapCache(a, o, g, n, l), a = o
        }
        n.makeAllReady()
    }, CreatureModuleUtils.FillDeformationCacheFlat = function(t, e, i, s) {
        s.init(e, i);
        for (var n = e, r = 0; r < t.timeSamplesLength(); r++) {
            for (var a = t.timeSamples(r), o = a.time(), h = [], l = 0; l < a.meshesLength(); l++) {
                var u = a.meshes(l),
                    c = new MeshDisplacementCache(u.name()),
                    d = u.useLocalDisplacements(),
                    p = u.usePostDisplacements();
                if (1 == d) {
                    f = CreatureModuleUtils.ReadPointsArray2DFlat(u.localDisplacementsArray());
                    c.setLocalDisplacements(f)
                }
                if (1 == p) {
                    u.postDisplacementsLength();
                    var f = CreatureModuleUtils.ReadPointsArray2DFlat(u.postDisplacementsArray());
                    c.setPostDisplacements(f)
                }
                h.push(c)
            }
            var m = s.getIndexByTime(o);
            s.displacement_cache_table[m] = h, CreatureModuleUtils.FillDeformationGapCache(n, o, m, s, h), n = o
        }
        s.makeAllReady()
    }, CreatureModuleUtils.FillUVSwapCache = function(t, e, i, s, n) {
        var r = t[e];
        n.init(i, s);
        for (var a in r) {
            var o = r[a],
                h = [];
            for (var l in o) {
                var u = o[l],
                    c = new MeshUVWarpCache(l),
                    d = CreatureModuleUtils.ReadBoolJSON(u, "enabled");
                if (c.setEnabled(d), 1 == d) {
                    var p = CreatureModuleUtils.ReadVector2JSON(u, "local_offset"),
                        f = CreatureModuleUtils.ReadVector2JSON(u, "global_offset"),
                        m = CreatureModuleUtils.ReadVector2JSON(u, "scale");
                    c.setUvWarpLocalOffset(p), c.setUvWarpGlobalOffset(f), c.setUvWarpScale(m)
                }
                h.push(c)
            }
            var g = n.getIndexByTime(a);
            n.uv_cache_table[g] = h
        }
        n.makeAllReady()
    }, CreatureModuleUtils.FillUVSwapCacheFlat = function(t, e, i, s) {
        s.init(e, i);
        for (var n = 0; n < t.timeSamplesLength(); n++) {
            for (var r = t.timeSamples(n), a = r.time(), o = [], h = 0; h < r.uvSwapsLength(); h++) {
                var l = r.uvSwaps(h),
                    u = new MeshUVWarpCache(l.name()),
                    c = l.enabled();
                if (u.setEnabled(c), 1 == c) {
                    var d = CreatureModuleUtils.ReadVector2Flat(l.localOffsetArray()),
                        p = CreatureModuleUtils.ReadVector2Flat(l.globalOffsetArray()),
                        f = CreatureModuleUtils.ReadVector2Flat(l.scaleArray());
                    u.setUvWarpLocalOffset(d), u.setUvWarpGlobalOffset(p), u.setUvWarpScale(f)
                }
                o.push(u)
            }
            var m = s.getIndexByTime(a);
            s.uv_cache_table[m] = o
        }
        s.makeAllReady()
    }, CreatureModuleUtils.FillOpacityGapCache = function(t, e, i, s, n) {
        var r = e - t;
        if (r > 1)
            for (var a = s.getIndexByTime(t), o = 1; o < r; o++) {
                for (var h = o / r, l = [], u = 0; u < n.length; u++) {
                    var c = s.opacity_cache_table[i][u],
                        d = s.opacity_cache_table[a][u],
                        p = new MeshOpacityCache(c.getKey());
                    p.setOpacity(Utils.scalarInterp(d.getOpacity(), c.getOpacity(), h)), l.push(p)
                }
                s.opacity_cache_table[a + o] = l
            }
    }, CreatureModuleUtils.FillOpacityCache = function(t, e, i, s, n) {
        var r = t[e];
        n.init(i, s);
        var a = i;
        for (var o in r) {
            var h = r[o],
                l = [];
            for (var u in h) {
                var c = h[u],
                    d = new MeshOpacityCache(u);
                d.setOpacity(c.opacity), l.push(d)
            }
            var p = n.getIndexByTime(o);
            n.opacity_cache_table[p] = l, CreatureModuleUtils.FillOpacityGapCache(a, o, p, n, l), a = o
        }
        n.makeAllReady()
    }, CreatureModuleUtils.FillOpacityCacheFlat = function(t, e, i, s) {
        s.init(e, i);
        for (var n = e, r = 0; r < t.timeSamplesLength(); r++) {
            for (var a = t.timeSamples(r), o = a.time(), h = [], l = 0; l < a.meshOpacitiesLength(); l++) {
                var u = a.meshOpacities(l),
                    c = new MeshOpacityCache(u.name());
                c.setOpacity(u.opacity()), h.push(c)
            }
            var d = s.getIndexByTime(o);
            s.opacity_cache_table[d] = h, CreatureModuleUtils.FillOpacityGapCache(n, o, d, s, h), n = o
        }
        s.makeAllReady()
    }, CreatureModuleUtils.FillSwapUVPacketMap = function(t) {
        ret_map = {};
        for (var e in t) {
            for (var i = t[e], s = e, n = [], r = 0; r < i.length; r++) {
                var a = i[r],
                    o = new CreatureUVSwapPacket(CreatureModuleUtils.ReadVector2JSON(a, "local_offset"), CreatureModuleUtils.ReadVector2JSON(a, "global_offset"), CreatureModuleUtils.ReadVector2JSON(a, "scale"), a.tag);
                n.push(o)
            }
            ret_map[s] = n
        }
        return ret_map
    }, CreatureModuleUtils.FillSwapUVPacketMapFlat = function(t) {
        ret_map = {};
        for (var e = 0; e < t.meshesLength(); e++) {
            for (var i = t.meshes(e), s = i.name(), n = [], r = 0; r < i.itemsLength(); r++) {
                var a = i.items(r),
                    o = new CreatureUVSwapPacket(CreatureModuleUtils.ReadVector2Flat(a.localOffsetArray()), CreatureModuleUtils.ReadVector2Flat(a.globalOffsetArray()), CreatureModuleUtils.ReadVector2Flat(a.scaleArray()), a.tag());
                n.push(o)
            }
            ret_map[s] = n
        }
        return ret_map
    }, CreatureModuleUtils.FillAnchorPointMap = function(t) {
        var e = t.AnchorPoints;
        ret_map = {};
        for (var i = 0; i < e.length; i++) {
            var s = e[i],
                n = CreatureModuleUtils.ReadVector2JSON(s, "point"),
                r = s.anim_clip_name;
            ret_map[r] = n
        }
        return ret_map
    }, CreatureModuleUtils.FillAnchorPointMapFlat = function(t) {
        ret_map = {};
        for (var e = 0; e < t.anchorPointsLength(); e++) {
            var i = t.anchorPoints(e),
                s = CreatureModuleUtils.ReadVector2Flat(i.pointArray()),
                n = i.animClipName();
            ret_map[n] = s
        }
        return ret_map
    }, Creature.prototype.InitDefaultData = function() {
        this.total_num_pts = 0, this.total_num_indices = 0, this.global_indices = null, this.global_pts = null, this.global_uvs = null, this.render_pts = null, this.render_colours = null, this.render_composition = null, this.boundary_indices = [], this.boundary_min = vec2.create(), this.boundary_max = vec2.create(), this.uv_swap_packets = {}, this.active_uv_swap_actions = {}, this.anchor_point_map = {}, this.anchor_points_active = !1, this.skin_swap_active = !1, this.skin_swap_name = "", this.final_skin_swap_indices = null, this.creature_meta_data = null
    }, Creature.prototype.SetMetaData = function(t) {
        this.creature_meta_data = t
    }, Creature.prototype.EnableSkinSwap = function(t, e) {
        this.skin_swap_active = e, this.skin_swap_active ? (this.skin_swap_name = t, this.final_skin_swap_indices = this.creature_meta_data.buildSkinSwapIndices(this.skin_swap_name, this.render_composition)) : (this.skin_swap_name = "", this.final_skin_swap_indices = null)
    }, Creature.prototype.DisableSkinSwap = function() {
        this.EnableSkinSwap("", !1)
    }, Creature.prototype.ShouldSkinSwap = function() {
        return this.creature_meta_data && this.skin_swap_active && this.final_skin_swap_indices
    }, Creature.prototype.SetActiveItemSwap = function(t, e) {
        this.active_uv_swap_actions[t] = e
    }, Creature.prototype.RemoveActiveItemSwap = function(t) {
        delete this.active_uv_swap_actions[t]
    }, Creature.prototype.GetAnchorPoint = function(t) {
        return t in this.anchor_point_map ? this.anchor_point_map[t] : vec2.fromValues(0, 0)
    }, Creature.prototype.FillRenderColours = function(t, e, i, s) {
        for (var n = 0; n < this.total_num_pts; n++) {
            var r = 4 * n;
            this.render_colours[0 + r] = t, this.render_colours[1 + r] = e, this.render_colours[2 + r] = i, this.render_colours[3 + r] = s
        }
    }, Creature.prototype.ComputeBoundaryIndices = function() {
        for (var t = {}, e = 0; e < this.total_num_pts; e++) t[e] = 0;
        for (var i = this.render_composition.getRegions(), e = 0; e < this.global_indices.length; e++) {
            for (var s = this.global_indices[e], n = !1, r = 0; r < i.length; r++) {
                var a = i[r],
                    o = a.getStartPtIndex(),
                    h = a.getEndPtIndex();
                if (s >= o && s <= h) {
                    n = !0;
                    break
                }
            }
            n && t[s]++
        }
        this.boundary_indices = [];
        for (e = 0; e < this.total_num_pts; e++) t[e] <= 5 && this.boundary_indices.push(e)
    }, Creature.prototype.ComputeBoundaryMinMax = function() {
        this.boundary_indices.length <= 0 && this.ComputeBoundaryIndices();
        for (var t = 3 * this.boundary_indices[0], e = vec2.fromValues(this.render_pts[t + 0], this.render_pts[t + 1]), i = vec2.fromValues(e[0], e[1]), s = 0; s < this.boundary_indices.length; s++) {
            var n = 3 * this.boundary_indices[s],
                r = this.render_pts[n],
                a = this.render_pts[n + 1];
            e[0] > r && (e[0] = r), e[1] > a && (e[1] = a), i[0] < r && (i[0] = r), i[1] < a && (i[1] = a)
        }
        this.boundary_min = e, this.boundary_max = i
    }, Creature.prototype.LoadFromData = function(t) {
        var e = t.mesh;
        this.global_pts = CreatureModuleUtils.ReadFloatArray3DJSON(e, "points"), this.total_num_pts = this.global_pts.length / 3, this.global_indices = CreatureModuleUtils.ReadIntArrayJSON(e, "indices"), this.total_num_indices = this.global_indices.length, this.global_uvs = CreatureModuleUtils.ReadFloatArrayJSON(e, "uvs"), this.render_colours = [];
        for (n = 0; n < 4 * this.total_num_pts; n++) this.render_colours.push(0);
        this.FillRenderColours(1, 1, 1, 1), this.render_pts = [];
        var i = CreatureModuleUtils.CreateBones(t, "skeleton"),
            s = CreatureModuleUtils.CreateRegions(e, "regions", this.global_indices, this.global_pts, this.global_uvs);
        this.render_composition = new MeshRenderBoneComposition, this.render_composition.setRootBone(i), this.render_composition.getRootBone().computeRestParentTransforms();
        for (n = 0; n < s.length; n++)(r = s[n]).setMainBoneKey(i.getKey()), r.determineMainBone(i), this.render_composition.addRegion(r);
        this.render_composition.initBoneMap(), this.render_composition.initRegionsMap();
        for (var n = 0; n < s.length; n++) {
            var r = s[n];
            r.initFastNormalWeightMap(this.render_composition.bones_map)
        }
        if (this.render_composition.resetToWorldRestPts(), "uv_swap_items" in t) {
            var a = t.uv_swap_items;
            this.uv_swap_packets = CreatureModuleUtils.FillSwapUVPacketMap(a)
        }
        if ("anchor_points_items" in t) {
            var o = t.anchor_points_items;
            this.anchor_point_map = CreatureModuleUtils.FillAnchorPointMap(o)
        }
    }, Creature.prototype.LoadFromDataFlat = function(t) {
        var e = t.dataMesh(),
            i = t.dataSkeleton();
        this.global_pts = CreatureModuleUtils.ReadFloatArray3DFlat(e.pointsArray()), this.total_num_pts = this.global_pts.length / 3, this.global_indices = CreatureModuleUtils.getIntArray(e.indicesArray()), this.total_num_indices = this.global_indices.length, this.global_uvs = CreatureModuleUtils.getFloatArray(e.uvsArray()), this.render_colours = [];
        for (r = 0; r < 4 * this.total_num_pts; r++) this.render_colours.push(0);
        this.FillRenderColours(1, 1, 1, 1), this.render_pts = [];
        var s = CreatureModuleUtils.CreateBonesFlat(i),
            n = CreatureModuleUtils.CreateRegionsFlat(e, this.global_indices, this.global_pts, this.global_uvs);
        this.render_composition = new MeshRenderBoneComposition, this.render_composition.setRootBone(s), this.render_composition.getRootBone().computeRestParentTransforms();
        for (r = 0; r < n.length; r++)(a = n[r]).setMainBoneKey(s.getKey()), a.determineMainBone(s), this.render_composition.addRegion(a);
        this.render_composition.initBoneMap(), this.render_composition.initRegionsMap();
        for (var r = 0; r < n.length; r++) {
            var a = n[r];
            a.initFastNormalWeightMap(this.render_composition.bones_map)
        }
        this.render_composition.resetToWorldRestPts();
        var o = t.dataUvSwapItem();
        this.uv_swap_packets = CreatureModuleUtils.FillSwapUVPacketMapFlat(o);
        var h = t.dataAnchorPoints();
        this.anchor_point_map = CreatureModuleUtils.FillAnchorPointMapFlat(h)
    }, CreatureAnimation.prototype.initDefaultData = function(t) {
        this.name = t, this.bones_cache = new MeshBoneCacheManager, this.displacement_cache = new MeshDisplacementCacheManager, this.uv_warp_cache = new MeshUVWarpCacheManager, this.opacity_cache = new MeshOpacityCacheManager, this.cache_pts = [], this.fill_cache_pts = []
    }, CreatureAnimation.prototype.LoadFromData = function(t, e) {
        var i = e.animation[t],
            s = CreatureModuleUtils.GetStartEndTimes(i, "bones");
        this.start_time = s.first, this.end_time = s.second, CreatureModuleUtils.FillBoneCache(i, "bones", this.start_time, this.end_time, this.bones_cache), CreatureModuleUtils.FillDeformationCache(i, "meshes", this.start_time, this.end_time, this.displacement_cache), CreatureModuleUtils.FillUVSwapCache(i, "uv_swaps", this.start_time, this.end_time, this.uv_warp_cache), CreatureModuleUtils.FillOpacityCache(i, "mesh_opacities", this.start_time, this.end_time, this.opacity_cache)
    }, CreatureAnimation.prototype.LoadFromDataFlat = function(t, e) {
        for (var i = null, s = 0; s < e.clipsLength(); s++)
            if (e.clips(s).name() == t) {
                i = e.clips(s);
                break
            }
        var n = CreatureModuleUtils.GetStartEndTimesFlat(i.bones());
        this.start_time = n.first, this.end_time = n.second, CreatureModuleUtils.FillBoneCacheFlat(i.bones(), this.start_time, this.end_time, this.bones_cache), CreatureModuleUtils.FillDeformationCacheFlat(i.meshes(), this.start_time, this.end_time, this.displacement_cache), CreatureModuleUtils.FillUVSwapCacheFlat(i.uvSwaps(), this.start_time, this.end_time, this.uv_warp_cache), CreatureModuleUtils.FillOpacityCacheFlat(i.meshOpacities(), this.start_time, this.end_time, this.opacity_cache)
    }, CreatureAnimation.prototype.getIndexByTime = function(t) {
        var e = t - this.start_time;
        return e = Utils.clamp(e, 0, this.cache_pts.length - 1)
    }, CreatureAnimation.prototype.verifyFillCache = function() {
        this.fill_cache_pts.length == this.end_time - this.start_time + 1 && (this.cache_pts = this.fill_cache_pts)
    }, CreatureAnimation.prototype.poseFromCachePts = function(t, e, i) {
        for (var s = this.getIndexByTime(Math.floor(t)), n = this.getIndexByTime(Math.ceil(t)), r = t - Math.floor(t), a = e, o = this.cache_pts[s], h = this.cache_pts[n], l = 0, u = 0, c = 0, d = 0; d < i; d++) a[l + 0] = (1 - r) * o[u + 0] + r * h[c + 0], a[l + 1] = (1 - r) * o[u + 1] + r * h[c + 1], a[l + 2] = (1 - r) * o[u + 2] + r * h[c + 2], l += 3, u += 3, c += 3
    }, CreatureFrameCallback.prototype.resetCallback = function() {
        this.triggered = !1
    }, CreatureFrameCallback.prototype.tryTrigger = function(t) {
        return !this.triggered && (Math.round(t) >= this.frame && (this.triggered = !0, !0))
    }, CreatureGameController.prototype.BuildFrameCallbacks = function(t) {
        if (null != this.meta_asset)
            for (var e in this.meta_asset.anim_events_map) {
                var i = this.meta_asset.anim_events_map[e];
                for (var s in i) {
                    var n = i[s],
                        r = new CreatureFrameCallback;
                    r.animClipName = e, r.name = n, r.frame = Number(s), r.callback = t(animClipName, name), this.event_callbacks.push(r)
                }
            }
    }, CreatureGameController.prototype.AddFrameCallback = function(t, e, i, s) {
        var n = new CreatureFrameCallback;
        n.animClipName = t, n.name = e, n.frame = i, n.callback = s, this.event_callbacks.push(n)
    }, CreatureGameController.prototype.ResetFrameCallbacks = function() {
        for (var t in this.event_callbacks) this.event_callbacks[t].resetCallback()
    }, CreatureGameController.prototype.ProcessCallbacks = function(t) {
        var e = t.getActualRuntime();
        e < this.run_time && this.ResetFrameCallbacks(), this.run_time = e;
        for (var i = 0; i < this.event_callbacks.length; i++) {
            var s = this.event_callbacks[i];
            s.animClipName == t.active_animation_name && s.tryTrigger(e) && null != s.callback && s.callback(s.name, e)
        }
    }, CreatureMetaData.prototype.clear = function() {
        this.skin_swaps = {}, this.anim_events_map = {}
    }, CreatureMetaData.prototype.buildSkinSwapIndices = function(t, e) {
        var i = null;
        if (!(t in this.skin_swaps)) return i = [];
        var s = this.skin_swaps[t],
            n = e.getRegionsMap();
        for (var r in n) r in s && (a = n[r]).getNumIndices();
        i = [];
        for (var r in n)
            if (r in s) {
                for (var a = n[r], o = 0; o < a.getNumIndices(); o++) i.push(a.getLocalIndex(o));
                a.getNumIndices()
            }
        return i
    }, CreatureManager.prototype.CreateAnimation = function(t, e) {
        var i = new CreatureAnimation(t, e);
        this.AddAnimation(i)
    }, CreatureManager.prototype.CreateAllAnimations = function(t) {
        for (var e = CreatureModuleUtils.GetAllAnimationNames(t), i = 0; i < e.length; i++) {
            var s = e[i];
            this.CreateAnimation(t, s)
        }
        this.SetActiveAnimationName(e[0])
    }, CreatureManager.prototype.AddAnimation = function(t) {
        this.animations[t.name] = t
    }, CreatureManager.prototype.GetAnimation = function(t) {
        return this.animations[t]
    }, CreatureManager.prototype.GetCreature = function() {
        return this.target_creature
    }, CreatureManager.prototype.GetAnimationNames = function() {
        var t = [];
        for (var e in animations) t.push(e);
        return t
    }, CreatureManager.prototype.SetActiveAnimationName = function(t, e) {
        if (null == t || t in this.animations == 0) return !1;
        if (1 == e && this.active_animation_name == t) return !1;
        this.active_animation_name = t;
        var i = this.animations[this.active_animation_name];
        return this.run_time = i.start_time, this.UpdateRegionsSwitches(t), !0
    }, CreatureManager.prototype.GetActiveAnimationName = function() {
        return this.active_animation_name
    }, CreatureManager.prototype.GetAllAnimations = function() {
        return this.animations
    }, CreatureManager.prototype.MakePointCache = function(t) {
        var e = this.getRunTime(),
            i = this.animations[t];
        if (!(i.length > 0)) {
            var s = i.cache_pts;
            this.UpdateRegionsSwitches(t);
            for (var n = i.start_time; n <= i.end_time; n++) {
                this.setRunTime(n);
                for (var r = [], a = 0; a < 3 * this.target_creature.total_num_pts; a++) r[a] = 0;
                this.PoseCreature(t, r, this.getRunTime()), s.push(r)
            }
            this.setRunTime(e)
        }
    }, CreatureManager.prototype.FillSinglePointCacheFrame = function(t, e) {
        var i = this.getRunTime(),
            s = this.animations[t];
        this.setRunTime(e);
        for (var n = [], r = 0; r < 3 * this.target_creature.total_num_pts; r++) n[r] = 0;
        this.PoseCreature(t, n, e), s.fill_cache_pts.push(n), s.verifyFillCache(), this.setRunTime(i)
    }, CreatureManager.prototype.GetIsPlaying = function() {
        return this.is_playing
    }, CreatureManager.prototype.SetShouldLoop = function(t) {
        this.should_loop = t
    }, CreatureManager.prototype.SetUseCustomTimeRange = function(t) {
        this.use_custom_time_range = t
    }, CreatureManager.prototype.SetCustomTimeRange = function(t, e) {
        this.custom_start_time = t, this.custom_end_time = e
    }, CreatureManager.prototype.SetIsPlaying = function(t) {
        this.is_playing = t
    }, CreatureManager.prototype.ProcessAutoBlending = function() {
        this.blending_factor += this.auto_blend_delta, this.blending_factor > 1 && (this.blending_factor = 1)
    }, CreatureManager.prototype.IncreAutoBlendRunTimes = function(t) {
        set_animation_name = "";
        for (var e = 0; e < this.auto_blend_names.length; e++) {
            var i = this.auto_blend_names[e];
            i in this.animations && set_animation_name != i && (cur_run_time = this.active_blend_run_times[i], cur_run_time += t, cur_run_time = this.correctRunTime(cur_run_time, i), this.active_blend_run_times[i] = cur_run_time, set_animation_name = i)
        }
    }, CreatureManager.prototype.correctRunTime = function(t, e) {
        return ret_time = t, cur_animation = this.animations[e], anim_start_time = cur_animation.start_time, anim_end_time = cur_animation.end_time, ret_time > anim_end_time ? this.should_loop ? ret_time = anim_start_time : ret_time = anim_end_time : ret_time < anim_start_time && (this.should_loop ? ret_time = anim_end_time : ret_time = anim_start_time), ret_time
    }, CreatureManager.prototype.ResetToStartTimes = function() {
        var t = this.animations[active_animation_name];
        this.run_time = t.start_time
    }, CreatureManager.prototype.setRunTime = function(t) {
        this.run_time = t, this.correctTime()
    }, CreatureManager.prototype.increRunTime = function(t) {
        this.run_time += t, this.correctTime()
    }, CreatureManager.prototype.correctTime = function() {
        var t = this.animations[this.active_animation_name],
            e = t.start_time,
            i = t.end_time;
        this.use_custom_time_range && (e = this.custom_start_time, i = this.custom_end_time), this.run_time > i ? this.should_loop ? this.run_time = e : this.run_time = i : this.run_time < e && (this.should_loop ? this.run_time = i : this.run_time = e)
    }, CreatureManager.prototype.getRunTime = function() {
        return this.run_time
    }, CreatureManager.prototype.getActualRuntime = function() {
        return this.do_auto_blending && this.active_animation_name in this.active_blend_run_times ? this.active_blend_run_times[this.active_animation_name] : this.run_time
    }, CreatureManager.prototype.checkAnimationBlendValid = function() {
        for (var t = 0; t < 2; t++)
            if (cur_animation_name = this.active_blend_animation_names[t], !(cur_animation_name in this.animations && cur_animation_name in this.active_blend_run_times)) return !1;
        return !0
    }, CreatureManager.prototype.UpdateRegionsSwitches = function(t) {
        for (var e = this.animations[t], i = e.displacement_cache.displacement_cache_table[0], s = e.uv_warp_cache.uv_cache_table[0], n = this.target_creature.render_composition.getRegions(), r = 0, a = 0; a < n.length; a++) {
            var o = n[a],
                h = !(0 == i[r].getLocalDisplacements().length),
                l = !(0 == i[r].getPostDisplacements().length);
            o.setUseLocalDisplacements(h), o.setUsePostDisplacements(l), o.setUseUvWarp(s[r].getEnabled()), r++
        }
    }, CreatureManager.prototype.Update = function(t) {
        this.is_playing && (this.increRunTime(t * this.time_scale), this.do_auto_blending && (this.ProcessAutoBlending(), this.IncreAutoBlendRunTimes(t * this.time_scale)), this.RunCreature())
    }, CreatureManager.prototype.RunAtTime = function(t) {
        this.is_playing && (this.setRunTime(t), this.RunCreature())
    }, CreatureManager.prototype.RunCreature = function() {
        if (this.do_blending) {
            for (var t = 0; t < 2; t++) {
                cur_animation_name = this.active_blend_animation_names[t];
                var e = this.animations[this.active_blend_animation_names[t]];
                cur_animation_run_time = this.active_blend_run_times[cur_animation_name], e.cache_pts.length > 0 ? (this.UpdateRegionsSwitches(cur_animation_name), e.poseFromCachePts(cur_animation_run_time, this.blend_render_pts[t], this.target_creature.total_num_pts)) : (this.UpdateRegionsSwitches(cur_animation_name), this.PoseCreature(this.active_blend_animation_names[t], this.blend_render_pts[t], cur_animation_run_time))
            }
            for (var i = 0; i < 3 * this.target_creature.total_num_pts; i++) {
                var s = i,
                    n = this.blend_render_pts[0][i],
                    r = this.blend_render_pts[1][i];
                this.target_creature.render_pts[s] = (1 - this.blending_factor) * n + this.blending_factor * r
            }
        } else(e = this.animations[this.active_animation_name]).cache_pts.length > 0 ? e.poseFromCachePts(this.getRunTime(), this.target_creature.render_pts, this.target_creature.total_num_pts) : this.PoseCreature(this.active_animation_name, this.target_creature.render_pts, this.getRunTime());
        this.RunUVItemSwap()
    }, CreatureManager.prototype.RunUVItemSwap = function() {
        var t = this.target_creature.render_composition.getRegionsMap(),
            e = this.target_creature.uv_swap_packets,
            i = this.target_creature.active_uv_swap_actions;
        if (!isDictEmpty(e) && !isDictEmpty(i))
            for (var s in i)
                if (s in t)
                    for (var n = i[s], r = e[s], a = 0; a < r.length; a++) {
                        var o = r[a];
                        if (o.tag == n) {
                            var h = t[s];
                            h.setUvWarpLocalOffset(o.local_offset), h.setUvWarpGlobalOffset(o.global_offset), h.setUvWarpScale(o.scale), h.runUvWarp();
                            break
                        }
                    }
    }, CreatureManager.prototype.AlterBonesByAnchor = function(t, e) {
        if (0 != this.target_creature.anchor_points_active) {
            var i = this.target_creature.GetAnchorPoint(e);
            for (var s in t) {
                var n = t[s],
                    r = n.getWorldStartPt(),
                    a = n.getWorldEndPt();
                r = vec3.subtract(r, r, vec3.fromValues(i[0], i[1], 0)), a = vec3.subtract(a, a, vec3.fromValues(i[0], i[1], 0)), n.setWorldStartPt(r), n.setWorldEndPt(a)
            }
        }
    }, CreatureManager.prototype.SetTimeScale = function(t) {
        this.time_scale = t
    }, CreatureManager.prototype.SetBlending = function(t) {
        if (this.do_blending = t, this.do_blending) {
            if (0 == this.blend_render_pts[0].length) {
                for (var e = [], i = 0; i < 3 * this.target_creature.total_num_pts; i++) e.push(0);
                this.blend_render_pts.push(e)
            }
            if (0 == this.blend_render_pts[1].length) {
                for (var e = [], i = 0; i < 3 * this.target_creature.total_num_pts; i++) e.push(0);
                this.blend_render_pts[1] = e
            }
        }
    }, CreatureManager.prototype.SetAutoBlending = function(t) {
        this.do_auto_blending = t, this.SetBlending(t), this.do_auto_blending && this.AutoBlendTo(this.active_animation_name, .1)
    }, CreatureManager.prototype.AutoBlendTo = function(t, e) {
        t != this.auto_blend_names[1] && (this.ResetBlendTime(t), this.auto_blend_delta = e, this.auto_blend_names[0] = this.active_animation_name, this.auto_blend_names[1] = t, this.blending_factor = 0, this.active_animation_name = t, this.SetBlendingAnimations(this.auto_blend_names[0], this.auto_blend_names[1]))
    }, CreatureManager.prototype.ResetBlendTime = function(t) {
        cur_animation = this.animations[t], this.active_blend_run_times[t] = cur_animation.start_time
    }, CreatureManager.prototype.SetBlendingAnimations = function(t, e) {
        this.active_blend_animation_names[0] = t, this.active_blend_animation_names[1] = e
    }, CreatureManager.prototype.SetBlendingFactor = function(t) {
        this.blending_factor = t
    }, CreatureManager.prototype.IsContactBone = function(t, e) {
        var i = this.target_creature.render_composition.getRootBone();
        return this.ProcessContactBone(t, e, i)
    }, CreatureManager.prototype.PoseCreature = function(t, e, i) {
        var s = this.animations[t],
            n = s.bones_cache,
            r = s.displacement_cache,
            a = s.uv_warp_cache,
            o = s.opacity_cache,
            h = this.target_creature.render_composition,
            l = h.getBonesMap(),
            u = h.getRegionsMap();
        n.retrieveValuesAtTime(i, l), this.AlterBonesByAnchor(l, t), null != this.bones_override_callback && this.bones_override_callback(l), r.retrieveValuesAtTime(i, u), a.retrieveValuesAtTime(i, u), o.retrieveValuesAtTime(i, u);
        var c = h.getRegions(),
            d = h.getBonesMap();
        h.updateAllTransforms(!1);
        for (var p = 0, f = c.length; p < f; p++) {
            var m = c[p],
                g = m.getStartPtIndex();
            m.poseFinalPts(e, 3 * g, d);
            for (var v = 3 * m.getStartPtIndex(), y = 3 * m.getEndPtIndex(), _ = v; _ <= y; _ += 3) e[_ + 2] = .001 * -p
        }
    },
    function() {
        function t(t, e, i, n) {
            var r = t.createTexture();
            return t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n === s.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n === s.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null), r
        }

        function e(e, i, s, r, a) {
            var o = e.createFramebuffer(),
                h = e.createRenderbuffer(),
                l = null,
                u = 0;
            return e.activeTexture(e.TEXTURE0 + a), e.bindFramebuffer(e.FRAMEBUFFER, o), e.bindRenderbuffer(e.RENDERBUFFER, h), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this.renderBuffer), l = t(e, i, s, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, l, 0), (u = e.checkFramebufferStatus(e.FRAMEBUFFER)) !== e.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", n[u]), o.width = i, o.height = s, o.targetTexture = l, o.renderBuffer = h, o
        }
        var i = this,
            s = s || {};
        s.DisplayObject = function() {
            this.position = new s.Point(0, 0), this.scale = new s.Point(1, 1), this.pivot = new s.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new Phaser.Matrix, this.worldPosition = new s.Point(0, 0), this.worldScale = new s.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new s.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, s.DisplayObject.prototype = {
            constructor: s.DisplayObject,
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--;) this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), this._destroyTintedTexture()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game) return this;
                var e = this.parent;
                t ? e = t : this.parent || (e = this.game.world);
                var i, s, n, r, a, o, h = e.worldTransform,
                    l = this.worldTransform;
                this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, a = this.position.x, o = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * i + this.pivot.y * n, o -= this.pivot.x * s + this.pivot.y * r), l.a = i * h.a + s * h.c, l.b = i * h.b + s * h.d, l.c = n * h.a + r * h.c, l.d = n * h.b + r * h.d, l.tx = a * h.a + o * h.c + h.tx, l.ty = a * h.b + o * h.d + h.ty) : (i = this.scale.x, s = 0, n = 0, r = this.scale.y, a = this.position.x - this.pivot.x * i, o = this.position.y - this.pivot.y * r, l.a = i * h.a, l.b = i * h.b, l.c = r * h.c, l.d = r * h.d, l.tx = a * h.a + o * h.c + h.tx, l.ty = a * h.b + o * h.d + h.ty), i = l.a, s = l.b, n = l.c;
                var u = i * (r = l.d) - s * n;
                if (i || s) {
                    var c = Math.sqrt(i * i + s * s);
                    this.worldRotation = s > 0 ? Math.acos(i / c) : -Math.acos(i / c), this.worldScale.x = c, this.worldScale.y = u / c
                } else if (n || r) {
                    var d = Math.sqrt(n * n + r * r);
                    this.worldRotation = Phaser.Math.HALF_PI - (r > 0 ? Math.acos(-n / d) : -Math.acos(n / d)), this.worldScale.x = u / d, this.worldScale.y = d
                } else this.worldScale.x = 0, this.worldScale.y = 0;
                return this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.x = l.tx, this.worldPosition.y = l.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, l, h), this
            },
            preUpdate: function() {},
            generateTexture: function(t, e, i) {
                var n = this.getLocalBounds(),
                    r = new Phaser.RenderTexture(this.game, 0 | n.width, 0 | n.height, i, e, t);
                return s.DisplayObject._tempMatrix.tx = -n.x, s.DisplayObject._tempMatrix.ty = -n.y, r.render(this, s.DisplayObject._tempMatrix), r
            },
            updateCache: function() {
                return this._generateCachedSprite(), this
            },
            toGlobal: function(t) {
                return this.updateTransform(), this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? s.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : s.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
                else {
                    var e = 0;
                    this.texture && this.texture.baseTexture && s._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                    var i = new Phaser.RenderTexture(this.game, t.width, t.height, void 0, void 0, void 0, void 0, e);
                    this._cachedSprite = new s.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform
                }
                var n = this._filters;
                this._filters = null, this._cachedSprite.filters = n, s.DisplayObject._tempMatrix.tx = -t.x, s.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, s.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = n, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            },
            _destroyTintedTexture: function() {
                this.tintedTexture && (Phaser.CanvasPool.removeByCanvas(this.tintedTexture), this.tintedTexture = null)
            }
        }, s.DisplayObject.prototype.displayObjectUpdateTransform = s.DisplayObject.prototype.updateTransform, Object.defineProperties(s.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t) return this.visible;
                        do {
                            if (!t.visible) return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0; i < t.length; i++)
                            for (var n = t[i].passes, r = 0; r < n.length; r++) e.push(n[r]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: e
                        }
                    }
                    this._filters = t, this.blendMode && this.blendMode === s.blendModes.MULTIPLY && (this.blendMode = s.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                }
            }
        }), s.DisplayObjectContainer = function() {
            s.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, s.DisplayObjectContainer.prototype = Object.create(s.DisplayObject.prototype), s.DisplayObjectContainer.prototype.constructor = s.DisplayObjectContainer, s.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }, s.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }, s.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t),
                    s = this.getChildIndex(e);
                if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e, this.children[s] = t
            }
        }, s.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }, s.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1), this.children.splice(e, 0, t)
        }, s.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }, s.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e) return this.removeChildAt(e)
        }, s.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0, this.children.splice(t, 1)), e
        }, s.DisplayObjectContainer.prototype.bringChildToTop = function(t) {
            if (t.parent === this) return this.setChildIndex(t, this.children.length - 1)
        }, s.DisplayObjectContainer.prototype.sendChildToBack = function(t) {
            if (t.parent === this) return this.setChildIndex(t, 0)
        }, s.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
            var i = e - t;
            if (i > 0 && i <= e) {
                for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) s[n].parent = void 0;
                return s
            }
            if (0 === i && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, s.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, s.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = s.DisplayObjectContainer.prototype.updateTransform, s.DisplayObjectContainer.prototype.getBounds = function(t) {
            var e = t && t instanceof s.DisplayObject,
                i = !0;
            e ? i = t instanceof s.DisplayObjectContainer && t.contains(this) : t = this;
            var n;
            if (e) {
                var r = t.worldTransform;
                for (t.worldTransform = Phaser.identityMatrix, n = 0; n < t.children.length; n++) t.children[n].updateTransform()
            }
            var a, o, h, l = 1 / 0,
                u = 1 / 0,
                c = -1 / 0,
                d = -1 / 0,
                p = !1;
            for (n = 0; n < this.children.length; n++) this.children[n].visible && (p = !0, l = l < (a = this.children[n].getBounds()).x ? l : a.x, u = u < a.y ? u : a.y, o = a.width + a.x, h = a.height + a.y, c = c > o ? c : o, d = d > h ? d : h);
            var f = this._bounds;
            if (!p) {
                var m = (f = new s.Rectangle).x,
                    g = f.width + f.x,
                    v = f.y,
                    y = f.height + f.y,
                    _ = this.worldTransform,
                    x = _.a,
                    b = _.b,
                    T = _.c,
                    S = _.d,
                    w = _.tx,
                    M = _.ty,
                    C = x * g + T * y + w,
                    P = S * y + b * g + M,
                    E = x * m + T * y + w,
                    A = S * y + b * m + M,
                    I = x * m + T * v + w,
                    R = S * v + b * m + M,
                    D = x * g + T * v + w,
                    O = S * v + b * g + M;
                c = C, d = P, u = P, l = D < (l = I < (l = E < (l = C) ? E : l) ? I : l) ? D : l, u = O < (u = R < (u = A < u ? A : u) ? R : u) ? O : u, c = D > (c = I > (c = E > c ? E : c) ? I : c) ? D : c, d = O > (d = R > (d = A > d ? A : d) ? R : d) ? O : d
            }
            if (f.x = l, f.y = u, f.width = c - l, f.height = d - u, e)
                for (t.worldTransform = r, n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            if (!i) {
                var F = t.getBounds();
                f.x -= F.x, f.y -= F.y
            }
            return f
        }, s.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, s.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }, s.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            if (this.visible && !(this.alpha <= 0))
                if (this._cacheAsBitmap) this._renderCachedSprite(t);
                else {
                    var e;
                    if (this._mask || this._filters) {
                        for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                        t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                    } else
                        for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
                }
        }, s.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha)
                if (this._cacheAsBitmap) this._renderCachedSprite(t);
                else {
                    this._mask && t.maskManager.pushMask(this._mask, t);
                    for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
        }, Object.defineProperty(s.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds().width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds().width;
                this.scale.x = 0 !== e ? t / e : 1, this._width = t
            }
        }), Object.defineProperty(s.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds().height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds().height;
                this.scale.y = 0 !== e ? t / e : 1, this._height = t
            }
        }), s.Sprite = function(t) {
            s.DisplayObjectContainer.call(this), this.anchor = new s.Point(s.Sprite.defaultAnchor.x, s.Sprite.defaultAnchor.y), this.texture = t || s.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = s.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, s.Sprite.defaultAnchor = {
            x: 0,
            y: 0
        }, s.Sprite.prototype = Object.create(s.DisplayObjectContainer.prototype), s.Sprite.prototype.constructor = s.Sprite, Object.defineProperty(s.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(s.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), s.Sprite.prototype.setTexture = function(t, e) {
            e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
        }, s.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, s.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width,
                i = this.texture.frame.height,
                s = e * (1 - this.anchor.x),
                n = e * -this.anchor.x,
                r = i * (1 - this.anchor.y),
                a = i * -this.anchor.y,
                o = t || this.worldTransform,
                h = o.a,
                l = o.b,
                u = o.c,
                c = o.d,
                d = o.tx,
                p = o.ty,
                f = -1 / 0,
                m = -1 / 0,
                g = 1 / 0,
                v = 1 / 0;
            if (0 === l && 0 === u) {
                if (h < 0) {
                    h *= -1;
                    y = s;
                    s = -n, n = -y
                }
                if (c < 0) {
                    c *= -1;
                    var y = r;
                    r = -a, a = -y
                }
                g = h * n + d, f = h * s + d, v = c * a + p, m = c * r + p
            } else {
                var _ = h * n + u * a + d,
                    x = c * a + l * n + p,
                    b = h * s + u * a + d,
                    T = c * a + l * s + p,
                    S = h * s + u * r + d,
                    w = c * r + l * s + p,
                    M = h * n + u * r + d,
                    C = c * r + l * n + p;
                g = M < (g = S < (g = b < (g = _ < g ? _ : g) ? b : g) ? S : g) ? M : g, v = C < (v = w < (v = T < (v = x < v ? x : v) ? T : v) ? w : v) ? C : v, f = M > (f = S > (f = b > (f = _ > f ? _ : f) ? b : f) ? S : f) ? M : f, m = C > (m = w > (m = T > (m = x > m ? x : m) ? T : m) ? w : m) ? C : m
            }
            var P = this._bounds;
            return P.x = g, P.width = f - g, P.y = v, P.height = m - v, this._currentBounds = P, P
        }, s.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = Phaser.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, s.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e), this._mask || this._filters) {
                    var s = t.spriteBatch;
                    this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                    for (n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                    s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
                } else {
                    t.spriteBatch.render(this);
                    for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
                }
            }
        }, s.Sprite.prototype._renderCanvas = function(t, e) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width < 1 || this.texture.crop.height < 1)) {
                var i = this.worldTransform;
                if (e && (i = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = s.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                    var n = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === s.scaleModes.LINEAR);
                    var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        a = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        o = i.tx * t.resolution + t.shakeX,
                        h = i.ty * t.resolution + t.shakeY,
                        l = this.texture.crop.width,
                        u = this.texture.crop.height;
                    if (this.texture.rotated) {
                        var c = i.a,
                            d = i.b,
                            p = i.c,
                            f = i.d,
                            m = l;
                        o = i.c * u + o, h = i.d * u + h, i.a = 6.123233995736766e-17 * c - p, i.b = 6.123233995736766e-17 * d - f, i.c = c + 6.123233995736766e-17 * p, i.d = d + 6.123233995736766e-17 * f, l = u, u = m
                    }
                    if (t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | o, 0 | h), r |= 0, a |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, o, h), r /= n, a /= n, l |= 0, u |= 0, l && u) {
                        if (16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = s.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, u, r, a, l / n, u / n);
                        else {
                            var g = this.texture.crop.x,
                                v = this.texture.crop.y;
                            t.context.drawImage(this.texture.baseTexture.source, g, v, l, u, r, a, l / n, u / n)
                        }
                        for (y = 0; y < this.children.length; y++) this.children[y]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                } else {
                    for (var y = 0; y < this.children.length; y++) this.children[y]._renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            }
        }, s.initDefaultShaders = function() {}, s.CompileVertexShader = function(t, e) {
            return s._CompileShader(t, e, t.VERTEX_SHADER)
        }, s.CompileFragmentShader = function(t, e) {
            return s._CompileShader(t, e, t.FRAGMENT_SHADER)
        }, s._CompileShader = function(t, e, i) {
            var s = e;
            Array.isArray(e) && (s = e.join("\n"));
            var n = t.createShader(i);
            return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
        }, s.compileProgram = function(t, e, i) {
            var n = s.CompileFragmentShader(t, i),
                r = s.CompileVertexShader(t, e),
                a = t.createProgram();
            return t.attachShader(a, r), t.attachShader(a, n), t.linkProgram(a), t.getProgramParameter(a, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(a)), window.console.log("Could not initialise shaders")), a
        }, s.PixiShader = function(t) {
            this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = null, this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
        }, s.PixiShader.prototype.constructor = s.PixiShader, s.PixiShader.prototype.initMultitexShader = function() {
            var t = this.gl;
            this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) {gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;return;}\n";
            this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}", "}"];
            var n = s.compileProgram(t, this.vertexSrc || s.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(n), this.uSamplerArray = t.getUniformLocation(n, "uSamplerArray[0]"), this.projectionVector = t.getUniformLocation(n, "projectionVector"), this.offsetVector = t.getUniformLocation(n, "offsetVector"), this.dimensions = t.getUniformLocation(n, "dimensions"), this.aVertexPosition = t.getAttribLocation(n, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(n, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(n, "aColor"), this.aTextureIndex = t.getAttribLocation(n, "aTextureIndex");
            var r = [],
                a = t.createTexture();
            t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
            for (var o = 0; o < this.MAX_TEXTURES; ++o) t.activeTexture(t.TEXTURE0 + o), t.bindTexture(t.TEXTURE_2D, a), r.push(o);
            t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSamplerArray, r), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
            for (var h in this.uniforms) this.uniforms[h].uniformLocation = t.getUniformLocation(n, h);
            this.initUniforms(), this.program = n
        }, s.PixiShader.prototype.initDefaultShader = function() {
            null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc || s.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
            for (var i in this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
            this.initUniforms(), this.program = e
        }, s.PixiShader.prototype.init = function(t) {
            s._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
        }, s.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) {
                var s = (t = this.uniforms[i]).type;
                "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
            }
        }, s.PixiShader.prototype.initSampler2D = function(t) {
            if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                var e = this.gl;
                if (e.activeTexture(e.TEXTURE0 + this.textureCount), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                    var i = t.textureData,
                        s = i.magFilter ? i.magFilter : e.LINEAR,
                        n = i.minFilter ? i.minFilter : e.LINEAR,
                        r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                        a = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                        o = i.luminance ? e.LUMINANCE : e.RGBA;
                    if (i.repeat && (r = e.REPEAT, a = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                        var h = i.width ? i.width : 512,
                            l = i.height ? i.height : 2,
                            u = i.border ? i.border : 0;
                        e.texImage2D(e.TEXTURE_2D, 0, o, h, l, u, o, e.UNSIGNED_BYTE, null)
                    } else e.texImage2D(e.TEXTURE_2D, 0, o, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a)
                }
                e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
            }
        }, s.PixiShader.prototype.syncUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) 1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? s.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
        }, s.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, s.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"], s.PixiFastShader = function(t) {
            if (this._UID = Phaser._UID++, this.gl = t, this.program = null, s._enableMultiTextureToggle) {
                var t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) { gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;return;}\n";
                this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
            } else this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
            this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
        }, s.PixiFastShader.prototype.constructor = s.PixiFastShader, s.PixiFastShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            if (t.useProgram(e), this.uSampler = s._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), s._enableMultiTextureToggle) {
                var i = [],
                    n = t.createTexture();
                t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), i.push(r);
                t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, i)
            }
            this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.program = e
        }, s.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, s.StripShader = function(t) {
            if (this._UID = Phaser._UID++, this.gl = t, this.program = null, s._enableMultiTextureToggle) {
                var t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) { gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) ;return;}\n";
                this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
            } else this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
            this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"], this.init()
        }, s.StripShader.prototype.constructor = s.StripShader, s.StripShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            if (t.useProgram(e), this.uSampler = s._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), s._enableMultiTextureToggle) {
                var i = [],
                    n = t.createTexture();
                t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), i.push(r);
                t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, i)
            }
            this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, s.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, s.PrimitiveShader = function(t) {
            this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
        }, s.PrimitiveShader.prototype.constructor = s.PrimitiveShader, s.PrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, s.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, s.ComplexPrimitiveShader = function(t) {
            this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
        }, s.ComplexPrimitiveShader.prototype.constructor = s.ComplexPrimitiveShader, s.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, s.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, s.glContexts = [], s.instances = [], s._enableMultiTextureToggle = !1, s.WebGLRenderer = function(t, e) {
            this.game = t, s.defaultRenderer || (s.defaultRenderer = this), this.extensions = {}, this.type = Phaser.WEBGL, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.powerPreference = t.powerPreference, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            }, this.projection = new s.Point, this.offset = new s.Point, this.shaderManager = new s.WebGLShaderManager, this.spriteBatch = new s.WebGLSpriteBatch(t), this.maskManager = new s.WebGLMaskManager, this.filterManager = new s.WebGLFilterManager, this.stencilManager = new s.WebGLStencilManager, this.blendModeManager = new s.WebGLBlendModeManager, this.renderSession = {}, this.currentBatchedTextures = [], this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.renderSession.roundPixels = e.roundPixels || !1, this.renderSession.maxTextureAvailableSpace = null, this.initContext(), this.mapBlendModes()
        }, s.WebGLRenderer.prototype.constructor = s.WebGLRenderer, s.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = this.gl.getParameter(t.MAX_TEXTURE_SIZE), this.glContextId = t.id = s.WebGLRenderer.glContextId++, s.glContexts[this.glContextId] = t, s.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height), this.extensions.compression = {};
            var e = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            e && (this.extensions.compression.ETC1 = e), i && (this.extensions.compression.PVRTC = i), n && (this.extensions.compression.S3TC = n)
        }, s.WebGLRenderer.prototype.setTexturePriority = function(t) {
            if (s._enableMultiTextureToggle) {
                for (var e = function(t) {
                        return --t, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
                    }, i = this.gl, n = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), r = i.getParameter(i.MAX_TEXTURE_SIZE), a = this.game.cache._cache.image, o = null, h = 0; h < this.currentBatchedTextures.length; h++)(o = this.currentBatchedTextures[h]) in a ? a[o].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', o);
                var l = r - e(Math.max(this.width, this.height));
                this.currentBatchedTextures.length = 0;
                for (var u = 0; u < t.length; ++u)
                    if ((o = t[u]) in a) {
                        var c = a[o].base;
                        (l -= e(Math.max(c.width, c.height))) <= 0 ? (c.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', o, l)) : c.textureIndex = 1 + u % (n - 1), this.currentBatchedTextures.push(o)
                    } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', o);
                return this.renderSession.maxTextureAvailableSpace = l, this.currentBatchedTextures
            }
            console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
        }, s.WebGLRenderer.prototype.render = function(t) {
            if (!this.contextLost) {
                var e = this.gl;
                e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
            }
        }, s.WebGLRenderer.prototype.postRender = function() {
            this.gl.flush()
        }, s.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, n) {
            this.renderSession.blendModeManager.setBlendMode(s.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, n), this.spriteBatch.end()
        }, s.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
        }, s.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
            if (!t.hasLoaded) return !1;
            var e = this.gl,
                i = t.source;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.compressedTexImage2D(e.TEXTURE_2D, 0, i.glExtensionFormat, i.width, i.height, 0, i.textureData), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
        }, s.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded || !t.source) return !1;
            if (t.source.compressionAlgorithm) return this.updateCompressedTexture(t);
            var e = this.gl;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
        }, s.WebGLRenderer.prototype.destroy = function() {
            s.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, Phaser.CanvasPool.remove(this), s.instances[this.glContextId] = null, s.WebGLRenderer.glContextId--
        }, s.WebGLRenderer.prototype.mapBlendModes = function() {
            var t = this.gl;
            if (!s.blendModesWebGL) {
                var e = [],
                    i = s.blendModes;
                e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[i.SCREEN] = [t.SRC_ALPHA, t.ONE], e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], s.blendModesWebGL = e
            }
        }, s.WebGLRenderer.prototype.getMaxTextureUnit = function() {
            var t = this.gl;
            return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
        }, s.enableMultiTexture = function() {
            s._enableMultiTextureToggle = !0
        }, s.WebGLRenderer.glContextId = 0, s.WebGLRenderer.textureArray = [], s.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }, s.WebGLBlendModeManager.prototype.constructor = s.WebGLBlendModeManager, s.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }, s.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t) return !1;
            this.currentBlendMode = t;
            var e = s.blendModesWebGL[this.currentBlendMode];
            return e && this.gl.blendFunc(e[0], e[1]), !0
        }, s.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }, s.WebGLMaskManager = function() {}, s.WebGLMaskManager.prototype.constructor = s.WebGLMaskManager, s.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }, s.WebGLMaskManager.prototype.pushMask = function(t, e) {
            var i = e.gl;
            t.dirty && s.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
        }, s.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }, s.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }, s.WebGLStencilManager = function() {
            this.stencilStack = [], this.reverse = !0, this.count = 0
        }, s.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }, s.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var s = this.gl;
            this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
            var n = this.count;
            s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
        }, s.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
            this._currentGraphics = t;
            var s, n = this.gl,
                r = i.projection,
                a = i.offset;
            1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -a.x, -a.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -a.x, -a.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
        }, s.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var s = this.gl;
            if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
            else {
                var n = this.count;
                this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
            }
        }, s.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null, this.gl = null
        }, s.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
            this.stack = []
        }, s.WebGLShaderManager.prototype.constructor = s.WebGLShaderManager, s.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t, this.primitiveShader = new s.PrimitiveShader(t), this.complexPrimitiveShader = new s.ComplexPrimitiveShader(t), this.defaultShader = new s.PixiShader(t), this.fastShader = new s.PixiFastShader(t), this.stripShader = new s.StripShader(t), this.creatureShader = s.CreatureShader ? new s.CreatureShader(t) : null, this.setShader(this.defaultShader)
        }, s.WebGLShaderManager.prototype.setAttribs = function(t) {
            var e;
            for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var s = this.gl;
            for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
        }, s.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
        }, s.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.creatureShader && this.creatureShader.destroy(), this.gl = null
        }, s.WebGLSpriteBatch = function(t) {
            this.game = t, this.vertSize = 5, this.size = 2e3, this.vertexSize = 24;
            var e = this.vertexSize * this.size * 4,
                i = 6 * this.size;
            this.vertices = new ArrayBuffer(e), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(i), this.lastIndexCount = 0;
            for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = null
        }, s.WebGLSpriteBatch.prototype.setContext = function(t) {
            if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.gl = t, s._enableMultiTextureToggle) {
                for (var e = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) {gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;return;}\n";
                this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
            } else this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
            this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var n = new s.PixiShader(t);
            n.fragmentSrc = this.defaultShader.fragmentSrc, n.uniforms = {}, n.init(), this.defaultShader.shaders[t.id] = n
        }, s.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
        }, s.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }, s.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture;
            if (s._enableMultiTextureToggle) {
                var n = i.baseTexture,
                    r = this.gl;
                s.WebGLRenderer.textureArray[n.textureIndex] != n && (this.flush(), r.activeTexture(r.TEXTURE0 + n.textureIndex), r.bindTexture(r.TEXTURE_2D, n._glTextures[r.id]), s.WebGLRenderer.textureArray[n.textureIndex] = n)
            }
            var a = t.worldTransform;
            e && (a = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
            var o = i._uvs;
            if (o) {
                var h, l, u, c, d = t.anchor.x,
                    p = t.anchor.y;
                if (i.trim) {
                    var f = i.trim;
                    h = (l = f.x - d * f.width) + i.crop.width, u = (c = f.y - p * f.height) + i.crop.height
                } else h = i.frame.width * (1 - d), l = i.frame.width * -d, u = i.frame.height * (1 - p), c = i.frame.height * -p;
                var m = this.currentBatchSize * this.vertexSize,
                    g = i.baseTexture.resolution,
                    v = i.baseTexture.textureIndex,
                    y = a.a / g,
                    _ = a.b / g,
                    x = a.c / g,
                    b = a.d / g,
                    T = a.tx,
                    S = a.ty,
                    w = i.crop.height;
                if (i.rotated) {
                    var M = a.a,
                        C = a.b,
                        P = a.c,
                        E = a.d,
                        A = l,
                        I = h;
                    T = a.c * w + T, S = a.d * w + S, y = 6.123233995736766e-17 * M - P, _ = 6.123233995736766e-17 * C - E, x = M + 6.123233995736766e-17 * P, b = C + 6.123233995736766e-17 * E, i._updateUvsInverted(), h = u, l = c, u = I, c = A
                }
                var R = this.colors,
                    D = this.positions,
                    O = t.tint,
                    F = (O >> 16) + (65280 & O) + ((255 & O) << 16) + (255 * t.worldAlpha << 24);
                this.renderSession.roundPixels ? (D[m++] = y * l + x * c + T | 0, D[m++] = b * c + _ * l + S | 0, D[m++] = o.x0, D[m++] = o.y0, R[m++] = F, D[m++] = v, D[m++] = y * h + x * c + T | 0, D[m++] = b * c + _ * h + S | 0, D[m++] = o.x1, D[m++] = o.y1, R[m++] = F, D[m++] = v, D[m++] = y * h + x * u + T | 0, D[m++] = b * u + _ * h + S | 0, D[m++] = o.x2, D[m++] = o.y2, R[m++] = F, D[m++] = v, D[m++] = y * l + x * u + T | 0, D[m++] = b * u + _ * l + S | 0, D[m++] = o.x3, D[m++] = o.y3, R[m++] = F, D[m++] = v) : (D[m++] = y * l + x * c + T, D[m++] = b * c + _ * l + S, D[m++] = o.x0, D[m++] = o.y0, R[m++] = F, D[m++] = v, D[m++] = y * h + x * c + T, D[m++] = b * c + _ * h + S, D[m++] = o.x1, D[m++] = o.y1, R[m++] = F, D[m++] = v, D[m++] = y * h + x * u + T, D[m++] = b * u + _ * h + S, D[m++] = o.x2, D[m++] = o.y2, R[m++] = F, D[m++] = v, D[m++] = y * l + x * u + T, D[m++] = b * u + _ * l + S, D[m++] = o.x3, D[m++] = o.y3, R[m++] = F, D[m++] = v), this.sprites[this.currentBatchSize++] = t
            }
        }, s.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var e = t.tilingTexture,
                i = t.texture.baseTexture.textureIndex;
            if (s._enableMultiTextureToggle) {
                var n = e.baseTexture,
                    r = this.gl;
                s.WebGLRenderer.textureArray[i] != n && (this.flush(), r.activeTexture(r.TEXTURE0 + i), r.bindTexture(r.TEXTURE_2D, n._glTextures[r.id]), s.WebGLRenderer.textureArray[i] = n)
            }
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new s.TextureUvs);
            var a = t._uvs,
                o = e.baseTexture.width,
                h = e.baseTexture.height;
            t.tilePosition.x %= o * t.tileScaleOffset.x, t.tilePosition.y %= h * t.tileScaleOffset.y;
            var l = t.tilePosition.x / (o * t.tileScaleOffset.x),
                u = t.tilePosition.y / (h * t.tileScaleOffset.y),
                c = t.width / o / (t.tileScale.x * t.tileScaleOffset.x),
                d = t.height / h / (t.tileScale.y * t.tileScaleOffset.y);
            a.x0 = 0 - l, a.y0 = 0 - u, a.x1 = 1 * c - l, a.y1 = 0 - u, a.x2 = 1 * c - l, a.y2 = 1 * d - u, a.x3 = 0 - l, a.y3 = 1 * d - u;
            var p = t.tint,
                f = (p >> 16) + (65280 & p) + ((255 & p) << 16) + (255 * t.worldAlpha << 24),
                m = this.positions,
                g = this.colors,
                v = t.width,
                y = t.height,
                _ = t.anchor.x,
                x = t.anchor.y,
                b = v * (1 - _),
                T = v * -_,
                S = y * (1 - x),
                w = y * -x,
                M = this.currentBatchSize * this.vertexSize,
                C = e.baseTexture.resolution,
                P = t.worldTransform,
                E = P.a / C,
                A = P.b / C,
                I = P.c / C,
                R = P.d / C,
                D = P.tx,
                O = P.ty;
            m[M++] = E * T + I * w + D, m[M++] = R * w + A * T + O, m[M++] = a.x0, m[M++] = a.y0, g[M++] = f, m[M++] = i, m[M++] = E * b + I * w + D, m[M++] = R * w + A * b + O, m[M++] = a.x1, m[M++] = a.y1, g[M++] = f, m[M++] = i, m[M++] = E * b + I * S + D, m[M++] = R * S + A * b + O, m[M++] = a.x2, m[M++] = a.y2, g[M++] = f, m[M++] = i, m[M++] = E * T + I * S + D, m[M++] = R * S + A * T + O, m[M++] = a.x3, m[M++] = a.y3, g[M++] = f, m[M++] = i, this.sprites[this.currentBatchSize++] = t
        }, s.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t, e = this.gl;
                if (this.dirty) {
                    this.dirty = !1, t = this.defaultShader.shaders[e.id], e.activeTexture(e.TEXTURE0), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    var i = this.vertexSize;
                    e.vertexAttribPointer(t.aVertexPosition, 2, e.FLOAT, !1, i, 0), e.vertexAttribPointer(t.aTextureCoord, 2, e.FLOAT, !1, i, 8), e.vertexAttribPointer(t.colorAttribute, 4, e.UNSIGNED_BYTE, !0, i, 16), e.vertexAttribPointer(t.aTextureIndex, 1, e.FLOAT, !1, i, 20)
                }
                if (this.currentBatchSize > .5 * this.size) e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices);
                else {
                    e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
                    var n = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                    e.bufferSubData(e.ARRAY_BUFFER, 0, n)
                }
                for (var r, a, o, h, l = 0, u = 0, c = null, d = this.renderSession.blendModeManager.currentBlendMode, p = null, f = !1, m = !1, g = 0, v = this.currentBatchSize; g < v; g++) {
                    r = (h = this.sprites[g]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, f = d !== (a = h.blendMode), m = p !== (o = h.shader || this.defaultShader);
                    var y = r.skipRender;
                    y && h.children.length > 0 && (y = !1);
                    var _ = c !== r;
                    if ((!s._enableMultiTextureToggle && _ && !y || f || m) && (this.renderBatch(c, l, u), u = g, l = 0, c = r, f && (d = a, this.renderSession.blendModeManager.setBlendMode(d)), m)) {
                        (t = (p = o).shaders[e.id]) || ((t = new s.PixiShader(e)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[e.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                        var x = this.renderSession.projection;
                        e.uniform2f(t.projectionVector, x.x, x.y);
                        var b = this.renderSession.offset;
                        e.uniform2f(t.offsetVector, b.x, b.y)
                    }
                    l++
                }
                this.renderBatch(c, l, u), this.currentBatchSize = 0
            }
        }, s.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var s = this.gl;
                if (t._dirty[s.id]) {
                    if (!this.renderSession.renderer.updateTexture(t)) return
                } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
                s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
            }
        }, s.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(), this.dirty = !0
        }, s.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }, s.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
        }, s.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 11, this.maxSize = 6e3, this.size = this.maxSize;
            var e = 4 * this.size * this.vertSize,
                i = 6 * this.maxSize;
            this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
            for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
        }, s.WebGLFastSpriteBatch.prototype.constructor = s.WebGLFastSpriteBatch, s.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }, s.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
        }, s.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }, s.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children,
                i = e[0];
            if (i.texture._uvs) {
                this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                var n = this.currentBaseTexture.textureIndex,
                    r = this.gl;
                r.activeTexture(r.TEXTURE0 + n), r.bindTexture(r.TEXTURE_2D, this.currentBaseTexture._glTextures[r.id]), s.WebGLRenderer.textureArray[n] = this.currentBaseTexture;
                for (var a = 0, o = e.length; a < o; a++) this.renderSprite(e[a]);
                this.flush()
            }
        }, s.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            var e = t.texture.baseTexture,
                i = this.gl,
                n = t.texture.baseTexture.textureIndex;
            if ((s.WebGLRenderer.textureArray[n] == e || !e._glTextures[i.id] || t.texture.baseTexture.skipRender || (this.flush(), i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, e._glTextures[i.id]), s.WebGLRenderer.textureArray[n] = e, t.texture._uvs)) && t.visible) {
                var r, a, o, h, l, u, c, d, p = this.vertices;
                if (r = t.texture._uvs, a = t.texture.frame.width, o = t.texture.frame.height, t.texture.trim) {
                    var f = t.texture.trim;
                    h = (l = f.x - t.anchor.x * f.width) + t.texture.crop.width, u = (c = f.y - t.anchor.y * f.height) + t.texture.crop.height
                } else h = a * (1 - t.anchor.x), l = a * -t.anchor.x, u = o * (1 - t.anchor.y), c = o * -t.anchor.y;
                d = 4 * this.currentBatchSize * this.vertSize, p[d++] = l, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x0, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = c, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x1, p[d++] = r.y1, p[d++] = t.alpha, p[d++] = n, p[d++] = h, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x2, p[d++] = r.y2, p[d++] = t.alpha, p[d++] = n, p[d++] = l, p[d++] = u, p[d++] = t.position.x, p[d++] = t.position.y, p[d++] = t.scale.x, p[d++] = t.scale.y, p[d++] = t.rotation, p[d++] = r.x3, p[d++] = r.y3, p[d++] = t.alpha, p[d++] = n, ++this.currentBatchSize >= this.size && this.flush()
            }
        }, s.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl;
                if (this.currentBaseTexture._glTextures[t.id]) {
                    if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                    else {
                        var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                        t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                    }
                    t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
                } else this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
            }
        }, s.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }, s.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var i = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36), t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
        }, s.WebGLFilterManager = function() {
            this.filterStack = [], this.offsetX = 0, this.offsetY = 0
        }, s.WebGLFilterManager.prototype.constructor = s.WebGLFilterManager, s.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t, this.texturePool = [], this.initShaderBuffers()
        }, s.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
            var i = this.renderSession.projection;
            this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
        }, s.WebGLFilterManager.prototype.pushFilter = function(t) {
            var e = this.gl,
                i = this.renderSession.projection,
                n = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new s.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
            var r = t.filterPasses[0];
            this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
            var a = this.texturePool.pop();
            a ? a.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : a = new s.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, a.texture);
            var o = t._filterArea,
                h = r.padding;
            o.x -= h, o.y -= h, o.width += 2 * h, o.height += 2 * h, o.x < 0 && (o.x = 0), o.width > this.width && (o.width = this.width), o.y < 0 && (o.y = 0), o.height > this.height && (o.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, a.frameBuffer), e.viewport(0, 0, o.width * this.renderSession.resolution, o.height * this.renderSession.resolution), i.x = o.width / 2, i.y = -o.height / 2, n.x = -o.x, n.y = -o.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = a
        }, s.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl,
                e = this.filterStack.pop(),
                i = e._filterArea,
                n = e._glFilterTexture,
                r = this.renderSession.projection,
                a = this.renderSession.offset;
            if (e.filterPasses.length > 1) {
                t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var o = n,
                    h = this.texturePool.pop();
                h || (h = new s.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                for (var l = 0; l < e.filterPasses.length - 1; l++) {
                    var u = e.filterPasses[l];
                    t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o.texture), this.applyFilterPass(u, i, i.width, i.height);
                    var c = o;
                    o = h, h = c
                }
                t.enable(t.BLEND), n = o, this.texturePool.push(h)
            }
            var d = e.filterPasses[e.filterPasses.length - 1];
            this.offsetX -= i.x, this.offsetY -= i.y;
            var p = this.width,
                f = this.height,
                m = 0,
                g = 0,
                v = this.buffer;
            if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
            else {
                var y = this.filterStack[this.filterStack.length - 1];
                p = (i = y._filterArea).width, f = i.height, m = i.x, g = i.y, v = y._glFilterTexture.frameBuffer
            }
            r.x = p / 2, r.y = -f / 2, a.x = m, a.y = g;
            var _ = (i = e._filterArea).x - m,
                x = i.y - g;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = _, this.vertexArray[1] = x + i.height, this.vertexArray[2] = _ + i.width, this.vertexArray[3] = x + i.height, this.vertexArray[4] = _, this.vertexArray[5] = x, this.vertexArray[6] = _ + i.width, this.vertexArray[7] = x, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, v), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, i, p, f), this.texturePool.push(n), e._glFilterTexture = null
        }, s.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, n) {
            var r = this.gl,
                a = t.shaders[r.id];
            a || ((a = new s.PixiShader(r)).fragmentSrc = t.fragmentSrc, a.uniforms = t.uniforms, a.init(!0), t.shaders[r.id] = a), this.renderSession.shaderManager.setShader(a), r.uniform2f(a.projectionVector, i / 2, -n / 2), r.uniform2f(a.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), a.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(a.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(a.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(a.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, s.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }, s.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
            for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
            this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
        };
        var n = {
            36054: "Incomplete attachment",
            36055: "Missing attachment",
            36057: "Incomplete dimensions",
            36061: "Framebuffer unsupported"
        };
        return s.FilterTexture = function(t, i, n, r, a) {
            a = "number" == typeof a ? a : 0, this.gl = t, this.frameBuffer = e(t, i, n, r || s.scaleModes.DEFAULT, a), this.texture = this.frameBuffer.targetTexture, this.width = i, this.height = n, this.renderBuffer = this.frameBuffer.renderBuffer
        }, s.FilterTexture.prototype.constructor = s.FilterTexture, s.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
        }, s.FilterTexture.prototype.resize = function(t, e) {
            if (this.width !== t || this.height !== e) {
                this.width = t, this.height = e;
                var i = this.gl;
                i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
            }
        }, s.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, s.CanvasBuffer = function(t, e) {
            this.width = t, this.height = e, this.canvas = Phaser.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
        }, s.CanvasBuffer.prototype.constructor = s.CanvasBuffer, s.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, s.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t, this.height = this.canvas.height = e
        }, s.CanvasBuffer.prototype.destroy = function() {
            Phaser.CanvasPool.remove(this)
        }, s.CanvasMaskManager = function() {}, s.CanvasMaskManager.prototype.constructor = s.CanvasMaskManager, s.CanvasMaskManager.prototype.pushMask = function(t, e) {
            var i = e.context;
            i.save();
            var n = t.alpha,
                r = t.worldTransform,
                a = e.resolution;
            i.setTransform(r.a * a, r.b * a, r.c * a, r.d * a, r.tx * a, r.ty * a), s.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = n
        }, s.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }, s.CanvasTinter = function() {}, s.CanvasTinter.getTintedTexture = function(t, e) {
            var i = t.tintedTexture || Phaser.CanvasPool.create(this);
            return s.CanvasTinter.tintMethod(t.texture, e, i), i
        }, s.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var s = i.getContext("2d"),
                n = t.crop,
                r = n.width,
                a = n.height;
            t.rotated && (r = a, a = n.width), i.width === r && i.height === a || (i.width = r, i.height = a), s.clearRect(0, 0, r, a), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, r, a), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, r, a, 0, 0, r, a), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, r, a, 0, 0, r, a)
        }, s.CanvasTinter.tintWithPerPixel = function(t, e, i) {
            var n = i.getContext("2d"),
                r = t.crop,
                a = r.width,
                o = r.height;
            t.rotated && (a = o, o = r.width), i.width === a && i.height === o || (i.width = a, i.height = o), n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, r.x, r.y, a, o, 0, 0, a, o);
            for (var h = Phaser.Color.hexToRGBArray(e), l = h[0], u = h[1], c = h[2], d = n.getImageData(0, 0, a, o), p = d.data, f = 0; f < p.length; f += 4)
                if (p[f + 0] *= l, p[f + 1] *= u, p[f + 2] *= c, !s.CanvasTinter.canHandleAlpha) {
                    var m = p[f + 3];
                    p[f + 0] /= 255 / m, p[f + 1] /= 255 / m, p[f + 2] /= 255 / m
                }
            n.putImageData(d, 0, 0)
        }, s.CanvasRenderer = function(t, e) {
            if (this.game = t, s.defaultRenderer || (s.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                    alpha: this.transparent
                }), !this.context) throw new Error("Failed to create a Canvas 2d context.");
            this.refresh = !0, this.count = 0, this.maskManager = new s.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: e.roundPixels || !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, s.CanvasRenderer.prototype.constructor = s.CanvasRenderer, s.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
        }, s.CanvasRenderer.prototype.postRender = function() {}, s.CanvasRenderer.prototype.setTexturePriority = function() {}, s.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, s.CanvasRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === s.scaleModes.LINEAR)
        }, s.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
        }, s.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!s.blendModesCanvas) {
                var t = [],
                    e = s.blendModes,
                    i = this.game.device.canUseMultiply;
                t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", s.blendModesCanvas = t
            }
        }, s.BaseTexture = function(t, e, i) {
            this.resolution = i || 1, this.width = 100, this.height = 100, this.scaleMode = e || s.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this.textureIndex = 0, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, s.BaseTexture.prototype.constructor = s.BaseTexture, s.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
        }, s.BaseTexture.prototype.destroy = function() {
            this.source && Phaser.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, s.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
        }, s.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; t >= 0; t--) {
                var e = this._glTextures[t],
                    i = s.glContexts[t];
                i && e && i.deleteTexture(e)
            }
            this._glTextures.length = 0, this.dirty()
        }, s.BaseTexture.fromCanvas = function(t, e, i) {
            return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), i = i || 1, new s.BaseTexture(t, e, i)
        }, s.TextureSilentFail = !1, s.Texture = function(t, e, i, n) {
            this.noFrame = !1, e || (this.noFrame = !0, e = new s.Rectangle(0, 0, 1, 1)), t instanceof s.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new s.Rectangle(0, 0, 1, 1), this.rotated = !1, t.hasLoaded && (this.noFrame && (e = new s.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
        }, s.Texture.prototype.constructor = s.Texture, s.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new s.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
        }, s.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(), this.valid = !1
        }, s.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
            else {
                if (!s.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                this.valid = !1
            }
        }, s.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new s.TextureUvs);
            var t = this.crop,
                e = this.baseTexture.width,
                i = this.baseTexture.height;
            this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
        }, s.Texture.prototype._updateUvsInverted = function() {
            this._uvs || (this._uvs = new s.TextureUvs);
            var t = this.crop,
                e = this.baseTexture.width,
                i = this.baseTexture.height;
            this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.height) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.height) / e, this._uvs.y2 = (t.y + t.width) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.width) / i
        }, s.Texture.fromCanvas = function(t, e) {
            var i = s.BaseTexture.fromCanvas(t, e);
            return new s.Texture(i)
        }, s.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = s), exports.PIXI = s) : "undefined" != typeof define && define.amd ? define("PIXI", i.PIXI = s) : i.PIXI = s, s
    }.call(this),
    function() {
        var t = this,
            e = e || {
                VERSION: "2.18.0",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                WEBGL_MULTI: 4,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                PIXI: PIXI || {},
                _UID: 0
            };
        if ("undefined" != typeof AudioBufferSourceNode && (AudioBufferSourceNode.prototype.start || (AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn), AudioBufferSourceNode.prototype.stop || (AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff)), Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = function() {
                var t = Array.prototype.slice;
                return function(e) {
                    function i() {
                        var r = n.concat(t.call(arguments));
                        s.apply(this instanceof i ? this : e, r)
                    }
                    var s = this,
                        n = t.call(arguments, 1);
                    if ("function" != typeof s) throw new TypeError;
                    return i.prototype = function t(e) {
                        if (e && (t.prototype = e), !(this instanceof t)) return new t
                    }(s.prototype), i
                }
            }()), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                "use strict";
                if (void 0 === this || null === this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var i = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t) {
                        Array.call(this, t), this.length = t;
                        for (e = 0; e < this.length; e++) this[e] = 0
                    } else {
                        Array.call(this, t.length), this.length = t.length;
                        for (var e = 0; e < this.length; e++) this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            i("Float32Array"), i("Uint32Array"), i("Uint16Array"), i("Int16Array"), i("ArrayBuffer")
        }
        window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), Object.assign || (Object.assign = function(t, e) {
            "use strict";
            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
            for (var i = Object(t), s = Object.prototype.hasOwnProperty, n = 1; n < arguments.length; n++) {
                var r = arguments[n];
                if (null != r)
                    for (var a in r) s.call(r, a) && (i[a] = r[a])
            }
            return i
        }), e.Utils = {
            defaults: function(t, e) {
                for (var i = Object.keys(e), s = 0, n = i.length; s < n; s++) {
                    var r = i[s];
                    void 0 === t[r] && (t[r] = e[r])
                }
                return t
            },
            reverseString: function(t) {
                return t.split("").reverse().join("")
            },
            getProperty: function(t, e) {
                var i = e.split(".");
                switch (i.length) {
                    case 1:
                        return t[e];
                    case 2:
                        return t[i[0]][i[1]];
                    case 3:
                        return t[i[0]][i[1]][i[2]];
                    case 4:
                        return t[i[0]][i[1]][i[2]][i[3]];
                    default:
                        return this._getProperty(t, e)
                }
            },
            setProperties: function(t, e) {
                for (var i in e) this.setProperty(t, i, e[i]);
                return t
            },
            setProperty: function(t, e, i) {
                var s = e.split(".");
                switch (s.length) {
                    case 1:
                        t[e] = i;
                        break;
                    case 2:
                        t[s[0]][s[1]] = i;
                        break;
                    case 3:
                        t[s[0]][s[1]][s[2]] = i;
                        break;
                    case 4:
                        t[s[0]][s[1]][s[2]][s[3]] = i;
                        break;
                    default:
                        this._setProperty(t, e, i)
                }
            },
            _getProperty: function(t, e) {
                for (var i = e.split("."), s = i.length, n = 0, r = t; n < s;) {
                    var a = i[n];
                    if (null == r) return;
                    r = r[a], n++
                }
                return r
            },
            _setProperty: function(t, e, i) {
                var s = e.split("."),
                    n = s.length,
                    r = 0,
                    a = t,
                    o = s[0];
                if (1 === n) t[e] = i;
                else {
                    for (; r < n - 1;) a = a[o], o = s[++r];
                    a[o] = i
                }
                return t
            },
            chanceRoll: function(t) {
                return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
            },
            randomChoice: function(t, e) {
                return Math.random() < .5 ? t : e
            },
            parseDimension: function(t, e) {
                var i = 0,
                    s = 0;
                return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
            },
            pad: function(t, e, i, s) {
                if (void 0 === e) var e = 0;
                if (void 0 === i) var i = " ";
                if (void 0 === s) var s = 3;
                var n = 0;
                if (e + 1 >= (t = t.toString()).length) switch (s) {
                    case 1:
                        t = new Array(e + 1 - t.length).join(i) + t;
                        break;
                    case 3:
                        var r = Math.ceil((n = e - t.length) / 2),
                            a = n - r;
                        t = new Array(a + 1).join(i) + t + new Array(r + 1).join(i);
                        break;
                    default:
                        t += new Array(e + 1 - t.length).join(i)
                }
                return t
            },
            isPlainObject: function(t) {
                if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                try {
                    if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                } catch (t) {
                    return !1
                }
                return !0
            },
            extend: function() {
                var t, i, s, n, r, a, o = arguments[0] || {},
                    h = 1,
                    l = arguments.length,
                    u = !1;
                for ("boolean" == typeof o && (u = o, o = arguments[1] || {}, h = 2), l === h && (o = this, --h); h < l; h++)
                    if (null != (t = arguments[h]))
                        for (i in t) s = o[i], o !== (n = t[i]) && (u && n && (e.Utils.isPlainObject(n) || (r = Array.isArray(n))) ? (r ? (r = !1, a = s && Array.isArray(s) ? s : []) : a = s && e.Utils.isPlainObject(s) ? s : {}, o[i] = e.Utils.extend(u, a, n)) : void 0 !== n && (o[i] = n));
                return o
            },
            mixinPrototype: function(t, e, i) {
                void 0 === i && (i = !1);
                for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                    var r = s[n],
                        a = e[r];
                    !i && r in t || (!a || "function" != typeof a.get && "function" != typeof a.set ? t[r] = a : "function" == typeof a.clone ? t[r] = a.clone() : Object.defineProperty(t, r, a))
                }
            },
            mixin: function(t, i) {
                if (!t || "object" != typeof t) return i;
                for (var s in t) {
                    var n = t[s];
                    if (!n.childNodes && !n.cloneNode) {
                        var r = typeof t[s];
                        t[s] && "object" === r ? typeof i[s] === r ? i[s] = e.Utils.mixin(t[s], i[s]) : i[s] = e.Utils.mixin(t[s], new n.constructor) : i[s] = t[s]
                    }
                }
                return i
            }
        }, e.Circle = function(t, i, s) {
            t = t || 0, i = i || 0, s = s || 0, this.x = t, this.y = i, this._diameter = s, this._radius = 0, s > 0 && (this._radius = .5 * s), this.type = e.CIRCLE
        }, e.Circle.prototype = {
            circumference: function() {
                return Math.PI * this._radius * 2
            },
            random: function(t) {
                void 0 === t && (t = new e.Point);
                var i = 2 * Math.PI * Math.random(),
                    s = Math.random() + Math.random(),
                    n = s > 1 ? 2 - s : s,
                    r = n * Math.cos(i),
                    a = n * Math.sin(i);
                return t.x = this.x + r * this.radius, t.y = this.y + a * this.radius, t
            },
            getBounds: function() {
                return new e.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
            },
            setTo: function(t, e, i) {
                return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.diameter)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
            },
            distance: function(t, i) {
                var s = e.Math.distance(this.x, this.y, t.x, t.y);
                return i ? Math.round(s) : s
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new e.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
            },
            contains: function(t, i) {
                return e.Circle.contains(this, t, i)
            },
            circumferencePoint: function(t, i, s) {
                return e.Circle.circumferencePoint(this, t, i, s)
            },
            sample: function(t, i, s, n, r) {
                t || (t = 60), null == i && (i = 0), null == s && (s = e.Math.PI2), r || (r = []);
                for (var a = 0; a < t;) this.circumferencePoint(e.Math.linear(i, s, a / t), n, r[a] || (r[a] = new e.Point)), a += 1;
                return r
            },
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            toString: function() {
                return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
            }
        }, e.Circle.prototype.constructor = e.Circle, Object.defineProperty(e.Circle.prototype, "diameter", {
            get: function() {
                return this._diameter
            },
            set: function(t) {
                t > 0 && (this._diameter = t, this._radius = .5 * t)
            }
        }), Object.defineProperty(e.Circle.prototype, "radius", {
            get: function() {
                return this._radius
            },
            set: function(t) {
                t > 0 && (this._radius = t, this._diameter = 2 * t)
            }
        }), Object.defineProperty(e.Circle.prototype, "left", {
            get: function() {
                return this.x - this._radius
            },
            set: function(t) {
                t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
            }
        }), Object.defineProperty(e.Circle.prototype, "right", {
            get: function() {
                return this.x + this._radius
            },
            set: function(t) {
                t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
            }
        }), Object.defineProperty(e.Circle.prototype, "top", {
            get: function() {
                return this.y - this._radius
            },
            set: function(t) {
                t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
            }
        }), Object.defineProperty(e.Circle.prototype, "bottom", {
            get: function() {
                return this.y + this._radius
            },
            set: function(t) {
                t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
            }
        }), Object.defineProperty(e.Circle.prototype, "area", {
            get: function() {
                return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
            }
        }), Object.defineProperty(e.Circle.prototype, "empty", {
            get: function() {
                return 0 === this._diameter
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0)
            }
        }), e.Circle.contains = function(t, e, i) {
            return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
        }, e.Circle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.diameter === e.diameter
        }, e.Circle.intersects = function(t, i) {
            return e.Math.distance(t.x, t.y, i.x, i.y) <= t.radius + i.radius
        }, e.Circle.circumferencePoint = function(t, i, s, n) {
            return void 0 === s && (s = !1), void 0 === n && (n = new e.Point), !0 === s && (i = e.Math.degToRad(i)), n.x = t.x + t.radius * Math.cos(i), n.y = t.y + t.radius * Math.sin(i), n
        }, e.Circle.intersectsRectangle = function(t, e) {
            var i = Math.abs(t.x - e.x - e.halfWidth);
            if (i > e.halfWidth + t.radius) return !1;
            var s = Math.abs(t.y - e.y - e.halfHeight);
            if (s > e.halfHeight + t.radius) return !1;
            if (i <= e.halfWidth || s <= e.halfHeight) return !0;
            var n = i - e.halfWidth,
                r = s - e.halfHeight;
            return n * n + r * r <= t.radius * t.radius
        }, e.Circle.intersectsLine = function(t, i, s) {
            var n = t.x,
                r = t.y,
                a = (i.end.y - i.start.y) / (i.end.x - i.start.x),
                o = i.end.y - a * i.end.x,
                h = t.radius,
                l = t.radius,
                u = o + a * n,
                c = (n * (l * l) - a * (h * h) * (o - r) + h * l * Math.sqrt(h * h * (a * a) + l * l - u * u - r * r + 2 * u * r)) / (h * h * (a * a) + l * l),
                d = (n * (l * l) - a * (h * h) * (o - r) - h * l * Math.sqrt(h * h * (a * a) + l * l - u * u - r * r + 2 * u * r)) / (h * h * (a * a) + l * l),
                p = a * c + o,
                f = a * d + o,
                m = new e.Point(c, p),
                g = new e.Point(d, f),
                v = i.pointOnSegment(m.x, m.y, .01),
                y = i.pointOnSegment(g.x, g.y, .01);
            return v && y ? !s || [m, g] : v ? !s || [m] : y ? !s || [g] : !!s && []
        }, PIXI.Circle = e.Circle, e.Ellipse = function(t, i, s, n) {
            t = t || 0, i = i || 0, s = s || 0, n = n || 0, this.x = t, this.y = i, this.width = s, this.height = n, this.type = e.ELLIPSE
        }, e.Ellipse.prototype = {
            setTo: function(t, e, i, s) {
                return this.x = t, this.y = e, this.width = i, this.height = s, this
            },
            getBounds: function() {
                return new e.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new e.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            },
            contains: function(t, i) {
                return e.Ellipse.contains(this, t, i)
            },
            random: function(t) {
                void 0 === t && (t = new e.Point);
                var i = Math.random() * Math.PI * 2,
                    s = Math.sqrt(Math.random());
                return t.x = this.centerX + .5 * s * Math.cos(i) * this.width, t.y = this.centerY + .5 * s * Math.sin(i) * this.height, t
            },
            toString: function() {
                return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
            }
        }, e.Ellipse.prototype.constructor = e.Ellipse, Object.defineProperty(e.Ellipse.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        }), Object.defineProperty(e.Ellipse.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t < this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(e.Ellipse.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }), Object.defineProperty(e.Ellipse.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t < this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(e.Ellipse.prototype, "centerX", {
            get: function() {
                return this.x + .5 * this.width
            }
        }), Object.defineProperty(e.Ellipse.prototype, "centerY", {
            get: function() {
                return this.y + .5 * this.height
            }
        }), Object.defineProperty(e.Ellipse.prototype, "empty", {
            get: function() {
                return 0 === this.width || 0 === this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }), e.Ellipse.contains = function(t, e, i) {
            if (t.width <= 0 || t.height <= 0) return !1;
            var s = (e - t.x) / t.width - .5,
                n = (i - t.y) / t.height - .5;
            return s *= s, n *= n, s + n < .25
        }, e.Ellipse.intersectsLine = function(t, i, s) {
            var n = t.x,
                r = t.y,
                a = (i.end.y - i.start.y) / (i.end.x - i.start.x),
                o = i.end.y - a * i.end.x,
                h = t.width / 2,
                l = t.height / 2,
                u = o + a * n,
                c = (n * (l * l) - a * (h * h) * (o - r) + h * l * Math.sqrt(h * h * (a * a) + l * l - u * u - r * r + 2 * u * r)) / (h * h * (a * a) + l * l),
                d = (n * (l * l) - a * (h * h) * (o - r) - h * l * Math.sqrt(h * h * (a * a) + l * l - u * u - r * r + 2 * u * r)) / (h * h * (a * a) + l * l),
                p = a * c + o,
                f = a * d + o,
                m = new e.Point(c, p),
                g = new e.Point(d, f),
                v = i.pointOnSegment(m.x, m.y, .01),
                y = i.pointOnSegment(g.x, g.y, .01);
            return v && y ? !s || [m, g] : v ? !s || [m] : y ? !s || [g] : !!s && []
        }, PIXI.Ellipse = e.Ellipse, e.Line = function(t, i, s, n) {
            t = t || 0, i = i || 0, s = s || 0, n = n || 0, this.start = new e.Point(t, i), this.end = new e.Point(s, n), this.type = e.LINE
        }, e.Line.prototype = {
            setTo: function(t, e, i, s) {
                return this.start.setTo(t, e), this.end.setTo(i, s), this
            },
            fromPoints: function(t, e) {
                return this.setTo(t.x, t.y, e.x, e.y), this
            },
            fromSprite: function(t, e, i) {
                return void 0 === i && (i = !1), i ? this.setTo(t.centerX, t.centerY, e.centerX, e.centerY) : this.fromPoints(t, e)
            },
            fromAngle: function(t, e, i, s) {
                return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
            },
            rotate: function(t, e) {
                var i = (this.start.x + this.end.x) / 2,
                    s = (this.start.y + this.end.y) / 2;
                return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
            },
            rotateAround: function(t, e, i, s) {
                return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
            },
            intersects: function(t, i, s) {
                return e.Line.intersectsPoints(this.start, this.end, t.start, t.end, i, s)
            },
            reflect: function(t) {
                return e.Line.reflect(this, t)
            },
            midPoint: function(t) {
                return void 0 === t && (t = new e.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
            },
            centerOn: function(t, e) {
                var i = t - (this.start.x + this.end.x) / 2,
                    s = e - (this.start.y + this.end.y) / 2;
                this.start.add(i, s), this.end.add(i, s)
            },
            pointOnLine: function(t, i, s) {
                return e.Math.fuzzyEqual((t - this.start.x) * (this.end.y - this.start.y), (this.end.x - this.start.x) * (i - this.start.y), s || 0)
            },
            pointOnSegment: function(t, e, i) {
                var s = Math.min(this.start.x, this.end.x),
                    n = Math.max(this.start.x, this.end.x),
                    r = Math.min(this.start.y, this.end.y),
                    a = Math.max(this.start.y, this.end.y);
                return this.pointOnLine(t, e, i) && t >= s && t <= n && e >= r && e <= a
            },
            random: function(t) {
                void 0 === t && (t = new e.Point);
                var i = Math.random();
                return t.x = this.start.x + i * (this.end.x - this.start.x), t.y = this.start.y + i * (this.end.y - this.start.y), t
            },
            coordinatesOnLine: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = []);
                var i = Math.round(this.start.x),
                    s = Math.round(this.start.y),
                    n = Math.round(this.end.x),
                    r = Math.round(this.end.y),
                    a = Math.abs(n - i),
                    o = Math.abs(r - s),
                    h = i < n ? 1 : -1,
                    l = s < r ? 1 : -1,
                    u = a - o;
                e.push([i, s]);
                for (var c = 1; i !== n || s !== r;) {
                    var d = u << 1;
                    d > -o && (u -= o, i += h), d < a && (u += a, s += l), c % t == 0 && e.push([i, s]), c++
                }
                return e
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new e.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
            }
        }, Object.defineProperty(e.Line.prototype, "length", {
            get: function() {
                return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
            }
        }), Object.defineProperty(e.Line.prototype, "angle", {
            get: function() {
                return e.Point.angle(this.end, this.start)
            }
        }), Object.defineProperty(e.Line.prototype, "slope", {
            get: function() {
                return (this.end.y - this.start.y) / (this.end.x - this.start.x)
            }
        }), Object.defineProperty(e.Line.prototype, "perpSlope", {
            get: function() {
                return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
            }
        }), Object.defineProperty(e.Line.prototype, "x", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(e.Line.prototype, "y", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(e.Line.prototype, "left", {
            get: function() {
                return Math.min(this.start.x, this.end.x)
            }
        }), Object.defineProperty(e.Line.prototype, "right", {
            get: function() {
                return Math.max(this.start.x, this.end.x)
            }
        }), Object.defineProperty(e.Line.prototype, "top", {
            get: function() {
                return Math.min(this.start.y, this.end.y)
            }
        }), Object.defineProperty(e.Line.prototype, "bottom", {
            get: function() {
                return Math.max(this.start.y, this.end.y)
            }
        }), Object.defineProperty(e.Line.prototype, "width", {
            get: function() {
                return Math.abs(this.start.x - this.end.x)
            }
        }), Object.defineProperty(e.Line.prototype, "height", {
            get: function() {
                return Math.abs(this.start.y - this.end.y)
            }
        }), Object.defineProperty(e.Line.prototype, "normalX", {
            get: function() {
                return Math.cos(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(e.Line.prototype, "normalY", {
            get: function() {
                return Math.sin(this.angle - 1.5707963267948966)
            }
        }), Object.defineProperty(e.Line.prototype, "normalAngle", {
            get: function() {
                return e.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
            }
        }), e.Line.intersectsPoints = function(t, i, s, n, r, a) {
            void 0 === r && (r = !0), void 0 === a && (a = new e.Point);
            var o = i.y - t.y,
                h = n.y - s.y,
                l = t.x - i.x,
                u = s.x - n.x,
                c = i.x * t.y - t.x * i.y,
                d = n.x * s.y - s.x * n.y,
                p = o * u - h * l;
            if (0 === p) return null;
            if (a.x = (l * d - u * c) / p, a.y = (h * c - o * d) / p, r) {
                var f = (n.y - s.y) * (i.x - t.x) - (n.x - s.x) * (i.y - t.y),
                    m = ((n.x - s.x) * (t.y - s.y) - (n.y - s.y) * (t.x - s.x)) / f,
                    g = ((i.x - t.x) * (t.y - s.y) - (i.y - t.y) * (t.x - s.x)) / f;
                return m >= 0 && m <= 1 && g >= 0 && g <= 1 ? a : null
            }
            return a
        }, e.Line.intersects = function(t, i, s, n) {
            return e.Line.intersectsPoints(t.start, t.end, i.start, i.end, s, n)
        }, e.Line.intersectsRectangle = function(t, e) {
            if (0 === t.length || e.empty) return !1;
            var i = t.start.x,
                s = t.start.y,
                n = t.end.x,
                r = t.end.y,
                a = e.x,
                o = e.y,
                h = e.right,
                l = e.bottom,
                u = 0;
            if (i >= a && i <= h && s >= o && s <= l || n >= a && n <= h && r >= o && r <= l) return !0;
            if (i < a && n >= a) {
                if ((u = s + (r - s) * (a - i) / (n - i)) > o && u <= l) return !0
            } else if (i > h && n <= h && (u = s + (r - s) * (h - i) / (n - i)) >= o && u <= l) return !0;
            if (s < o && r >= o) {
                if ((u = i + (n - i) * (o - s) / (r - s)) >= a && u <= h) return !0
            } else if (s > l && r <= l && (u = i + (n - i) * (l - s) / (r - s)) >= a && u <= h) return !0;
            return !1
        }, e.Line.intersectionWithRectangle = function(t, i, s) {
            var n = e.Line.intersectionWithRectangle;
            s || (s = new e.Point), n.edges || (n.edges = [new e.Line, new e.Line, new e.Line, new e.Line]), n.edgeIntersection || (n.edgeIntersection = new e.Point);
            var r = n.edges,
                a = n.edgeIntersection.set(0),
                o = i.x,
                h = i.y,
                l = i.right,
                u = i.bottom,
                c = 1 / 0;
            r[0].setTo(o, h, l, h), r[1].setTo(o, u, l, u), r[2].setTo(o, h, o, u), r[3].setTo(l, h, l, u);
            for (var d, p = 0; d = r[p]; p++)
                if (t.intersects(d, !0, a)) {
                    var f = t.start.distance(a);
                    f < c && (c = f, s.copyFrom(a))
                }
            return null != f ? s : null
        }, e.Line.reflect = function(t, e) {
            return 2 * e.normalAngle - 3.141592653589793 - t.angle
        }, e.Matrix = function(t, i, s, n, r, a) {
            void 0 !== t && null !== t || (t = 1), void 0 !== i && null !== i || (i = 0), void 0 !== s && null !== s || (s = 0), void 0 !== n && null !== n || (n = 1), void 0 !== r && null !== r || (r = 0), void 0 !== a && null !== a || (a = 0), this.a = t, this.b = i, this.c = s, this.d = n, this.tx = r, this.ty = a, this.type = e.MATRIX
        }, e.Matrix.prototype = {
            fromArray: function(t) {
                return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
            },
            setTo: function(t, e, i, s, n, r) {
                return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = r, this
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new e.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
            },
            copyTo: function(t) {
                return t.copyFrom(this), t
            },
            copyFrom: function(t) {
                return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
            },
            toArray: function(t, e) {
                return void 0 === e && (e = new Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
            },
            apply: function(t, i) {
                return void 0 === i && (i = new e.Point), i.x = this.a * t.x + this.c * t.y + this.tx, i.y = this.b * t.x + this.d * t.y + this.ty, i
            },
            applyInverse: function(t, i) {
                void 0 === i && (i = new e.Point);
                var s = 1 / (this.a * this.d + this.c * -this.b),
                    n = t.x,
                    r = t.y;
                return i.x = this.d * s * n + -this.c * s * r + (this.ty * this.c - this.tx * this.d) * s, i.y = this.a * s * r + -this.b * s * n + (-this.ty * this.a + this.tx * this.b) * s, i
            },
            translate: function(t, e) {
                return this.tx += t, this.ty += e, this
            },
            scale: function(t, e) {
                return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t),
                    i = Math.sin(t),
                    s = this.a,
                    n = this.c,
                    r = this.tx;
                return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
            },
            append: function(t) {
                var e = this.a,
                    i = this.b,
                    s = this.c,
                    n = this.d;
                return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
            },
            identity: function() {
                return this.setTo(1, 0, 0, 1, 0, 0)
            }
        }, e.identityMatrix = new e.Matrix, e.Point = function(t, i) {
            t = t || 0, i = i || 0, this.x = t, this.y = i, this.type = e.POINT
        }, e.Point.prototype = {
            copyFrom: function(t) {
                return this.setTo(t.x, t.y)
            },
            invert: function() {
                return this.setTo(this.y, this.x)
            },
            setTo: function(t, i) {
                return e.Point.set(this, t, i)
            },
            set: function(t, i) {
                return e.Point.set(this, t, i)
            },
            setToPolar: function(t, i, s) {
                return null == i && (i = 1), s && (t = e.Math.degToRad(t)), this.setTo(Math.cos(t) * i, Math.sin(t) * i)
            },
            add: function(t, e) {
                return this.x += t, this.y += e, this
            },
            subtract: function(t, e) {
                return this.x -= t, this.y -= e, this
            },
            multiply: function(t, e) {
                return this.x *= t, this.y *= e, this
            },
            divide: function(t, e) {
                return this.x /= t, this.y /= e, this
            },
            clampX: function(t, i) {
                return this.x = e.Math.clamp(this.x, t, i), this
            },
            clampY: function(t, i) {
                return this.y = e.Math.clamp(this.y, t, i), this
            },
            clamp: function(t, i) {
                return this.x = e.Math.clamp(this.x, t, i), this.y = e.Math.clamp(this.y, t, i), this
            },
            clip: function(t) {
                var e = t.left,
                    i = t.top,
                    s = t.right,
                    n = t.bottom;
                return this.x < e ? this.x = e : this.x > s && (this.x = s), this.y < i ? this.y = i : this.y > n && (this.y = n), this
            },
            clone: function(t) {
                return void 0 === t || null === t ? t = new e.Point(this.x, this.y) : t.setTo(this.x, this.y), t
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t
            },
            distance: function(t, i) {
                return e.Point.distance(this, t, i)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            equalsXY: function(t, e) {
                return this.x === t && this.y === e
            },
            fuzzyEquals: function(t, i) {
                return e.Point.fuzzyEquals(this, t, i)
            },
            fuzzyEqualsXY: function(t, i, s) {
                return e.Point.fuzzyEqualsXY(this, t, i, s)
            },
            angle: function(t, e) {
                return this.angleXY(t.x, t.y, e)
            },
            angleXY: function(t, i, s) {
                var n = Math.atan2(i - this.y, t - this.x);
                return s ? e.Math.radToDeg(n) : n
            },
            atan: function(t) {
                var i = Math.atan2(this.y, this.x);
                return t ? e.Math.radToDeg(i) : i
            },
            rotate: function(t, i, s, n, r) {
                return e.Point.rotate(this, t, i, s, n, r)
            },
            getMagnitude: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            getMagnitudeSq: function() {
                return this.x * this.x + this.y * this.y
            },
            setMagnitude: function(t) {
                return this.normalize().multiply(t, t)
            },
            normalize: function() {
                if (!this.isZero()) {
                    var t = this.getMagnitude();
                    this.x /= t, this.y /= t
                }
                return this
            },
            limit: function(t) {
                return this.getMagnitudeSq() > t * t && this.setMagnitude(t), this
            },
            expand: function(t) {
                return this.getMagnitudeSq() < t * t && this.setMagnitude(t), this
            },
            isZero: function() {
                return 0 === this.x && 0 === this.y
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            cross: function(t) {
                return this.x * t.y - this.y * t.x
            },
            perp: function() {
                return this.setTo(-this.y, this.x)
            },
            rperp: function() {
                return this.setTo(this.y, -this.x)
            },
            normalRightHand: function() {
                return this.setTo(-1 * this.y, this.x)
            },
            floor: function() {
                return this.setTo(Math.floor(this.x), Math.floor(this.y))
            },
            ceil: function() {
                return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
            },
            round: function() {
                return this.setTo(Math.round(this.x), Math.round(this.y))
            },
            toString: function() {
                return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
            }
        }, e.Point.prototype.constructor = e.Point, e.Point.add = function(t, i, s) {
            return void 0 === s && (s = new e.Point), s.x = t.x + i.x, s.y = t.y + i.y, s
        }, e.Point.subtract = function(t, i, s) {
            return void 0 === s && (s = new e.Point), s.x = t.x - i.x, s.y = t.y - i.y, s
        }, e.Point.multiply = function(t, i, s) {
            return void 0 === s && (s = new e.Point), s.x = t.x * i.x, s.y = t.y * i.y, s
        }, e.Point.divide = function(t, i, s) {
            return void 0 === s && (s = new e.Point), s.x = t.x / i.x, s.y = t.y / i.y, s
        }, e.Point.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, e.Point.equalsXY = function(t, e, i) {
            return t.x === e && t.y === i
        }, e.Point.fuzzyEquals = function(t, i, s) {
            return e.Math.fuzzyEqual(t.x, i.x, s) && e.Math.fuzzyEqual(t.y, i.y, s)
        }, e.Point.fuzzyEqualsXY = function(t, i, s, n) {
            return e.Math.fuzzyEqual(t.x, i, n) && e.Math.fuzzyEqual(t.y, s, n)
        }, e.Point.angle = function(t, e) {
            return Math.atan2(t.y - e.y, t.x - e.x)
        }, e.Point.negative = function(t, i) {
            return void 0 === i && (i = new e.Point), i.setTo(-t.x, -t.y)
        }, e.Point.multiplyAdd = function(t, i, s, n) {
            return void 0 === n && (n = new e.Point), n.setTo(t.x + i.x * s, t.y + i.y * s)
        }, e.Point.interpolate = function(t, i, s, n) {
            return void 0 === n && (n = new e.Point), n.setTo(t.x + (i.x - t.x) * s, t.y + (i.y - t.y) * s)
        }, e.Point.perp = function(t, i) {
            return void 0 === i && (i = new e.Point), i.setTo(-t.y, t.x)
        }, e.Point.rperp = function(t, i) {
            return void 0 === i && (i = new e.Point), i.setTo(t.y, -t.x)
        }, e.Point.distance = function(t, i, s) {
            var n = e.Math.distance(t.x, t.y, i.x, i.y);
            return s ? Math.round(n) : n
        }, e.Point.project = function(t, i, s) {
            void 0 === s && (s = new e.Point);
            var n = t.dot(i) / i.getMagnitudeSq();
            return 0 !== n && s.setTo(n * i.x, n * i.y), s
        }, e.Point.projectUnit = function(t, i, s) {
            void 0 === s && (s = new e.Point);
            var n = t.dot(i);
            return 0 !== n && s.setTo(n * i.x, n * i.y), s
        }, e.Point.normalRightHand = function(t, i) {
            return void 0 === i && (i = new e.Point), i.setTo(-1 * t.y, t.x)
        }, e.Point.normalize = function(t, i) {
            void 0 === i && (i = new e.Point);
            var s = t.getMagnitude();
            return 0 !== s && i.setTo(t.x / s, t.y / s), i
        }, e.Point.rotate = function(t, i, s, n, r, a) {
            if (r && (n = e.Math.degToRad(n)), void 0 === a) {
                t.subtract(i, s);
                var o = Math.sin(n),
                    h = Math.cos(n),
                    l = h * t.x - o * t.y,
                    u = o * t.x + h * t.y;
                t.x = l + i, t.y = u + s
            } else {
                var c = n + Math.atan2(t.y - s, t.x - i);
                t.x = i + a * Math.cos(c), t.y = s + a * Math.sin(c)
            }
            return t
        }, e.Point.centroid = function(t, i) {
            if (void 0 === i && (i = new e.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
            var s = t.length;
            if (s < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
            if (1 === s) return i.copyFrom(t[0]), i;
            for (var n = 0; n < s; n++) e.Point.add(i, t[n], i);
            return i.divide(s, s), i
        }, e.Point.parse = function(t, i, s) {
            i = i || "x", s = s || "y";
            var n = new e.Point;
            return t[i] && (n.x = parseFloat(t[i])), t[s] && (n.y = parseFloat(t[s])), n
        }, e.Point.trunc = function(t) {
            return t.x = e.Math.trunc(t.x), t.y = e.Math.trunc(t.y), t
        }, e.Point.isPoint = function(t) {
            return null != t && "number" == typeof t.x && "number" == typeof t.y
        }, e.Point.set = function(t, e, i) {
            return t.x = e || 0, t.y = i || (0 !== i ? t.x : 0), t
        }, e.Point.sortClockwise = function(t, e) {
            e || (e = this.centroid(t));
            var i = e.x,
                s = e.y;
            return t.sort(function(t, e) {
                if (t.x - i >= 0 && e.x - i < 0) return -1;
                if (t.x - i < 0 && e.x - i >= 0) return 1;
                if (t.x - i == 0 && e.x - i == 0) return t.y - s >= 0 || e.y - s >= 0 ? t.y > e.y ? 1 : -1 : e.y > t.y ? 1 : -1;
                var n = (t.x - i) * -(e.y - s) - (e.x - i) * -(t.y - s);
                return n < 0 ? -1 : n > 0 ? 1 : (t.x - i) * (t.x - i) + (t.y - s) * (t.y - s) > (e.x - i) * (e.x - i) + (e.y - s) * (e.y - s) ? -1 : 1
            })
        }, PIXI.Point = e.Point, e.Polygon = function() {
            this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = e.POLYGON
        }, e.Polygon.prototype = {
            toNumberArray: function(t) {
                void 0 === t && (t = []);
                for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                return t
            },
            flatten: function() {
                return this._points = this.toNumberArray(), this.flattened = !0, this
            },
            clone: function(t) {
                var i = this._points.slice();
                return void 0 === t || null === t ? t = new e.Polygon(i) : t.setTo(i), t
            },
            contains: function(t, e) {
                var i = !1;
                if (this.flattened)
                    for (var s = -2, n = this._points.length - 2;
                        (s += 2) < this._points.length; n = s) {
                        var r = this._points[s],
                            a = this._points[s + 1],
                            o = this._points[n],
                            h = this._points[n + 1];
                        (a <= e && e < h || h <= e && e < a) && t < (o - r) * (e - a) / (h - a) + r && (i = !i)
                    } else
                        for (var s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                            var r = this._points[s].x,
                                a = this._points[s].y,
                                o = this._points[n].x,
                                h = this._points[n].y;
                            (a <= e && e < h || h <= e && e < a) && t < (o - r) * (e - a) / (h - a) + r && (i = !i)
                        }
                return i
            },
            setTo: function(t) {
                if (this.area = 0, this._points = [], arguments.length > 0) {
                    Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                    for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                        if ("number" == typeof t[i]) {
                            n = new PIXI.Point(t[i], t[i + 1]);
                            i++
                        } else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]);
                        else var n = new PIXI.Point(t[i].x, t[i].y);
                        this._points.push(n), n.y < e && (e = n.y)
                    }
                    this.calculateArea(e)
                }
                return this
            },
            calculateArea: function(t) {
                for (var e, i, s, n, r = 0, a = this._points.length; r < a; r++) e = this._points[r], i = r === a - 1 ? this._points[0] : this._points[r + 1], s = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += s * n;
                return this.area
            }
        }, e.Polygon.prototype.constructor = e.Polygon, Object.defineProperty(e.Polygon.prototype, "points", {
            get: function() {
                return this._points
            }
        }), PIXI.Polygon = e.Polygon, e.Rectangle = function(t, i, s, n) {
            t = t || 0, i = i || 0, s = s || 0, n = n || 0, this.x = t, this.y = i, this.width = s, this.height = n, this.type = e.RECTANGLE
        }, e.Rectangle.prototype = {
            offset: function(t, e) {
                return this.x += t, this.y += e, this
            },
            offsetPoint: function(t) {
                return this.offset(t.x, t.y)
            },
            setTo: function(t, e, i, s) {
                return this.x = t, this.y = e, this.width = i, this.height = s, this
            },
            scale: function(t, e) {
                return void 0 === e && (e = t), this.width *= t, this.height *= e, this
            },
            centerOn: function(t, e) {
                return this.centerX = t, this.centerY = e, this
            },
            floor: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y)
            },
            floorAll: function() {
                this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
            },
            ceil: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
            },
            ceilAll: function() {
                this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
            },
            copyFrom: function(t) {
                return this.setTo(t.x, t.y, t.width, t.height)
            },
            copyFromBounds: function(t) {
                return this.setTo(t.left, t.top, t.width, t.height)
            },
            copyTo: function(t) {
                return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
            },
            inflate: function(t, i) {
                return e.Rectangle.inflate(this, t, i)
            },
            size: function(t) {
                return e.Rectangle.size(this, t)
            },
            resize: function(t, e) {
                return this.width = t, this.height = e, this
            },
            clone: function(t) {
                return e.Rectangle.clone(this, t)
            },
            contains: function(t, i) {
                return e.Rectangle.contains(this, t, i)
            },
            containsRect: function(t) {
                return e.Rectangle.containsRect(t, this)
            },
            equals: function(t) {
                return e.Rectangle.equals(this, t)
            },
            intersection: function(t, i) {
                return e.Rectangle.intersection(this, t, i)
            },
            intersects: function(t) {
                return e.Rectangle.intersects(this, t)
            },
            intersectsRaw: function(t, i, s, n, r) {
                return e.Rectangle.intersectsRaw(this, t, i, s, n, r)
            },
            union: function(t, i) {
                return e.Rectangle.union(this, t, i)
            },
            random: function(t) {
                return void 0 === t && (t = new e.Point), t.x = this.randomX, t.y = this.randomY, t
            },
            getPoint: function(t, i) {
                switch (void 0 === i && (i = new e.Point), t) {
                    default:
                        case e.TOP_LEFT:
                        return i.set(this.x, this.y);
                    case e.TOP_CENTER:
                            return i.set(this.centerX, this.y);
                    case e.TOP_RIGHT:
                            return i.set(this.right, this.y);
                    case e.LEFT_CENTER:
                            return i.set(this.x, this.centerY);
                    case e.CENTER:
                            return i.set(this.centerX, this.centerY);
                    case e.RIGHT_CENTER:
                            return i.set(this.right, this.centerY);
                    case e.BOTTOM_LEFT:
                            return i.set(this.x, this.bottom);
                    case e.BOTTOM_CENTER:
                            return i.set(this.centerX, this.bottom);
                    case e.BOTTOM_RIGHT:
                            return i.set(this.right, this.bottom)
                }
            },
            sides: function(t, i, s, n) {
                arguments.length || (t = new e.Line, i = new e.Line, s = new e.Line, n = new e.Line);
                var r = this.x,
                    a = this.y,
                    o = this.right,
                    h = this.bottom;
                return t.setTo(r, a, o, a), i.setTo(o, a, o, h), s.setTo(r, h, o, h), n.setTo(r, a, r, h), arguments.length ? null : [t, i, s, n]
            },
            toString: function() {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
            }
        }, Object.defineProperty(e.Rectangle.prototype, "halfWidth", {
            get: function() {
                return Math.round(this.width / 2)
            }
        }), Object.defineProperty(e.Rectangle.prototype, "halfHeight", {
            get: function() {
                return Math.round(this.height / 2)
            }
        }), Object.defineProperty(e.Rectangle.prototype, "bottom", {
            get: function() {
                return this.y + this.height
            },
            set: function(t) {
                t <= this.y ? this.height = 0 : this.height = t - this.y
            }
        }), Object.defineProperty(e.Rectangle.prototype, "bottomLeft", {
            get: function() {
                return new e.Point(this.x, this.bottom)
            },
            set: function(t) {
                this.x = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(e.Rectangle.prototype, "bottomRight", {
            get: function() {
                return new e.Point(this.right, this.bottom)
            },
            set: function(t) {
                this.right = t.x, this.bottom = t.y
            }
        }), Object.defineProperty(e.Rectangle.prototype, "left", {
            get: function() {
                return this.x
            },
            set: function(t) {
                t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
            }
        }), Object.defineProperty(e.Rectangle.prototype, "right", {
            get: function() {
                return this.x + this.width
            },
            set: function(t) {
                t <= this.x ? this.width = 0 : this.width = t - this.x
            }
        }), Object.defineProperty(e.Rectangle.prototype, "volume", {
            get: function() {
                return this.width * this.height
            }
        }), Object.defineProperty(e.Rectangle.prototype, "perimeter", {
            get: function() {
                return 2 * this.width + 2 * this.height
            }
        }), Object.defineProperty(e.Rectangle.prototype, "centerX", {
            get: function() {
                return this.x + this.halfWidth
            },
            set: function(t) {
                this.x = t - this.halfWidth
            }
        }), Object.defineProperty(e.Rectangle.prototype, "centerY", {
            get: function() {
                return this.y + this.halfHeight
            },
            set: function(t) {
                this.y = t - this.halfHeight
            }
        }), Object.defineProperty(e.Rectangle.prototype, "randomX", {
            get: function() {
                return this.x + Math.random() * this.width
            }
        }), Object.defineProperty(e.Rectangle.prototype, "randomY", {
            get: function() {
                return this.y + Math.random() * this.height
            }
        }), Object.defineProperty(e.Rectangle.prototype, "top", {
            get: function() {
                return this.y
            },
            set: function(t) {
                t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
            }
        }), Object.defineProperty(e.Rectangle.prototype, "topLeft", {
            get: function() {
                return new e.Point(this.x, this.y)
            },
            set: function(t) {
                this.x = t.x, this.y = t.y
            }
        }), Object.defineProperty(e.Rectangle.prototype, "topRight", {
            get: function() {
                return new e.Point(this.x + this.width, this.y)
            },
            set: function(t) {
                this.right = t.x, this.y = t.y
            }
        }), Object.defineProperty(e.Rectangle.prototype, "empty", {
            get: function() {
                return !this.width || !this.height
            },
            set: function(t) {
                !0 === t && this.setTo(0, 0, 0, 0)
            }
        }), e.Rectangle.prototype.constructor = e.Rectangle, e.Rectangle.inflate = function(t, e, i) {
            return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
        }, e.Rectangle.inflatePoint = function(t, i) {
            return e.Rectangle.inflate(t, i.x, i.y)
        }, e.Rectangle.size = function(t, i) {
            return void 0 === i || null === i ? i = new e.Point(t.width, t.height) : i.setTo(t.width, t.height), i
        }, e.Rectangle.clone = function(t, i) {
            return void 0 === i || null === i ? i = new e.Rectangle(t.x, t.y, t.width, t.height) : i.setTo(t.x, t.y, t.width, t.height), i
        }, e.Rectangle.createFromBounds = function(t, i) {
            return void 0 !== i && null !== i || (i = new e.Rectangle(t.x, t.y, t.width, t.height)), i.copyFromBounds(t)
        }, e.Rectangle.contains = function(t, e, i) {
            return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
        }, e.Rectangle.containsRaw = function(t, e, i, s, n, r) {
            return n >= t && n < t + i && r >= e && r < e + s
        }, e.Rectangle.containsPoint = function(t, i) {
            return e.Rectangle.contains(t, i.x, i.y)
        }, e.Rectangle.containsRect = function(t, e) {
            return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
        }, e.Rectangle.equals = function(t, e) {
            return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
        }, e.Rectangle.sameDimensions = function(t, e) {
            return t.width === e.width && t.height === e.height
        }, e.Rectangle.intersection = function(t, i, s) {
            return void 0 === s && (s = new e.Rectangle), e.Rectangle.intersects(t, i) && (s.x = Math.max(t.x, i.x), s.y = Math.max(t.y, i.y), s.width = Math.min(t.right, i.right) - s.x, s.height = Math.min(t.bottom, i.bottom) - s.y), s
        }, e.Rectangle.intersects = function(t, e) {
            return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
        }, e.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
            return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
        }, e.Rectangle.union = function(t, i, s) {
            return void 0 === s && (s = new e.Rectangle), s.setTo(Math.min(t.x, i.x), Math.min(t.y, i.y), Math.max(t.right, i.right) - Math.min(t.left, i.left), Math.max(t.bottom, i.bottom) - Math.min(t.top, i.top))
        }, e.Rectangle.aabb = function(t, i) {
            void 0 === i && (i = new e.Rectangle);
            var s = Number.NEGATIVE_INFINITY,
                n = Number.POSITIVE_INFINITY,
                r = Number.NEGATIVE_INFINITY,
                a = Number.POSITIVE_INFINITY;
            return t.forEach(function(t) {
                t.x > s && (s = t.x), t.x < n && (n = t.x), t.y > r && (r = t.y), t.y < a && (a = t.y)
            }), i.setTo(n, a, s - n, r - a), i
        }, PIXI.Rectangle = e.Rectangle, e.EmptyRectangle = new e.Rectangle(0, 0, 0, 0), e.RoundedRectangle = function(t, i, s, n, r) {
            void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 20), this.x = t, this.y = i, this.width = s, this.height = n, this.radius = r || 20, this.type = e.ROUNDEDRECTANGLE
        }, e.RoundedRectangle.prototype = {
            clone: function() {
                return new e.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
            },
            contains: function(t, e) {
                if (this.width <= 0 || this.height <= 0) return !1;
                var i = this.x;
                if (t >= i && t <= i + this.width) {
                    var s = this.y;
                    if (e >= s && e <= s + this.height) return !0
                }
                return !1
            }
        }, e.RoundedRectangle.prototype.constructor = e.RoundedRectangle, PIXI.RoundedRectangle = e.RoundedRectangle, e.Camera = function(t, i, s, n, r, a) {
            this.game = t, this.world = t.world, this.id = 0, this.view = new e.Rectangle(s, n, r, a), this.bounds = new e.Rectangle(s, n, r, a), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                x: !1,
                y: !1
            }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new e.Point(1, 1), this.onShakeComplete = new e.Signal, this.onFlashComplete = new e.Signal, this.onFadeComplete = new e.Signal, this.fx = null, this._targetPosition = new e.Point, this._edge = 0, this._position = new e.Point, this._shake = {
                intensity: 0,
                duration: 0,
                horizontal: !1,
                vertical: !1,
                shakeBounds: !0,
                x: 0,
                y: 0
            }, this._fxDuration = 0, this._fxType = 0, this._fixedView = new e.Rectangle
        }, e.Camera.FOLLOW_LOCKON = 0, e.Camera.FOLLOW_PLATFORMER = 1, e.Camera.FOLLOW_TOPDOWN = 2, e.Camera.FOLLOW_TOPDOWN_TIGHT = 3, e.Camera.SHAKE_BOTH = 4, e.Camera.SHAKE_HORIZONTAL = 5, e.Camera.SHAKE_VERTICAL = 6, e.Camera.ENABLE_FX = !0, e.Camera.FLASH = 0, e.Camera.FADE_OUT = 1, e.Camera.FADE_IN = 2, e.Camera.prototype = {
            boot: function() {
                this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, e.Graphics && e.Camera.ENABLE_FX && (this.fx = new e.Graphics(this.game), this.game.stage.addChild(this.fx))
            },
            preUpdate: function() {
                this.totalInView = 0
            },
            follow: function(t, i, s, n) {
                void 0 === i && (i = e.Camera.FOLLOW_LOCKON), void 0 === s && (s = 1), void 0 === n && (n = 1), this.target = t, this.lerp.set(s, n);
                var r;
                switch (i) {
                    case e.Camera.FOLLOW_PLATFORMER:
                        var a = this.width / 8,
                            o = this.height / 3;
                        this.deadzone = new e.Rectangle((this.width - a) / 2, (this.height - o) / 2 - .25 * o, a, o);
                        break;
                    case e.Camera.FOLLOW_TOPDOWN:
                        r = Math.max(this.width, this.height) / 4, this.deadzone = new e.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                        break;
                    case e.Camera.FOLLOW_TOPDOWN_TIGHT:
                        r = Math.max(this.width, this.height) / 8, this.deadzone = new e.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                        break;
                    case e.Camera.FOLLOW_LOCKON:
                    default:
                        this.deadzone = null
                }
            },
            unfollow: function() {
                this.target = null
            },
            focusOn: function(t) {
                this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
            },
            focusOnXY: function(t, e) {
                this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
            },
            shake: function(t, i, s, n, r) {
                return void 0 === t && (t = .05), void 0 === i && (i = 500), void 0 === s && (s = !0), void 0 === n && (n = e.Camera.SHAKE_BOTH), void 0 === r && (r = !0), !(!s && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = i, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = n === e.Camera.SHAKE_BOTH || n === e.Camera.SHAKE_HORIZONTAL, this._shake.vertical = n === e.Camera.SHAKE_BOTH || n === e.Camera.SHAKE_VERTICAL, !0)
            },
            flash: function(t, e, i, s) {
                return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
            },
            fade: function(t, i, s, n) {
                return this.fadeEffect(t, i, s, n, e.Camera.FADE_OUT)
            },
            fadeIn: function(t, i, s, n) {
                return this.fadeEffect(t, i, s, n, e.Camera.FADE_IN)
            },
            fadeEffect: function(t, i, s, n, r) {
                if (void 0 === t && (t = 0), void 0 === i && (i = 500), void 0 === s && (s = !1), void 0 === n && (n = 1), !this.fx || !s && this._fxDuration > 0) return !1;
                if (this.fx.clear(), this.fx.beginFill(t, n), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), r < 1 || r > 2) throw new Error("Wrong `type` argument");
                return this.fx.alpha = r === e.Camera.FADE_IN ? 1 : 0, this._fxDuration = i, this._fxType = r, !0
            },
            update: function() {
                this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            },
            updateFX: function() {
                this._fxType === e.Camera.FLASH ? (this.fx.alpha -= this.game.time.delta / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : this._fxType === e.Camera.FADE_IN ? (this.fx.alpha -= this.game.time.delta / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFadeComplete.dispatch())) : (this.fx.alpha += this.game.time.delta / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
            },
            updateShake: function() {
                this._shake.duration -= this.game.time.delta, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
            },
            updateTarget: function() {
                this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
            },
            setBoundsToWorld: function() {
                this.bounds && this.bounds.copyFrom(this.game.world.bounds)
            },
            checkBounds: function() {
                this.atLimit.x = !1, this.atLimit.y = !1;
                var t = this.view.x + this._shake.x,
                    e = this.view.right + this._shake.x,
                    i = this.view.y + this._shake.y,
                    s = this.view.bottom + this._shake.y;
                t <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)) : e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)) : s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
            },
            setPosition: function(t, e) {
                this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
            },
            setSize: function(t, e) {
                this.view.width = t, this.view.height = e
            },
            reset: function() {
                this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.resetFX()
            },
            resetFX: function() {
                this.fx && (this.fx.clear(), this.fx.alpha = 0), this._fxDuration = 0
            }
        }, e.Camera.prototype.constructor = e.Camera, Object.defineProperty(e.Camera.prototype, "x", {
            get: function() {
                return this.view.x
            },
            set: function(t) {
                this.view.x = t, this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(e.Camera.prototype, "y", {
            get: function() {
                return this.view.y
            },
            set: function(t) {
                this.view.y = t, this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(e.Camera.prototype, "position", {
            get: function() {
                return this._position.set(this.view.x, this.view.y), this._position
            },
            set: function(t) {
                void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
            }
        }), Object.defineProperty(e.Camera.prototype, "width", {
            get: function() {
                return this.view.width
            },
            set: function(t) {
                this.view.width = t
            }
        }), Object.defineProperty(e.Camera.prototype, "height", {
            get: function() {
                return this.view.height
            },
            set: function(t) {
                this.view.height = t
            }
        }), Object.defineProperty(e.Camera.prototype, "shakeIntensity", {
            get: function() {
                return this._shake.intensity
            },
            set: function(t) {
                this._shake.intensity = t
            }
        }), Object.defineProperty(e.Camera.prototype, "fixedView", {
            get: function() {
                return this._fixedView.setTo(0, 0, this.view.width, this.view.height), this._fixedView
            }
        }), Object.defineProperty(e.Camera.prototype, "centerX", {
            get: function() {
                return this.x + .5 * this.width
            }
        }), Object.defineProperty(e.Camera.prototype, "centerY", {
            get: function() {
                return this.y + .5 * this.height
            }
        }), e.State = function() {
            this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
        }, e.State.prototype = {
            init: function() {},
            preload: function() {},
            loadUpdate: function() {},
            loadRender: function() {},
            create: function() {},
            update: function() {},
            postUpdate: function() {},
            preRender: function() {},
            render: function() {},
            resize: function() {},
            paused: function() {},
            resumed: function() {},
            pauseUpdate: function() {},
            shutdown: function() {}
        }, e.State.prototype.constructor = e.State, e.StateManager = function(t, i) {
            this.game = t, this.states = {}, this._pendingState = null, void 0 !== i && null !== i && (this._pendingState = i), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new e.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
        }, e.StateManager.prototype = {
            boot: function() {
                this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
            },
            add: function(t, i, s) {
                void 0 === s && (s = !1);
                var n;
                return i instanceof e.State ? n = i : "object" == typeof i ? (n = i).game = this.game : "function" == typeof i && (n = new i(this.game)), this.states[t] = n, s && (this.game.isBooted ? this.start(t) : this._pendingState = t), n
            },
            remove: function(t) {
                this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
            },
            start: function(t, e, i) {
                void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
            },
            restart: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
            },
            dummy: function() {},
            preUpdate: function() {
                if (this._pendingState && this.game.isBooted) {
                    if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.current !== this._pendingState) return;
                    this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                }
            },
            clearCurrentState: function() {
                this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
            },
            checkState: function(t) {
                var e = this.states[t];
                return e ? !!(e.preload || e.create || e.update || e.render) || (console.warn("Invalid Phaser State object given. Must contain at least one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
            },
            link: function(t) {
                var e = this.states[t];
                e.game = this.game, e.add = this.game.add, e.make = this.game.make, e.camera = this.game.camera, e.cache = this.game.cache, e.input = this.game.input, e.load = this.game.load, e.math = this.game.math, e.sound = this.game.sound, e.scale = this.game.scale, e.state = this, e.stage = this.game.stage, e.time = this.game.time, e.tweens = this.game.tweens, e.world = this.game.world, e.particles = this.game.particles, e.rnd = this.game.rnd, e.physics = this.game.physics, e.key = t
            },
            unlink: function(t) {
                var e = this.states[t];
                e && (e.game = null, e.add = null, e.make = null, e.camera = null, e.cache = null, e.input = null, e.load = null, e.math = null, e.sound = null, e.scale = null, e.state = null, e.stage = null, e.time = null, e.tweens = null, e.world = null, e.particles = null, e.rnd = null, e.physics = null)
            },
            setCurrentState: function(t) {
                var e = this.current,
                    i = this.states[t];
                this.callbackContext = i, this.link(t), this.onInitCallback = i.init || this.dummy, this.onPreloadCallback = i.preload || null, this.onLoadRenderCallback = i.loadRender || null, this.onLoadUpdateCallback = i.loadUpdate || null, this.onCreateCallback = i.create || null, this.onUpdateCallback = i.update || null, this.onPostUpdateCallback = i.postUpdate || null, this.onPreRenderCallback = i.preRender || null, this.onRenderCallback = i.render || null, this.onResizeCallback = i.resize || null, this.onPausedCallback = i.paused || null, this.onResumedCallback = i.resumed || null, this.onPauseUpdateCallback = i.pauseUpdate || null, this.onShutDownCallback = i.shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onStateChange.dispatch(this.current, e), this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
            },
            getCurrentState: function() {
                return this.states[this.current]
            },
            loadComplete: function() {
                !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
            },
            loadUpdate: function() {
                !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            pause: function() {
                this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
            },
            resume: function() {
                this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
            },
            update: function() {
                this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            postUpdate: function() {
                this._created && this.onPostUpdateCallback && this.onPostUpdateCallback.call(this.callbackContext, this.game)
            },
            pauseUpdate: function() {
                this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
            },
            preRender: function() {
                this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game)
            },
            resize: function(t, e) {
                this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
            },
            render: function() {
                this._created ? this.onRenderCallback && (this.game.renderType === e.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
            },
            destroy: function() {
                this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPostUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
            }
        }, e.StateManager.prototype.constructor = e.StateManager, Object.defineProperty(e.StateManager.prototype, "created", {
            get: function() {
                return this._created
            }
        }), e.Signal = function() {}, e.Signal.prototype = {
            _bindings: null,
            _prevParams: null,
            memorize: !1,
            _shouldPropagate: !0,
            active: !0,
            _boundDispatch: !1,
            validateListener: function(t, e) {
                if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
            },
            _registerListener: function(t, i, s, n, r) {
                var a, o = this._indexOfListener(t, s);
                if (-1 !== o) {
                    if ((a = this._bindings[o]).isOnce() !== i) throw new Error("You cannot add" + (i ? "" : "Once") + "() then add" + (i ? "Once" : "") + "() the same listener without removing the relationship first.")
                } else a = new e.SignalBinding(this, t, i, s, n, r), this._addBinding(a);
                return this.memorize && this._prevParams && a.execute(this._prevParams), a
            },
            _addBinding: function(t) {
                this._bindings || (this._bindings = []);
                var e = this._bindings.length;
                do {
                    e--
                } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                this._bindings.splice(e + 1, 0, t)
            },
            _indexOfListener: function(t, e) {
                if (!this._bindings) return -1;
                void 0 === e && (e = null);
                for (var i, s = this._bindings.length; s--;)
                    if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                return -1
            },
            has: function(t, e) {
                return -1 !== this._indexOfListener(t, e)
            },
            add: function(t, e, i) {
                this.validateListener(t, "add");
                var s = [];
                if (arguments.length > 3)
                    for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                return this._registerListener(t, !1, e, i, s)
            },
            addOnce: function(t, e, i) {
                this.validateListener(t, "addOnce");
                var s = [];
                if (arguments.length > 3)
                    for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                return this._registerListener(t, !0, e, i, s)
            },
            remove: function(t, e) {
                this.validateListener(t, "remove");
                var i = this._indexOfListener(t, e);
                return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
            },
            removeAll: function(t) {
                if (void 0 === t && (t = null), this._bindings) {
                    for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                    t || (this._bindings.length = 0)
                }
            },
            getNumListeners: function() {
                return this._bindings ? this._bindings.length : 0
            },
            halt: function() {
                this._shouldPropagate = !1
            },
            dispatch: function() {
                if (this.active && (this._bindings || this.memorize)) {
                    var t = Array.prototype.slice.call(arguments);
                    this.memorize && (this._prevParams = t);
                    var e = this._bindings ? this._bindings.length : 0;
                    if (e) {
                        var i = this._bindings.slice();
                        this._shouldPropagate = !0;
                        do {
                            e--
                        } while (i[e] && this._shouldPropagate && !1 !== i[e].execute(t))
                    }
                }
            },
            forget: function() {
                this._prevParams && (this._prevParams = null)
            },
            dispose: function() {
                this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
            },
            toString: function() {
                return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
            }
        }, Object.defineProperty(e.Signal.prototype, "boundDispatch", {
            get: function() {
                var t = this;
                return this._boundDispatch || (this._boundDispatch = function() {
                    return t.dispatch.apply(t, arguments)
                })
            }
        }), e.Signal.prototype.constructor = e.Signal, e.SignalBinding = function(t, e, i, s, n, r) {
            this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), r && r.length && (this._args = r)
        }, e.SignalBinding.prototype = {
            context: null,
            _isOnce: !1,
            _priority: 0,
            _args: null,
            callCount: 0,
            active: !0,
            params: null,
            execute: function(t) {
                var e, i;
                return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
            },
            detach: function() {
                return this.isBound() ? this._signal.remove(this._listener, this.context) : null
            },
            isBound: function() {
                return !!this._signal && !!this._listener
            },
            isOnce: function() {
                return this._isOnce
            },
            getListener: function() {
                return this._listener
            },
            getSignal: function() {
                return this._signal
            },
            _destroy: function() {
                delete this._signal, delete this._listener, delete this.context
            },
            toString: function() {
                return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
            }
        }, e.SignalBinding.prototype.constructor = e.SignalBinding, e.Filter = function(t, i, s) {
            this.game = t, this.type = e.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new e.Point;
            var n = new Date;
            if (this.uniforms = {
                    resolution: {
                        type: "2f",
                        value: {
                            x: 256,
                            y: 256
                        }
                    },
                    time: {
                        type: "1f",
                        value: 0
                    },
                    mouse: {
                        type: "2f",
                        value: {
                            x: 0,
                            y: 0
                        }
                    },
                    date: {
                        type: "4fv",
                        value: [n.getFullYear(), n.getMonth(), n.getDate(), 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds()]
                    },
                    sampleRate: {
                        type: "1f",
                        value: 44100
                    },
                    iChannel0: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel1: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel2: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    },
                    iChannel3: {
                        type: "sampler2D",
                        value: null,
                        textureData: {
                            repeat: !0
                        }
                    }
                }, i)
                for (var r in i) this.uniforms[r] = i[r];
            "string" == typeof s && (s = s.split("\n")), this.fragmentSrc = s || []
        }, e.Filter.prototype = {
            init: function() {},
            setResolution: function(t, e) {
                this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
            },
            update: function(t) {
                if (t) {
                    var e = t.x / this.game.width,
                        i = 1 - t.y / this.game.height;
                    e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                }
                this.uniforms.time.value = this.game.time.totalElapsedSeconds()
            },
            addToWorld: function(t, i, s, n, r, a) {
                void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 !== s && null !== s ? this.width = s : s = this.width, void 0 !== n && null !== n ? this.height = n : n = this.height;
                var o = this.game.add.image(t, i, e.Cache.DEFAULT);
                return o.width = s, o.height = n, o.anchor.set(r, a), o.filters = [this], o
            },
            syncUniforms: function() {
                for (var t = 0; t < this.shaders.length; t++) this.shaders[t].dirty = !0
            },
            destroy: function() {
                this.passes.length = 0, this.shaders.length = 0, this.fragmentSrc.length = 0, this.game = null, this.uniforms = null, this.prevPoint = null
            }
        }, e.Filter.prototype.constructor = e.Filter, Object.defineProperty(e.Filter.prototype, "width", {
            get: function() {
                return this.uniforms.resolution.value.x
            },
            set: function(t) {
                this.uniforms.resolution.value.x = t
            }
        }), Object.defineProperty(e.Filter.prototype, "height", {
            get: function() {
                return this.uniforms.resolution.value.y
            },
            set: function(t) {
                this.uniforms.resolution.value.y = t
            }
        }), e.Plugin = function(t, e) {
            void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
        }, e.Plugin.prototype = {
            preUpdate: function() {},
            update: function() {},
            render: function() {},
            postRender: function() {},
            destroy: function() {
                this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }
        }, e.Plugin.prototype.constructor = e.Plugin, e.PluginManager = function(t) {
            this.game = t, this.plugins = [], this._len = 0, this._i = 0
        }, e.PluginManager.prototype = {
            add: function(t) {
                var e = Array.prototype.slice.call(arguments, 1),
                    i = !1;
                return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
            },
            remove: function(t, e) {
                for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                    if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
            },
            removeAll: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                this.plugins.length = 0, this._len = 0
            },
            preUpdate: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
            },
            update: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
            },
            postUpdate: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
            },
            render: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
            },
            postRender: function() {
                for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
            },
            destroy: function() {
                this.removeAll(), this.game = null
            }
        }, e.PluginManager.prototype.constructor = e.PluginManager, e.Stage = function(t) {
            this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new e.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                color: 0,
                rgba: "#000000"
            }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
        }, e.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), e.Stage.prototype.constructor = e.Stage, e.Stage.prototype.parseConfig = function(t) {
            t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
        }, e.Stage.prototype.boot = function() {
            e.DOM.getOffset(this.game.canvas, this.offset), e.Canvas.setUserSelect(this.game.canvas, "none"), e.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
        }, e.Stage.prototype.preUpdate = function() {
            this.currentRenderOrderID = 0;
            for (var t = 0; t < this.children.length;) {
                var e = this.children[t];
                e.preUpdate(), this === e.parent && t++
            }
        }, e.Stage.prototype.update = function() {
            for (var t = this.children.length; t--;) this.children[t].update()
        }, e.Stage.prototype.postUpdate = function() {
            this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
            this.updateTransform()
        }, e.Stage.prototype.updateTransform = function() {
            this.worldAlpha = 1;
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, e.Stage.prototype.checkVisibility = function() {
            void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
            var t = this;
            this._onChange = function(e) {
                return t.visibilityChange(e)
            }, this._onChangePause = function() {
                return t._onChange({
                    type: "pause"
                })
            }, this._onChangeResume = function() {
                return t._onChange({
                    type: "resume"
                })
            }, this._onClick = function(e) {
                void 0 === document.hasFocus || document.hasFocus() || t.visibilityChange(e)
            }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.addEventListener("click", this._onClick), this.game.device.cocoonJSApp && CocoonJS.App && (CocoonJS.App.onSuspended && CocoonJS.App.onSuspended.addEventListener(this._onChangePause), CocoonJS.App.onActivated && CocoonJS.App.onActivated.addEventListener(this._onChangeResume), CocoonJS.App.on && (CocoonJS.App.on("activated", this._onChangeResume), CocoonJS.App.on("suspended", this._onChangePause)))
        }, e.Stage.prototype.visibilityChange = function(t) {
            switch (t.type) {
                case "blur":
                case "pagehide":
                    return void this.game.focusLoss(t);
                case "click":
                case "focus":
                case "pageshow":
                    return void this.game.focusGain(t)
            }
            this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
        }, e.Stage.prototype.setBackgroundColor = function(t) {
            this.game.transparent || (e.Color.valueToColor(t, this._bgColor), e.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
        }, e.Stage.prototype.destroy = function() {
            this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null, window.removeEventListener("click", this._onClick)
        }, e.Stage.prototype.add = function(t, e, i) {
            return t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? this.addChild(t) : this.addChildAt(t, i), t)
        }, Object.defineProperty(e.Stage.prototype, "backgroundColor", {
            get: function() {
                return this._bgColor.color
            },
            set: function(t) {
                this.setBackgroundColor(t)
            }
        }), Object.defineProperty(e.Stage.prototype, "smoothed", {
            get: function() {
                return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
            },
            set: function(t) {
                PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
            }
        }), e.Group = function(t, i, s, n, r, a) {
            void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === a && (a = e.Physics.ARCADE), this.game = t, void 0 === i && (i = t.world), this.name = s || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), n ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : i && (i.addChild(this), this.z = i.children.length), this.type = e.GROUP, this.physicsType = e.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = e.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.updateOnlyExistingChildren = !1, this.onChildInputDown = new e.Signal, this.onChildInputUp = new e.Signal, this.onChildInputOver = new e.Signal, this.onChildInputOut = new e.Signal, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = a, this.physicsSortDirection = null, this.onDestroy = new e.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new e.Point, this.hash = [], this._sortProperty = "z"
        }, e.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), e.Group.prototype.constructor = e.Group, e.Group.RETURN_NONE = 0, e.Group.RETURN_TOTAL = 1, e.Group.RETURN_CHILD = 2, e.Group.RETURN_ALL = 3, e.Group.SORT_ASCENDING = -1, e.Group.SORT_DESCENDING = 1, e.Group.prototype.add = function(t, e, i) {
            return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
        }, e.Group.prototype.addAt = function(t, e, i) {
            return this.add(t, i, e)
        }, e.Group.prototype.addToHash = function(t) {
            return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0)
        }, e.Group.prototype.removeFromHash = function(t) {
            if (t) {
                var e = this.hash.indexOf(t);
                if (-1 !== e) return this.hash.splice(e, 1), !0
            }
            return !1
        }, e.Group.prototype.addMultiple = function(t, i) {
            if (t instanceof e.Group) t.moveAll(this, i);
            else if (Array.isArray(t))
                for (var s = 0; s < t.length; s++) this.add(t[s], i);
            return t
        }, e.Group.prototype.getAt = function(t) {
            return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
        }, e.Group.prototype.create = function(t, e, i, s, n, r) {
            void 0 === n && (n = !0);
            var a = new this.classType(this.game, t, e, i, s);
            return a.exists = n, a.visible = n, a.alive = n, this.add(a, !1, r)
        }, e.Group.prototype.createMultiple = function(t, e, i, s, n, r) {
            void 0 === i && (i = 0), void 0 === s && (s = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
            var a = this,
                o = [];
            return e.forEach(function(e) {
                i.forEach(function(i) {
                    for (var h = 0; h < t; h++) {
                        var l = a.create(0, 0, e, i, s);
                        n && n.call(r || l, l, h), o.push(l)
                    }
                })
            }), o
        }, e.Group.prototype.updateZ = function() {
            for (var t = this.children.length; t--;) this.children[t].z = t
        }, e.Group.prototype.align = function(t, i, s, n, r, a) {
            if (void 0 === r && (r = e.TOP_LEFT), void 0 === a && (a = 0), 0 === this.children.length || a > this.children.length || -1 === t && -1 === i) return !1;
            for (var o = new e.Rectangle(0, 0, s, n), h = t * s, l = i * n, u = a; u < this.children.length; u++) {
                var c = this.children[u];
                if (c.alignIn)
                    if (c.alignIn(o, r), -1 === t) o.y += n, o.y === l && (o.x += s, o.y = 0);
                    else if (-1 === i) o.x += s, o.x === h && (o.x = 0, o.y += n);
                else if (o.x += s, o.x === h && (o.x = 0, o.y += n, o.y === l)) return !0
            }
            return !0
        }, e.Group.prototype.resetCursor = function(t) {
            if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
        }, e.Group.prototype.next = function() {
            if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
        }, e.Group.prototype.previous = function() {
            if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
        }, e.Group.prototype.swap = function(t, e) {
            this.swapChildren(t, e), this.updateZ()
        }, e.Group.prototype.bringToTop = function(t) {
            return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
        }, e.Group.prototype.bringChildToTop = e.Group.prototype.bringToTop, e.Group.prototype.sendToBack = function(t) {
            return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
        }, e.Group.prototype.sendChildToBack = e.Group.prototype.sendToBack, e.Group.prototype.moveUp = function(t) {
            if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                var e = this.getIndex(t),
                    i = this.getAt(e + 1);
                i && this.swap(t, i)
            }
            return t
        }, e.Group.prototype.moveDown = function(t) {
            if (t.parent === this && this.getIndex(t) > 0) {
                var e = this.getIndex(t),
                    i = this.getAt(e - 1);
                i && this.swap(t, i)
            }
            return t
        }, e.Group.prototype.xy = function(t, e, i) {
            if (t < 0 || t > this.children.length) return -1;
            this.getChildAt(t).x = e, this.getChildAt(t).y = i
        }, e.Group.prototype.reverse = function() {
            this.children.reverse(), this.updateZ()
        }, e.Group.prototype.getIndex = function(t) {
            return this.children.indexOf(t)
        }, e.Group.prototype.getByName = function(t) {
            return this.getFirst("name", t)
        }, e.Group.prototype.replace = function(t, i) {
            var s = this.getIndex(t);
            if (-1 !== s) return i.parent && (i.parent instanceof e.Group ? i.parent.remove(i) : i.parent.removeChild(i)), this.remove(t), this.addAt(i, s), t
        }, e.Group.prototype.hasProperty = function(t, e) {
            var i = e.length;
            return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
        }, e.Group.prototype.setProperty = function(t, e, i, s, n) {
            if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return !1;
            var r = e.length;
            return 1 === r ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
        }, e.Group.prototype.checkProperty = function(t, i, s, n) {
            if (void 0 === n && (n = !1), this !== t.parent) return !1;
            var r = e.Utils.getProperty(t, i);
            return !(void 0 === r && n || r !== s)
        }, e.Group.prototype.set = function(t, e, i, s, n, r, a) {
            if (void 0 === a && (a = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, r, a)
        }, e.Group.prototype.setAll = function(t, e, i, s, n, r) {
            void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), t = t.split("."), n = n || 0;
            for (var a = this.children.length, o = 0; o < a; o++) {
                var h = this.children[o];
                i && !h.alive || s && !h.visible || this.setProperty(h, t, e, n, r)
            }
        }, e.Group.prototype.setAllChildren = function(t, i, s, n, r, a) {
            void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === a && (a = !1), r = r || 0;
            for (var o = this.children.length, h = 0; h < o; h++) {
                var l = this.children[h];
                s && !l.alive || n && !l.visible || (l instanceof e.Group ? l.setAllChildren(t, i, s, n, r, a) : this.setProperty(l, t.split("."), i, r, a))
            }
        }, e.Group.prototype.checkAll = function(t, e, i, s, n) {
            void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
            for (var r = 0; r < this.children.length; r++) {
                var a = this.children[r];
                if ((!i || a.alive) && (!s || a.visible) && !this.checkProperty(a, t, e, n)) return !1
            }
            return !0
        }, e.Group.prototype.checkAny = function(t, e, i, s) {
            void 0 === i && (i = !1), void 0 === s && (s = !1);
            for (var n = 0; n < this.children.length; n++) {
                var r = this.children[n];
                if ((!i || r.alive) && (!s || r.visible) && this.checkProperty(r, t, e)) return !0
            }
            return !1
        }, e.Group.prototype.addAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 1)
        }, e.Group.prototype.subAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 2)
        }, e.Group.prototype.multiplyAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 3)
        }, e.Group.prototype.divideAll = function(t, e, i, s) {
            this.setAll(t, e, i, s, 4)
        }, e.Group.prototype.kill = function() {
            this.alive = !1, this.exists = !1, this.visible = !1
        }, e.Group.prototype.killAll = function() {
            this.callAllExists("kill", !0)
        }, e.Group.prototype.revive = function() {
            this.alive = !0, this.exists = !0, this.visible = !0
        }, e.Group.prototype.reviveAll = function() {
            this.callAllExists("revive", !1)
        }, e.Group.prototype.resetAll = function(t, e, i, s, n) {
            this.forEach(this.resetChild, this, n, t, e, i, s)
        }, e.Group.prototype.callAllExists = function(t, e) {
            var i;
            if (arguments.length > 2) {
                i = [];
                for (s = 2; s < arguments.length; s++) i.push(arguments[s])
            }
            for (var s = 0; s < this.children.length; s++) {
                var n = this.children[s];
                n.exists === e && n[t] && n[t].apply(n, i)
            }
        }, e.Group.prototype.callbackFromArray = function(t, e, i) {
            if (1 === i) {
                if (t[e[0]]) return t[e[0]]
            } else if (2 === i) {
                if (t[e[0]][e[1]]) return t[e[0]][e[1]]
            } else if (3 === i) {
                if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
            } else if (4 === i) {
                if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
            } else if (t[e]) return t[e];
            return !1
        }, e.Group.prototype.callAll = function(t, e) {
            if (void 0 !== t) {
                var i = (t = t.split(".")).length;
                if (void 0 === e || null === e || "" === e) e = null;
                else if ("string" == typeof e) var s = (e = e.split(".")).length;
                var n;
                if (arguments.length > 2) {
                    n = [];
                    for (o = 2; o < arguments.length; o++) n.push(arguments[o])
                }
                for (var r = null, a = null, o = 0; o < this.children.length; o++) {
                    var h = this.children[o];
                    r = this.callbackFromArray(h, t, i), e && r ? (a = this.callbackFromArray(h, e, s), r.apply(a, n)) : r && r.apply(h, n)
                }
            }
        }, e.Group.prototype.preUpdate = function() {
            if (this.pendingDestroy) return this.destroy(), !1;
            if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
            for (var t = 0; t < this.children.length;) {
                var e = this.children[t];
                e.preUpdate(), this === e.parent && t++
            }
            return !0
        }, e.Group.prototype.update = function() {
            for (var t = this.children.length; t--;) {
                var e = this.children.length;
                t >= e && (t = e - 1);
                var i = this.children[t];
                this.updateOnlyExistingChildren && !i.exists || i.update()
            }
        }, e.Group.prototype.postUpdate = function() {
            this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, e.Group.prototype.filter = function(t, i) {
            for (var s = -1, n = this.children.length, r = []; ++s < n;) {
                var a = this.children[s];
                i && !a.exists || t(a, s, this.children) && r.push(a)
            }
            return new e.ArraySet(r)
        }, e.Group.prototype.forEach = function(t, e, i) {
            if (void 0 === i && (i = !1), arguments.length <= 3)
                for (n = 0; n < this.children.length; n++) {
                    r = this.children[n];
                    i && !r.exists || t.call(e, r)
                } else {
                    for (var s = [null], n = 3; n < arguments.length; n++) s.push(arguments[n]);
                    for (n = 0; n < this.children.length; n++) {
                        var r = this.children[n];
                        i && !r.exists || (s[0] = r, t.apply(e, s))
                    }
                }
        }, e.Group.prototype.forEachExists = function(t, i) {
            var s;
            if (arguments.length > 2) {
                s = [null];
                for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
            }
            this.iterate("exists", !0, e.Group.RETURN_TOTAL, t, i, s)
        }, e.Group.prototype.forEachAlive = function(t, i) {
            var s;
            if (arguments.length > 2) {
                s = [null];
                for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
            }
            this.iterate("alive", !0, e.Group.RETURN_TOTAL, t, i, s)
        }, e.Group.prototype.forEachDead = function(t, i) {
            var s;
            if (arguments.length > 2) {
                s = [null];
                for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
            }
            this.iterate("alive", !1, e.Group.RETURN_TOTAL, t, i, s)
        }, e.Group.prototype.sort = function(t, i) {
            this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === i && (i = e.Group.SORT_ASCENDING), this._sortProperty = t, i === e.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
        }, e.Group.prototype.customSort = function(t, e) {
            this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
        }, e.Group.prototype.ascendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
        }, e.Group.prototype.descendingSortHandler = function(t, e) {
            return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
        }, e.Group.prototype.iterate = function(t, i, s, n, r, a) {
            if (0 === this.children.length) {
                if (s === e.Group.RETURN_TOTAL) return 0;
                if (s === e.Group.RETURN_ALL) return []
            }
            var o = 0;
            if (s === e.Group.RETURN_ALL) var h = [];
            for (var l = 0; l < this.children.length; l++)
                if (this.children[l][t] === i) {
                    if (o++, n && (a ? (a[0] = this.children[l], n.apply(r, a)) : n.call(r, this.children[l])), s === e.Group.RETURN_CHILD) return this.children[l];
                    s === e.Group.RETURN_ALL && h.push(this.children[l])
                }
            return s === e.Group.RETURN_TOTAL ? o : s === e.Group.RETURN_ALL ? h : null
        }, e.Group.prototype.getFirst = function(t, i) {
            return this.iterate(t, i, e.Group.RETURN_CHILD)
        }, e.Group.prototype.getFirstExists = function(t, e, i, s, n, r) {
            void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
            var a = this.getFirst("exists", t);
            return null === a && e ? this.create(i, s, n, r) : this.resetChild(a, i, s, n, r)
        }, e.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
            void 0 === t && (t = !1);
            var r = this.getFirst("alive", !0);
            return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
        }, e.Group.prototype.getFirstDead = function(t, e, i, s, n) {
            void 0 === t && (t = !1);
            var r = this.getFirst("alive", !1);
            return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
        }, e.Group.prototype.resetChild = function(t, e, i, s, n) {
            return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
        }, e.Group.prototype.getTop = function() {
            if (this.children.length > 0) return this.children[this.children.length - 1]
        }, e.Group.prototype.getBottom = function() {
            if (this.children.length > 0) return this.children[0]
        }, e.Group.prototype.getClosestTo = function(t, i, s) {
            for (var n = Number.MAX_VALUE, r = 0, a = null, o = 0; o < this.children.length; o++) {
                var h = this.children[o];
                h.exists && (r = Math.abs(e.Point.distance(t, h))) < n && (!i || i.call(s, h, r)) && (n = r, a = h)
            }
            return a
        }, e.Group.prototype.getFurthestFrom = function(t, i, s) {
            for (var n = 0, r = 0, a = null, o = 0; o < this.children.length; o++) {
                var h = this.children[o];
                h.exists && (r = Math.abs(e.Point.distance(t, h))) > n && (!i || i.call(s, h, r)) && (n = r, a = h)
            }
            return a
        }, e.Group.prototype.count = function(t, i) {
            return this.iterate(t, i, e.Group.RETURN_TOTAL)
        }, e.Group.prototype.countLiving = function() {
            return this.count("alive", !0)
        }, e.Group.prototype.countDead = function() {
            return this.count("alive", !1)
        }, e.Group.prototype.getRandom = function(t, i) {
            return void 0 === t && (t = 0), void 0 === i && (i = this.children.length), 0 === i ? null : e.ArrayUtils.getRandomItem(this.children, t, i)
        }, e.Group.prototype.getRandomExists = function(t, e) {
            var i = this.getAll("exists", !0, t, e);
            return this.game.rnd.pick(i)
        }, e.Group.prototype.getAll = function(t, e, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
            for (var n = [], r = i; r < s; r++) {
                var a = this.children[r];
                t ? a[t] === e && n.push(a) : n.push(a)
            }
            return n
        }, e.Group.prototype.remove = function(t, e, i) {
            if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
            var s = this.removeChild(t);
            return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
        }, e.Group.prototype.moveAll = function(t, i) {
            if (void 0 === i && (i = !1), this.children.length > 0 && t instanceof e.Group) {
                do {
                    t.add(this.children[0], i)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
            return t
        }, e.Group.prototype.removeAll = function(t, e, i) {
            if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                do {
                    !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                    var s = this.removeChild(this.children[0]);
                    this.removeFromHash(s), t && s && s.destroy(!0, i)
                } while (this.children.length > 0);
                this.hash = [], this.cursor = null
            }
        }, e.Group.prototype.removeBetween = function(t, e, i, s) {
            if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                if (t > e || t < 0 || e > this.children.length) return !1;
                for (var n = e; n >= t;) {
                    !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                    var r = this.removeChild(this.children[n]);
                    this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                }
                this.updateZ()
            }
        }, e.Group.prototype.scatter = function(t, e) {
            null == t && (t = this.game.world.bounds), this.forEach(function(e) {
                e.position.set(t.randomX, t.randomY)
            }, null, e)
        }, e.Group.prototype.shuffle = function() {
            e.ArrayUtils.shuffle(this.children), this.updateZ()
        }, e.Group.prototype.destroy = function(t, e) {
            null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
        }, Object.defineProperty(e.Group.prototype, "total", {
            get: function() {
                return this.iterate("exists", !0, e.Group.RETURN_TOTAL)
            }
        }), Object.defineProperty(e.Group.prototype, "length", {
            get: function() {
                return this.children.length
            }
        }), Object.defineProperty(e.Group.prototype, "angle", {
            get: function() {
                return e.Math.radToDeg(this.rotation)
            },
            set: function(t) {
                this.rotation = e.Math.degToRad(t)
            }
        }), Object.defineProperty(e.Group.prototype, "centerX", {
            get: function() {
                return this.getBounds(this.parent).centerX
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.halfWidth
            }
        }), Object.defineProperty(e.Group.prototype, "centerY", {
            get: function() {
                return this.getBounds(this.parent).centerY
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.halfHeight
            }
        }), Object.defineProperty(e.Group.prototype, "left", {
            get: function() {
                return this.getBounds(this.parent).left
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i
            }
        }), Object.defineProperty(e.Group.prototype, "right", {
            get: function() {
                return this.getBounds(this.parent).right
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.width
            }
        }), Object.defineProperty(e.Group.prototype, "top", {
            get: function() {
                return this.getBounds(this.parent).top
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i
            }
        }), Object.defineProperty(e.Group.prototype, "bottom", {
            get: function() {
                return this.getBounds(this.parent).bottom
            },
            set: function(t) {
                var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.height
            }
        }), e.World = function(t) {
            e.Group.call(this, t, null, "__world", !1), this.bounds = new e.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
        }, e.World.prototype = Object.create(e.Group.prototype), e.World.prototype.constructor = e.World, e.World.prototype.boot = function() {
            this.camera = new e.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
        }, e.World.prototype.stateChange = function() {
            this.x = 0, this.y = 0, this.camera.reset()
        }, e.World.prototype.setBounds = function(t, e, i, s) {
            this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
        }, e.World.prototype.resize = function(t, e) {
            this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
        }, e.World.prototype.shutdown = function() {
            this.destroy(!0, !0)
        }, e.World.prototype.wrap = function(t, e, i, s, n) {
            void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
        }, e.World.prototype.wrapAll = function(t, e, i, s, n, r) {
            t.forEach(this.wrap, this, e, i, s, n, r)
        }, Object.defineProperty(e.World.prototype, "width", {
            get: function() {
                return this.bounds.width
            },
            set: function(t) {
                t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
            }
        }), Object.defineProperty(e.World.prototype, "height", {
            get: function() {
                return this.bounds.height
            },
            set: function(t) {
                t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
            }
        }), Object.defineProperty(e.World.prototype, "centerX", {
            get: function() {
                return this.bounds.halfWidth + this.bounds.x
            }
        }), Object.defineProperty(e.World.prototype, "centerY", {
            get: function() {
                return this.bounds.halfHeight + this.bounds.y
            }
        }), Object.defineProperty(e.World.prototype, "randomX", {
            get: function() {
                return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
            }
        }), Object.defineProperty(e.World.prototype, "randomY", {
            get: function() {
                return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
            }
        }), e.Game = function(t, i, s, n, r, a, o, h) {
            return this.id = e.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.multiTexture = !1, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = e.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = e.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.pendingDestroy = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this.onBoot = new e.Signal, this._paused = !1, this._codePaused = !1, this._focusGained = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this.rendersThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new e.Signal, this.forceSingleUpdate = !0, this.forceSingleRender = !1, this.dropFrames = !1, this.powerPreference = "default", this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                enableDebug: !0
            }, void 0 !== t && (this._width = t), void 0 !== i && (this._height = i), void 0 !== s && (this.renderType = s), void 0 !== n && (this.parent = n), void 0 !== a && (this.transparent = a), void 0 !== o && (this.antialias = o), this.rnd = new e.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new e.StateManager(this, r)), this.device.whenReady(this.boot, this), this
        }, e.Game.prototype = {
            parseConfig: function(t) {
                this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), void 0 !== t.clearBeforeRender && (this.clearBeforeRender = t.clearBeforeRender), void 0 !== t.multiTexture && (this.multiTexture = t.multiTexture), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), void 0 !== t.powerPreference && (this.powerPreference = t.powerPreference), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                var i = [(Date.now() * Math.random()).toString()];
                t.seed && (i = t.seed), this.rnd = new e.RandomDataGenerator(i);
                var s = null;
                t.state && (s = t.state), this.state = new e.StateManager(this, s)
            },
            boot: function() {
                if (!this.isBooted) {
                    if (this.onPause = new e.Signal, this.onResume = new e.Signal, this.onBlur = new e.Signal, this.onFocus = new e.Signal, this.isBooted = !0, PIXI.game = this, this.math = e.Math, this.scale = new e.ScaleManager(this, this._width, this._height), this.stage = new e.Stage(this), this.setUpRenderer(), this.world = new e.World(this), this.add = new e.GameObjectFactory(this), this.make = new e.GameObjectCreator(this), this.cache = new e.Cache(this), this.load = new e.Loader(this), this.time = new e.Time(this), this.tweens = new e.TweenManager(this), this.input = new e.Input(this), this.sound = new e.SoundManager(this), this.physics = new e.Physics(this, this.physicsConfig), this.particles = new e.Particles(this), this.create = new e.Create(this), this.plugins = new e.PluginManager(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(this.config), this.sound.boot(), this.state.boot(), this.config.enableDebug) this.debug = new e.Utils.Debug(this), this.debug.boot();
                    else {
                        var t = function() {};
                        this.debug = {
                            preUpdate: t,
                            update: t,
                            reset: t,
                            destroy: t,
                            isDisabled: !0
                        }
                    }
                    this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new e.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new e.RequestAnimationFrame(this, !1), this._kickstart = !0, this.focusWindow(), this.onBoot.dispatch(this), this.config.disableStart || (this.cache.isReady ? this.raf.start() : this.cache.onReady.addOnce(function() {
                        this.raf.start()
                    }, this))
                }
            },
            showDebugHeader: function() {
                if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                    var t = e.VERSION,
                        i = "Canvas",
                        s = "HTML Audio",
                        n = 1;
                    if (this.renderType === e.WEBGL ? (i = "WebGL", n++) : this.renderType === e.HEADLESS && (i = "Headless"), this.device.webAudio && (s = "WebAudio", n++), this.device.ie) window.console && console.log("Phaser v" + t + " | Pixi.js | " + i + " | " + s + " | http://phaser.io");
                    else {
                        for (var r = ["%c %c %c Phaser CE v" + t + " | Pixi.js | " + i + " | " + s + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], a = 0; a < 3; a++) a < n ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                        console.log.apply(console, r)
                    }
                }
            },
            setUpRenderer: function() {
                if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas 2d context, aborting.");
                if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = e.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.config.crisp && e.Canvas.setImageRenderingCrisp(this.canvas), this.renderType === e.WEBGL || this.renderType === e.WEBGL_MULTI || this.renderType === e.AUTO && this.device.webGL) {
                    (this.multiTexture || this.renderType === e.WEBGL_MULTI) && (PIXI.enableMultiTexture(), this.multiTexture = !0);
                    try {
                        this.renderer = new PIXI.WebGLRenderer(this, this.config), this.renderType = e.WEBGL, this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1)
                    } catch (t) {
                        if (PIXI.defaultRenderer = null, this.renderer = null, this.multiTexture = !1, PIXI._enableMultiTextureToggle = !1, this.renderType === e.WEBGL) throw t
                    }
                }
                this.renderer || (this.renderer = new PIXI.CanvasRenderer(this, this.config), this.context = this.renderer.context, this.renderType === e.AUTO && (this.renderType = e.CANVAS)), this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === e.CANVAS), this.renderType !== e.HEADLESS && (this.stage.smoothed = this.antialias, e.Canvas.addToDOM(this.canvas, this.parent, !1), e.Canvas.setTouchAction(this.canvas))
            },
            contextLost: function(t) {
                t.preventDefault(), this.renderer.contextLost = !0
            },
            contextRestored: function() {
                this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
            },
            update: function(t) {
                if (this.pendingDestroy) this.destroy();
                else if (this.isBooted) {
                    if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(), void(this._kickstart = !1);
                    if (this._focusGained) this._focusGained = !1;
                    else {
                        var e = this.time.elapsed;
                        if (!(e <= 0)) {
                            if (e > this.time.deltaMax) {
                                if (this.dropFrames) return;
                                e = this.time.deltaMax
                            }
                            if (this.forceSingleUpdate) this.updatesThisFrame = 1, this.rendersThisFrame = 1, this.updateLogic(.001 * e / this.time.slowMotion), this.updateRender();
                            else if (this._spiraling > 2) this.updatesThisFrame = 0, this.rendersThisFrame = 0, this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0;
                            else {
                                var i = 0,
                                    s = 1e3 * this.time.desiredFpsMult;
                                for (this._deltaTime += e, this.updatesThisFrame = Math.floor(this._deltaTime / s), this.rendersThisFrame = this.forceSingleRender ? 1 : Math.min(1, this.updatesThisFrame); this._deltaTime >= s;) this._deltaTime -= s, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult / this.time.slowMotion), this.time.refresh(), i++;
                                i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.rendersThisFrame > 0 && this.updateRender()
                            }
                        }
                    }
                }
            },
            updateLogic: function(t) {
                this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(t), this.debug.preUpdate(), this.input.pauseUpdate()) : (this.stepping && (this.pendingStep = !0), this.time.preUpdate(t), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.plugins.update(), this.stage.postUpdate(), this.state.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
            },
            updateRender: function() {
                this.lockRender || this.renderType === e.HEADLESS || (this.time.preRender(), this.state.preRender(), this.renderer.render(this.stage), this.plugins.render(), this.state.render(), this.plugins.postRender(), this.renderer.postRender())
            },
            enableStep: function() {
                this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
            },
            disableStep: function() {
                this.stepping = !1, this.pendingStep = !1
            },
            step: function() {
                this.pendingStep = !1, this.stepCount++
            },
            destroy: function() {
                this.raf.stop(), this.debug.destroy(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.tweens.destroy(), this.debug = null, this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.tweens = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), e.Canvas.removeFromDOM(this.canvas), PIXI.game === this && (PIXI.game = null), PIXI.defaultRenderer = null, e.GAMES[this.id] = null
            },
            gamePaused: function(t) {
                this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.gamePaused(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
            },
            gameResumed: function(t) {
                this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.gameResumed(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
            },
            focusLoss: function(t) {
                this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
            },
            focusGain: function(t) {
                this._focusGained = !0, this.focusWindow(), this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
            },
            focusWindow: function() {
                window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus()
            }
        }, e.Game.prototype.constructor = e.Game, Object.defineProperty(e.Game.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.muteOnPause && this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
            }
        }), e.Input = function(t) {
            this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = e.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.touchLockCallbacks = [], this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new e.ArraySet, this._localPoint = new e.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
        }, e.Input.MOUSE_OVERRIDES_TOUCH = 0, e.Input.TOUCH_OVERRIDES_MOUSE = 1, e.Input.MOUSE_TOUCH_COMBINE = 2, e.Input.MAX_POINTERS = 10, e.Input.prototype = {
            boot: function(t) {
                "maxPointers" in t && (this.maxPointers = t.maxPointers), this.mousePointer = new e.Pointer(this.game, 0, e.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new e.Mouse(this.game), this.touch = new e.Touch(this.game), this.mspointer = new e.MSPointer(this.game), this.mouseWheel = new e.MouseWheel(this.game), this.pointerLock = new e.PointerLock(this.game), e.Keyboard && (this.keyboard = new e.Keyboard(this.game)), e.Gamepad && (this.gamepad = new e.Gamepad(this.game)), this.onDown = new e.Signal, this.onUp = new e.Signal, this.onTap = new e.Signal, this.onHold = new e.Signal, this.scale = new e.Point(1, 1), this.speed = new e.Point, this.position = new e.Point, this._oldPosition = new e.Point, this.circle = new e.Circle(0, 0, 45), this.activePointer = this.mousePointer, this.hitCanvas = e.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.game.device.mspointer && !1 !== t.mspointer ? this.mspointer.start() : this.game.device.touch && !1 !== t.touch && this.touch.start(), this.mspointer.active || !1 === t.mouse || this.mouse.start(), this.mousePointer.active = !0, !0 === t.mouseWheel && this.mouseWheel.start(), !1 !== t.pointerLock && this.pointerLock.start(), this.keyboard && !1 !== t.keyboard && this.keyboard.start();
                var i = this;
                this._onClickTrampoline = function(t) {
                    i.onClickTrampoline(t)
                }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
            },
            destroy: function() {
                this.mouse.stop(), this.mouseWheel.stop(), this.touch.stop(), this.mspointer.stop(), this.pointerLock.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], e.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
            },
            setInteractiveCandidateHandler: function(t, e) {
                this.customCandidateHandler = t, this.customCandidateHandlerContext = e
            },
            addMoveCallback: function(t, e) {
                this.moveCallbacks.push({
                    callback: t,
                    context: e
                })
            },
            addTouchLockCallback: function(t, e, i) {
                void 0 === i && (i = !1), this.touchLockCallbacks.push({
                    callback: t,
                    context: e,
                    onEnd: i
                })
            },
            removeTouchLockCallback: function(t, e) {
                for (var i = this.touchLockCallbacks.length; i--;)
                    if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                return !1
            },
            executeTouchLockCallbacks: function(t, e) {
                for (var i = this.touchLockCallbacks.length; i--;) {
                    var s = this.touchLockCallbacks[i];
                    s.onEnd === t && s.callback.call(s.context, this, e) && this.touchLockCallbacks.splice(i, 1)
                }
            },
            deleteMoveCallback: function(t, e) {
                for (var i = this.moveCallbacks.length; i--;)
                    if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
            },
            addPointer: function() {
                if (this.pointers.length >= e.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + e.Input.MAX_POINTERS + " pointers reached."), null;
                var t = this.pointers.length + 1,
                    i = new e.Pointer(this.game, t, e.PointerMode.CONTACT);
                return this.pointers.push(i), this["pointer" + t] = i, i
            },
            update: function() {
                if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                else {
                    this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                    for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                    this._pollCounter = 0
                }
            },
            pauseUpdate: function() {
                this.gamepad && this.gamepad.active && this.gamepad.update()
            },
            reset: function(t) {
                if (this.game.isBooted && !this.resetLocked) {
                    void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t);
                    for (var i = 0; i < this.pointers.length; i++) this.pointers[i].reset();
                    "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new e.Signal, this.onUp = new e.Signal, this.onTap = new e.Signal, this.onHold = new e.Signal, this.moveCallbacks = []), this._pollCounter = 0
                }
            },
            resetSpeed: function(t, e) {
                this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
            },
            startPointer: function(t) {
                if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                if (!this.pointer1.active) return this.pointer1.start(t);
                if (!this.pointer2.active) return this.pointer2.start(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (!i.active) return i.start(t)
                }
                return null
            },
            updatePointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier) return i.move(t)
                }
                return null
            },
            stopPointer: function(t) {
                if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                for (var e = 2; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active && i.identifier === t.identifier) return i.stop(t)
                }
                return null
            },
            countActivePointers: function(t) {
                void 0 === t && (t = this.pointers.length);
                for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) this.pointers[i].active && e--;
                return t - e
            },
            getPointer: function(t) {
                void 0 === t && (t = !1);
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.active === t) return i
                }
                return null
            },
            getPointerFromIdentifier: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.identifier === t) return i
                }
                return null
            },
            getPointerFromId: function(t) {
                for (var e = 0; e < this.pointers.length; e++) {
                    var i = this.pointers[e];
                    if (i.pointerId === t) return i
                }
                return null
            },
            getLocalPosition: function(t, i, s) {
                void 0 === s && (s = new e.Point);
                var n = t.worldTransform,
                    r = 1 / (n.a * n.d + n.c * -n.b);
                return s.setTo(n.d * r * i.x + -n.c * r * i.y + (n.ty * n.c - n.tx * n.d) * r, n.a * r * i.y + -n.b * r * i.x + (-n.ty * n.a + n.tx * n.b) * r)
            },
            hitTest: function(t, i, s) {
                if (!t.worldVisible) return !1;
                if (this.getLocalPosition(t, i, this._localPoint), s.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                if (e.Creature && t instanceof e.Creature) {
                    var n = Math.abs(t.width),
                        r = Math.abs(t.height),
                        a = t.x - n * t.anchorX;
                    if (this.game.camera.x + i.x >= a && this.game.camera.x + i.x < a + n) {
                        o = t.y - r * t.anchorY;
                        if (this.game.camera.y + i.y >= o && this.game.camera.y + i.y < o + r) return !0
                    }
                } else if (t instanceof e.TileSprite) {
                    var n = t.width,
                        r = t.height,
                        a = -n * t.anchor.x;
                    if (this._localPoint.x >= a && this._localPoint.x < a + n) {
                        o = -r * t.anchor.y;
                        if (this._localPoint.y >= o && this._localPoint.y < o + r) return !0
                    }
                } else if (t instanceof PIXI.Sprite) {
                    var n = t.texture.frame.width / t.texture.baseTexture.resolution,
                        r = t.texture.frame.height / t.texture.baseTexture.resolution,
                        a = -n * t.anchor.x;
                    if (this._localPoint.x >= a && this._localPoint.x < a + n) {
                        var o = -r * t.anchor.y;
                        if (this._localPoint.y >= o && this._localPoint.y < o + r) return !0
                    }
                } else if (t instanceof e.Graphics)
                    for (l = 0; l < t.graphicsData.length; l++) {
                        var h = t.graphicsData[l];
                        if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                    }
                for (var l = 0; l < t.children.length; l++)
                    if (this.hitTest(t.children[l], i, s)) return !0;
                return !1
            },
            onClickTrampoline: function() {
                this.activePointer.processClickTrampolines()
            },
            callAll: function(t, e) {
                for (var i = this.interactiveItems.list, s = i.length; s--;) {
                    var n = i[s];
                    n && n.enabled && n[t](e)
                }
            }
        }, e.Input.prototype.constructor = e.Input, Object.defineProperty(e.Input.prototype, "x", {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = Math.floor(t)
            }
        }), Object.defineProperty(e.Input.prototype, "y", {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = Math.floor(t)
            }
        }), Object.defineProperty(e.Input.prototype, "pollLocked", {
            get: function() {
                return this.pollRate > 0 && this._pollCounter < this.pollRate
            }
        }), Object.defineProperty(e.Input.prototype, "totalInactivePointers", {
            get: function() {
                return this.pointers.length - this.countActivePointers()
            }
        }), Object.defineProperty(e.Input.prototype, "totalActivePointers", {
            get: function() {
                return this.countActivePointers()
            }
        }), Object.defineProperty(e.Input.prototype, "worldX", {
            get: function() {
                return this.game.camera.view.x + this.x
            }
        }), Object.defineProperty(e.Input.prototype, "worldY", {
            get: function() {
                return this.game.camera.view.y + this.y
            }
        }), e.Mouse = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.capture = !1, this.active = !1, this.enabled = !0, this.stopOnGameOut = !1, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null
        }, e.Mouse.NO_BUTTON = -1, e.Mouse.LEFT_BUTTON = 0, e.Mouse.MIDDLE_BUTTON = 1, e.Mouse.RIGHT_BUTTON = 2, e.Mouse.BACK_BUTTON = 3, e.Mouse.FORWARD_BUTTON = 4, e.Mouse.prototype = {
            start: function() {
                var t = this.game.device;
                if (t.isAndroidStockBrowser() && this.input.touch.active) return !1;
                if (null !== this._onMouseDown) return !1;
                var e = this;
                this._onMouseDown = function(t) {
                    return e.onMouseDown(t)
                }, this._onMouseMove = function(t) {
                    return e.onMouseMove(t)
                }, this._onMouseUp = function(t) {
                    return e.onMouseUp(t)
                }, this._onMouseUpGlobal = function(t) {
                    return e.onMouseUpGlobal(t)
                }, this._onMouseOutGlobal = function(t) {
                    return e.onMouseOutGlobal(t)
                }, this._onMouseOut = function(t) {
                    return e.onMouseOut(t)
                }, this._onMouseOver = function(t) {
                    return e.onMouseOver(t)
                };
                var i = this.game.canvas;
                return i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), t.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0)), this.active = !0, !0
            },
            onMouseDown: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
            },
            onMouseMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
            },
            onMouseUp: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseUpGlobal: function(t) {
                this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
            },
            onMouseOutGlobal: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.resetButtons())
            },
            onMouseOut: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (this.input.mousePointer.updateButtons(t), this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t), this.input.callAll("_pointerOutHandler", this.input.mousePointer)))
            },
            onMouseOver: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.input.mousePointer.updateButtons(t)
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), this.active = !1
            }
        }, e.Mouse.prototype.constructor = e.Mouse, e.MouseWheel = function(t) {
            this.game = t, this.input = t.input, this.element = t.canvas, this.preventDefault = !0, this.active = !1, this.callback = null, this.callbackContext = t, this.delta = 0, this.wheelEventName = t.device.wheelEvent, this.boundOnWheelHandler = this.onWheelHandler.bind(this), this.eventProxy = null
        }, e.MouseWheel.UP = 1, e.MouseWheel.DOWN = -1, e.MouseWheel.prototype.start = function() {
            return !(!this.wheelEventName || this.active) && (this.element.addEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), "mousewheel" === this.wheelEventName ? this.eventProxy = new e.WheelEventProxy(-.025, 1) : "DOMMouseScroll" === this.wheelEventName && (this.eventProxy = new e.WheelEventProxy(1, 1)), this.active = !0, !0)
        }, e.MouseWheel.prototype.stop = function() {
            this.active && (this.element.removeEventListener(this.wheelEventName, this.boundOnWheelHandler, !0), this.active = !1)
        }, e.MouseWheel.prototype.onWheelHandler = function(t) {
            this.eventProxy && (t = this.eventProxy.bindEvent(t)), this.preventDefault && t.preventDefault(), this.delta = e.Math.clamp(-t.deltaY, -1, 1), this.callback && this.callback.call(this.callbackContext, t)
        }, e.MSPointer = function(t) {
            this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.pointerOutCallback = null, this.pointerOverCallback = null, this.pointerCancelCallback = null, this.capture = !1, this.event = null, this.active = !1, this.enabled = !0, this.stopOnGameOut = !1, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
        }, e.MSPointer.prototype = {
            start: function() {
                if (!this.game.device.mspointer) return !1;
                if (null !== this._onMSPointerDown) return !1;
                var t = this;
                this._onMSPointerDown = function(e) {
                    return t.onPointerDown(e)
                }, this._onMSPointerMove = function(e) {
                    return t.onPointerMove(e)
                }, this._onMSPointerUp = function(e) {
                    return t.onPointerUp(e)
                }, this._onMSPointerUpGlobal = function(e) {
                    return t.onPointerUpGlobal(e)
                }, this._onMSPointerOut = function(e) {
                    return t.onPointerOut(e)
                }, this._onMSPointerOver = function(e) {
                    return t.onPointerOver(e)
                }, this._onMSPointerCancel = function(e) {
                    return t.onPointerCancel(e)
                };
                var e = this.game.canvas;
                return e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("MSPointerCancel", this._onMSPointerCancel, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.addEventListener("pointercancel", this._onMSPointerCancel, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0)), this.active = !0, !0
            },
            onPointerDown: function(t) {
                this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, this.isMousePointerEvent(t) ? this.input.mousePointer.start(t) : this.input.startPointer(t))
            },
            onPointerMove: function(t) {
                this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, this.isMousePointerEvent(t) ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
            },
            onPointerUp: function(t) {
                this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, this.isMousePointerEvent(t) ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
            },
            onPointerUpGlobal: function(t) {
                if (t.identifier = t.pointerId, this.isMousePointerEvent(t) && !this.input.mousePointer.withinGame) this.onPointerUp(t);
                else {
                    var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && e.withinGame && this.onPointerUp(t)
                }
            },
            onPointerOut: function(t) {
                this.event = t, this.capture && t.preventDefault(), t.identifier = t.pointerId;
                var e = this.getPointerFromEvent(t);
                e && (e.withinGame = !1), this.pointerOutCallback && this.pointerOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, e || (e = this.input.mousePointer), e.stop(t), this.input.callAll("_pointerOutHandler", e))
            },
            onPointerOver: function(t) {
                this.event = t, this.capture && t.preventDefault(), t.identifier = t.pointerId;
                var e = this.getPointerFromEvent(t);
                e && (e.withinGame = !0), this.pointerOverCallback && this.pointerOverCallback.call(this.callbackContext, t)
            },
            onPointerCancel: function(t) {
                this.event = t, this.pointerCancelCallback && this.pointerCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && (t.identifier = t.pointerId, this.isMousePointerEvent(t) ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
            },
            stop: function() {
                var t = this.game.canvas;
                t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0), this.active = !1
            },
            isMousePointerEvent: function(t) {
                return "mouse" === t.pointerType || 4 === t.pointerType
            },
            getPointerFromEvent: function(t) {
                return this.isMousePointerEvent(t) ? this.input.mousePointer : this.input.getPointerFromIdentifier(t.identifier)
            }
        }, e.MSPointer.prototype.constructor = e.MSPointer, e.DeviceButton = function(t, i) {
            this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = i, this.onDown = new e.Signal, this.onUp = new e.Signal, this.onFloat = new e.Signal
        }, e.DeviceButton.prototype = {
            start: function(t, e) {
                this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
            },
            stop: function(t, e) {
                this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
            },
            startStop: function(t, e, i) {
                t ? this.start(e, i) : this.stop(e, i)
            },
            padFloat: function(t) {
                this.isDown = !1, this.isUp = !1, this.value = t, this.onFloat.dispatch(this, t)
            },
            justPressed: function(t) {
                return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
            },
            reset: function() {
                this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
            },
            destroy: function() {
                this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
            }
        }, e.DeviceButton.prototype.constructor = e.DeviceButton, Object.defineProperty(e.DeviceButton.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }), e.Pointer = function(t, i, s) {
            this.game = t, this.id = i, this.type = e.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = s || e.PointerMode.CURSOR | e.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new e.DeviceButton(this, e.Pointer.LEFT_BUTTON), this.middleButton = new e.DeviceButton(this, e.Pointer.MIDDLE_BUTTON), this.rightButton = new e.DeviceButton(this, e.Pointer.RIGHT_BUTTON), this.backButton = new e.DeviceButton(this, e.Pointer.BACK_BUTTON), this.forwardButton = new e.DeviceButton(this, e.Pointer.FORWARD_BUTTON), this.eraserButton = new e.DeviceButton(this, e.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === i, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new e.Point, this.positionDown = new e.Point, this.positionUp = new e.Point, this.circle = new e.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
        }, e.Pointer.NO_BUTTON = 0, e.Pointer.LEFT_BUTTON = 1, e.Pointer.RIGHT_BUTTON = 2, e.Pointer.MIDDLE_BUTTON = 4, e.Pointer.BACK_BUTTON = 8, e.Pointer.FORWARD_BUTTON = 16, e.Pointer.ERASER_BUTTON = 32, e.Pointer.prototype = {
            resetButtons: function() {
                this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
            },
            processButtonsDown: function(t, i) {
                switch (t) {
                    case e.Mouse.LEFT_BUTTON:
                        this.leftButton.start(i);
                        break;
                    case e.Mouse.RIGHT_BUTTON:
                        this.rightButton.start(i);
                        break;
                    case e.Mouse.MIDDLE_BUTTON:
                        this.middleButton.start(i);
                        break;
                    case e.Mouse.BACK_BUTTON:
                        this.backButton.start(i);
                        break;
                    case e.Mouse.FORWARD_BUTTON:
                        this.forwardButton.start(i)
                }
            },
            processButtonsUp: function(t, i) {
                switch (t) {
                    case e.Mouse.LEFT_BUTTON:
                        this.leftButton.stop(i);
                        break;
                    case e.Mouse.RIGHT_BUTTON:
                        this.rightButton.stop(i);
                        break;
                    case e.Mouse.MIDDLE_BUTTON:
                        this.middleButton.stop(i);
                        break;
                    case e.Mouse.BACK_BUTTON:
                        this.backButton.stop(i);
                        break;
                    case e.Mouse.FORWARD_BUTTON:
                        this.forwardButton.stop(i)
                }
            },
            processButtonsUpDown: function(t, i) {
                var s = i.type.toLowerCase().substr(-4),
                    n = "down" === s,
                    r = "move" === s;
                void 0 !== t ? (n && 1 === t && i.ctrlKey && (t = 2), this.leftButton.startStop(e.Pointer.LEFT_BUTTON & t, i), this.rightButton.startStop(e.Pointer.RIGHT_BUTTON & t, i), this.middleButton.startStop(e.Pointer.MIDDLE_BUTTON & t, i), this.backButton.startStop(e.Pointer.BACK_BUTTON & t, i), this.forwardButton.startStop(e.Pointer.FORWARD_BUTTON & t, i), this.eraserButton.startStop(e.Pointer.ERASER_BUTTON & t, i)) : void 0 !== i.button ? n && i.ctrlKey && 0 === i.button ? this.rightButton.start(i) : n ? this.processButtonsDown(i.button, i) : r || this.processButtonsUp(i.button, i) : n ? i.ctrlKey ? this.rightButton.start(i) : this.leftButton.start(i) : (this.leftButton.stop(i), this.rightButton.stop(i))
            },
            updateButtons: function(t) {
                this.button = t.button, this.processButtonsUpDown(t.buttons, t), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
            },
            start: function(t) {
                var i = this.game.input;
                return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (i.multiInputOverride === e.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === e.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === e.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.x = this.x, i.y = this.y, i.position.setTo(this.x, this.y), i.onDown.dispatch(this, t), i.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
            },
            update: function() {
                var t = this.game.input;
                this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === e.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === e.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === e.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                    x: this.position.x,
                    y: this.position.y
                }), this._history.length > t.recordLimit && this._history.shift()))
            },
            move: function(t, i) {
                var s = this.game.input;
                if (!s.pollLocked) {
                    void 0 === i && (i = !1), void 0 !== t.button && (this.button = t.button), this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && s.pointerLock.locked && !i && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * s.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * s.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (s.multiInputOverride === e.Input.MOUSE_OVERRIDES_TOUCH || s.multiInputOverride === e.Input.MOUSE_TOUCH_COMBINE || s.multiInputOverride === e.Input.TOUCH_OVERRIDES_MOUSE && 0 === s.totalActivePointers) && (s.activePointer = this, s.x = this.x, s.y = this.y, s.position.setTo(s.x, s.y), s.circle.x = s.x, s.circle.y = s.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                    for (var n = s.moveCallbacks.length; n--;) s.moveCallbacks[n].callback.call(s.moveCallbacks[n].context, this, this.x, this.y, i, t);
                    return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? s.interactiveItems.total > 0 && this.processInteractiveObjects(i) : !1 === this.targetObject.update(this) && (this.targetObject = null), this
                }
            },
            processInteractiveObjects: function(t) {
                var e = 0,
                    i = -1,
                    s = null,
                    n = this.game.input.interactiveItems.first;
                for (this.interactiveCandidates = []; n;) n.checked = !1, !n.validForInput(i, e, !1) || this.game.paused && !n.sprite.noPause || (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
                for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
                return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
            },
            swapTarget: function(t, e) {
                void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
            },
            leave: function(t) {
                this.withinGame = !1, this.move(t, !1)
            },
            stop: function(t) {
                var i = this.game.input; {
                    if (!this._stateReset || !this.withinGame) {
                        if (this.timeUp = this.game.time.time, (i.multiInputOverride === e.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === e.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === e.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= i.tapRate)) {
                            var s = this.timeUp - this.previousTapTime < i.doubleTapRate;
                            i.onTap.dispatch(this, s, t), this.previousTapTime = this.timeUp
                        }
                        return this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && i.currentPointers--, i.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this
                    }
                    t.preventDefault()
                }
            },
            justPressed: function(t) {
                return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
            },
            justReleased: function(t) {
                return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
            },
            addClickTrampoline: function(t, e, i, s) {
                if (this.isDown) {
                    for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++)
                        if (n[r].name === t) {
                            n.splice(r, 1);
                            break
                        }
                    n.push({
                        name: t,
                        targetObject: this.targetObject,
                        callback: e,
                        callbackContext: i,
                        callbackArgs: s
                    })
                }
            },
            processClickTrampolines: function() {
                var t = this._clickTrampolines;
                if (t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                    }
                    this._clickTrampolines = null, this._trampolineTargetObject = null
                }
            },
            reset: function() {
                !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
            },
            resetMovement: function() {
                this.movementX = 0, this.movementY = 0
            }
        }, e.Pointer.prototype.constructor = e.Pointer, Object.defineProperty(e.Pointer.prototype, "duration", {
            get: function() {
                return this.isUp ? -1 : this.game.time.time - this.timeDown
            }
        }), Object.defineProperty(e.Pointer.prototype, "worldX", {
            get: function() {
                return this.game.world.camera.x + this.x
            }
        }), Object.defineProperty(e.Pointer.prototype, "worldY", {
            get: function() {
                return this.game.world.camera.y + this.y
            }
        }), e.PointerMode = {
            CURSOR: 1,
            CONTACT: 2
        }, e.PointerModes = {}, e.PointerModes[e.PointerMode.CURSOR] = "CURSOR", e.PointerModes[e.PointerMode.CONTACT] = "CONTACT", e.Touch = function(t) {
            this.game = t, this.active = !1, this.enabled = !0, this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
        }, e.Touch.prototype = {
            start: function() {
                if (!this.game.device.touch) return !1;
                if (null !== this._onTouchStart) return !1;
                var t = this;
                return this._onTouchStart = function(e) {
                    return t.onTouchStart(e)
                }, this._onTouchMove = function(e) {
                    return t.onTouchMove(e)
                }, this._onTouchEnd = function(e) {
                    return t.onTouchEnd(e)
                }, this._onTouchEnter = function(e) {
                    return t.onTouchEnter(e)
                }, this._onTouchLeave = function(e) {
                    return t.onTouchLeave(e)
                }, this._onTouchCancel = function(e) {
                    return t.onTouchCancel(e)
                }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)), this.active = !0, !0
            },
            consumeDocumentTouches: function() {
                this._documentTouchMove = function(t) {
                    t.preventDefault()
                }, document.addEventListener("touchmove", this._documentTouchMove, !1)
            },
            onTouchStart: function(t) {
                if (this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.game.input.enabled && this.enabled) {
                    this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                }
            },
            onTouchCancel: function(t) {
                if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                    this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                }
            },
            onTouchEnter: function(t) {
                this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
            },
            onTouchLeave: function(t) {
                this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
            },
            onTouchMove: function(t) {
                this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
            },
            onTouchEnd: function(t) {
                this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
            },
            stop: function() {
                this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel), this.active = !1)
            }
        }, e.Touch.prototype.constructor = e.Touch, e.InputHandler = function(t) {
            this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new e.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new e.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new e.Point, this.snapPoint = new e.Point, this._dragPoint = new e.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new e.Point, this._pointerData = [], this._pointerData.push({
                id: 0,
                x: 0,
                y: 0,
                camX: 0,
                camY: 0,
                isDown: !1,
                isUp: !1,
                isOver: !1,
                isOut: !1,
                timeOver: 0,
                timeOut: 0,
                timeDown: 0,
                timeUp: 0,
                downDuration: 0,
                isDragged: !1
            })
        }, e.InputHandler.prototype = {
            start: function(t, i) {
                if (t = t || 0, void 0 === i && (i = !1), !1 === this.enabled) {
                    this.game.input.interactiveItems.add(this), this.useHandCursor = i, this.priorityID = t;
                    for (var s = 0; s < 10; s++) this._pointerData[s] = {
                        id: s,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    };
                    this.snapOffset = new e.Point, this.enabled = !0, this._wasEnabled = !0
                }
                return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
            },
            addedToGroup: function() {
                this._dragPhase || this._wasEnabled && !this.enabled && this.start()
            },
            removedFromGroup: function() {
                this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
            },
            reset: function() {
                this.enabled = !1;
                for (var t = 0; t < 10; t++) this._pointerData[t] = {
                    id: t,
                    x: 0,
                    y: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                }
            },
            stop: function() {
                !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
            },
            destroy: function() {
                this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
            },
            validForInput: function(t, e, i) {
                return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
            },
            isPixelPerfect: function() {
                return this.pixelPerfectClick || this.pixelPerfectOver
            },
            pointerX: function(t) {
                return t = t || 0, this._pointerData[t].x
            },
            pointerY: function(t) {
                return t = t || 0, this._pointerData[t].y
            },
            pointerDown: function(t) {
                return t = t || 0, this._pointerData[t].isDown
            },
            pointerUp: function(t) {
                return t = t || 0, this._pointerData[t].isUp
            },
            pointerTimeDown: function(t) {
                return t = t || 0, this._pointerData[t].timeDown
            },
            pointerTimeUp: function(t) {
                return t = t || 0, this._pointerData[t].timeUp
            },
            pointerOver: function(t) {
                if (!this.enabled) return !1;
                if (void 0 === t) {
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOver) return !0;
                    return !1
                }
                return this._pointerData[t].isOver
            },
            pointerOut: function(t) {
                if (!this.enabled) return !1;
                if (void 0 !== t) return this._pointerData[t].isOut;
                for (var e = 0; e < 10; e++)
                    if (this._pointerData[e].isOut) return !0
            },
            pointerTimeOver: function(t) {
                return t = t || 0, this._pointerData[t].timeOver
            },
            pointerTimeOut: function(t) {
                return t = t || 0, this._pointerData[t].timeOut
            },
            pointerDragged: function(t) {
                return t = t || 0, this._pointerData[t].isDragged
            },
            checkPointerDown: function(t, e) {
                return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            },
            checkPointerOver: function(t, e) {
                return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
            },
            checkPixel: function(t, e, i) {
                if (this.sprite.texture.baseTexture.source) {
                    if (null === t && null === e) {
                        this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                        var t = this._tempPoint.x,
                            e = this._tempPoint.y
                    }
                    if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                    if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                }
                return !1
            },
            update: function(t) {
                if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = e.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
            },
            _pointerOverHandler: function(t, e) {
                if (null !== this.sprite) {
                    var i = this._pointerData[t.id];
                    if (!1 === i.isOver || t.dirty) {
                        var s = !1 === i.isOver;
                        i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.onChildInputOver && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                    }
                }
            },
            _pointerOutHandler: function(t, e) {
                if (null !== this.sprite) {
                    var i = this._pointerData[t.id];
                    i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputOut && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                }
            },
            _touchedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (!e.isDown && e.isOver) {
                        if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                        if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputDown && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                        this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                    }
                }
            },
            dragTimeElapsed: function(t) {
                this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
            },
            _releasedHandler: function(t) {
                if (null !== this.sprite) {
                    var e = this._pointerData[t.id];
                    if (e.isDown && t.isUp) {
                        e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                        var i = this.checkPointerOver(t);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputUp && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), e.isOver = i, !i && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                    }
                }
            },
            updateDrag: function(t, e) {
                var i = this.game.camera,
                    s = this.dragOffset,
                    n = this._dragPoint,
                    r = this._pointerData[t.id],
                    a = this.snapPoint,
                    o = this.sprite;
                if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                var h = this.globalToLocal(t);
                if (o.fixedToCamera) var l = i.scale.x * h.x + n.x + s.x,
                    u = i.scale.y * h.y + n.y + s.y;
                else var l = h.x + n.x + s.x,
                    u = h.y + n.y + s.y;
                if (o.fixedToCamera) {
                    var c = o.cameraOffset,
                        d = c.x,
                        p = c.y;
                    this.allowHorizontalDrag && (c.x = l - i.x), this.allowVerticalDrag && (c.y = u - i.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (c.x = Math.round((c.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, c.y = Math.round((c.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, a.set(c.x, c.y));
                    var f = c.x - d,
                        m = c.y - p
                } else {
                    var g = i.x - r.camX,
                        v = i.y - r.camY,
                        d = o.x,
                        p = o.y;
                    this.allowHorizontalDrag && (o.x = l + g), this.allowVerticalDrag && (o.y = u + v), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (o.x = Math.round((o.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, o.y = Math.round((o.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, a.set(o.x, o.y));
                    var f = o.x - d,
                        m = o.y - p
                }
                return this.sprite.events.onDragUpdate.dispatch(o, t, l, u, a, e, f, m), !0
            },
            justOver: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
            },
            justOut: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
            },
            justPressed: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
            },
            justReleased: function(t, e) {
                return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
            },
            overDuration: function(t) {
                return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
            },
            downDuration: function(t) {
                return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
            },
            enableDrag: function(t, i, s, n, r, a) {
                void 0 === t && (t = !1), void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = 255), void 0 === r && (r = null), void 0 === a && (a = null), this._dragPoint = new e.Point, this.draggable = !0, this.bringToTop = i, this.dragOffset = new e.Point, this.dragFromCenter = t, this.pixelPerfectClick = s, this.pixelPerfectAlpha = n, r && (this.boundsRect = r), a && (this.boundsSprite = a)
            },
            disableDrag: function() {
                if (this._pointerData)
                    for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
            },
            startDrag: function(t) {
                var i = this.sprite.x,
                    s = this.sprite.y,
                    n = this.globalToLocal(t);
                if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                    if (this.dragFromCenter) {
                        var r = this.sprite.getBounds(),
                            a = this.globalToLocal(new e.Point(r.centerX, r.centerY));
                        this.sprite.cameraOffset.x = n.x + (this.sprite.cameraOffset.x - a.x), this.sprite.cameraOffset.y = n.y + (this.sprite.cameraOffset.y - a.y)
                    }
                    this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                } else {
                    if (this.dragFromCenter) {
                        var r = this.sprite.getBounds(),
                            a = this.globalToLocal(new e.Point(r.centerX, r.centerY));
                        this.sprite.x = n.x + (this.sprite.x - a.x), this.sprite.y = n.y + (this.sprite.y - a.y)
                    }
                    this._dragPoint.setTo(this.sprite.x - n.x, this.sprite.y - n.y)
                }
                this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(i, s), this.sprite.events.onDragStart$dispatch(this.sprite, t, i, s), this._pendingDrag = !1
            },
            globalToLocalX: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
            },
            globalToLocalY: function(t) {
                return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
            },
            globalToLocal: function(t) {
                return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                    x: t.x,
                    y: t.y
                }) : t
            },
            stopDrag: function(t) {
                this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
            },
            setDragLock: function(t, e) {
                void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
            },
            enableSnap: function(t, e, i, s, n, r) {
                void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = s
            },
            disableSnap: function() {
                this.snapOnDrag = !1, this.snapOnRelease = !1
            },
            checkBoundsRect: function() {
                this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
            },
            checkBoundsSprite: function() {
                this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
            }
        }, e.InputHandler.prototype.constructor = e.InputHandler, e.PointerLock = function(t) {
            this.game = t, this.input = t.input, this.element = t.canvas, this.active = !1, this.locked = !1, this.onChange = new e.Signal, this.onError = new e.Signal, this.boundOnChangeHandler = this.onChangeHandler.bind(this), this.boundOnErrorHandler = this.onErrorHandler.bind(this);
            var i = t.device;
            this.pointerLockElement = i.pointerLockElement, this.pointerlockchange = i.pointerlockchange, this.pointerlockerror = i.pointerlockerror
        }, e.PointerLock.prototype.start = function() {
            return !(!this.game.device.pointerLock || this.active) && (this.element.requestPointerLock || (this.element.requestPointerLock = this.element.mozRequestPointerLock || this.element.webkitRequestPointerLock), document.exitPointerLock || (document.exitPointerLock = document.mozExitPointerLock || document.webkitExitPointerLock), document.addEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.addEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !0, !0)
        }, e.PointerLock.prototype.stop = function() {
            this.active && (document.removeEventListener(this.pointerlockchange, this.boundOnChangeHandler, !0), document.removeEventListener(this.pointerlockerror, this.boundOnErrorHandler, !0), this.active = !1)
        }, e.PointerLock.prototype.request = function() {
            this.active && !this.locked && this.element.requestPointerLock()
        }, e.PointerLock.prototype.exit = function() {
            document.exitPointerLock()
        }, e.PointerLock.prototype.onChangeHandler = function(t) {
            this.locked = document[this.pointerLockElement] === this.element, this.onChange.dispatch(this.locked, t)
        }, e.PointerLock.prototype.onErrorHandler = function(t) {
            this.onError.dispatch(t)
        }, e.Key = function(t, i) {
            this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.durationUp = -2500, this.repeats = 0, this.keyCode = i, this.onDown = new e.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new e.Signal, this._justDown = !1, this._justUp = !1
        }, e.Key.prototype = {
            update: function() {
                this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp)
            },
            processKeyDown: function(t) {
                this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.durationUp = this.game.time.time - this.timeUp, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
            },
            processKeyUp: function(t) {
                this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this.durationUp = 0, this._justUp = !0, this.onUp.dispatch(this)))
            },
            reset: function(t) {
                void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this.durationUp = -2500, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
            },
            downDuration: function(t) {
                return void 0 === t && (t = 50), this.isDown && this.duration < t
            },
            upDuration: function(t) {
                return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
            },
            justPressed: function() {
                return this.isDown && 0 === this.duration
            },
            justReleased: function() {
                return !this.isDown && 0 === this.durationUp
            }
        }, Object.defineProperty(e.Key.prototype, "justDown", {
            get: function() {
                var t = this._justDown;
                return this._justDown = !1, t
            }
        }), Object.defineProperty(e.Key.prototype, "justUp", {
            get: function() {
                var t = this._justUp;
                return this._justUp = !1, t
            }
        }), Object.defineProperty(e.Key.prototype, "enabled", {
            get: function() {
                return this._enabled
            },
            set: function(t) {
                (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
            }
        }), e.Key.prototype.constructor = e.Key, e.Keyboard = function(t) {
            this.game = t, this.active = !1, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
        }, e.Keyboard.prototype = {
            addCallbacks: function(t, e, i, s) {
                this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== s && null !== s && (this.onPressCallback = s)
            },
            removeCallbacks: function() {
                this.callbackContext = this, this.onDownCallback = null, this.onUpCallback = null, this.onPressCallback = null
            },
            addKey: function(t) {
                return this._keys[t] || (this._keys[t] = new e.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
            },
            addKeys: function(t) {
                var e = {};
                for (var i in t) e[i] = this.addKey(t[i]);
                return e
            },
            removeKey: function(t) {
                this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
            },
            createCursorKeys: function() {
                return this.addKeys({
                    up: e.KeyCode.UP,
                    down: e.KeyCode.DOWN,
                    left: e.KeyCode.LEFT,
                    right: e.KeyCode.RIGHT
                })
            },
            start: function() {
                if (this.game.device.cocoonJS) return !1;
                if (this.active) return !1;
                var t = this;
                return this._onKeyDown = function(e) {
                    return t.processKeyDown(e)
                }, this._onKeyUp = function(e) {
                    return t.processKeyUp(e)
                }, this._onKeyPress = function(e) {
                    return t.processKeyPress(e)
                }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1), this.active = !0, !0
            },
            stop: function() {
                window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null, this.active = !1
            },
            destroy: function() {
                this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
            },
            addKeyCapture: function(t) {
                if ("object" == typeof t)
                    for (var e in t) this._capture[t[e]] = !0;
                else this._capture[t] = !0
            },
            removeKeyCapture: function(t) {
                delete this._capture[t]
            },
            clearCaptures: function() {
                this._capture = {}
            },
            update: function() {
                for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
            },
            processKeyDown: function(t) {
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    var i = t.keyCode;
                    this._capture[i] && t.preventDefault(), this._keys[i] || (this._keys[i] = new e.Key(this.game, i)), this._keys[i].processKeyDown(t), this._k = i, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                }
            },
            processKeyPress: function(t) {
                this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
            },
            processKeyUp: function(t) {
                if (this.event = t, this.game.input.enabled && this.enabled) {
                    var i = t.keyCode;
                    this._capture[i] && t.preventDefault(), this._keys[i] || (this._keys[i] = new e.Key(this.game, i)), this._keys[i].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                }
            },
            reset: function(t) {
                void 0 === t && (t = !0), this.event = null;
                for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
            },
            downDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].downDuration(e) : null
            },
            upDuration: function(t, e) {
                return this._keys[t] ? this._keys[t].upDuration(e) : null
            },
            justPressed: function(t) {
                return this._keys[t] ? this._keys[t].justPressed() : null
            },
            justReleased: function(t) {
                return this._keys[t] ? this._keys[t].justReleased() : null
            },
            isDown: function(t) {
                return this._keys[t] ? this._keys[t].isDown : null
            }
        }, Object.defineProperty(e.Keyboard.prototype, "lastChar", {
            get: function() {
                return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null
            }
        }), Object.defineProperty(e.Keyboard.prototype, "lastKey", {
            get: function() {
                return this._keys[this._k]
            }
        }), e.Keyboard.prototype.constructor = e.Keyboard, e.KeyCode = {
            A: "A".charCodeAt(0),
            B: "B".charCodeAt(0),
            C: "C".charCodeAt(0),
            D: "D".charCodeAt(0),
            E: "E".charCodeAt(0),
            F: "F".charCodeAt(0),
            G: "G".charCodeAt(0),
            H: "H".charCodeAt(0),
            I: "I".charCodeAt(0),
            J: "J".charCodeAt(0),
            K: "K".charCodeAt(0),
            L: "L".charCodeAt(0),
            M: "M".charCodeAt(0),
            N: "N".charCodeAt(0),
            O: "O".charCodeAt(0),
            P: "P".charCodeAt(0),
            Q: "Q".charCodeAt(0),
            R: "R".charCodeAt(0),
            S: "S".charCodeAt(0),
            T: "T".charCodeAt(0),
            U: "U".charCodeAt(0),
            V: "V".charCodeAt(0),
            W: "W".charCodeAt(0),
            X: "X".charCodeAt(0),
            Y: "Y".charCodeAt(0),
            Z: "Z".charCodeAt(0),
            ZERO: "0".charCodeAt(0),
            ONE: "1".charCodeAt(0),
            TWO: "2".charCodeAt(0),
            THREE: "3".charCodeAt(0),
            FOUR: "4".charCodeAt(0),
            FIVE: "5".charCodeAt(0),
            SIX: "6".charCodeAt(0),
            SEVEN: "7".charCodeAt(0),
            EIGHT: "8".charCodeAt(0),
            NINE: "9".charCodeAt(0),
            NUMPAD_0: 96,
            NUMPAD_1: 97,
            NUMPAD_2: 98,
            NUMPAD_3: 99,
            NUMPAD_4: 100,
            NUMPAD_5: 101,
            NUMPAD_6: 102,
            NUMPAD_7: 103,
            NUMPAD_8: 104,
            NUMPAD_9: 105,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_ADD: 107,
            NUMPAD_ENTER: 108,
            NUMPAD_SUBTRACT: 109,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            F13: 124,
            F14: 125,
            F15: 126,
            COLON: 186,
            EQUALS: 187,
            COMMA: 188,
            UNDERSCORE: 189,
            PERIOD: 190,
            QUESTION_MARK: 191,
            TILDE: 192,
            OPEN_BRACKET: 219,
            BACKWARD_SLASH: 220,
            CLOSED_BRACKET: 221,
            QUOTES: 222,
            BACKSPACE: 8,
            TAB: 9,
            CLEAR: 12,
            ENTER: 13,
            SHIFT: 16,
            CONTROL: 17,
            ALT: 18,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACEBAR: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PLUS: 43,
            MINUS: 44,
            INSERT: 45,
            DELETE: 46,
            HELP: 47,
            NUM_LOCK: 144
        };
        for (var s in e.KeyCode) e.KeyCode.hasOwnProperty(s) && !s.match(/[a-z]/) && (e.Keyboard[s] = e.KeyCode[s]);
        e.Component = function() {}, e.Component.Angle = function() {}, e.Component.Angle.prototype = {
            angle: {
                get: function() {
                    return e.Math.wrapAngle(e.Math.radToDeg(this.rotation))
                },
                set: function(t) {
                    this.rotation = e.Math.degToRad(e.Math.wrapAngle(t))
                }
            }
        }, e.Component.Animation = function() {}, e.Component.Animation.prototype = {
            play: function(t, e, i, s) {
                if (this.animations) return this.animations.play(t, e, i, s)
            }
        }, e.Component.AutoCull = function() {}, e.Component.AutoCull.prototype = {
            autoCull: !1,
            inCamera: {
                get: function() {
                    return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, e.Component.Bounds = function() {}, e.Component.Bounds.prototype = {
            offsetX: {
                get: function() {
                    return this.anchor.x * this.width
                }
            },
            offsetY: {
                get: function() {
                    return this.anchor.y * this.height
                }
            },
            centerX: {
                get: function() {
                    return this.x - this.offsetX + .5 * this.width
                },
                set: function(t) {
                    this.x = t + this.offsetX - .5 * this.width
                }
            },
            centerY: {
                get: function() {
                    return this.y - this.offsetY + .5 * this.height
                },
                set: function(t) {
                    this.y = t + this.offsetY - .5 * this.height
                }
            },
            left: {
                get: function() {
                    return this.x - this.offsetX
                },
                set: function(t) {
                    this.x = t + this.offsetX
                }
            },
            right: {
                get: function() {
                    return this.x + this.width - this.offsetX
                },
                set: function(t) {
                    this.x = t - this.width + this.offsetX
                }
            },
            top: {
                get: function() {
                    return this.y - this.offsetY
                },
                set: function(t) {
                    this.y = t + this.offsetY
                }
            },
            bottom: {
                get: function() {
                    return this.y + this.height - this.offsetY
                },
                set: function(t) {
                    this.y = t - this.height + this.offsetY
                }
            },
            alignIn: function(t, i, s, n) {
                switch (void 0 === s && (s = 0), void 0 === n && (n = 0), i) {
                    default:
                        case e.TOP_LEFT:
                        this.left = t.left - s,
                    this.top = t.top - n;
                    break;
                    case e.TOP_CENTER:
                            this.centerX = t.centerX + s,
                        this.top = t.top - n;
                        break;
                    case e.TOP_RIGHT:
                            this.right = t.right + s,
                        this.top = t.top - n;
                        break;
                    case e.LEFT_CENTER:
                            this.left = t.left - s,
                        this.centerY = t.centerY + n;
                        break;
                    case e.CENTER:
                            this.centerX = t.centerX + s,
                        this.centerY = t.centerY + n;
                        break;
                    case e.RIGHT_CENTER:
                            this.right = t.right + s,
                        this.centerY = t.centerY + n;
                        break;
                    case e.BOTTOM_LEFT:
                            this.left = t.left - s,
                        this.bottom = t.bottom + n;
                        break;
                    case e.BOTTOM_CENTER:
                            this.centerX = t.centerX + s,
                        this.bottom = t.bottom + n;
                        break;
                    case e.BOTTOM_RIGHT:
                            this.right = t.right + s,
                        this.bottom = t.bottom + n
                }
                return this
            },
            alignTo: function(t, i, s, n) {
                switch (void 0 === s && (s = 0), void 0 === n && (n = 0), i) {
                    default:
                        case e.TOP_LEFT:
                        this.left = t.left - s,
                    this.bottom = t.top - n;
                    break;
                    case e.TOP_CENTER:
                            this.centerX = t.centerX + s,
                        this.bottom = t.top - n;
                        break;
                    case e.TOP_RIGHT:
                            this.right = t.right + s,
                        this.bottom = t.top - n;
                        break;
                    case e.LEFT_TOP:
                            this.right = t.left - s,
                        this.top = t.top - n;
                        break;
                    case e.LEFT_CENTER:
                            this.right = t.left - s,
                        this.centerY = t.centerY + n;
                        break;
                    case e.LEFT_BOTTOM:
                            this.right = t.left - s,
                        this.bottom = t.bottom + n;
                        break;
                    case e.RIGHT_TOP:
                            this.left = t.right + s,
                        this.top = t.top - n;
                        break;
                    case e.RIGHT_CENTER:
                            this.left = t.right + s,
                        this.centerY = t.centerY + n;
                        break;
                    case e.RIGHT_BOTTOM:
                            this.left = t.right + s,
                        this.bottom = t.bottom + n;
                        break;
                    case e.BOTTOM_LEFT:
                            this.left = t.left - s,
                        this.top = t.bottom + n;
                        break;
                    case e.BOTTOM_CENTER:
                            this.centerX = t.centerX + s,
                        this.top = t.bottom + n;
                        break;
                    case e.BOTTOM_RIGHT:
                            this.right = t.right + s,
                        this.top = t.bottom + n
                }
                return this
            }
        }, e.Group.prototype.alignIn = e.Component.Bounds.prototype.alignIn, e.Group.prototype.alignTo = e.Component.Bounds.prototype.alignTo, e.Component.BringToTop = function() {}, e.Component.BringToTop.prototype.bringToTop = function() {
            return this.parent && this.parent.bringChildToTop && this.parent.bringChildToTop(this), this
        }, e.Component.BringToTop.prototype.sendToBack = function() {
            return this.parent && this.parent.sendChildToBack && this.parent.sendChildToBack(this), this
        }, e.Component.BringToTop.prototype.moveUp = function() {
            return this.parent && this.parent.moveUp(this), this
        }, e.Component.BringToTop.prototype.moveDown = function() {
            return this.parent && this.parent.moveDown(this), this
        }, e.Component.Core = function() {}, e.Component.Core.install = function(t) {
            e.Utils.mixinPrototype(this, e.Component.Core.prototype), this.components = {};
            for (var i = 0; i < t.length; i++) {
                var s = t[i],
                    n = !1;
                "Destroy" === s && (n = !0), e.Utils.mixinPrototype(this, e.Component[s].prototype, n), this.components[s] = !0
            }
        }, e.Component.Core.init = function(t, i, s, n, r) {
            this.game = t, this.key = n, this.data = {}, this.position.set(i, s), this.world = new e.Point(i, s), this.previousPosition = new e.Point(i, s), this.events = new e.Events(this), this._bounds = new e.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new e.AnimationManager(this)), this.components.LoadTexture && null !== n && this.loadTexture(n, r), this.components.FixedToCamera && (this.cameraOffset = new e.Point(i, s))
        }, e.Component.Core.preUpdate = function() {
            return this.pendingDestroy ? (this.destroy(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.exists && this.parent.exists ? (this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(), this.preUpdateChildren(), !0) : (this.renderOrderID = -1, !1))
        }, e.Component.Core.prototype = {
            game: null,
            name: "",
            data: {},
            components: {},
            z: 0,
            events: void 0,
            animations: void 0,
            key: "",
            world: null,
            debug: !1,
            previousPosition: null,
            previousRotation: 0,
            renderOrderID: 0,
            fresh: !0,
            pendingDestroy: !1,
            _bounds: null,
            _exists: !0,
            exists: {
                get: function() {
                    return this._exists
                },
                set: function(t) {
                    t ? (this._exists = !0, this.body && this.body.type === e.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === e.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                }
            },
            preUpdateChildren: function() {
                for (var t = 0; t < this.children.length;) {
                    var e = this.children[t];
                    e.preUpdate(), this === e.parent && t++
                }
            },
            update: function() {},
            postUpdate: function() {
                this.customRender && this.key.render(), this.components.PhysicsBody && e.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && e.Component.FixedToCamera.postUpdate.call(this);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }
        }, e.Component.Crop = function() {}, e.Component.Crop.prototype = {
            cropRect: null,
            _crop: null,
            crop: function(t, i) {
                void 0 === i && (i = !1), t ? (i && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : i && null === this.cropRect ? this.cropRect = new e.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
            },
            updateCrop: function() {
                if (this.cropRect) {
                    var t = this.texture.crop.x,
                        i = this.texture.crop.y,
                        s = this.texture.crop.width,
                        n = this.texture.crop.height;
                    this._crop = e.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                    var r = Math.max(this._frame.x, this._crop.x),
                        a = Math.max(this._frame.y, this._crop.y),
                        o = Math.min(this._frame.right, this._crop.right) - r,
                        h = Math.min(this._frame.bottom, this._crop.bottom) - a;
                    this.texture.crop.x = r, this.texture.crop.y = a, this.texture.crop.width = o, this.texture.crop.height = h, this.texture.frame.width = Math.min(o, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === r && i === a && s === o && n === h || (this.texture.requiresReTint = !0)
                }
            }
        }, e.Component.Delta = function() {}, e.Component.Delta.prototype = {
            deltaX: {
                get: function() {
                    return this.world.x - this.previousPosition.x
                }
            },
            deltaY: {
                get: function() {
                    return this.world.y - this.previousPosition.y
                }
            },
            deltaZ: {
                get: function() {
                    return this.rotation - this.previousRotation
                }
            }
        }, e.Component.Destroy = function() {}, e.Component.Destroy.prototype = {
            destroyPhase: !1,
            destroy: function(t, i) {
                if (null !== this.game && !this.destroyPhase) {
                    void 0 === t && (t = !0), void 0 === i && (i = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof e.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                    var s = this.children.length;
                    if (t)
                        for (; s--;) this.children[s].destroy(t);
                    else
                        for (; s--;) this.removeChild(this.children[s]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), e.Video && this.key instanceof e.Video && this.key.onChangeSource.remove(this.resizeFrame, this), e.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), this._destroyTintedTexture(), i && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                }
            }
        }, e.Events = function(t) {
            this.parent = t
        }, e.Events.prototype = {
            destroy: function() {
                this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
            },
            onAddedToGroup: null,
            onRemovedFromGroup: null,
            onDestroy: null,
            onKilled: null,
            onRevived: null,
            onOutOfBounds: null,
            onEnterBounds: null,
            onInputOver: null,
            onInputOut: null,
            onInputDown: null,
            onInputUp: null,
            onDragStart: null,
            onDragUpdate: null,
            onDragStop: null,
            onAnimationStart: null,
            onAnimationComplete: null,
            onAnimationLoop: null
        }, e.Events.prototype.constructor = e.Events;
        for (var n in e.Events.prototype) e.Events.prototype.hasOwnProperty(n) && 0 === n.indexOf("on") && null === e.Events.prototype[n] && function(t, i) {
            "use strict";
            Object.defineProperty(e.Events.prototype, t, {
                get: function() {
                    return this[i] || (this[i] = new e.Signal)
                }
            }), e.Events.prototype[t + "$dispatch"] = function() {
                return this[i] ? this[i].dispatch.apply(this[i], arguments) : null
            }
        }(n, "_" + n);
        e.Component.FixedToCamera = function() {}, e.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, e.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(t) {
                    t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new e.Point
        }, e.Component.Health = function() {}, e.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            },
            setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, e.Component.InCamera = function() {}, e.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, e.Component.InputEnabled = function() {}, e.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(t) {
                    t ? null === this.input ? (this.input = new e.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, e.Component.InWorld = function() {}, e.Component.InWorld.preUpdate = function() {
            if (this.pendingDestroy) return this.destroy(), !1;
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, e.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, e.Component.LifeSpan = function() {}, e.Component.LifeSpan.preUpdate = function() {
            return this.pendingDestroy ? (this.destroy(), !1) : !(this.lifespan > 0 && (this.lifespan -= this.game.time.delta, this.lifespan <= 0)) || (this.kill(), !1)
        }, e.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, e.Component.LoadTexture = function() {}, e.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, i, s) {
                t === e.PENDING_ATLAS ? (t = i, i = 0) : i = i || 0, (s || void 0 === s) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var n = this.game.cache,
                    r = !0,
                    a = this.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR;
                if (e.RenderTexture && t instanceof e.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (e.BitmapData && t instanceof e.BitmapData) this.customRender = !0, this.setTexture(t.texture), r = n.hasFrameData(t.key, e.Cache.BITMAPDATA) ? !this.animations.loadFrameData(n.getFrameData(t.key, e.Cache.BITMAPDATA), i) : !this.animations.loadFrameData(t.frameData, 0);
                else if (e.Video && t instanceof e.Video) {
                    this.customRender = !0;
                    var o = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = o
                } else if (e.Tilemap && t instanceof e.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) a = t.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, this.setTexture(t);
                else {
                    var h = n.getImage(t, !0);
                    this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, r = !this.animations.loadFrameData(h.frameData, i)
                }
                r && (this._frame = e.Rectangle.clone(this.texture.frame)), a || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), t.rotated && (this.texture.rotated = !0), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, e.Component.Overlap = function() {}, e.Component.Overlap.prototype = {
            overlap: function(t) {
                return e.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        }, e.Component.PhysicsBody = function() {}, e.Component.PhysicsBody.preUpdate = function() {
            return this.pendingDestroy ? (this.destroy(), !1) : this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, this.preUpdateChildren(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, e.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, e.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, e.Component.Reset = function() {}, e.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, e.Component.ScaleMinMax = function() {}, e.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, i, s, n) {
                void 0 === i ? i = s = n = t : void 0 === s && (s = n = i, i = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, i) : this.scaleMin = new e.Point(t, i), null === s ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(s, n) : this.scaleMax = new e.Point(s, n), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, e.Component.Smoothed = function() {}, e.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && 0 !== this.texture.baseTexture.scaleMode && (this.texture.baseTexture.scaleMode = 0, this.texture.baseTexture.dirty()) : this.texture && 1 !== this.texture.baseTexture.scaleMode && (this.texture.baseTexture.scaleMode = 1, this.texture.baseTexture.dirty())
                }
            }
        }, e.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, e.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(t, i, s, n, r) {
                var a = this.game.plugins.add(e.Weapon);
                return r && (a.bulletClass = r), a.createBullets(t, i, s, n), a
            },
            image: function(t, i, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new e.Image(this.game, t, i, s, n))
            },
            sprite: function(t, i, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new e.Sprite(this.game, t, i, s, n))
            },
            creature: function(t, i, s, n, r, a, o) {
                void 0 === r && (r = this.world);
                var h = new e.Creature(this.game, t, i, s, n, a, o);
                return r.add(h), h
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(t, i, s, n, r) {
                return new e.Group(this.game, t, i, s, n, r)
            },
            physicsGroup: function(t, i, s, n) {
                return new e.Group(this.game, i, s, n, !0, t)
            },
            spriteBatch: function(t, i, s) {
                return void 0 === t && (t = null), void 0 === i && (i = "group"), void 0 === s && (s = !1), new e.SpriteBatch(this.game, t, i, s)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(t, i, s, n, r, a, o) {
                return void 0 === o && (o = this.world), o.add(new e.TileSprite(this.game, t, i, s, n, r, a))
            },
            rope: function(t, i, s, n, r, a) {
                return void 0 === a && (a = this.world), a.add(new e.Rope(this.game, t, i, s, n, r))
            },
            text: function(t, i, s, n, r) {
                return void 0 === r && (r = this.world), r.add(new e.Text(this.game, t, i, s, n))
            },
            button: function(t, i, s, n, r, a, o, h, l, u) {
                return void 0 === u && (u = this.world), u.add(new e.Button(this.game, t, i, s, n, r, a, o, h, l))
            },
            graphics: function(t, i, s) {
                return void 0 === s && (s = this.world), s.add(new e.Graphics(this.game, t, i))
            },
            emitter: function(t, i, s) {
                return this.game.particles.add(new e.Particles.Arcade.Emitter(this.game, t, i, s))
            },
            retroFont: function(t, i, s, n, r, a, o, h, l) {
                return new e.RetroFont(this.game, t, i, s, n, r, a, o, h, l)
            },
            bitmapText: function(t, i, s, n, r, a) {
                return void 0 === a && (a = this.world), a.add(new e.BitmapText(this.game, t, i, s, n, r))
            },
            tilemap: function(t, i, s, n, r) {
                return new e.Tilemap(this.game, t, i, s, n, r)
            },
            renderTexture: function(t, i, s, n) {
                void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === n && (n = !1);
                var r = new e.RenderTexture(this.game, t, i, s);
                return n && this.game.cache.addRenderTexture(s, r), r
            },
            video: function(t, i) {
                return new e.Video(this.game, t, i)
            },
            bitmapData: function(t, i, s, n) {
                void 0 === n && (n = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                var r = new e.BitmapData(this.game, s, t, i);
                return n && this.game.cache.addBitmapData(s, r), r
            },
            filter: function(t) {
                var i = Array.prototype.slice.call(arguments, 1);
                return (t = new e.Filter[t](this.game)).init.apply(t, i), t
            },
            plugin: function() {
                return this.game.plugins.add.apply(this.game.plugins, arguments)
            }
        }, e.GameObjectFactory.prototype.constructor = e.GameObjectFactory, e.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, e.GameObjectCreator.prototype = {
            image: function(t, i, s, n) {
                return new e.Image(this.game, t, i, s, n)
            },
            sprite: function(t, i, s, n) {
                return new e.Sprite(this.game, t, i, s, n)
            },
            tween: function(t) {
                return new e.Tween(t, this.game, this.game.tweens)
            },
            group: function(t, i, s, n, r) {
                return new e.Group(this.game, t || null, i, s, n, r)
            },
            spriteBatch: function(t, i, s) {
                return void 0 === i && (i = "group"), void 0 === s && (s = !1), new e.SpriteBatch(this.game, t, i, s)
            },
            audio: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, s) {
                return this.game.sound.add(t, e, i, s)
            },
            tileSprite: function(t, i, s, n, r, a) {
                return new e.TileSprite(this.game, t, i, s, n, r, a)
            },
            rope: function(t, i, s, n, r) {
                return new e.Rope(this.game, t, i, s, n, r)
            },
            text: function(t, i, s, n) {
                return new e.Text(this.game, t, i, s, n)
            },
            button: function(t, i, s, n, r, a, o, h, l) {
                return new e.Button(this.game, t, i, s, n, r, a, o, h, l)
            },
            graphics: function(t, i) {
                return new e.Graphics(this.game, t, i)
            },
            emitter: function(t, i, s) {
                return new e.Particles.Arcade.Emitter(this.game, t, i, s)
            },
            retroFont: function(t, i, s, n, r, a, o, h, l) {
                return new e.RetroFont(this.game, t, i, s, n, r, a, o, h, l)
            },
            bitmapText: function(t, i, s, n, r, a) {
                return new e.BitmapText(this.game, t, i, s, n, r, a)
            },
            tilemap: function(t, i, s, n, r) {
                return new e.Tilemap(this.game, t, i, s, n, r)
            },
            renderTexture: function(t, i, s, n) {
                void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === n && (n = !1);
                var r = new e.RenderTexture(this.game, t, i, s);
                return n && this.game.cache.addRenderTexture(s, r), r
            },
            bitmapData: function(t, i, s, n) {
                void 0 === n && (n = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                var r = new e.BitmapData(this.game, s, t, i);
                return n && this.game.cache.addBitmapData(s, r), r
            },
            filter: function(t) {
                var i = Array.prototype.slice.call(arguments, 1);
                return (t = new e.Filter[t](this.game)).init.apply(t, i), t
            }
        }, e.GameObjectCreator.prototype.constructor = e.GameObjectCreator, e.Sprite = function(t, i, s, n, r) {
            i = i || 0, s = s || 0, n = n || null, r = r || null, this.type = e.SPRITE, this.physicsType = e.SPRITE, PIXI.Sprite.call(this, e.Cache.DEFAULT), e.Component.Core.init.call(this, t, i, s, n, r)
        }, e.Sprite.prototype = Object.create(PIXI.Sprite.prototype), e.Sprite.prototype.constructor = e.Sprite, e.Component.Core.install.call(e.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), e.Sprite.prototype.preUpdatePhysics = e.Component.PhysicsBody.preUpdate, e.Sprite.prototype.preUpdateLifeSpan = e.Component.LifeSpan.preUpdate, e.Sprite.prototype.preUpdateInWorld = e.Component.InWorld.preUpdate, e.Sprite.prototype.preUpdateCore = e.Component.Core.preUpdate, e.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, e.Image = function(t, i, s, n, r) {
            i = i || 0, s = s || 0, n = n || null, r = r || null, this.type = e.IMAGE, PIXI.Sprite.call(this, e.Cache.DEFAULT), e.Component.Core.init.call(this, t, i, s, n, r)
        }, e.Image.prototype = Object.create(PIXI.Sprite.prototype), e.Image.prototype.constructor = e.Image, e.Component.Core.install.call(e.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), e.Image.prototype.preUpdateLifeSpan = e.Component.LifeSpan.preUpdate, e.Image.prototype.preUpdateInWorld = e.Component.InWorld.preUpdate, e.Image.prototype.preUpdateCore = e.Component.Core.preUpdate, e.Image.prototype.preUpdate = function() {
            return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
        }, e.Button = function(t, i, s, n, r, a, o, h, l, u) {
            i = i || 0, s = s || 0, n = n || null, r = r || null, a = a || this, e.Image.call(this, t, i, s, n, h), this.type = e.BUTTON, this.physicsType = e.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new e.Signal, this.onInputOut = new e.Signal, this.onInputDown = new e.Signal, this.onInputUp = new e.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = e.PointerMode.CONTACT, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(o, h, l, u), null !== r && this.onInputUp.add(r, a), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this)
        }, e.Button.prototype = Object.create(e.Image.prototype), e.Button.prototype.constructor = e.Button;
        return e.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, e.Button.prototype.setStateFrame = function(t, e, i) {
            var s = "_on" + t + "Frame";
            null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
        }, e.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames) return !1;
            var e = this["_on" + t + "Frame"];
            return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
        }, e.Button.prototype.setFrames = function(t, e, i, s) {
            this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", s, this.input.pointerUp())
        }, e.Button.prototype.setStateSound = function(t, i, s) {
            var n = "on" + t + "Sound",
                r = "on" + t + "SoundMarker";
            i instanceof e.Sound || i instanceof e.AudioSprite ? (this[n] = i, this[r] = "string" == typeof s ? s : "") : (this[n] = null, this[r] = "")
        }, e.Button.prototype.playStateSound = function(t) {
            var e = this["on" + t + "Sound"];
            if (e) {
                var i = this["on" + t + "SoundMarker"];
                return e.play(i), !0
            }
            return !1
        }, e.Button.prototype.setSounds = function(t, e, i, s, n, r, a, o) {
            this.setStateSound("Over", t, e), this.setStateSound("Out", n, r), this.setStateSound("Down", i, s), this.setStateSound("Up", a, o)
        }, e.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound("Over", t, e)
        }, e.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound("Out", t, e)
        }, e.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound("Down", t, e)
        }, e.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound("Up", t, e)
        }, e.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
        }, e.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, e.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, e.Button.prototype.onInputUpHandler = function(t, e, i) {
            this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out")))
        }, e.SpriteBatch = function(t, i, s, n) {
            void 0 !== i && null !== i || (i = t.world), e.Group.call(this, t, i, s, n), this.type = e.SPRITEBATCH, this.fastSpriteBatch = null, this.ready = !1
        }, e.SpriteBatch.prototype = Object.create(e.Group.prototype), e.SpriteBatch.prototype.constructor = e.SpriteBatch, e.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(t.gl), this.ready = !0), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
        }, e.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                    var r = this.children[n];
                    if (r.visible) {
                        var a = r.texture,
                            o = a.frame;
                        if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(a.baseTexture.source, o.x, o.y, o.width, o.height, r.anchor.x * (-o.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-o.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, o.width * r.scale.x, o.height * r.scale.y);
                        else {
                            s || (s = !0), r.displayObjectUpdateTransform();
                            var h = r.worldTransform,
                                l = h.tx * t.resolution + t.shakeX,
                                u = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | u) : e.setTransform(h.a, h.b, h.c, h.d, l, u), e.drawImage(a.baseTexture.source, o.x, o.y, o.width, o.height, r.anchor.x * -o.width + .5 | 0, r.anchor.y * -o.height + .5 | 0, o.width, o.height)
                        }
                    }
                }
            }
        }, e.BitmapData = function(t, i, s, n, r) {
            void 0 !== s && 0 !== s || (s = 256), void 0 !== n && 0 !== n || (n = 256), void 0 === r && (r = !1), this.game = t, this.key = i, this.width = s, this.height = n, this.canvas = e.Canvas.create(this, s, n, null, r), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = t.renderType === e.CANVAS ? t.renderer.renderSession.smoothProperty : e.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, s, n), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas, null, this.game.resolution), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new e.FrameData, this.textureFrame = this.frameData.addFrame(new e.Frame(0, 0, 0, s, n, "bitmapData")), this.texture.frame = this.textureFrame, this.type = e.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new e.Point, this._size = new e.Point, this._scale = new e.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new e.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new e.Circle, this._swapCanvas = void 0
        }, e.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            },
            moveH: function(t, i) {
                void 0 === i && (i = !0), void 0 === this._swapCanvas && (this._swapCanvas = e.CanvasPool.create(this, this.width, this.height));
                var s = this._swapCanvas.getContext("2d"),
                    n = this.height,
                    r = this.canvas;
                if (s.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    a = this.width - t;
                    i && s.drawImage(r, 0, 0, t, n, a, 0, t, n), s.drawImage(r, t, 0, a, n, 0, 0, a, n)
                } else {
                    var a = this.width - t;
                    i && s.drawImage(r, a, 0, t, n, 0, 0, t, n), s.drawImage(r, 0, 0, a, n, t, 0, a, n)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(t, i) {
                void 0 === i && (i = !0), void 0 === this._swapCanvas && (this._swapCanvas = e.CanvasPool.create(this, this.width, this.height));
                var s = this._swapCanvas.getContext("2d"),
                    n = this.width,
                    r = this.canvas;
                if (s.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    a = this.height - t;
                    i && s.drawImage(r, 0, 0, n, t, 0, a, n, t), s.drawImage(r, 0, t, n, a, 0, 0, n, a)
                } else {
                    var a = this.height - t;
                    i && s.drawImage(r, 0, a, n, t, 0, 0, n, t), s.drawImage(r, 0, 0, n, a, 0, t, n, a)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            },
            clear: function(t, e, i, s) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
            },
            fill: function(t, e, i, s) {
                return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            getBase64: function(t, e) {
                return this.canvas.toDataURL(t, e)
            },
            getImage: function(t, e, i, s) {
                var n = new Image;
                return i && (n.onload = i), s && (n.onerror = s), n.src = this.getBase64(t, e), n
            },
            generateTexture: function(t, e, i) {
                var s = this.game.cache,
                    n = new Image;
                if (e && (n.onload = function() {
                        var r = s.addImage(t, "", n),
                            a = new PIXI.Texture(r.base);
                        e.call(i || null, a), n.onload = null
                    }), n.src = this.getBase64(), !e) {
                    var r = s.addImage(t, "", n);
                    return new PIXI.Texture(r.base)
                }
                return null
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            },
            update: function(t, e, i, s) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(t, i, s, n, r, a) {
                void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = this.width), void 0 === a && (a = this.height);
                for (var o = s + r, h = n + a, l = e.Color.createColor(), u = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, c = !1, d = n; d < h; d++)
                    for (var p = s; p < o; p++) e.Color.unpackPixel(this.getPixel32(p, d), l), !1 !== (u = t.call(i, l, p, d)) && null !== u && void 0 !== u && (this.setPixel32(p, d, u.r, u.g, u.b, u.a, !1), c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(t, e, i, s, n, r) {
                void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height);
                for (var a = i + n, o = s + r, h = 0, l = 0, u = !1, c = s; c < o; c++)
                    for (var d = i; d < a; d++) h = this.getPixel32(d, c), (l = t.call(e, h, d, c)) !== h && (this.pixels[c * this.width + d] = l, u = !0);
                return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(t, i, s, n, r, a, o, h, l) {
                var u = 0,
                    c = 0,
                    d = this.width,
                    p = this.height,
                    f = e.Color.packPixel(t, i, s, n);
                void 0 !== l && l instanceof e.Rectangle && (u = l.x, c = l.y, d = l.width, p = l.height);
                for (var m = 0; m < p; m++)
                    for (var g = 0; g < d; g++) this.getPixel32(u + g, c + m) === f && this.setPixel32(u + g, c + m, r, a, o, h, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(t, i, s, n) {
                var r = t || 0 === t,
                    a = i || 0 === i,
                    o = s || 0 === s;
                if (r || a || o) {
                    void 0 === n && (n = new e.Rectangle(0, 0, this.width, this.height));
                    for (var h = e.Color.createColor(), l = n.y; l < n.bottom; l++)
                        for (var u = n.x; u < n.right; u++) e.Color.unpackPixel(this.getPixel32(u, l), h, !0), r && (h.h = t), a && (h.s = i), o && (h.l = s), e.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(u, l, h.r, h.g, h.b, h.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(t, i, s, n) {
                if (void 0 !== t && null !== t || (t = !1), void 0 !== i && null !== i || (i = !1), void 0 !== s && null !== s || (s = !1), t || i || s) {
                    void 0 === n && (n = new e.Rectangle(0, 0, this.width, this.height));
                    for (var r = e.Color.createColor(), a = n.y; a < n.bottom; a++)
                        for (var o = n.x; o < n.right; o++) e.Color.unpackPixel(this.getPixel32(o, a), r, !0), t && (r.h = this.game.math.wrap(r.h + t, 0, 1)), i && (r.s = this.game.math.clamp(r.s + i, 0, 1)), s && (r.l = this.game.math.clamp(r.l + s, 0, 1)), e.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(o, a, r.r, r.g, r.b, r.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(t, i, s, n, r, a, o) {
                return void 0 === o && (o = !0), t >= 0 && t <= this.width && i >= 0 && i <= this.height && (e.Device.LITTLE_ENDIAN ? this.pixels[i * this.width + t] = a << 24 | r << 16 | n << 8 | s : this.pixels[i * this.width + t] = s << 24 | n << 16 | r << 8 | a, o && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(t, e, i, s, n, r) {
                return this.setPixel32(t, e, i, s, n, 255, r)
            },
            getPixel: function(t, i, s) {
                s || (s = e.Color.createColor());
                var n = ~~(t + i * this.width);
                return n *= 4, s.r = this.data[n], s.g = this.data[++n], s.b = this.data[++n], s.a = this.data[++n], s
            },
            getPixel32: function(t, e) {
                if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(t, i, s, n, r) {
                return e.Color.unpackPixel(this.getPixel32(t, i), s, n, r)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var i = e.Color.createColor(),
                    s = 0,
                    n = 0,
                    r = 1,
                    a = !1;
                1 === t ? (r = -1, n = this.height) : 3 === t && (r = -1, s = this.width);
                do {
                    e.Color.unpackPixel(this.getPixel32(s, n), i), 0 === t || 1 === t ? ++s === this.width && (s = 0, ((n += r) >= this.height || n <= 0) && (a = !0)) : 2 !== t && 3 !== t || ++n === this.height && (n = 0, ((s += r) >= this.width || s <= 0) && (a = !0))
                } while (0 === i.a && !a);
                return i.x = s, i.y = n, i
            },
            getBounds: function(t) {
                return void 0 === t && (t = new e.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
            },
            addToWorld: function(t, e, i, s, n, r) {
                n = n || 1, r = r || 1;
                var a = this.game.add.image(t, e, this);
                return a.anchor.set(i, s), a.scale.set(n, r), a
            },
            copy: function(t, i, s, n, r, a, o, h, l, u, c, d, p, f, m, g, v) {
                if (void 0 !== t && null !== t || (t = this), t instanceof e.RenderTexture && (t = t.getCanvas()), this._image = t, t instanceof e.Sprite || t instanceof e.Image || t instanceof e.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof e.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== a && null !== a || (a = t.x), void 0 !== o && null !== o || (o = t.y), t.texture.trim && (a += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof e.BitmapData) this._image = t.canvas;
                    else if ("string" == typeof t) {
                        if (null === (t = this.game.cache.getImage(t))) return this;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (void 0 !== i && null !== i || (i = 0), void 0 !== s && null !== s || (s = 0), n && (this._size.x = n), r && (this._size.y = r), void 0 !== a && null !== a || (a = i), void 0 !== o && null !== o || (o = s), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof u && (this._rotate = u), "number" == typeof c && (this._anchor.x = c), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof m && (this._alpha.current = m), void 0 === g && (g = null), void 0 === v && (v = !1), this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y) return this;
                var y = this.context;
                return this._alpha.prev = y.globalAlpha, y.save(), y.globalAlpha = this._alpha.current, g && (this.op = g), v && (a |= 0, o |= 0), y.translate(a, o), y.scale(this._scale.x, this._scale.y), y.rotate(this._rotate), y.drawImage(this._image, this._pos.x + i, this._pos.y + s, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), y.restore(), y.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyTransform: function(t, i, s) {
                if (void 0 === i && (i = null), void 0 === s && (s = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                var n = t.worldTransform;
                if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === n.a || 0 === n.d || 0 === this._size.x || 0 === this._size.y) return this;
                t.texture instanceof e.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var r = n.tx,
                    a = n.ty;
                t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), s && (r |= 0, a |= 0);
                var o = this.context;
                return this._alpha.prev = o.globalAlpha, o.save(), o.globalAlpha = this._alpha.current, i && (this.op = i), o[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, o.setTransform(n.a, n.b, n.c, n.d, r, a), o.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), o.restore(), o.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(t, e, i, s, n, r, a) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, r, a)
            },
            draw: function(t, e, i, s, n, r, a) {
                return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, r, a)
            },
            drawGroup: function(t, e, i) {
                return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
            },
            drawGroupProxy: function(t, i, s) {
                if (t.hasOwnProperty("texture") && this.copyTransform(t, i, s), t.type === e.GROUP && t.exists) this.drawGroup(t, i, s);
                else if (t.hasOwnProperty("children") && t.children.length > 0)
                    for (var n = 0; n < t.children.length; n++) t.children[n].exists && this.copyTransform(t.children[n], i, s)
            },
            drawFull: function(t, i, s) {
                if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                if (t.type !== e.GROUP && t.type !== e.EMITTER && t.type !== e.BITMAPTEXT)
                    if (t.type === e.GRAPHICS) {
                        var n = t.getBounds();
                        this.ctx.save(), this.ctx.translate(n.x, n.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                    } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, i, s);
                if (t.children)
                    for (var r = 0; r < t.children.length; r++) this.drawFull(t.children[r], i, s);
                return this
            },
            shadow: function(t, e, i, s) {
                var n = this.context;
                return void 0 === t || null === t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = 0 === e ? 0 : e || 5, n.shadowOffsetX = 0 === i ? 0 : i || 10, n.shadowOffsetY = 0 === s ? 0 : s || 10), this
            },
            alphaMask: function(t, e, i, s) {
                return void 0 === s || null === s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            },
            extract: function(t, e, i, s, n, r, a, o, h) {
                return void 0 === n && (n = 255), void 0 === r && (r = !1), void 0 === a && (a = e), void 0 === o && (o = i), void 0 === h && (h = s), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, l, u) {
                    return r.r === e && r.g === i && r.b === s && t.setPixel32(l, u, a, o, h, n, !1), !1
                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
            },
            rect: function(t, e, i, s, n) {
                return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s), this
            },
            text: function(t, e, i, s, n, r) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === r && (r = !0);
                var a = this.context,
                    o = a.font;
                return a.font = s, r && (a.fillStyle = "rgb(0,0,0)", a.fillText(t, e + 1, i + 1)), a.fillStyle = n, a.fillText(t, e, i), a.font = o, this
            },
            circle: function(t, e, i, s) {
                var n = this.context;
                return void 0 !== s && (n.fillStyle = s), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this
            },
            line: function(t, e, i, s, n, r) {
                void 0 === n && (n = "#fff"), void 0 === r && (r = 1);
                var a = this.context;
                return a.beginPath(), a.moveTo(t, e), a.lineTo(i, s), a.lineWidth = r, a.strokeStyle = n, a.stroke(), a.closePath(), this
            },
            polygon: function(t, e, i, s) {
                void 0 === s && (s = "#fff"), void 0 === i && (i = 0);
                var n = this.context;
                e && (n.fillStyle = e), i && (n.lineWidth = i, n.strokeStyle = s), n.beginPath(), n.moveTo(t[0].x, t[0].y);
                for (var r = 1, a = t.length; r < a; r++) {
                    var o = t[r];
                    n.lineTo(o.x, o.y)
                }
                return n.closePath(), e && n.fill(), i && n.stroke(), this
            },
            textureLine: function(t, i, s) {
                if (void 0 === s && (s = "repeat-x"), "string" != typeof i || (i = this.game.cache.getImage(i))) {
                    var n = t.length;
                    "no-repeat" === s && n > i.width && (n = i.width);
                    var r = this.context;
                    return r.fillStyle = r.createPattern(i, s), this._circle = new e.Circle(t.start.x, t.start.y, i.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), r.save(), r.translate(this._pos.x, this._pos.y), r.rotate(t.angle), r.fillRect(0, 0, n, i.height), r.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), e.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            },
            copyBitmapData: function(t, e, i) {
                t.update();
                for (var s, n = 0; n < t.height; n++) {
                    s = (i + n) * this.width + e;
                    for (var r = 0; r < t.width; r++) this.pixels[s + r] = t.pixels[n * t.width + r]
                }
                return this
            }
        }, Object.defineProperty(e.BitmapData.prototype, "smoothed", {
            get: function() {
                return e.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(t) {
                e.Canvas.setSmoothingEnabled(this.context, t)
            }
        }), Object.defineProperty(e.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), e.BitmapData.getTransform = function(t, e, i, s, n, r) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof n && (n = 0), "number" != typeof r && (r = 0), {
                sx: i,
                sy: s,
                scaleX: i,
                scaleY: s,
                skewX: n,
                skewY: r,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, e.BitmapData.prototype.constructor = e.BitmapData, e.EarCut = {}, e.EarCut.Triangulate = function(t, i, s) {
            s = s || 2;
            var n = i && i.length,
                r = n ? i[0] * s : t.length,
                a = e.EarCut.linkedList(t, 0, r, s, !0),
                o = [];
            if (!a) return o;
            var h, l, u, c, d, p, f;
            if (n && (a = e.EarCut.eliminateHoles(t, i, a, s)), t.length > 80 * s) {
                h = u = t[0], l = c = t[1];
                for (var m = s; m < r; m += s) d = t[m], p = t[m + 1], d < h && (h = d), p < l && (l = p), d > u && (u = d), p > c && (c = p);
                f = Math.max(u - h, c - l)
            }
            return e.EarCut.earcutLinked(a, o, s, h, l, f), o
        }, e.EarCut.linkedList = function(t, i, s, n, r) {
            var a, o, h, l = 0;
            for (a = i, o = s - n; a < s; a += n) l += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
            if (r === l > 0)
                for (a = i; a < s; a += n) h = e.EarCut.insertNode(a, t[a], t[a + 1], h);
            else
                for (a = s - n; a >= i; a -= n) h = e.EarCut.insertNode(a, t[a], t[a + 1], h);
            return h
        }, e.EarCut.filterPoints = function(t, i) {
            if (!t) return t;
            i || (i = t);
            var s, n = t;
            do {
                if (s = !1, n.steiner || !e.EarCut.equals(n, n.next) && 0 !== e.EarCut.area(n.prev, n, n.next)) n = n.next;
                else {
                    if (e.EarCut.removeNode(n), (n = i = n.prev) === n.next) return null;
                    s = !0
                }
            } while (s || n !== i);
            return i
        }, e.EarCut.earcutLinked = function(t, i, s, n, r, a, o) {
            if (t) {
                !o && a && e.EarCut.indexCurve(t, n, r, a);
                for (var h, l, u = t; t.prev !== t.next;)
                    if (h = t.prev, l = t.next, a ? e.EarCut.isEarHashed(t, n, r, a) : e.EarCut.isEar(t)) i.push(h.i / s), i.push(t.i / s), i.push(l.i / s), e.EarCut.removeNode(t), t = l.next, u = l.next;
                    else if ((t = l) === u) {
                    o ? 1 === o ? (t = e.EarCut.cureLocalIntersections(t, i, s), e.EarCut.earcutLinked(t, i, s, n, r, a, 2)) : 2 === o && e.EarCut.splitEarcut(t, i, s, n, r, a) : e.EarCut.earcutLinked(e.EarCut.filterPoints(t), i, s, n, r, a, 1);
                    break
                }
            }
        }, e.EarCut.isEar = function(t) {
            var i = t.prev,
                s = t,
                n = t.next;
            if (e.EarCut.area(i, s, n) >= 0) return !1;
            for (var r = t.next.next; r !== t.prev;) {
                if (e.EarCut.pointInTriangle(i.x, i.y, s.x, s.y, n.x, n.y, r.x, r.y) && e.EarCut.area(r.prev, r, r.next) >= 0) return !1;
                r = r.next
            }
            return !0
        }, e.EarCut.isEarHashed = function(t, i, s, n) {
            var r = t.prev,
                a = t,
                o = t.next;
            if (e.EarCut.area(r, a, o) >= 0) return !1;
            for (var h = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, l = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, u = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, c = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, d = e.EarCut.zOrder(h, l, i, s, n), p = e.EarCut.zOrder(u, c, i, s, n), f = t.nextZ; f && f.z <= p;) {
                if (f !== t.prev && f !== t.next && e.EarCut.pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) && e.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                f = f.nextZ
            }
            for (f = t.prevZ; f && f.z >= d;) {
                if (f !== t.prev && f !== t.next && e.EarCut.pointInTriangle(r.x, r.y, a.x, a.y, o.x, o.y, f.x, f.y) && e.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                f = f.prevZ
            }
            return !0
        }, e.EarCut.cureLocalIntersections = function(t, i, s) {
            var n = t;
            do {
                var r = n.prev,
                    a = n.next.next;
                e.EarCut.intersects(r, n, n.next, a) && e.EarCut.locallyInside(r, a) && e.EarCut.locallyInside(a, r) && (i.push(r.i / s), i.push(n.i / s), i.push(a.i / s), e.EarCut.removeNode(n), e.EarCut.removeNode(n.next), n = t = a), n = n.next
            } while (n !== t);
            return n
        }, e.EarCut.splitEarcut = function(t, i, s, n, r, a) {
            var o = t;
            do {
                for (var h = o.next.next; h !== o.prev;) {
                    if (o.i !== h.i && e.EarCut.isValidDiagonal(o, h)) {
                        var l = e.EarCut.splitPolygon(o, h);
                        return o = e.EarCut.filterPoints(o, o.next), l = e.EarCut.filterPoints(l, l.next), e.EarCut.earcutLinked(o, i, s, n, r, a), void e.EarCut.earcutLinked(l, i, s, n, r, a)
                    }
                    h = h.next
                }
                o = o.next
            } while (o !== t)
        }, e.EarCut.eliminateHoles = function(t, i, s, n) {
            var r, a, o, h, l, u = [];
            for (r = 0, a = i.length; r < a; r++) o = i[r] * n, h = r < a - 1 ? i[r + 1] * n : t.length, (l = e.EarCut.linkedList(t, o, h, n, !1)) === l.next && (l.steiner = !0), u.push(e.EarCut.getLeftmost(l));
            for (u.sort(e.EarCut.compareX), r = 0; r < u.length; r++) e.EarCut.eliminateHole(u[r], s), s = e.EarCut.filterPoints(s, s.next);
            return s
        }, e.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, e.EarCut.eliminateHole = function(t, i) {
            if (i = e.EarCut.findHoleBridge(t, i)) {
                var s = e.EarCut.splitPolygon(i, t);
                e.EarCut.filterPoints(s, s.next)
            }
        }, e.EarCut.findHoleBridge = function(t, i) {
            var s, n = i,
                r = t.x,
                a = t.y,
                o = -1 / 0;
            do {
                if (a <= n.y && a >= n.next.y) {
                    var h = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    h <= r && h > o && (o = h, s = n.x < n.next.x ? n : n.next)
                }
                n = n.next
            } while (n !== i);
            if (!s) return null;
            if (t.x === s.x) return s.prev;
            var l, u = s,
                c = 1 / 0;
            for (n = s.next; n !== u;) r >= n.x && n.x >= s.x && e.EarCut.pointInTriangle(a < s.y ? r : o, a, s.x, s.y, a < s.y ? o : r, a, n.x, n.y) && ((l = Math.abs(a - n.y) / (r - n.x)) < c || l === c && n.x > s.x) && e.EarCut.locallyInside(n, t) && (s = n, c = l), n = n.next;
            return s
        }, e.EarCut.indexCurve = function(t, i, s, n) {
            var r = t;
            do {
                null === r.z && (r.z = e.EarCut.zOrder(r.x, r.y, i, s, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
            } while (r !== t);
            r.prevZ.nextZ = null, r.prevZ = null, e.EarCut.sortLinked(r)
        }, e.EarCut.sortLinked = function(t) {
            var e, i, s, n, r, a, o, h, l = 1;
            do {
                for (i = t, t = null, r = null, a = 0; i;) {
                    for (a++, s = i, o = 0, e = 0; e < l && (o++, s = s.nextZ); e++);
                    for (h = l; o > 0 || h > 0 && s;) 0 === o ? (n = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (n = i, i = i.nextZ, o--) : (n = s, s = s.nextZ, h--) : (n = i, i = i.nextZ, o--), r ? r.nextZ = n : t = n, n.prevZ = r, r = n;
                    i = s
                }
                r.nextZ = null, l *= 2
            } while (a > 1);
            return t
        }, e.EarCut.zOrder = function(t, e, i, s, n) {
            return t = 32767 * (t - i) / n, e = 32767 * (e - s) / n, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
        }, e.EarCut.getLeftmost = function(t) {
            var e = t,
                i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }, e.EarCut.pointInTriangle = function(t, e, i, s, n, r, a, o) {
            return (n - a) * (e - o) - (t - a) * (r - o) >= 0 && (t - a) * (s - o) - (i - a) * (e - o) >= 0 && (i - a) * (r - o) - (n - a) * (s - o) >= 0
        }, e.EarCut.isValidDiagonal = function(t, i) {
            return e.EarCut.equals(t, i) || t.next.i !== i.i && t.prev.i !== i.i && !e.EarCut.intersectsPolygon(t, i) && e.EarCut.locallyInside(t, i) && e.EarCut.locallyInside(i, t) && e.EarCut.middleInside(t, i)
        }, e.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, e.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, e.EarCut.intersects = function(t, i, s, n) {
            return e.EarCut.area(t, i, s) > 0 != e.EarCut.area(t, i, n) > 0 && e.EarCut.area(s, n, t) > 0 != e.EarCut.area(s, n, i) > 0
        }, e.EarCut.intersectsPolygon = function(t, i) {
            var s = t;
            do {
                if (s.i !== t.i && s.next.i !== t.i && s.i !== i.i && s.next.i !== i.i && e.EarCut.intersects(s, s.next, t, i)) return !0;
                s = s.next
            } while (s !== t);
            return !1
        }, e.EarCut.locallyInside = function(t, i) {
            return e.EarCut.area(t.prev, t, t.next) < 0 ? e.EarCut.area(t, i, t.next) >= 0 && e.EarCut.area(t, t.prev, i) >= 0 : e.EarCut.area(t, i, t.prev) < 0 || e.EarCut.area(t, t.next, i) < 0
        }, e.EarCut.middleInside = function(t, e) {
            var i = t,
                s = !1,
                n = (t.x + e.x) / 2,
                r = (t.y + e.y) / 2;
            do {
                i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
            } while (i !== t);
            return s
        }, e.EarCut.splitPolygon = function(t, i) {
            var s = new e.EarCut.Node(t.i, t.x, t.y),
                n = new e.EarCut.Node(i.i, i.x, i.y),
                r = t.next,
                a = i.prev;
            return t.next = i, i.prev = t, s.next = r, r.prev = s, n.next = s, s.prev = n, a.next = n, n.prev = a, n
        }, e.EarCut.insertNode = function(t, i, s, n) {
            var r = new e.EarCut.Node(t, i, s);
            return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
        }, e.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, e.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, i) {
            var s, n = i.gl,
                r = i.projection,
                a = i.offset,
                o = i.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, n);
            var h = t._webGL[n.id];
            if (h)
                for (var l = 0; l < h.data.length; l++) 1 === h.data[l].mode ? (s = h.data[l], i.stencilManager.pushStencil(t, s, i), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (s.indices.length - 4)), i.stencilManager.popStencil(t, s, i)) : (s = h.data[l], i.shaderManager.setShader(o), o = i.shaderManager.primitiveShader, n.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(o.flipY, 1), n.uniform2f(o.projectionVector, r.x, -r.y), n.uniform2f(o.offsetVector, -a.x, -a.y), n.uniform3fv(o.tintColor, e.Color.hexToRGBArray(t.tint)), n.uniform1f(o.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, s.buffer), n.vertexAttribPointer(o.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(o.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, s.indexBuffer), n.drawElements(n.TRIANGLE_STRIP, s.indices.length, n.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(t, i) {
            var s = t._webGL[i.id];
            s || (s = t._webGL[i.id] = {
                lastIndex: 0,
                data: [],
                gl: i
            }), t.dirty = !1;
            var n;
            if (t.clearDirty) {
                for (t.clearDirty = !1, n = 0; n < s.data.length; n++) {
                    var r = s.data[n];
                    r.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(r)
                }
                s.data = [], s.lastIndex = 0
            }
            var a;
            for (n = s.lastIndex; n < t.graphicsData.length; n++) {
                var o = t.graphicsData[n];
                o.type === e.POLYGON ? (o.points = o.shape.points.slice(), o.shape.closed && (o.points[0] === o.points[o.points.length - 2] && o.points[1] === o.points[o.points.length - 1] || o.points.push(o.points[0], o.points[1])), o.fill && o.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (o.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (a = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildPoly(o, a) || (a = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(o, a))) : (a = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(o, a))), o.lineWidth > 0 && (a = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildLine(o, a))) : (a = PIXI.WebGLGraphics.switchMode(s, 0), o.type === e.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(o, a) : o.type === e.CIRCLE || o.type === e.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(o, a) : o.type === e.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(o, a)), s.lastIndex++
            }
            for (n = 0; n < s.data.length; n++)(a = s.data[n]).dirty && a.upload()
        }, PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length ? (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)) : ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
        }, PIXI.WebGLGraphics.buildRectangle = function(t, i) {
            var s = t.shape,
                n = s.x,
                r = s.y,
                a = s.width,
                o = s.height;
            if (t.fill) {
                var h = e.Color.hexToRGBArray(t.fillColor),
                    l = t.fillAlpha,
                    u = h[0] * l,
                    c = h[1] * l,
                    d = h[2] * l,
                    p = i.points,
                    f = i.indices,
                    m = p.length / 6;
                p.push(n, r), p.push(u, c, d, l), p.push(n + a, r), p.push(u, c, d, l), p.push(n, r + o), p.push(u, c, d, l), p.push(n + a, r + o), p.push(u, c, d, l), f.push(m, m, m + 1, m + 2, m + 3, m + 3)
            }
            if (t.lineWidth) {
                var g = t.points;
                t.points = [n, r, n + a, r, n + a, r + o, n, r + o, n, r], PIXI.WebGLGraphics.buildLine(t, i), t.points = g
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, i) {
            var s = t.shape,
                n = s.x,
                r = s.y,
                a = s.width,
                o = s.height,
                h = s.radius,
                l = [];
            if (l.push(n, r + h), l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n, r + o - h, n, r + o, n + h, r + o)), l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + a - h, r + o, n + a, r + o, n + a, r + o - h)), l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + a, r + h, n + a, r, n + a - h, r)), l = l.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + h, r, n, r, n, r + h)), t.fill) {
                var u = e.Color.hexToRGBArray(t.fillColor),
                    c = t.fillAlpha,
                    d = u[0] * c,
                    p = u[1] * c,
                    f = u[2] * c,
                    m = i.points,
                    g = i.indices,
                    v = m.length / 6,
                    y = e.EarCut.Triangulate(l, null, 2),
                    _ = 0;
                for (_ = 0; _ < y.length; _ += 3) g.push(y[_] + v), g.push(y[_] + v), g.push(y[_ + 1] + v), g.push(y[_ + 2] + v), g.push(y[_ + 2] + v);
                for (_ = 0; _ < l.length; _++) m.push(l[_], l[++_], d, p, f, c)
            }
            if (t.lineWidth) {
                var x = t.points;
                t.points = l, PIXI.WebGLGraphics.buildLine(t, i), t.points = x
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
            function a(t, e, i) {
                return t + (e - t) * i
            }
            for (var o, h, l, u, c, d, p = [], f = 0, m = 0; m <= 20; m++) o = a(t, i, f = m / 20), h = a(e, s, f), l = a(i, n, f), u = a(s, r, f), c = a(o, l, f), d = a(h, u, f), p.push(c, d);
            return p
        }, PIXI.WebGLGraphics.buildCircle = function(t, i) {
            var s, n, r = t.shape,
                a = r.x,
                o = r.y;
            t.type === e.CIRCLE ? (s = r.radius, n = r.radius) : (s = r.width, n = r.height);
            var h = 2 * Math.PI / 40,
                l = 0;
            if (t.fill) {
                var u = e.Color.hexToRGBArray(t.fillColor),
                    c = t.fillAlpha,
                    d = u[0] * c,
                    p = u[1] * c,
                    f = u[2] * c,
                    m = i.points,
                    g = i.indices,
                    v = m.length / 6;
                for (g.push(v), l = 0; l < 41; l++) m.push(a, o, d, p, f, c), m.push(a + Math.sin(h * l) * s, o + Math.cos(h * l) * n, d, p, f, c), g.push(v++, v++);
                g.push(v - 1)
            }
            if (t.lineWidth) {
                var y = t.points;
                for (t.points = [], l = 0; l < 41; l++) t.points.push(a + Math.sin(h * l) * s, o + Math.cos(h * l) * n);
                PIXI.WebGLGraphics.buildLine(t, i), t.points = y
            }
        }, PIXI.WebGLGraphics.buildLine = function(t, i) {
            var s = 0,
                n = t.points;
            if (0 !== n.length) {
                if (t.lineWidth % 2)
                    for (s = 0; s < n.length; s++) n[s] += .5;
                var r = new PIXI.Point(n[0], n[1]),
                    a = new PIXI.Point(n[n.length - 2], n[n.length - 1]);
                if (r.x === a.x && r.y === a.y) {
                    (n = n.slice()).pop(), n.pop();
                    var o = (a = new PIXI.Point(n[n.length - 2], n[n.length - 1])).x + .5 * (r.x - a.x),
                        h = a.y + .5 * (r.y - a.y);
                    n.unshift(o, h), n.push(o, h)
                }
                var l, u, c, d, p, f, m, g, v, y, _, x, b, T, S, w, M, C, P, E, A, I, R = i.points,
                    D = i.indices,
                    O = n.length / 2,
                    F = n.length,
                    L = R.length / 6,
                    k = t.lineWidth / 2,
                    B = e.Color.hexToRGBArray(t.lineColor),
                    U = t.lineAlpha,
                    G = B[0] * U,
                    N = B[1] * U,
                    W = B[2] * U;
                for (c = n[0], d = n[1], p = n[2], v = -(d - (f = n[3])), y = c - p, v /= I = Math.sqrt(v * v + y * y), y /= I, v *= k, y *= k, R.push(c - v, d - y, G, N, W, U), R.push(c + v, d + y, G, N, W, U), s = 1; s < O - 1; s++) c = n[2 * (s - 1)], d = n[2 * (s - 1) + 1], p = n[2 * s], f = n[2 * s + 1], m = n[2 * (s + 1)], g = n[2 * (s + 1) + 1], v = -(d - f), y = c - p, v /= I = Math.sqrt(v * v + y * y), y /= I, v *= k, y *= k, _ = -(f - g), x = p - m, _ /= I = Math.sqrt(_ * _ + x * x), x /= I, M = (-v + c) * (-y + f) - (-v + p) * (-y + d), E = (-(_ *= k) + m) * (-(x *= k) + f) - (-_ + p) * (-x + g), A = (S = -y + d - (-y + f)) * (P = -_ + p - (-_ + m)) - (C = -x + g - (-x + f)) * (w = -v + p - (-v + c)), Math.abs(A) < .1 ? (A += 10.1, R.push(p - v, f - y, G, N, W, U), R.push(p + v, f + y, G, N, W, U)) : ((l = (w * E - P * M) / A) - p) * (l - p) + ((u = (C * M - S * E) / A) - f) + (u - f) > 19600 ? (b = v - _, T = y - x, b /= I = Math.sqrt(b * b + T * T), T /= I, b *= k, T *= k, R.push(p - b, f - T), R.push(G, N, W, U), R.push(p + b, f + T), R.push(G, N, W, U), R.push(p - b, f - T), R.push(G, N, W, U), F++) : (R.push(l, u), R.push(G, N, W, U), R.push(p - (l - p), f - (u - f)), R.push(G, N, W, U));
                for (c = n[2 * (O - 2)], d = n[2 * (O - 2) + 1], p = n[2 * (O - 1)], v = -(d - (f = n[2 * (O - 1) + 1])), y = c - p, v /= I = Math.sqrt(v * v + y * y), y /= I, v *= k, y *= k, R.push(p - v, f - y), R.push(G, N, W, U), R.push(p + v, f + y), R.push(G, N, W, U), D.push(L), s = 0; s < F; s++) D.push(L++);
                D.push(L - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(t, i) {
            var s = t.points.slice();
            if (!(s.length < 6)) {
                var n = i.indices;
                i.points = s, i.alpha = t.fillAlpha, i.color = e.Color.hexToRGBArray(t.fillColor);
                for (var r, a, o = 1 / 0, h = -1 / 0, l = 1 / 0, u = -1 / 0, c = 0; c < s.length; c += 2) r = s[c], a = s[c + 1], o = r < o ? r : o, h = r > h ? r : h, l = a < l ? a : l, u = a > u ? a : u;
                s.push(o, l, h, l, h, u, o, u);
                var d = s.length / 2;
                for (c = 0; c < d; c++) n.push(c)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(t, i) {
            var s = t.points;
            if (!(s.length < 6)) {
                var n = i.points,
                    r = i.indices,
                    a = s.length / 2,
                    o = e.Color.hexToRGBArray(t.fillColor),
                    h = t.fillAlpha,
                    l = o[0] * h,
                    u = o[1] * h,
                    c = o[2] * h,
                    d = e.EarCut.Triangulate(s, null, 2);
                if (!d) return !1;
                var p = n.length / 6,
                    f = 0;
                for (f = 0; f < d.length; f += 3) r.push(d[f] + p), r.push(d[f] + p), r.push(d[f + 1] + p), r.push(d[f + 2] + p), r.push(d[f + 2] + p);
                for (f = 0; f < a; f++) n.push(s[2 * f], s[2 * f + 1], l, u, c, h);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
            this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, i) {
            var s = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
            for (var n = 0; n < t.graphicsData.length; n++) {
                var r = t.graphicsData[n],
                    a = r.shape,
                    o = r._fillTint,
                    h = r._lineTint;
                if (i.lineWidth = r.lineWidth, r.type === e.POLYGON) {
                    i.beginPath();
                    var l = a.points;
                    i.moveTo(l[0], l[1]);
                    for (var u = 1; u < l.length / 2; u++) i.lineTo(l[2 * u], l[2 * u + 1]);
                    a.closed && i.lineTo(l[0], l[1]), l[0] === l[l.length - 2] && l[1] === l[l.length - 1] && i.closePath(), r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke())
                } else if (r.type === e.RECTANGLE)(r.fillColor || 0 === r.fillColor) && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), i.fillRect(a.x, a.y, a.width, a.height)), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.strokeRect(a.x, a.y, a.width, a.height));
                else if (r.type === e.CIRCLE) i.beginPath(), i.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), i.closePath(), r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke());
                else if (r.type === e.ELLIPSE) {
                    var c = 2 * a.width,
                        d = 2 * a.height,
                        p = a.x - c / 2,
                        f = a.y - d / 2;
                    i.beginPath();
                    var m = c / 2 * .5522848,
                        g = d / 2 * .5522848,
                        v = p + c,
                        y = f + d,
                        _ = p + c / 2,
                        x = f + d / 2;
                    i.moveTo(p, x), i.bezierCurveTo(p, x - g, _ - m, f, _, f), i.bezierCurveTo(_ + m, f, v, x - g, v, x), i.bezierCurveTo(v, x + g, _ + m, y, _, y), i.bezierCurveTo(_ - m, y, p, x + g, p, x), i.closePath(), r.fill && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke())
                } else if (r.type === e.ROUNDEDRECTANGLE) {
                    var b = a.x,
                        T = a.y,
                        S = a.width,
                        w = a.height,
                        M = a.radius,
                        C = Math.min(S, w) / 2 | 0;
                    M = M > C ? C : M, i.beginPath(), i.moveTo(b, T + M), i.lineTo(b, T + w - M), i.quadraticCurveTo(b, T + w, b + M, T + w), i.lineTo(b + S - M, T + w), i.quadraticCurveTo(b + S, T + w, b + S, T + w - M), i.lineTo(b + S, T + M), i.quadraticCurveTo(b + S, T, b + S - M, T), i.lineTo(b + M, T), i.quadraticCurveTo(b, T, b, T + M), i.closePath(), (r.fillColor || 0 === r.fillColor) && (i.globalAlpha = r.fillAlpha * s, i.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), i.fill()), r.lineWidth && (i.globalAlpha = r.lineAlpha * s, i.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), i.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, i) {
            var s = t.graphicsData.length;
            if (0 !== s) {
                i.beginPath();
                for (var n = 0; n < s; n++) {
                    var r = t.graphicsData[n],
                        a = r.shape;
                    if (r.type === e.POLYGON) {
                        var o = a.points;
                        i.moveTo(o[0], o[1]);
                        for (var h = 1; h < o.length / 2; h++) i.lineTo(o[2 * h], o[2 * h + 1]);
                        o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && i.closePath()
                    } else if (r.type === e.RECTANGLE) i.rect(a.x, a.y, a.width, a.height), i.closePath();
                    else if (r.type === e.CIRCLE) i.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), i.closePath();
                    else if (r.type === e.ELLIPSE) {
                        var l = 2 * a.width,
                            u = 2 * a.height,
                            c = a.x - l / 2,
                            d = a.y - u / 2,
                            p = l / 2 * .5522848,
                            f = u / 2 * .5522848,
                            m = c + l,
                            g = d + u,
                            v = c + l / 2,
                            y = d + u / 2;
                        i.moveTo(c, y), i.bezierCurveTo(c, y - f, v - p, d, v, d), i.bezierCurveTo(v + p, d, m, y - f, m, y), i.bezierCurveTo(m, y + f, v + p, g, v, g), i.bezierCurveTo(v - p, g, c, y + f, c, y), i.closePath()
                    } else if (r.type === e.ROUNDEDRECTANGLE) {
                        var _ = a.x,
                            x = a.y,
                            b = a.width,
                            T = a.height,
                            S = a.radius,
                            w = Math.min(b, T) / 2 | 0;
                        S = S > w ? w : S, i.moveTo(_, x + S), i.lineTo(_, x + T - S), i.quadraticCurveTo(_, x + T, _ + S, x + T), i.lineTo(_ + b - S, x + T), i.quadraticCurveTo(_ + b, x + T, _ + b, x + T - S), i.lineTo(_ + b, x + S), i.quadraticCurveTo(_ + b, x, _ + b - S, x), i.lineTo(_ + S, x), i.quadraticCurveTo(_, x, _, x + S), i.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                    var r = t.graphicsData[n],
                        a = 0 | r.fillColor,
                        o = 0 | r.lineColor;
                    r._fillTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255, r._lineTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255
                }
        }, e.GraphicsData = function(t, e, i, s, n, r, a) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = r, this.shape = a, this.type = a.type
        }, e.GraphicsData.prototype.constructor = e.GraphicsData, e.GraphicsData.prototype.clone = function() {
            return new e.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, e.Graphics = function(t, i, s) {
            void 0 === i && (i = 0), void 0 === s && (s = 0), this.type = e.GRAPHICS, this.physicsType = e.SPRITE, this.anchor = new e.Point, PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new e.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1, e.Component.Core.init.call(this, t, i, s, "", null)
        }, e.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), e.Graphics.prototype.constructor = e.Graphics, e.Component.Core.install.call(e.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), e.Graphics.prototype.preUpdatePhysics = e.Component.PhysicsBody.preUpdate, e.Graphics.prototype.preUpdateLifeSpan = e.Component.LifeSpan.preUpdate, e.Graphics.prototype.preUpdateInWorld = e.Component.InWorld.preUpdate, e.Graphics.prototype.preUpdateCore = e.Component.Core.preUpdate, e.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, e.Graphics.prototype.postUpdate = function() {
            e.Component.PhysicsBody.postUpdate.call(this), e.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, e.Graphics.prototype.destroy = function(t) {
            this.clear(), e.Component.Destroy.prototype.destroy.call(this, t)
        }, e.Graphics.prototype.drawTriangle = function(t, i) {
            void 0 === i && (i = !1);
            var s = new e.Polygon(t);
            if (i) {
                var n = new e.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    r = new e.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    a = new e.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(r);
                n.dot(a) > 0 && this.drawPolygon(s)
            } else this.drawPolygon(s)
        }, e.Graphics.prototype.drawTriangles = function(t, i, s) {
            void 0 === s && (s = !1);
            var n, r = new e.Point,
                a = new e.Point,
                o = new e.Point,
                h = [];
            if (i)
                if (t[0] instanceof e.Point)
                    for (n = 0; n < i.length / 3; n++) h.push(t[i[3 * n]]), h.push(t[i[3 * n + 1]]), h.push(t[i[3 * n + 2]]), 3 === h.length && (this.drawTriangle(h, s), h = []);
                else
                    for (n = 0; n < i.length; n++) r.x = t[2 * i[n]], r.y = t[2 * i[n] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, s), h = []);
            else if (t[0] instanceof e.Point)
                for (n = 0; n < t.length / 3; n++) this.drawTriangle([t[3 * n], t[3 * n + 1], t[3 * n + 2]], s);
            else
                for (n = 0; n < t.length / 6; n++) r.x = t[6 * n + 0], r.y = t[6 * n + 1], a.x = t[6 * n + 2], a.y = t[6 * n + 3], o.x = t[6 * n + 4], o.y = t[6 * n + 5], this.drawTriangle([r, a, o], s)
        }, e.Graphics.prototype.lineStyle = function(t, i, s) {
            return this.lineWidth = t || 0, this.lineColor = i || 0, this.lineAlpha = void 0 === s ? 1 : s, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new e.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, e.Graphics.prototype.moveTo = function(t, i) {
            return this.drawShape(new e.Polygon([t, i])), this
        }, e.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, e.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var n, r, a = this.currentPath.shape.points;
            0 === a.length && this.moveTo(0, 0);
            for (var o = a[a.length - 2], h = a[a.length - 1], l = 0, u = 1; u <= 20; ++u) n = o + (t - o) * (l = u / 20), r = h + (e - h) * l, a.push(n + (t + (i - t) * l - n) * l, r + (e + (s - e) * l - r) * l);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, e.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var a, o, h, l, u, c = this.currentPath.shape.points, d = c[c.length - 2], p = c[c.length - 1], f = 0, m = 1; m <= 20; ++m) h = (o = (a = 1 - (f = m / 20)) * a) * a, u = (l = f * f) * f, c.push(h * d + 3 * o * f * t + 3 * a * l * i + u * n, h * p + 3 * o * f * e + 3 * a * l * s + u * r);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, e.Graphics.prototype.arcTo = function(t, e, i, s, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var r = this.currentPath.shape.points,
                a = r[r.length - 2],
                o = r[r.length - 1] - e,
                h = a - t,
                l = s - e,
                u = i - t,
                c = Math.abs(o * u - h * l);
            if (c < 1e-8 || 0 === n) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
            else {
                var d = o * o + h * h,
                    p = l * l + u * u,
                    f = o * l + h * u,
                    m = n * Math.sqrt(d) / c,
                    g = n * Math.sqrt(p) / c,
                    v = m * f / d,
                    y = g * f / p,
                    _ = m * u + g * h,
                    x = m * l + g * o,
                    b = h * (g + v),
                    T = o * (g + v),
                    S = u * (m + y),
                    w = l * (m + y),
                    M = Math.atan2(T - x, b - _),
                    C = Math.atan2(w - x, S - _);
                this.arc(_ + t, x + e, n, M, C, h * l > u * o)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, e.Graphics.prototype.arc = function(t, e, i, s, n, r, a) {
            if (s === n) return this;
            void 0 === r && (r = !1), void 0 === a && (a = 40), !r && n <= s ? n += 2 * Math.PI : r && s <= n && (s += 2 * Math.PI);
            var o = r ? -1 * (s - n) : n - s,
                h = Math.ceil(Math.abs(o) / (2 * Math.PI)) * a;
            if (0 === o) return this;
            var l = t + Math.cos(s) * i,
                u = e + Math.sin(s) * i;
            r && this.filling ? this.moveTo(t, e) : this.moveTo(l, u);
            for (var c = this.currentPath.shape.points, d = o / (2 * h), p = 2 * d, f = Math.cos(d), m = Math.sin(d), g = h - 1, v = g % 1 / g, y = 0; y <= g; y++) {
                var _ = d + s + p * (y + v * y),
                    x = Math.cos(_),
                    b = -Math.sin(_);
                c.push((f * x + m * b) * i + t, (f * -b + m * x) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, e.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, e.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, e.Graphics.prototype.drawRect = function(t, i, s, n) {
            return this.drawShape(new e.Rectangle(t, i, s, n)), this
        }, e.Graphics.prototype.drawRoundedRect = function(t, i, s, n, r) {
            return this.drawShape(new e.RoundedRectangle(t, i, s, n, r)), this
        }, e.Graphics.prototype.drawCircle = function(t, i, s) {
            return this.drawShape(new e.Circle(t, i, s)), this
        }, e.Graphics.prototype.drawEllipse = function(t, i, s, n) {
            return this.drawShape({
                x: t,
                y: i,
                width: s,
                height: n,
                type: e.ELLIPSE
            }), this
        }, e.Graphics.prototype.drawPolygon = function(t) {
            t instanceof e.Polygon && (t = t.points);
            var i = t;
            if (!Array.isArray(i)) {
                i = new Array(arguments.length);
                for (var s = 0; s < i.length; ++s) i[s] = arguments[s]
            }
            return this.drawShape(new e.Polygon(i)), this
        }, e.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, e.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var s = this.getBounds();
            s.width += i, s.height += i;
            var n = new PIXI.CanvasBuffer(s.width * t, s.height * t),
                r = PIXI.Texture.fromCanvas(n.canvas, e);
            return r.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), r
        }, e.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
            }
        }, e.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var s = t.resolution,
                    n = i.tx * t.resolution + t.shakeX,
                    r = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var a = 0; a < this.children.length; a++) this.children[a]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, e.Graphics.prototype.getBounds = function(t) {
            if (this._currentBounds) return this._currentBounds;
            if (this.isMask) return e.EmptyRectangle;
            this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
            var i = this._localBounds,
                s = i.x,
                n = i.width + i.x,
                r = i.y,
                a = i.height + i.y,
                o = t || this.worldTransform,
                h = o.a,
                l = o.b,
                u = o.c,
                c = o.d,
                d = o.tx,
                p = o.ty,
                f = h * n + u * a + d,
                m = c * a + l * n + p,
                g = h * s + u * a + d,
                v = c * a + l * s + p,
                y = h * s + u * r + d,
                _ = c * r + l * s + p,
                x = h * n + u * r + d,
                b = c * r + l * n + p,
                T = f,
                S = m,
                w = f,
                M = m;
            return w = g < w ? g : w, w = y < w ? y : w, w = x < w ? x : w, M = v < M ? v : M, M = _ < M ? _ : M, M = b < M ? b : M, T = g > T ? g : T, T = y > T ? y : T, T = x > T ? x : T, S = v > S ? v : S, S = _ > S ? _ : S, S = b > S ? b : S, this._bounds.x = w, this._bounds.width = T - w, this._bounds.y = M, this._bounds.height = S - M, this._currentBounds = this._bounds, this._currentBounds
        }, e.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = e.identityMatrix;
            for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform();
            var s = this.getBounds();
            for (this.worldTransform = t, i = 0; i < this.children.length; i++) this.children[i].updateTransform();
            return s
        }, e.Graphics.prototype.containsPoint = function(t, i) {
            void 0 === i && (i = new e.Point), this.worldTransform.applyInverse(t, i);
            for (var s = this.graphicsData, n = 0; n < s.length; n++) {
                var r = s[n];
                if (r.fill && (r.shape && r.shape.contains(i.x, i.y))) return !0
            }
            return !1
        }, e.Graphics.prototype.getVisualBounds = function(t) {
            return this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1), this._localBounds.clone(t)
        }, e.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0,
                i = -1 / 0,
                s = 1 / 0,
                n = -1 / 0;
            if (this.graphicsData.length)
                for (var r, a, o, h, l, u, c = 0; c < this.graphicsData.length; c++) {
                    var d = this.graphicsData[c],
                        p = d.type,
                        f = d.lineWidth;
                    if (r = d.shape, p === e.RECTANGLE || p === e.ROUNDEDRECTANGLE) o = r.x - f / 2, h = r.y - f / 2, l = r.width + f, u = r.height + f, t = o < t ? o : t, i = o + l > i ? o + l : i, s = h < s ? h : s, n = h + u > n ? h + u : n;
                    else if (p === e.CIRCLE) o = r.x, h = r.y, l = r.radius + f / 2, u = r.radius + f / 2, t = o - l < t ? o - l : t, i = o + l > i ? o + l : i, s = h - u < s ? h - u : s, n = h + u > n ? h + u : n;
                    else if (p === e.ELLIPSE) o = r.x, h = r.y, l = r.width + f / 2, u = r.height + f / 2, t = o - l < t ? o - l : t, i = o + l > i ? o + l : i, s = h - u < s ? h - u : s, n = h + u > n ? h + u : n;
                    else {
                        a = r.points;
                        for (var m = 0; m < a.length; m++) a[m] instanceof e.Point ? (o = a[m].x, h = a[m].y) : (o = a[m], h = a[m + 1], m < a.length - 1 && m++), t = o - f < t ? o - f : t, i = o + f > i ? o + f : i, s = h - f < s ? h - f : s, n = h + f > n ? h + f : n
                    }
                } else t = 0, i = 0, s = 0, n = 0;
            var g = this.boundsPadding;
            this._localBounds.x = t - g, this._localBounds.width = i - t + 2 * g, this._localBounds.y = s - g, this._localBounds.height = n - s + 2 * g
        }, e.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, e.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, e.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, e.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof e.Polygon && (t = t.clone()).flatten();
            var i = new e.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
            return this.graphicsData.push(i), i.type === e.POLYGON && (i.shape.closed = this.filling, this.currentPath = i), this.dirty = !0, this._boundsDirty = !0, i
        }, Object.defineProperty(e.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), e.RenderTexture = function(t, i, s, n, r, a, o, h) {
            if (void 0 === i && (i = 100), void 0 === s && (s = 100), void 0 === n && (n = ""), void 0 === r && (r = e.scaleModes.DEFAULT), void 0 === a && (a = 1), void 0 === o && (o = PIXI.defaultRenderer), void 0 === h && (h = 0), this.game = t, this.key = n, this.type = e.RENDERTEXTURE, this._tempMatrix = new e.Matrix, this.width = i, this.height = s, this.resolution = a, this.frame = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new PIXI.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = r, this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = o, this.renderer.type === e.WEBGL) {
                var l = this.renderer.gl;
                this.baseTexture.textureIndex = h, this.baseTexture._dirty[l.id] = !1, this.textureBuffer = new PIXI.FilterTexture(l, this.width, this.height, this.baseTexture.scaleMode, h), this.baseTexture._glTextures[l.id] = this.textureBuffer.texture, this.projection = new e.Point(.5 * this.width, .5 * -this.height)
            } else this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0, this.tempMatrix = new e.Matrix, this._updateUvs()
        }, e.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), e.RenderTexture.prototype.constructor = e.RenderTexture, e.RenderTexture.prototype.renderXY = function(t, i, s, n) {
            t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = i, this._tempMatrix.ty = s, this.renderer.type === e.WEBGL ? this._renderWebGL(t, this._tempMatrix, n) : this._renderCanvas(t, this._tempMatrix, n)
        }, e.RenderTexture.prototype.renderRawXY = function(t, i, s, n) {
            this._tempMatrix.identity().translate(i, s), this.renderer.type === e.WEBGL ? this._renderWebGL(t, this._tempMatrix, n) : this._renderCanvas(t, this._tempMatrix, n)
        }, e.RenderTexture.prototype.render = function(t, i, s) {
            void 0 === i || null === i ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(i), this.renderer.type === e.WEBGL ? this._renderWebGL(t, this._tempMatrix, s) : this._renderCanvas(t, this._tempMatrix, s)
        }, e.RenderTexture.prototype.resize = function(t, i, s) {
            t === this.width && i === this.height || (this.valid = t > 0 && i > 0, this.width = t, this.height = i, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = i * this.resolution, s && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === e.WEBGL && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
        }, e.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === e.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
        }, e.RenderTexture.prototype._renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                var r = this.renderer.gl;
                r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0, r.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }, e.RenderTexture.prototype._renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), e && s.append(e);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                i && this.textureBuffer.clear();
                var r = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
            }
        }, e.RenderTexture.prototype.getImage = function(t, e, i, s) {
            var n = new Image;
            return n.src = this.getBase64(t, e), i && (n.onload = i), s && (n.onerror = s), n
        }, e.RenderTexture.prototype.getBase64 = function(t, e) {
            return this.getCanvas().toDataURL(t, e)
        }, e.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type === e.WEBGL) {
                var t = this.renderer.gl,
                    i = this.textureBuffer.width,
                    s = this.textureBuffer.height,
                    n = new Uint8Array(4 * i * s);
                t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, i, s, t.RGBA, t.UNSIGNED_BYTE, n), t.bindFramebuffer(t.FRAMEBUFFER, null);
                var r = new PIXI.CanvasBuffer(i, s),
                    a = r.context.getImageData(0, 0, i, s);
                return a.data.set(n), r.context.putImageData(a, 0, 0), r.canvas
            }
            return this.textureBuffer.canvas
        }, e.Text = function(t, i, s, n, r) {
            i = i || 0, s = s || 0, n = void 0 === n || null === n ? "" : n.toString(), this.canvas = e.CanvasPool.create(this), e.Sprite.call(this, t, i, s, PIXI.Texture.fromCanvas(this.canvas)), this.type = e.TEXT, this.physicsType = e.SPRITE, this.padding = new e.Point, this.textBounds = null, this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this.splitRegExp = /(?:\r\n|\r|\n)/, this.characterLimitSize = -1, this.characterLimitSuffix = "", this._testString = "|MÉq", this._res = t.renderer.resolution, this._text = n, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, this.style = {}, this.setStyle(r || {}), "" !== n && this.updateText()
        }, e.Text.prototype = Object.create(e.Sprite.prototype), e.Text.prototype.constructor = e.Text, e.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, e.Text.prototype.update = function() {}, e.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0), e.Component.Destroy.prototype.destroy.call(this, t)
        }, e.Text.prototype.setShadow = function(t, e, i, s, n, r) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = r, this.dirty = !0, this
        }, e.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1);
            var i = Object.assign({}, t);
            i.font = t.font || "bold 20pt Arial", i.backgroundColor = t.backgroundColor || null, i.fill = t.fill || "black", i.align = (t.align || "left").toLowerCase(), i.boundsAlignH = (t.boundsAlignH || "left").toLowerCase(), i.boundsAlignV = (t.boundsAlignV || "top").toLowerCase(), i.stroke = t.stroke || "black", i.strokeThickness = Number(t.strokeThickness) || 0, i.wordWrap = t.wordWrap || !1, i.wordWrapWidth = t.wordWrapWidth || 100, i.maxLines = t.maxLines || 0, i.shadowOffsetX = t.shadowOffsetX || 0, i.shadowOffsetY = t.shadowOffsetY || 0, i.shadowColor = t.shadowColor || "rgba(0,0,0,0)", i.shadowBlur = t.shadowBlur || 0, i.tabs = t.tabs || 0;
            var s = this.fontToComponents(i.font);
            return i.fontStyle && (s.fontStyle = i.fontStyle), i.fontVariant && (s.fontVariant = i.fontVariant), i.fontWeight && (s.fontWeight = i.fontWeight), i.fontSize && ("number" == typeof i.fontSize && (i.fontSize = i.fontSize + "px"), s.fontSize = i.fontSize), this._fontComponents = s, i.font = this.componentsToFont(this._fontComponents), this.style = i, this.dirty = !0, e && this.updateText(), this
        }, e.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.characterLimitSize > -1 && this.characterLimitSize < t.length && (t = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix), this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(this.splitRegExp),
                i = this.style.tabs,
                s = [],
                n = 0,
                r = this.determineFontProperties(this.style.font),
                a = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (a = this.style.maxLines), this._charCount = 0;
            for (var o = 0; o < a; o++) {
                if (0 === i) {
                    l = this.style.strokeThickness + this.padding.x;
                    this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(e[o]) : l += this.context.measureText(e[o]).width, this.style.wordWrap && (l -= this.context.measureText(" ").width)
                } else {
                    var h = e[o].split(/(?:\t)/),
                        l = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var u = 0, c = 0; c < h.length; c++) {
                            var d = 0;
                            d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[c]) : Math.ceil(this.context.measureText(h[c]).width), c > 0 && (u += i[c - 1]), l = u + d
                        } else
                            for (c = 0; c < h.length; c++) this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(h[c]) : l += Math.ceil(this.context.measureText(h[c]).width), l += this.game.math.snapToCeil(l, i) - l
                }
                s[o] = Math.ceil(l), n = Math.max(n, s[o])
            }
            this.canvas.width = n * this._res;
            var p = r.fontSize + this.style.strokeThickness + this.padding.y,
                f = p * a,
                m = this._lineSpacing;
            m < 0 && Math.abs(m) > p && (m = -p), 0 !== m && (f += m > 0 ? m * e.length : m * (e.length - 1)), this.canvas.height = f * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
            var g, v;
            for (this._charCount = 0, o = 0; o < a; o++) g = this.style.strokeThickness / 2, v = this.style.strokeThickness / 2 + o * p + r.ascent, o > 0 && (v += m * o), "right" === this.style.align ? g += n - s[o] : "center" === this.style.align && (g += (n - s[o]) / 2), this.autoRound && (g = Math.round(g), v = Math.round(v)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[o], g, v) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[o], g, v) : this.renderTabLine(e[o], g, v, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[o], g, v) : this.renderTabLine(e[o], g, v, !0)));
            this.updateTexture(), this.dirty = !1
        }, e.Text.prototype.renderTabLine = function(t, e, i, s) {
            var n = t.split(/(?:\t)/),
                r = this.style.tabs,
                a = 0;
            if (Array.isArray(r))
                for (var o = 0, h = 0; h < n.length; h++) h > 0 && (o += r[h - 1]), a = e + o, s ? this.context.fillText(n[h], a, i) : this.context.strokeText(n[h], a, i);
            else
                for (h = 0; h < n.length; h++) {
                    var l = Math.ceil(this.context.measureText(n[h]).width);
                    a = this.game.math.snapToCeil(e, r), s ? this.context.fillText(n[h], a, i) : this.context.strokeText(n[h], a, i), e = a + l
                }
        }, e.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        }, e.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var s = t[i];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s).width, this._charCount++
            }
            return Math.ceil(e)
        }, e.Text.prototype.updateLine = function(t, e, i) {
            for (var s = 0; s < t.length; s++) {
                var n = t[s];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var r = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n).width, this._charCount++
            }
        }, e.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, e.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, e.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        }, e.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        }, e.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        }, e.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        }, e.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }, e.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }, e.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, a = 0; a < r; a++) {
                var o = n[a],
                    h = "";
                if (o = o.replace(/^ *|\s*$/gi, ""), e.measureText(o).width < i) s += o + "\n";
                else {
                    for (var l = i, u = o.split(" "), c = 0; c < u.length; c++) {
                        var d = u[c],
                            p = d + " ",
                            f = e.measureText(p).width;
                        if (f > l) {
                            if (0 === c) {
                                for (var m = p; m.length && (m = m.slice(0, -1), !((f = e.measureText(m).width) <= l)););
                                if (!m.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var g = d.substr(m.length);
                                u[c] = g, h += m
                            }
                            var v = u[c].length ? c : c + 1,
                                y = u.slice(v).join(" ").replace(/[ \n]*$/gi, "");
                            n[a + 1] = y + " " + (n[a + 1] || ""), r = n.length;
                            break
                        }
                        h += p, l -= f
                    }
                    s += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return s = s.replace(/[\s|\n]*$/gi, "")
        }, e.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                for (var n = this.style.wordWrapWidth, r = i[s].split(" "), a = 0; a < r.length; a++) {
                    var o = this.context.measureText(r[a]).width,
                        h = o + this.context.measureText(" ").width;
                    h > n ? (a > 0 && (e += "\n"), e += r[a] + " ", n = this.style.wordWrapWidth - o) : (n -= h, e += r[a] + " ")
                }
                s < i.length - 1 && (e += "\n")
            }
            return e
        }, e.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        }, e.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return console.warn("Phaser.Text - unparsable CSS font: " + t), {
                font: t
            }
        }, e.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
        }, e.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), (t = t.toString() || "") === this._text ? this : (this.text = t, e ? this.updateText() : this.dirty = !0, this)
        }, e.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t)) return this;
            for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        }, e.Text.prototype.setTextBounds = function(t, i, s, n) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, i, s, n) : this.textBounds = new e.Rectangle(t, i, s, n), this.style.wordWrapWidth > s && (this.style.wordWrapWidth = s)), this.updateTexture(), this
        }, e.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                s = this.canvas.width,
                n = this.canvas.height;
            if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
                var r = this.textBounds.x,
                    a = this.textBounds.y;
                "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? a += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (a += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -a
            }
            this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, e.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, e.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, e.Text.prototype.determineFontProperties = function(t) {
            var i = e.Text.fontPropertiesCache[t],
                s = this.testString || "|MÉq";
            if (!i) {
                i = {};
                var n = e.Text.fontPropertiesCanvas,
                    r = e.Text.fontPropertiesContext;
                r.font = t;
                var a = Math.ceil(r.measureText(s).width),
                    o = Math.ceil(r.measureText(s).width),
                    h = 2 * o;
                if (o = 1.4 * o | 0, n.width = a, n.height = h, r.fillStyle = "#f00", r.fillRect(0, 0, a, h), r.font = t, r.textBaseline = "alphabetic", r.fillStyle = "#000", r.fillText(s, 0, o), !r.getImageData(0, 0, a, h)) return i.ascent = o, i.descent = o + 6, i.fontSize = i.ascent + i.descent, e.Text.fontPropertiesCache[t] = i, i;
                var l, u, c = r.getImageData(0, 0, a, h).data,
                    d = c.length,
                    p = 4 * a,
                    f = 0,
                    m = !1;
                for (l = 0; l < o; l++) {
                    for (u = 0; u < p; u += 4)
                        if (255 !== c[f + u]) {
                            m = !0;
                            break
                        }
                    if (m) break;
                    f += p
                }
                for (i.ascent = o - l, f = d - p, m = !1, l = h; l > o; l--) {
                    for (u = 0; u < p; u += 4)
                        if (255 !== c[f + u]) {
                            m = !0;
                            break
                        }
                    if (m) break;
                    f -= p
                }
                i.descent = l - o, i.descent += 6, i.fontSize = i.ascent + i.descent, e.Text.fontPropertiesCache[t] = i
            }
            return i
        }, e.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        }, e.Text.prototype.setCharacterLimit = function(t, e) {
            this.characterLimitSuffix = void 0 === e ? "" : e, this.characterLimitSize = t, this.updateText()
        }, Object.defineProperty(e.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(e.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(e.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(e.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(e.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(e.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(e.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(e.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                (t = t.toLowerCase()) !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                (t = t.toLowerCase()) !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                (t = t.toLowerCase()) !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = Number(t), this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(e.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }), Object.defineProperty(e.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * (this.texture.frame.width / this.resolution)
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(e.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * (this.texture.frame.height / this.resolution)
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), Object.defineProperty(e.Text.prototype, "testString", {
            get: function() {
                return this._testString
            },
            set: function(t) {
                this._testString = t, this.updateText()
            }
        }), e.Text.fontPropertiesCache = {}, e.Text.fontPropertiesCanvas = document.createElement("canvas"), e.Text.fontPropertiesContext = e.Text.fontPropertiesCanvas.getContext("2d"), e.BitmapText = function(t, i, s, n, r, a, o) {
            i = i || 0, s = s || 0, n = n || "", r = r || "", a = a || 32, o = o || "left", PIXI.DisplayObjectContainer.call(this), this.type = e.BITMAPTEXT, this.physicsType = e.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new e.Point, this._prevAnchor = new e.Point, this._glyphs = [], this._maxWidth = 0, this._text = r.toString() || "", this._data = t.cache.getBitmapFont(n), this._font = n, this._fontSize = a, this._align = o, this._letterSpacing = 0, this._tint = 16777215, this.updateText(), this.dirty = !1, e.Component.Core.init.call(this, t, i, s, "", null)
        }, e.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), e.BitmapText.prototype.constructor = e.BitmapText, e.Component.Core.install.call(e.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), e.BitmapText.prototype.preUpdatePhysics = e.Component.PhysicsBody.preUpdate, e.BitmapText.prototype.preUpdateLifeSpan = e.Component.LifeSpan.preUpdate, e.BitmapText.prototype.preUpdateInWorld = e.Component.InWorld.preUpdate, e.BitmapText.prototype.preUpdateCore = e.Component.Core.preUpdate, e.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, e.BitmapText.prototype.postUpdate = function() {
            e.Component.PhysicsBody.postUpdate.call(this), e.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === e.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, e.BitmapText.prototype.setText = function(t) {
            this.text = t
        }, e.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var s = 0, n = 0, r = -1, a = 0, o = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], u = 0; u < i.length; u++) {
                var c = u === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(u))) return {
                    width: n,
                    text: i.substr(0, u),
                    end: c,
                    chars: l
                };
                var d = i.charCodeAt(u),
                    p = t.chars[d],
                    f = 0;
                void 0 === p && (d = 32, p = t.chars[d]);
                var m = o && p.kerning[o] ? p.kerning[o] : 0;
                if (/(\s)/.test(i.charAt(u)) && (r = u, a = n), f = (m + p.texture.width + p.xOffset) * e, h && n + f >= h && r > -1) return {
                    width: a || n,
                    text: i.substr(0, u - (u - r)),
                    end: !1,
                    chars: l
                };
                n += (p.xAdvance + m + this.letterSpacing) * e, l.push(s + (p.xOffset + m + this.letterSpacing) * e), s += (p.xAdvance + m + this.letterSpacing) * e, o = d
            }
            return {
                width: n,
                text: i,
                end: c,
                chars: l
            }
        }, e.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i) return "";
            for (var s = /\r\n|\n\r|\n|\r/g, n = t.replace(s, "\n").split("\n"), r = 0; r < n.length; r++) {
                for (var a = "", o = n[r], h = 0; h < o.length; h++) a = i.chars[o.charCodeAt(h)] ? a.concat(o[h]) : a.concat(e);
                n[r] = a
            }
            return n.join("\n")
        }, e.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text,
                    i = this._fontSize / t.size,
                    s = [],
                    n = 0;
                this.textWidth = 0;
                do {
                    (u = this.scanLine(t, i, e)).y = n, s.push(u), u.width > this.textWidth && (this.textWidth = u.width), n += t.lineHeight * i, e = e.substr(u.text.length + 1)
                } while (!1 === u.end);
                this.textHeight = n;
                for (var r = 0, a = 0, o = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < s.length; l++) {
                    var u = s[l];
                    "right" === this._align ? a = this.textWidth - u.width : "center" === this._align && (a = (this.textWidth - u.width) / 2);
                    for (var c = 0; c < u.text.length; c++) {
                        var d = u.text.charCodeAt(c),
                            p = t.chars[d];
                        void 0 === p && (d = 32, p = t.chars[d]);
                        var f = this._glyphs[r];
                        f ? f.texture = p.texture : ((f = new PIXI.Sprite(p.texture)).name = u.text[c], this._glyphs.push(f)), f.position.x = u.chars[c] + a - o, f.position.y = u.y + p.yOffset * i - h, f.scale.set(i), f.tint = this.tint, f.texture.requiresReTint = !0, f.cachedTint = 16777215, f.parent || this.addChild(f), r++
                    }
                }
                for (l = r; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
            }
        }, e.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
        }, e.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(e.BitmapText.prototype, "letterSpacing", {
            get: function() {
                return this._letterSpacing
            },
            set: function(t) {
                "number" == typeof t && (this._letterSpacing = t, this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t, this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t, this.updateText())
            }
        }), Object.defineProperty(e.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1, this._data.base.dirty()
            }
        }), e.TileSprite = function(t, i, s, n, r, a, o) {
            i = i || 0, s = s || 0, n = n || 256, r = r || 256, a = a || null, o = o || null, PIXI.Sprite.call(this, new PIXI.Texture(e.Cache.DEFAULT.baseTexture), n, r), this.type = e.TILESPRITE, this.physicsType = e.SPRITE, this._scroll = new e.Point, this.tileScale = new e.Point(1, 1), this.tileScaleOffset = new e.Point(1, 1), this.tilePosition = new e.Point, this.textureDebug = !1, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0, this._width = n, this._height = r, e.Component.Core.init.call(this, t, i, s, a, o)
        }, e.TileSprite.prototype = Object.create(PIXI.Sprite.prototype), e.TileSprite.prototype.constructor = e.TileSprite, e.Component.Core.install.call(e.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), e.TileSprite.prototype.preUpdatePhysics = e.Component.PhysicsBody.preUpdate, e.TileSprite.prototype.preUpdateLifeSpan = e.Component.LifeSpan.preUpdate, e.TileSprite.prototype.preUpdateInWorld = e.Component.InWorld.preUpdate, e.TileSprite.prototype.preUpdateCore = e.Component.Core.preUpdate, e.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += .001 * this._scroll.x * this.game.time.delta), 0 !== this._scroll.y && (this.tilePosition.y += .001 * this._scroll.y * this.game.time.delta), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, e.TileSprite.prototype.autoScroll = function(t, e) {
            return this._scroll.set(t, e), this
        }, e.TileSprite.prototype.stopScroll = function() {
            return this._scroll.set(0, 0), this
        }, e.TileSprite.prototype.destroy = function(t) {
            e.Component.Destroy.prototype.destroy.call(this, t), PIXI.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        }, e.TileSprite.prototype.reset = function(t, i) {
            return e.Component.Reset.prototype.reset.call(this, t, i), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, e.TileSprite.prototype.setTexture = function(t) {
            return this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215), this
        }, e.TileSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex, t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                var i = !1;
                this._filters && (i = !0, t.spriteBatch.stop(), t.filterManager.popFilter()), this._mask && (i || t.spriteBatch.stop(), t.maskManager.popMask(this._mask, t)), i && t.spriteBatch.start()
            }
        }, e.TileSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var e = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
                var i = this.worldTransform,
                    s = t.resolution,
                    n = i.tx * s + t.shakeX,
                    r = i.ty * s + t.shakeY;
                if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), 16777215 === this.tint || !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1, this.refreshTexture = !0), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                    this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var a = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]);
                var o = this.tilePosition,
                    h = this.tileScale;
                o.x %= this.tilingTexture.baseTexture.width, o.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(o.x + this.anchor.x * -this._width, o.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern, n = -o.x, r = -o.y;
                var l = this._width / h.x,
                    u = this._height / h.y;
                t.roundPixels && (n |= 0, r |= 0, l |= 0, u |= 0), e.fillRect(n, r, l, u), e.scale(1 / h.x, 1 / h.y), e.translate(-o.x + this.anchor.x * this._width, -o.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                for (var c = 0; c < this.children.length; c++) this.children[c]._renderCanvas(t);
                a !== this.blendMode && (t.currentBlendMode = a, e.globalCompositeOperation = PIXI.blendModesCanvas[a])
            }
        }, e.TileSprite.prototype.onTextureUpdate = function() {}, e.TileSprite.prototype.generateTilingTexture = function(t) {
            if (this.texture.baseTexture.hasLoaded) {
                var i = this.texture,
                    s = i.frame,
                    n = this._frame.sourceSizeW || this._frame.width,
                    r = this._frame.sourceSizeH || this._frame.height,
                    a = 0,
                    o = 0;
                this._frame.trimmed && (a = this._frame.spriteSourceSizeX, o = this._frame.spriteSourceSizeY), t && (n = e.Math.getNextPowerOfTwo(n), r = e.Math.getNextPowerOfTwo(r)), this.canvasBuffer ? (this.canvasBuffer.resize(n, r), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new PIXI.CanvasBuffer(n, r), this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, r));
                var h = i.crop.width,
                    l = i.crop.height;
                h === n && l === r || (h = n, l = r);
                var u = this.tintedTexture ? this.tintedTexture : i.baseTexture.source;
                this.canvasBuffer.context.drawImage(u, i.crop.x, i.crop.y, i.crop.width, i.crop.height, a, o, h, l), this.tileScaleOffset.x = s.width / n, this.tileScaleOffset.y = s.height / r, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }, e.TileSprite.prototype.getBounds = function() {
            var t = this._width,
                e = this._height,
                i = t * (1 - this.anchor.x),
                s = t * -this.anchor.x,
                n = e * (1 - this.anchor.y),
                r = e * -this.anchor.y,
                a = this.worldTransform,
                o = a.a,
                h = a.b,
                l = a.c,
                u = a.d,
                c = a.tx,
                d = a.ty,
                p = o * s + l * r + c,
                f = u * r + h * s + d,
                m = o * i + l * r + c,
                g = u * r + h * i + d,
                v = o * i + l * n + c,
                y = u * n + h * i + d,
                _ = o * s + l * n + c,
                x = u * n + h * s + d,
                b = -1 / 0,
                T = -1 / 0,
                S = 1 / 0,
                w = 1 / 0;
            S = _ < (S = v < (S = m < (S = p < S ? p : S) ? m : S) ? v : S) ? _ : S, w = x < (w = y < (w = g < (w = f < w ? f : w) ? g : w) ? y : w) ? x : w, b = _ > (b = v > (b = m > (b = p > b ? p : b) ? m : b) ? v : b) ? _ : b, T = x > (T = y > (T = g > (T = f > T ? f : T) ? g : T) ? y : T) ? x : T;
            var M = this._bounds;
            return M.x = S, M.width = b - S, M.y = w, M.height = T - w, this._currentBounds = M, M
        }, Object.defineProperty(e.TileSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }), Object.defineProperty(e.TileSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }), e.CanvasPool = {
            create: function(t, i, s) {
                var n, r = e.CanvasPool.getFirst();
                if (-1 === r) {
                    var a = {
                        parent: t,
                        canvas: document.createElement("canvas")
                    };
                    e.CanvasPool.pool.push(a), n = a.canvas
                } else e.CanvasPool.pool[r].parent = t, n = e.CanvasPool.pool[r].canvas;
                return void 0 !== i && (n.width = i, n.height = s), n
            },
            getFirst: function() {
                for (var t = e.CanvasPool.pool, i = 0; i < t.length; i++)
                    if (!t[i].parent) return i;
                return -1
            },
            remove: function(t) {
                for (var i = e.CanvasPool.pool, s = 0; s < i.length; s++) i[s].parent === t && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
            },
            removeByCanvas: function(t) {
                for (var i = e.CanvasPool.pool, s = 0; s < i.length; s++) i[s].canvas === t && (i[s].parent = null, i[s].canvas.width = 1, i[s].canvas.height = 1)
            },
            getTotal: function() {
                for (var t = e.CanvasPool.pool, i = 0, s = 0; s < t.length; s++) t[s].parent && i++;
                return i
            },
            getFree: function() {
                for (var t = e.CanvasPool.pool, i = 0, s = 0; s < t.length; s++) t[s].parent || i++;
                return i
            },
            log: function() {
                console.log("CanvasPool: %s used, %s free, %s total", e.CanvasPool.getTotal(), e.CanvasPool.getFree(), e.CanvasPool.pool.length)
            }
        }, e.CanvasPool.pool = [], Object.defineProperty(e.CanvasPool, "length", {
            get: function() {
                return this.pool.length
            }
        }), e.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.canHandleAlpha = !1, this.canUseMultiply = !1, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, e.Device = new e.Device, e.Device.onInitialized = new e.Signal, e.Device.whenReady = function(t, e, i) {
            var s = this._readyCheck;
            if (this.deviceReadyAt || !s) t.call(e, this);
            else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]);
            else {
                s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
                var n = void 0 !== window.cordova,
                    r = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
            }
        }, e.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                    for (var e; e = t._queue.shift();) {
                        var i = e[0],
                            s = e[1];
                        i.call(s, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        }, e.Device._initialize = function() {
            function t() {
                var t = new ArrayBuffer(4),
                    e = new Uint8Array(t),
                    i = new Uint32Array(t);
                return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
            }

            function i() {
                if (void 0 === Uint8ClampedArray) return !1;
                var t = e.CanvasPool.create(this, 1, 1).getContext("2d");
                if (!t) return !1;
                var i = t.createImageData(1, 1);
                return e.CanvasPool.remove(this), i.data instanceof Uint8ClampedArray
            }
            var s = this;
            ! function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? s.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? s.kindle = !0 : /Android/.test(t) ? s.android = !0 : /CrOS/.test(t) ? s.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (s.iOS = !0, navigator.appVersion.match(/OS (\d+)/), s.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? s.linux = !0 : /Mac OS/.test(t) ? s.macOS = !0 : /Windows/.test(t) && (s.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (s.android = !1, s.iOS = !1, s.macOS = !1, s.windows = !0, s.windowsPhone = !0);
                var e = /Silk/.test(t);
                (s.windows || s.macOS || s.linux && !e || s.chromeOS) && (s.desktop = !0), (s.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (s.desktop = !1)
            }(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? s.arora = !0 : /Edge\/\d+/.test(t) ? s.edge = !0 : /Chrome\/(\d+)/.test(t) && !s.windowsPhone ? (s.chrome = !0, s.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? s.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (s.firefox = !0, s.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && s.iOS ? s.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (s.ie = !0, s.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? s.midori = !0 : /Opera/.test(t) ? s.opera = !0 : /Safari\/(\d+)/.test(t) && !s.windowsPhone ? (s.safari = !0, /Version\/(\d+)\./.test(t) && (s.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (s.ie = !0, s.trident = !0, s.tridentVersion = parseInt(RegExp.$1, 10), s.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (s.silk = !0), navigator.standalone && (s.webApp = !0), void 0 !== window.cordova && (s.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (s.node = !0), s.node && "object" == typeof process.versions && (s.nodeWebkit = !!process.versions["node-webkit"], s.electron = !!process.versions.electron), navigator.isCocoonJS && (s.cocoonJS = !0), s.cocoonJS) try {
                    s.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (t) {
                    s.cocoonJSApp = !1
                }
                void 0 !== window.ejecta && (s.ejecta = !0), /Crosswalk/.test(t) && (s.crosswalk = !0)
            }(),
            function() {
                s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (s.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (s.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (s.mp3 = !0), t.canPlayType("audio/wav").replace(/^no$/, "") && (s.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (s.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (s.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (s.edge) s.dolby = !0;
                        else if (s.safari && s.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var e = parseInt(RegExp.$1, 10),
                            i = parseInt(RegExp.$2, 10);
                        (10 === e && i >= 11 || e > 10) && (s.dolby = !0)
                    }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (s.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (s.h264Video = !0, s.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (s.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (s.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (s.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, e = document.createElement("p"),
                    i = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                document.body.insertBefore(e, null);
                for (var n in i) void 0 !== e.style[n] && (e.style[n] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[n]));
                document.body.removeChild(e), s.css3D = void 0 !== t && t.length > 0 && "none" !== t
            }(), s.pixelRatio = window.devicePixelRatio || 1, s.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), s.iPhone4 = 2 === s.pixelRatio && s.iPhone, s.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? s.typedArray = !0 : s.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (s.littleEndian = t(), s.LITTLE_ENDIAN = s.littleEndian), s.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== s.littleEndian && i(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (s.vibration = !0),
                function() {
                    s.canvas = !!window.CanvasRenderingContext2D || s.cocoonJS;
                    try {
                        s.localStorage = !!localStorage.getItem
                    } catch (t) {
                        s.localStorage = !1
                    }
                    s.file = !!(window.File && window.FileReader && window.FileList && window.Blob), s.fileSystem = !!window.requestFileSystem, s.webGL = !!window.WebGLRenderingContext, s.worker = !!window.Worker, s.pointerLockElement = "pointerLockElement" in document && "pointerLockElement" || "mozPointerLockElement" in document && "mozPointerLockElement" || "webkitPointerLockElement" in document && "webkitPointerLockElement", s.pointerlockchange = "onpointerlockchange" in document && "pointerlockchange" || "onmozpointerlockchange" in document && "mozpointerlockchange" || "onwebkitpointerlockchange" in document && "webkitpointerlockchange", s.pointerlockerror = "onpointerlockerror" in document && "pointerlockerror" || "onmozpointerlockerror" in document && "mozpointerlockerror" || "onwebkitpointerlockerror" in document && "webkitpointerlockerror", s.pointerLock = !!s.pointerLockElement, s.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, s.getUserMedia = s.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (s.getUserMedia = !1), !s.iOS && (s.ie || s.firefox || s.chrome) && (s.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (s.canvasBitBltShift = !1)
                }(),
                function() {
                    var t = e.CanvasPool.create(this, 6, 1),
                        i = t.getContext("2d");
                    i.fillStyle = "rgba(10, 20, 30, 0.5)", i.fillRect(0, 0, 1, 1);
                    var n = i.getImageData(0, 0, 1, 1);
                    if (n) {
                        i.putImageData(n, 1, 0);
                        var r = i.getImageData(1, 0, 1, 1);
                        s.canHandleAlpha = r.data[0] === n.data[0] && r.data[1] === n.data[1] && r.data[2] === n.data[2] && r.data[3] === n.data[3]
                    }
                    i.globalCompositeOperation = "multiply", s.canUseMultiply = "multiply" === i.globalCompositeOperation, e.CanvasPool.removeByCanvas(t), PIXI.CanvasTinter.tintMethod = s.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel
                }(),
                function() {
                    for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                        if (e[t[i]]) {
                            s.fullscreen = !0, s.requestFullscreen = t[i];
                            break
                        }
                    var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                    if (s.fullscreen)
                        for (i = 0; i < n.length; i++)
                            if (document[n[i]]) {
                                s.cancelFullscreen = n[i];
                                break
                            }
                    window.Element && Element.ALLOW_KEYBOARD_INPUT && (s.fullscreenKeyboard = !0)
                }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (s.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (s.mspointer = !0), s.cocoonJS || ("onwheel" in window || s.ie && "WheelEvent" in window ? s.wheelEvent = "wheel" : "onmousewheel" in window ? s.wheelEvent = "mousewheel" : s.firefox && "MouseScrollEvent" in window && (s.wheelEvent = "DOMMouseScroll"))
        }, e.Device.canPlayAudio = function(t) {
            return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
        }, e.Device.canPlayVideo = function(t) {
            return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
        }, e.Device.needsTouchUnlock = function() {
            return !!(!this.cocoonJS && (this.iOS || this.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)
        }, e.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }, e.Canvas = {
            create: function(t, i, s, n, r) {
                i = i || 256, s = s || 256;
                var a = r ? document.createElement("canvas") : e.CanvasPool.create(t, i, s);
                return "string" == typeof n && "" !== n && (a.id = n), a.width = i, a.height = s, a.style.display = "block", a
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            },
            setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            },
            setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            },
            addToDOM: function(t, e, i) {
                var s;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, s, n, r, a) {
                return t.setTransform(s, r, a, n, e, i), t
            },
            setSmoothingEnabled: function(t, i) {
                var s = e.Canvas.getSmoothingPrefix(t);
                return s && (t[s] = i), t
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var s = e[i] + "mageSmoothingEnabled";
                    if (s in t) return s
                }
                return null
            },
            getSmoothingEnabled: function(t) {
                var i = e.Canvas.getSmoothingPrefix(t);
                if (i) return t[i]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["-webkit-optimize-contrast", "-moz-crisp-edges", "crisp-edges", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        }, e.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"] || window[i[s] + "CancelRequestAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, e.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var t = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return t.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                    return t.updateRAF(e)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        }, e.RequestAnimationFrame.prototype.constructor = e.RequestAnimationFrame, e.Math = {
            PI2: 2 * Math.PI,
            HALF_PI: .5 * Math.PI,
            DEG_TO_RAD: Math.PI / 180,
            RAD_TO_DEG: 180 / Math.PI,
            degToRad: function(t) {
                return t * e.Math.DEG_TO_RAD
            },
            radToDeg: function(t) {
                return t * e.Math.RAD_TO_DEG
            },
            getNextPowerOfTwo: function(t) {
                if (t > 0 && 0 == (t & t - 1)) return t;
                for (var e = 1; e < t;) e <<= 1;
                return e
            },
            isPowerOfTwo: function(t, e) {
                return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
            },
            random: function(t, e) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                if (t > e) {
                    var i = t;
                    t = e, e = i
                }
                return Math.random() * (e - t) + t
            },
            between: function(t, e) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                if (t > e) {
                    var i = t;
                    t = e, e = i
                }
                return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t > e - i
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.round(t * s) / s
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.floor(t * s) / s
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var s = Math.pow(i, -e);
                return Math.ceil(t * s) / s
            },
            trunc: function(t) {
                return isFinite(t) ? t - t % 1 || (t < 0 ? -0 : 0 === t ? t : 0) : t
            },
            rotateToAngle: function(t, i, s) {
                return void 0 === s && (s = .05), t === i ? t : (Math.abs(i - t) <= s || Math.abs(i - t) >= e.Math.PI2 - s ? t = i : (Math.abs(i - t) > Math.PI && (i < t ? i += e.Math.PI2 : i -= e.Math.PI2), i > t ? t += s : i < t && (t -= s)), t)
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, s) {
                return Math.atan2(s - e, i - t)
            },
            angleBetweenY: function(t, e, i, s) {
                return Math.atan2(i - t, s - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var s = i - e;
                if (s <= 0) return 0;
                var n = (t - e) % s;
                return n < 0 && (n += s), n + e
            },
            wrapValue: function(t, e, i) {
                return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), (t + e) % i
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments;
                for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
                return e[s][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1);
                for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
                return e[s][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1,
                    s = i * e,
                    n = Math.floor(s);
                return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i : n + 1], s - n)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1,
                    s = i * e,
                    n = Math.floor(s);
                return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t) return 1;
                for (var e = t; --t;) e *= t;
                return e
            },
            catmullRom: function(t, e, i, s, n) {
                var r = .5 * (i - t),
                    a = .5 * (s - e),
                    o = n * n;
                return (2 * e - 2 * i + r + a) * (n * o) + (-3 * e + 3 * i - 2 * r - a) * o + r * n + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return t > 0 ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, s) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                for (var n = e, r = i, a = s * Math.PI / t, o = [], h = [], l = 0; l < t; l++) n += (r -= n * a) * a, o[l] = r, h[l] = n;
                return {
                    sin: h,
                    cos: o,
                    length: t
                }
            },
            hypot: function(t, e) {
                return Math.sqrt(t * t + e * e)
            },
            distance: function(t, e, i, s) {
                var n = t - i,
                    r = e - s;
                return Math.sqrt(n * n + r * r)
            },
            distanceSq: function(t, e, i, s) {
                var n = t - i,
                    r = e - s;
                return n * n + r * r
            },
            distancePow: function(t, e, i, s, n) {
                return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, s, n) {
                return s + (t - e) * (n - s) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
            }
        }, e.RandomDataGenerator = function(t) {
            void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
        }, e.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
            },
            sow: function(t) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                    for (var e = 0; e < t.length && null != t[e]; e++) {
                        var i = t[e];
                        this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(t) {
                var e, i, s;
                for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)), e -= s = e >>> 0, s = (e *= s) >>> 0, s += 4294967296 * (e -= s);
                return 2.3283064365386963e-10 * (s >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t)
            },
            between: function(t, e) {
                return this.integerInRange(t, e)
            },
            realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var t = "",
                    e = "";
                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                return e
            },
            pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            },
            timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, e.RandomDataGenerator.prototype.constructor = e.RandomDataGenerator, e.QuadTree = function(t, e, i, s, n, r, a) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, r, a)
        }, e.QuadTree.prototype = {
            reset: function(t, e, i, s, n, r, a) {
                this.maxObjects = n || 10, this.maxLevels = r || 4, this.level = a || 0, this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: s,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(s / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(s / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            },
            populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            },
            split: function() {
                this.nodes[0] = new e.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new e.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new e.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new e.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            },
            insert: function(t) {
                var e, i = 0;
                if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                } else this.nodes[e].insert(t)
            },
            getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
            },
            retrieve: function(t) {
                if (t instanceof e.Rectangle) var i = this.objects,
                    s = this.getIndex(t);
                else {
                    if (!t.body) return this._empty;
                    var i = this.objects,
                        s = this.getIndex(t.body)
                }
                return this.nodes[0] && (i = -1 !== s ? i.concat(this.nodes[s].retrieve(t)) : (i = (i = (i = i.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), i
            },
            clear: function() {
                this.objects.length = 0;
                for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        }, e.QuadTree.prototype.constructor = e.QuadTree, e.TweenManager = function(t) {
            this.game = t, this._tweens = [], this._add = [], this.easeMap = {
                Power0: e.Easing.Power0,
                Power1: e.Easing.Power1,
                Power2: e.Easing.Power2,
                Power3: e.Easing.Power3,
                Power4: e.Easing.Power4,
                Linear: e.Easing.Linear.None,
                Quad: e.Easing.Quadratic.Out,
                Cubic: e.Easing.Cubic.Out,
                Quart: e.Easing.Quartic.Out,
                Quint: e.Easing.Quintic.Out,
                Sine: e.Easing.Sinusoidal.Out,
                Expo: e.Easing.Exponential.Out,
                Circ: e.Easing.Circular.Out,
                Elastic: e.Easing.Elastic.Out,
                Back: e.Easing.Back.Out,
                Bounce: e.Easing.Bounce.Out,
                "Quad.easeIn": e.Easing.Quadratic.In,
                "Cubic.easeIn": e.Easing.Cubic.In,
                "Quart.easeIn": e.Easing.Quartic.In,
                "Quint.easeIn": e.Easing.Quintic.In,
                "Sine.easeIn": e.Easing.Sinusoidal.In,
                "Expo.easeIn": e.Easing.Exponential.In,
                "Circ.easeIn": e.Easing.Circular.In,
                "Elastic.easeIn": e.Easing.Elastic.In,
                "Back.easeIn": e.Easing.Back.In,
                "Bounce.easeIn": e.Easing.Bounce.In,
                "Quad.easeOut": e.Easing.Quadratic.Out,
                "Cubic.easeOut": e.Easing.Cubic.Out,
                "Quart.easeOut": e.Easing.Quartic.Out,
                "Quint.easeOut": e.Easing.Quintic.Out,
                "Sine.easeOut": e.Easing.Sinusoidal.Out,
                "Expo.easeOut": e.Easing.Exponential.Out,
                "Circ.easeOut": e.Easing.Circular.Out,
                "Elastic.easeOut": e.Easing.Elastic.Out,
                "Back.easeOut": e.Easing.Back.Out,
                "Bounce.easeOut": e.Easing.Bounce.Out,
                "Quad.easeInOut": e.Easing.Quadratic.InOut,
                "Cubic.easeInOut": e.Easing.Cubic.InOut,
                "Quart.easeInOut": e.Easing.Quartic.InOut,
                "Quint.easeInOut": e.Easing.Quintic.InOut,
                "Sine.easeInOut": e.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": e.Easing.Exponential.InOut,
                "Circ.easeInOut": e.Easing.Circular.InOut,
                "Elastic.easeInOut": e.Easing.Elastic.InOut,
                "Back.easeInOut": e.Easing.Back.InOut,
                "Bounce.easeInOut": e.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, e.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(t, i) {
                void 0 === i && (i = !0);
                if (Array.isArray(t))
                    for (s = 0, n = t.length; s < n; s++) this.removeFrom(t[s]);
                else if (t.type === e.GROUP && i)
                    for (var s = 0, n = t.children.length; s < n; s++) this.removeFrom(t.children[s]);
                else {
                    for (s = 0, n = this._tweens.length; s < n; s++) t === this._tweens[s].target && this.remove(this._tweens[s]);
                    for (s = 0, n = this._add.length; s < n; s++) t === this._add[s].target && this.remove(this._add[s])
                }
            },
            add: function(t) {
                t._manager = this, this._add.push(t)
            },
            create: function(t) {
                return new e.Tween(t, this.game, this)
            },
            remove: function(t) {
                var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
            },
            update: function() {
                var t = this._add.length,
                    e = this._tweens.length;
                if (0 === e && 0 === t) return !1;
                for (var i = 0; i < e;) this._tweens[i].update(this.game.time.deltaTotal) ? i++ : (this._tweens.splice(i, 1), e--);
                return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(t, e) {
                return e || (e = !1), this._tweens.some(function(i) {
                    return i.target === t && (!e || i.isRunning && !i.pendingDelete)
                })
            },
            _pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
            },
            _resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
            },
            pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
            },
            resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
            },
            destroy: function() {
                this.game.onPause.remove(this._pauseAll, this), this.game.onResume.remove(this._resumeAll, this), this.game = null, this._add = null, this._tweens = null
            }
        }, e.TweenManager.prototype.constructor = e.TweenManager, e.Tween = function(t, i, s) {
            this.game = i, this.target = t, this.manager = s, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new e.Signal, this.onLoop = new e.Signal, this.onRepeat = new e.Signal, this.onChildComplete = new e.Signal, this.onComplete = new e.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, e.Tween.updateColor = function(t) {
            e.Color.updateColor(t.target)
        }, e.Tween.prototype = {
            to: function(t, i, s, n, r, a, o) {
                return (void 0 === i || i <= 0) && (i = 1e3), void 0 !== s && null !== s || (s = e.Easing.Default), void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === o && (o = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new e.TweenData(this).to(t, i, s, r, a, o)), n && this.start(), this)
            },
            from: function(t, i, s, n, r, a, o) {
                return void 0 === i && (i = 1e3), void 0 !== s && null !== s || (s = e.Easing.Default), void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === o && (o = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new e.TweenData(this).from(t, i, s, r, a, o)), n && this.start(), this)
            },
            start: function(t) {
                if (void 0 === t && (t = 0), this.pendingDelete) return console.warn("Phaser.Tween.start cannot be called after Tween.stop"), this;
                if (null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (i = 0; i < this.timeline.length; i++)
                    for (var e in this.timeline[i].vEnd) this.properties[e] = this.target[e] || 0, Array.isArray(this.properties[e]) || (this.properties[e] *= 1);
                for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
            },
            stop: function(t) {
                return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            },
            updateTweenData: function(t, e, i) {
                if (0 === this.timeline.length) return this;
                if (void 0 === i && (i = 0), -1 === i)
                    for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                else this.timeline[i][t] = e;
                return this
            },
            delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            },
            repeat: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatTotal", t, i), this.updateTweenData("repeatDelay", e, i)
            },
            repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            },
            yoyo: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
            },
            yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            },
            easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
            },
            interpolation: function(t, i, s) {
                return void 0 === i && (i = e.Math), this.updateTweenData("interpolationFunction", t, s), this.updateTweenData("interpolationContext", i, s)
            },
            repeatAll: function(t) {
                return void 0 === t && (t = 0), this.repeatCounter = t, this
            },
            chain: function() {
                for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            },
            loop: function(t) {
                return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
            },
            onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
            },
            pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.deltaTotal
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.deltaTotal)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.deltaTotal - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(t) {
                if (this.pendingDelete || !this.target) return !1;
                if (this.isPaused) return !0;
                var i = this.timeline[this.current].update(t);
                if (i === e.TweenData.PENDING) return !0;
                if (i === e.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if (i === e.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if (i === e.TweenData.COMPLETE) {
                    var s = !1;
                    return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, s = !0) : ++this.current === this.timeline.length && (this.current = 0, s = !0), s ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            },
            generateData: function(t, e) {
                if (null === this.game || null === this.target) return null;
                void 0 === t && (t = 60), void 0 === e && (e = []);
                for (s = 0; s < this.timeline.length; s++)
                    for (var i in this.timeline[s].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for (s = 0; s < this.timeline.length; s++) this.timeline[s].loadValues();
                for (var s = 0; s < this.timeline.length; s++) e = e.concat(this.timeline[s].generateData(t));
                return e
            }
        }, Object.defineProperty(e.Tween.prototype, "totalDuration", {
            get: function() {
                for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                return t
            }
        }), e.Tween.prototype.constructor = e.Tween, e.TweenData = function(t) {
            this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = e.Easing.Default, this.interpolationFunction = e.Math.linearInterpolation, this.interpolationContext = e.Math, this.isRunning = !1, this.isFrom = !1
        }, e.TweenData.PENDING = 0, e.TweenData.RUNNING = 1, e.TweenData.LOOPED = 2, e.TweenData.COMPLETE = 3, e.TweenData.prototype = {
            to: function(t, e, i, s, n, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !1, this
            },
            from: function(t, e, i, s, n, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !0, this
            },
            start: function() {
                if (this.startTime = this.game.time.deltaTotal + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                return this.value = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var t in this.parent.properties) {
                    if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                        if (0 === this.vEnd[t].length) continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t])), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                }
                return this
            },
            update: function(t) {
                if (this.isRunning) {
                    if (t < this.startTime) return e.TweenData.RUNNING
                } else {
                    if (!(t >= this.startTime)) return e.TweenData.PENDING;
                    this.isRunning = !0
                }
                var i = this.game.time.delta;
                this.parent.reverse ? (this.dt -= i * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += i * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                for (var s in this.vEnd) {
                    var n = this.vStart[s],
                        r = this.vEnd[s];
                    Array.isArray(r) ? this.parent.target[s] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[s] = n + (r - n) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : e.TweenData.RUNNING
            },
            generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = [],
                    i = !1,
                    s = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var n = {};
                    for (var r in this.vEnd) {
                        var a = this.vStart[r],
                            o = this.vEnd[r];
                        Array.isArray(o) ? n[r] = this.interpolationFunction.call(this.interpolationContext, o, this.value) : n[r] = a + (o - a) * this.value
                    }
                    e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while (!i);
                if (this.yoyo) {
                    var h = e.slice();
                    h.reverse(), e = e.concat(h)
                }
                return e
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        return this.inReverse = !1, e.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter) return e.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                else {
                    for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.deltaTotal, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, e.TweenData.LOOPED
            }
        }, e.TweenData.prototype.constructor = e.TweenData, e.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (.1, -1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4))
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (.1, 1 * Math.pow(2, -10 * t) * Math.sin((t - .1) * (2 * Math.PI) / .4) + 1)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (.1, (t *= 2) < 1 ? 1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4) * -.5 : 1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - .1) * (2 * Math.PI) / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                },
                Out: function(t) {
                    var e = 1.70158;
                    return --t * t * ((e + 1) * t + e) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(t) {
                    return 1 - e.Easing.Bounce.Out(1 - t)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(t) {
                    return t < .5 ? .5 * e.Easing.Bounce.In(2 * t) : .5 * e.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        }, e.Easing.Default = e.Easing.Linear.None, e.Easing.Power0 = e.Easing.Linear.None, e.Easing.Power1 = e.Easing.Quadratic.Out, e.Easing.Power2 = e.Easing.Cubic.Out, e.Easing.Power3 = e.Easing.Quartic.Out, e.Easing.Power4 = e.Easing.Quintic.Out, e.Time = function(t) {
            this.game = t, this.time = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.delta = 0, this.deltaTotal = 0, this.deltaMax = 200, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.updates = 0, this.renders = 0, this.fps = 0, this.ups = 0, this.rps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new e.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._timers = []
        }, e.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            },
            add: function(t) {
                return this._timers.push(t), t
            },
            create: function(t) {
                void 0 === t && (t = !0);
                var i = new e.Timer(this.game, t);
                return this._timers.push(i), i
            },
            removeAll: function() {
                for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t
            },
            update: function(t) {
                var e = this.time,
                    i = this.now;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.now = t, this.elapsed = this.now - i, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps + this.timeExpected - t)), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming()
            },
            updateTimers: function() {
                var t = 0,
                    e = this._timers.length;
                if (e)
                    for (; t < e;) this._timers[t].update(this.deltaTotal) ? t++ : (this._timers.splice(t, 1), e--)
            },
            updateAdvancedTiming: function() {
                if (this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3) {
                    var t = this.now - this._timeLastSecond;
                    this.fps = Math.round(1e3 * this.frames / t), this.ups = Math.round(1e3 * this.updates / t), this.rps = Math.round(1e3 * this.renders / t), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0, this.updates = 0, this.renders = 0
                }
            },
            preUpdate: function(t) {
                t *= 1e3, this.delta = t, this.deltaTotal += t, this.game.paused || (this.events.update(this.deltaTotal), this.updateTimers()), this.advancedTiming && this.updates++
            },
            preRender: function() {
                this.advancedTiming && this.renders++
            },
            gamePaused: function() {
                this._pauseStarted = Date.now()
            },
            gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(t) {
                return this.time - t
            },
            elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            },
            reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(e.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(t) {
                this._desiredFps = t, this.desiredFpsMult = 1 / t
            }
        }), Object.defineProperty(e.Time.prototype, "desiredMinFps", {
            get: function() {
                return 1e3 / this.deltaMax
            },
            set: function(t) {
                this.deltaMax = 1e3 / t
            }
        }), e.Time.prototype.constructor = e.Time, e.Timer = function(t, i) {
            void 0 === i && (i = !0), this.game = t, this.running = !1, this.autoDestroy = i, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new e.Signal, this.nextTick = 0, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = this.game.time ? this.game.time.deltaTotal : 0, this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, e.Timer.MINUTE = 6e4, e.Timer.SECOND = 1e3, e.Timer.HALF = 500, e.Timer.QUARTER = 250, e.Timer.prototype = {
            create: function(t, i, s, n, r, a) {
                var o = (t = Math.round(t)) + this._now,
                    h = new e.TimerEvent(this, t, o, s, i, n, r, a);
                return this.events.push(h), this.order(), this.expired = !1, h
            },
            add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(t, e, i, s) {
                return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            start: function(t) {
                if (!this.running) {
                    this._started = this.game.time.deltaTotal + (t || 0), this.running = !0;
                    for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                }
            },
            stop: function(t) {
                this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
            },
            remove: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                return !1
            },
            order: function() {
                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            },
            sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(t) {
                if (this.paused) return !0;
                if (this.elapsed = t - this._now, this._now = t, this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for (; this._i < this._len && this.running;) {
                        var e = this.events[this._i];
                        if (!(this._now >= e.tick) || e.pendingDelete) break;
                        this._newTick = this._now + e.delay - (this._now - e.tick), this._newTick < 0 && (this._newTick = this._now + e.delay), !0 === e.loop ? (e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : e.repeatCount > 0 ? (e.repeatCount--, e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : (this._marked++, e.pendingDelete = !0, e.callback.apply(e.callbackContext, e.args)), this._i++
                    }
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.deltaTotal, this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.deltaTotal, this.paused = !0)
            },
            adjustEvents: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) {
                        var i = this.events[e].tick - t;
                        i < 0 && (i = 0), this.events[e].tick = this._now + i
                    }
                var s = this.nextTick - t;
                this.nextTick = s < 0 ? this._now : this._now + s
            },
            resume: function() {
                if (this.paused) {
                    var t = this.game.time.deltaTotal;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.expired = !0, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(e.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(e.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(e.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(e.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(e.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), e.Timer.prototype.constructor = e.Timer, e.TimerEvent = function(t, e, i, s, n, r, a, o) {
            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = r, this.callbackContext = a, this.args = o, this.pendingDelete = !1
        }, e.TimerEvent.prototype.constructor = e.TimerEvent, e.AnimationManager = function(t) {
            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, e.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if (void 0 === t) return !1;
                if (this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(t);
                return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            copyFrameData: function(t, e) {
                if (this._frameData = t.clone(), this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            add: function(t, i, s, n, r) {
                return i = i || [], s = s || 60, void 0 === n && (n = !1), void 0 === r && (r = !(!i || "number" != typeof i[0])), this._outputFrames = [], this._frameData.getFrameIndexes(i, r, this._outputFrames), this._anims[t] = new e.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, s, n), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
            },
            validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for (var i = 0; i < t.length; i++)
                    if (!0 === e) {
                        if (t[i] > this._frameData.total) return !1
                    } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                return !0
            },
            play: function(t, e, i, s) {
                if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
            },
            stop: function(t, e) {
                void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
            },
            next: function(t) {
                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                t = null;
                for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, e.AnimationManager.prototype.constructor = e.AnimationManager, Object.defineProperty(e.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(e.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(e.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(t) {
                this.currentAnim.paused = t
            }
        }), Object.defineProperty(e.AnimationManager.prototype, "name", {
            get: function() {
                return this.currentAnim ? this.currentAnim.name : void 0
            }
        }), Object.defineProperty(e.AnimationManager.prototype, "frame", {
            get: function() {
                return this.currentFrame ? this.currentFrame.index : void 0
            },
            set: function(t) {
                var e;
                "number" == typeof t && this._frameData && (e = this._frameData.getFrame(t)) && (this.currentFrame = e, this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(e.AnimationManager.prototype, "frameName", {
            get: function() {
                return this.currentFrame ? this.currentFrame.name : void 0
            },
            set: function(t) {
                var e;
                "string" == typeof t && this._frameData && (e = this._frameData.getFrameByName(t)) ? (this.currentFrame = e, this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)) : console.warn("Cannot set frameName: " + t)
            }
        }), e.Animation = function(t, i, s, n, r, a, o) {
            void 0 === o && (o = !1), this.game = t, this._parent = i, this._frameData = n, this.name = s, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / a, this.loop = o, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new e.Signal, this.onUpdate = null, this.onComplete = new e.Signal, this.onLoop = new e.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, e.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.deltaTotal, this._timeNextFrame = this.game.time.deltaTotal + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
            },
            restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.deltaTotal, this._timeNextFrame = this.game.time.deltaTotal + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed, this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            },
            setFrame: function(t, e) {
                var i;
                if (void 0 === e && (e = !1), "string" == typeof t)
                    for (s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                else if ("number" == typeof t)
                    if (e) i = t;
                    else
                        for (var s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                if (i) {
                    var n = this.isReversed ? -1 : 1;
                    this._frameIndex = i - n, this._timeNextFrame = this.game.time.deltaTotal, this.update()
                }
            },
            stop: function(t, e) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.deltaTotal)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.deltaTotal + this._frameDiff)
            },
            update: function() {
                if (this.isPaused) return !1;
                var t = this.game.time.deltaTotal,
                    e = t - this._timeNextFrame;
                return !!(this.isPlaying && e >= 0) && (this._frameSkip = 1, this._frameDiff = e, this._timeLastFrame = t, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = t + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))
            },
            updateCurrentFrame: function(t, e) {
                if (void 0 === e && (e = !1), !this._frameData) return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            },
            next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(t) {
                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.updateCurrentFrame(!1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, e.Animation.prototype.constructor = e.Animation, Object.defineProperty(e.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(t) {
                this.isPaused = t, t ? this._pauseStartTime = this.game.time.deltaTotal : this.isPlaying && (this._timeNextFrame = this.game.time.deltaTotal + this.delay)
            }
        }), Object.defineProperty(e.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(t) {
                this.isReversed = t
            }
        }), Object.defineProperty(e.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(e.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(e.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(t) {
                t > 0 && (this.delay = 1e3 / t)
            }
        }), Object.defineProperty(e.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(t) {
                t && null === this.onUpdate ? this.onUpdate = new e.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), e.Animation.generateFrameNames = function(t, i, s, n, r) {
            void 0 === n && (n = "");
            var a = [],
                o = "";
            if (i < s)
                for (h = i; h <= s; h++) o = t + (o = "number" == typeof r ? e.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n, a.push(o);
            else
                for (var h = i; h >= s; h--) o = t + (o = "number" == typeof r ? e.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n, a.push(o);
            return a
        }, e.Frame = function(t, i, s, n, r, a) {
            this.index = t, this.x = i, this.y = s, this.width = n, this.height = r, 0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + a + '" has a width or height of zero'), this.name = a, this.centerX = Math.floor(n / 2), this.centerY = Math.floor(r / 2), this.distance = e.Math.distance(0, 0, n, r), this.rotated = !1, this.trimmed = !1, this.sourceSizeW = n, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, e.Frame.prototype = {
            resize: function(t, i) {
                this.width = t, this.height = i, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(i / 2), this.distance = e.Math.distance(0, 0, t, i), this.sourceSizeW = t, this.sourceSizeH = i, this.right = this.x + t, this.bottom = this.y + i
            },
            setTrim: function(t, e, i, s, n, r, a) {
                this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = a)
            },
            clone: function() {
                var t = new e.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for (var i in this) this.hasOwnProperty(i) && (t[i] = this[i]);
                return t
            },
            getRect: function(t) {
                return void 0 === t ? t = new e.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            }
        }, e.Frame.prototype.constructor = e.Frame, e.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, e.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
            },
            getFrame: function(t) {
                return t >= this._frames.length && (t = 0), this._frames[t]
            },
            getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            },
            checkFrameName: function(t) {
                return null != this._frameNames[t]
            },
            clone: function() {
                for (var t = new e.FrameData, i = 0; i < this._frames.length; i++) t._frames.push(this._frames[i].clone());
                for (var s in this._frameNames) this._frameNames.hasOwnProperty(s) && (t._frameNames[s] = this._frameNames[s]);
                return t
            },
            getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for (var s = t; s <= e; s++) i.push(this._frames[s]);
                return i
            },
            getFrames: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                else
                    for (var s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                return i
            },
            getFrameIndexes: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                else
                    for (var s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                return i
            },
            destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, e.FrameData.prototype.constructor = e.FrameData, Object.defineProperty(e.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), e.AnimationParser = {
            spriteSheet: function(t, i, s, n, r, a, o, h) {
                void 0 === r && (r = -1), void 0 === a && (a = 0), void 0 === o && (o = 0), void 0 === h && (h = 0);
                var l = i;
                if ("string" == typeof i ? l = t.cache.getImage(i) : i = l.name, null === l) return null;
                if (s <= 0 || n <= 0) return console.error('Spritesheet "%s": frameWidth (%s) and frameHeight (%s) values must be positive', i, s, n), null;
                var u = l.width,
                    c = l.height;
                if (0 === u || 0 === c) return console.error('Spritesheet "%s": Texture width (%s) or height (%s) is zero', i, u, c), null;
                if (u < s || c < n) return console.error('Spritesheet "%s": Texture width (%s) or height (%s) is less than the given frameWidth (%s) or frameHeight (%s)', i, u, c, s, n), null;
                var d = Math.floor((u - a) / (s + o)),
                    p = Math.floor((c - a) / (n + o)),
                    f = d * p,
                    m = f,
                    g = f - 1,
                    v = 0,
                    y = g;
                if (h > f || h < -f) return console.error('Spritesheet "%s": skipFrames=%s is larger than the frame total %s', i, h, f), null;
                if (r > -1 && (y = (f = r) - 1), d < 1 && console.warn('Spritesheet "%s": Texture has width %d, but it should be at least %d (frameWidth=%s, margin=%s, spacing=%s)', i, u, s + a + o, s, a, o), p < 1 && console.warn('Spritesheet "%s": Texture has height %d, but it should be at least %d (frameHeight=%s, margin=%s, spacing=%s)', i, c, n + a + o, n, a, o), 0 === m) return console.error('Spritesheet "%s": zero frames were produced', i), null;
                if (h > 0 ? y = (v = h) + (f = Math.min(f, m - h)) - 1 : h < 0 && (v = (y = g + h) - (f = Math.min(f, m + h)) + 1), v < 0) return console.error('Spritesheet "%s": There is no frame at index %s', i, v), null;
                if (y > g) return console.warn('Spritesheet "%s": There is no frame at index %s. Last frame found is index %s', i, y, g), null;
                for (var _ = new e.FrameData, x = a, b = a, T = 0, S = 0; S < m && !(S > y); S++) S >= v && _.addFrame(new e.Frame(T++, x, b, s, n, "")), (x += s + o) + s > u && (x = a, b += n + o);
                return _
            },
            JSONData: function(t, i) {
                if (!i.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(i);
                for (var s, n = new e.FrameData, r = i.frames, a = 0; a < r.length; a++) s = n.addFrame(new e.Frame(a, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, r[a].filename)), r[a].trimmed && s.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h), r[a].rotated && (s.rotated = !0);
                return n
            },
            JSONDataPyxel: function(t, i) {
                if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                        if (!i[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(i)
                    }), 1 !== i.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(i);
                for (var s = new e.FrameData, n = i.tileheight, r = i.tilewidth, a = i.layers[0].tiles, o = 0; o < a.length; o++) s.addFrame(new e.Frame(o, a[o].x, a[o].y, r, n, "frame_" + o)).setTrim(!1);
                return s
            },
            JSONDataHash: function(t, i) {
                if (!i.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(i);
                var s, n = new e.FrameData,
                    r = i.frames,
                    a = 0;
                for (var o in r) s = n.addFrame(new e.Frame(a, r[o].frame.x, r[o].frame.y, r[o].frame.w, r[o].frame.h, o)), r[o].trimmed && s.setTrim(r[o].trimmed, r[o].sourceSize.w, r[o].sourceSize.h, r[o].spriteSourceSize.x, r[o].spriteSourceSize.y, r[o].spriteSourceSize.w, r[o].spriteSourceSize.h), r[o].rotated && (s.rotated = !0), a++;
                return n
            },
            XMLData: function(t, i) {
                if (i.getElementsByTagName("TextureAtlas")) {
                    for (var s, n, r, a, o, h, l, u, c, d, p, f = new e.FrameData, m = i.getElementsByTagName("SubTexture"), g = 0; g < m.length; g++) n = (r = m[g].attributes).name.value, a = parseInt(r.x.value, 10), o = parseInt(r.y.value, 10), h = parseInt(r.width.value, 10), l = parseInt(r.height.value, 10), u = null, c = null, r.frameX && (u = Math.abs(parseInt(r.frameX.value, 10)), c = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)), s = f.addFrame(new e.Frame(g, a, o, h, l, n)), null === u && null === c || s.setTrim(!0, h, l, u, c, d, p);
                    return f
                }
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
            }
        }, e.Cache = function(t) {
            this.game = t, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {},
                compressedTexture: {},
                data: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new e.Signal, this._cacheMap = [], this._cacheMap[e.Cache.CANVAS] = this._cache.canvas, this._cacheMap[e.Cache.IMAGE] = this._cache.image, this._cacheMap[e.Cache.TEXTURE] = this._cache.texture, this._cacheMap[e.Cache.SOUND] = this._cache.sound, this._cacheMap[e.Cache.TEXT] = this._cache.text, this._cacheMap[e.Cache.PHYSICS] = this._cache.physics, this._cacheMap[e.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[e.Cache.BINARY] = this._cache.binary, this._cacheMap[e.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[e.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[e.Cache.JSON] = this._cache.json, this._cacheMap[e.Cache.XML] = this._cache.xml, this._cacheMap[e.Cache.VIDEO] = this._cache.video, this._cacheMap[e.Cache.SHADER] = this._cache.shader, this._cacheMap[e.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this._cacheMap[e.Cache.DATA] = this._cache.data, this._pendingCount = 0, this.onReady = new e.Signal, this._addImages()
        }, e.Cache.CANVAS = 1, e.Cache.IMAGE = 2, e.Cache.TEXTURE = 3, e.Cache.SOUND = 4, e.Cache.TEXT = 5, e.Cache.PHYSICS = 6, e.Cache.TILEMAP = 7, e.Cache.BINARY = 8, e.Cache.BITMAPDATA = 9, e.Cache.BITMAPFONT = 10, e.Cache.JSON = 11, e.Cache.XML = 12, e.Cache.VIDEO = 13, e.Cache.SHADER = 14, e.Cache.RENDER_TEXTURE = 15, e.Cache.DATA = 16, e.Cache.DEFAULT = null, e.Cache.DEFAULT_KEY = "__default", e.Cache.DEFAULT_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==", e.Cache.MISSING = null, e.Cache.MISSING_KEY = "__missing", e.Cache.MISSING_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==", e.Cache.READY_TIMEOUT = 1e3, e.Cache.prototype = {
            addCompressedTextureMetaData: function(t, i, s, n) {
                this.checkImageKey(t) && this.removeImage(t);
                var r = s in e.LoaderParser ? e.LoaderParser[s](n) : n,
                    a = {
                        key: t,
                        url: i,
                        data: r,
                        base: new PIXI.BaseTexture(r, null, this.game.resolution),
                        frame: new e.Frame(0, 0, 0, r.width, r.height, t),
                        frameData: new e.FrameData,
                        fileFormat: s
                    };
                return a.frameData.addFrame(new e.Frame(0, 0, 0, r.width, r.height, i)), this._cache.image[t] = a, this._resolveURL(i, a), a
            },
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                    canvas: e,
                    context: i
                }
            },
            addImage: function(t, i, s) {
                this.checkImageKey(t) && this.removeImage(t), !1 === s.complete && console.warn('Phaser.Cache.addImage: Image "%s" is not complete', t);
                var n = {
                    key: t,
                    url: i,
                    data: s,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution),
                    frame: new e.Frame(0, 0, 0, s.width, s.height, t),
                    frameData: new e.FrameData
                };
                return n.frameData.addFrame(new e.Frame(0, 0, 0, s.width, s.height, i)), this._cache.image[t] = n, this._resolveURL(i, n), "__default" === t ? e.Cache.DEFAULT = new PIXI.Texture(n.base) : "__missing" === t && (e.Cache.MISSING = new PIXI.Texture(n.base)), n
            },
            addImageAsync: function(t, e, i) {
                var s = this,
                    n = new Image;
                n.onload = function() {
                    i.call(this, s.addImage(t, null, n)), s._removePending(), n.onload = null
                }, this._addPending(), n.src = e
            },
            addDefaultImage: function() {
                this.addImageAsync(e.Cache.DEFAULT_KEY, e.Cache.DEFAULT_SRC, function(t) {
                    t.base.skipRender = !0, e.Cache.DEFAULT = new PIXI.Texture(t.base)
                })
            },
            addMissingImage: function() {
                this.addImageAsync(e.Cache.MISSING_KEY, e.Cache.MISSING_SRC, function(t) {
                    e.Cache.MISSING = new PIXI.Texture(t.base)
                })
            },
            addSound: function(t, e, i, s, n) {
                void 0 === s && (s = !0, n = !1), void 0 === n && (s = !1, n = !0);
                var r = !1;
                n && (r = !0), this._cache.sound[t] = {
                    url: e,
                    data: i,
                    isDecoding: !1,
                    decoded: r,
                    webAudio: s,
                    audioTag: n,
                    locked: this.game.sound.touchLocked
                }, this._resolveURL(e, this._cache.sound[t])
            },
            addText: function(t, e, i) {
                this._cache.text[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.text[t])
            },
            addPhysicsData: function(t, e, i, s) {
                this._cache.physics[t] = {
                    url: e,
                    data: i,
                    format: s
                }, this._resolveURL(e, this._cache.physics[t])
            },
            addTilemap: function(t, e, i, s) {
                this._cache.tilemap[t] = {
                    url: e,
                    data: i,
                    format: s
                }, this._resolveURL(e, this._cache.tilemap[t])
            },
            addBinary: function(t, e) {
                this._cache.binary[t] = e
            },
            addBitmapData: function(t, i, s) {
                return i.key = t, void 0 === s && (s = new e.FrameData).addFrame(i.textureFrame), this._cache.bitmapData[t] = {
                    data: i,
                    frameData: s
                }, i
            },
            addBitmapFont: function(t, i, s, n, r, a, o) {
                var h = {
                    url: i,
                    data: s,
                    font: null,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution)
                };
                void 0 === a && (a = 0), void 0 === o && (o = 0), h.font = "json" === r ? e.LoaderParser.jsonBitmapFont(n, h.base, a, o, !1, this.game.resolution) : e.LoaderParser.xmlBitmapFont(n, h.base, a, o, !1, this.game.resolution), this._cache.bitmapFont[t] = h, this._resolveURL(i, h)
            },
            addBitmapFontFromAtlas: function(t, i, s, n, r, a, o) {
                var h = this.getFrameByName(i, s);
                if (h) {
                    var l = {
                        font: null,
                        base: this.getBaseTexture(i),
                        frame: h
                    };
                    void 0 === a && (a = 0), void 0 === o && (o = 0);
                    var u;
                    "json" === r ? (u = this.getJSON(n), l.font = e.LoaderParser.jsonBitmapFont(u, l.base, a, o, h, this.game.resolution)) : (u = this.getXML(n), l.font = e.LoaderParser.xmlBitmapFont(u, l.base, a, o, h, this.game.resolution)), this._cache.bitmapFont[t] = l
                }
            },
            addJSON: function(t, e, i) {
                this._cache.json[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.json[t])
            },
            addXML: function(t, e, i) {
                this._cache.xml[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.xml[t])
            },
            addVideo: function(t, e, i, s) {
                this._cache.video[t] = {
                    url: e,
                    data: i,
                    isBlob: s,
                    locked: !0
                }, this._resolveURL(e, this._cache.video[t])
            },
            addShader: function(t, e, i) {
                this._cache.shader[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.shader[t])
            },
            addRenderTexture: function(t, i) {
                this._cache.renderTexture[t] = {
                    texture: i,
                    frame: new e.Frame(0, 0, 0, i.width, i.height, "", "")
                }
            },
            addSpriteSheet: function(t, i, s, n, r, a, o, h, l) {
                void 0 === a && (a = -1), void 0 === o && (o = 0), void 0 === h && (h = 0);
                var u = {
                    key: t,
                    url: i,
                    data: s,
                    frameWidth: n,
                    frameHeight: r,
                    margin: o,
                    spacing: h,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution),
                    frameData: e.AnimationParser.spriteSheet(this.game, s, n, r, a, o, h, l)
                };
                this._cache.image[t] = u, this._resolveURL(i, u)
            },
            addTextureAtlas: function(t, i, s, n, r) {
                var a = {
                    key: t,
                    url: i,
                    data: s,
                    base: new PIXI.BaseTexture(s, null, this.game.resolution)
                };
                r === e.Loader.TEXTURE_ATLAS_XML_STARLING ? a.frameData = e.AnimationParser.XMLData(this.game, n, t) : r === e.Loader.TEXTURE_ATLAS_JSON_PYXEL ? a.frameData = e.AnimationParser.JSONDataPyxel(this.game, n, t) : Array.isArray(n.frames) ? a.frameData = e.AnimationParser.JSONData(this.game, n, t) : a.frameData = e.AnimationParser.JSONDataHash(this.game, n, t), this._cache.image[t] = a, this._resolveURL(i, a)
            },
            addData: function(t, e) {
                this._cache.data[t] = e
            },
            reloadSound: function(t) {
                var e = this,
                    i = this.getSound(t);
                i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                    return e.reloadSoundComplete(t)
                }, !1), i.data.load())
            },
            reloadSoundComplete: function(t) {
                var e = this.getSound(t);
                e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
            },
            updateSound: function(t, e, i) {
                var s = this.getSound(t);
                s && (s[e] = i)
            },
            decodedSound: function(t, e) {
                var i = this.getSound(t);
                i.data = e, i.decoded = !0, i.isDecoding = !1
            },
            isSoundDecoded: function(t) {
                var i = this.getItem(t, e.Cache.SOUND, "isSoundDecoded");
                if (i) return i.decoded
            },
            isSoundReady: function(t) {
                var i = this.getItem(t, e.Cache.SOUND, "isSoundDecoded");
                if (i) return i.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            },
            checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            },
            checkCanvasKey: function(t) {
                return this.checkKey(e.Cache.CANVAS, t)
            },
            checkDataKey: function(t) {
                return this.checkKey(e.Cache.DATA, t)
            },
            checkImageKey: function(t) {
                return this.checkKey(e.Cache.IMAGE, t)
            },
            checkTextureKey: function(t) {
                return this.checkKey(e.Cache.TEXTURE, t)
            },
            checkSoundKey: function(t) {
                return this.checkKey(e.Cache.SOUND, t)
            },
            checkTextKey: function(t) {
                return this.checkKey(e.Cache.TEXT, t)
            },
            checkPhysicsKey: function(t) {
                return this.checkKey(e.Cache.PHYSICS, t)
            },
            checkTilemapKey: function(t) {
                return this.checkKey(e.Cache.TILEMAP, t)
            },
            checkBinaryKey: function(t) {
                return this.checkKey(e.Cache.BINARY, t)
            },
            checkBitmapDataKey: function(t) {
                return this.checkKey(e.Cache.BITMAPDATA, t)
            },
            checkBitmapFontKey: function(t) {
                return this.checkKey(e.Cache.BITMAPFONT, t)
            },
            checkJSONKey: function(t) {
                return this.checkKey(e.Cache.JSON, t)
            },
            checkXMLKey: function(t) {
                return this.checkKey(e.Cache.XML, t)
            },
            checkVideoKey: function(t) {
                return this.checkKey(e.Cache.VIDEO, t)
            },
            checkShaderKey: function(t) {
                return this.checkKey(e.Cache.SHADER, t)
            },
            checkRenderTextureKey: function(t) {
                return this.checkKey(e.Cache.RENDER_TEXTURE, t)
            },
            getItem: function(t, e, i, s) {
                return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
            },
            getCanvas: function(t) {
                return this.getItem(t, e.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(t, i) {
                void 0 !== t && null !== t || (t = "__default"), void 0 === i && (i = !1);
                var s = this.getItem(t, e.Cache.IMAGE, "getImage");
                return null === s && (s = this.getItem("__missing", e.Cache.IMAGE, "getImage")), i ? s : s.data
            },
            getTextureFrame: function(t) {
                return this.getItem(t, e.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(t) {
                return this.getItem(t, e.Cache.SOUND, "getSound")
            },
            getSoundData: function(t) {
                return this.getItem(t, e.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(t) {
                return this.getItem(t, e.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(t, i, s) {
                var n = this.getItem(t, e.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === n || void 0 === i || null === i) return n;
                if (n[i]) {
                    var r = n[i];
                    if (!r || !s) return r;
                    for (var a in r)
                        if ((a = r[a]).fixtureKey === s) return a;
                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + s + " in " + t + '"')
                } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + i + '"');
                return null
            },
            getTilemapData: function(t) {
                return this.getItem(t, e.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(t) {
                return this.getItem(t, e.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(t) {
                return this.getItem(t, e.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(t) {
                return this.getItem(t, e.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(t, i) {
                var s = this.getItem(t, e.Cache.JSON, "getJSON", "data");
                return s ? i ? e.Utils.extend(!0, Array.isArray(s) ? [] : {}, s) : s : null
            },
            getXML: function(t) {
                return this.getItem(t, e.Cache.XML, "getXML", "data")
            },
            getVideo: function(t) {
                return this.getItem(t, e.Cache.VIDEO, "getVideo")
            },
            getShader: function(t) {
                return this.getItem(t, e.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(t) {
                return this.getItem(t, e.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getData: function(t) {
                return this.getItem(t, e.Cache.DATA, "getData")
            },
            getBaseTexture: function(t, i) {
                return void 0 === i && (i = e.Cache.IMAGE), this.getItem(t, i, "getBaseTexture", "base")
            },
            getFrame: function(t, i) {
                return void 0 === i && (i = e.Cache.IMAGE), this.getItem(t, i, "getFrame", "frame")
            },
            getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            },
            getFrameData: function(t, i) {
                return void 0 === i && (i = e.Cache.IMAGE), this.getItem(t, i, "getFrameData", "frameData")
            },
            hasFrameData: function(t, i) {
                return void 0 === i && (i = e.Cache.IMAGE), null !== this.getItem(t, i, "", "frameData")
            },
            updateFrameData: function(t, i, s) {
                void 0 === s && (s = e.Cache.IMAGE), this._cacheMap[s][t] && (this._cacheMap[s][t].frameData = i)
            },
            getFrameByIndex: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrame(e) : null
            },
            getFrameByName: function(t, e, i) {
                var s = this.getFrameData(t, i);
                return s ? s.getFrameByName(e) : null
            },
            getURL: function(t) {
                return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
            },
            getKeys: function(t) {
                void 0 === t && (t = e.Cache.IMAGE);
                var i = [];
                if (this._cacheMap[t])
                    for (var s in this._cacheMap[t]) "__default" !== s && "__missing" !== s && i.push(s);
                return i
            },
            removeCanvas: function(t) {
                delete this._cache.canvas[t]
            },
            removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t]
            },
            removeSound: function(t) {
                delete this._cache.sound[t]
            },
            removeText: function(t) {
                delete this._cache.text[t]
            },
            removePhysics: function(t) {
                delete this._cache.physics[t]
            },
            removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            },
            removeBinary: function(t) {
                delete this._cache.binary[t]
            },
            removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            },
            removeBitmapFont: function(t) {
                delete this._cache.bitmapFont[t]
            },
            removeJSON: function(t) {
                delete this._cache.json[t]
            },
            removeXML: function(t) {
                delete this._cache.xml[t]
            },
            removeVideo: function(t) {
                delete this._cache.video[t]
            },
            removeShader: function(t) {
                delete this._cache.shader[t]
            },
            removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            },
            removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            },
            removeTextureAtlas: function(t) {
                delete this._cache.image[t]
            },
            removeData: function(t) {
                delete this._cache.data[t]
            },
            clearGLTextures: function() {
                for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
            },
            _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
            },
            destroy: function() {
                for (var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for (var i in e) "__default" !== i && "__missing" !== i && (this.destroyItem(e[i]), delete e[i])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            },
            destroyItem: function(t) {
                t.destroy ? t.destroy() : (t.base && t.base.destroy && t.base.destroy(), t.data && t.data.destroy && t.data.destroy(), t.frameData && t.frameData.destroy && t.frameData.destroy(), t.texture && t.texture.destroy && t.texture.destroy(!0))
            },
            _addImages: function() {
                this._pendingCount = 0, this.addDefaultImage(), this.addMissingImage();
                var t = this,
                    i = e.Cache.READY_TIMEOUT;
                e.Cache.READY_TIMEOUT > 0 ? setTimeout(function() {
                    t.isReady || (console.warn("Phaser.Cache: Still waiting for images after %s ms.", i), t._ready())
                }, e.Cache.READY_TIMEOUT) : this._ready()
            },
            _addPending: function() {
                this._pendingCount += 1
            },
            _removePending: function() {
                this._pendingCount -= 1, this._checkReady()
            },
            _checkReady: function() {
                this.isReady && this._ready()
            },
            _ready: function() {
                this._pendingCount = 0, this.onReady.dispatch(this)
            }
        }, e.Cache.prototype.constructor = e.Cache, Object.defineProperty(e.Cache.prototype, "isReady", {
            get: function() {
                return this._pendingCount <= 0
            }
        }), e.Loader = function(t) {
            this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new e.Signal, this.onBeforeLoadComplete = new e.Signal, this.onLoadComplete = new e.Signal, this.onPackComplete = new e.Signal, this.onFileStart = new e.Signal, this.onFileComplete = new e.Signal, this.onFileError = new e.Signal, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, e.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, e.Loader.TEXTURE_ATLAS_JSON_HASH = 1, e.Loader.TEXTURE_ATLAS_XML_STARLING = 2, e.Loader.PHYSICS_LIME_CORONA_JSON = 3, e.Loader.PHYSICS_PHASER_JSON = 4, e.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, e.Loader.mediaTypes = {
            avif: "image/avif",
            bmp: "image/bmp",
            cur: "image/x-icon",
            gif: "image/gif",
            ico: "image/x-icon",
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            png: "image/png",
            svg: "image/svg+xml",
            tif: "image/tiff",
            tiff: "image/tiff",
            webp: "image/webp"
        }, e.Loader.getMediaType = function(t) {
            var i = t.match(/\.(\w+)$/);
            return i ? e.Loader.mediaTypes[i[1]] || null : null
        }, e.Loader._getSource = function(t) {
            return "string" == typeof t ? {
                url: t,
                type: e.Loader.getMediaType(t)
            } : t
        }, e.Loader.prototype = {
            setPreloadSprite: function(t, i) {
                i = i || 0, this.preloadSprite = {
                    sprite: t,
                    direction: i,
                    width: t.width,
                    height: t.height,
                    rect: null
                }, this.preloadSprite.rect = 0 === i ? new e.Rectangle(0, 0, 1, t.height) : new e.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(t, e) {
                return this.getAssetIndex(t, e) > -1
            },
            getAssetIndex: function(t, e) {
                for (var i = -1, s = 0; s < this._fileList.length; s++) {
                    var n = this._fileList[s];
                    if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
                }
                return i
            },
            getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return i > -1 && {
                    index: i,
                    file: this._fileList[i]
                }
            },
            reset: function(t, e) {
                void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            },
            addToFileList: function(t, e, i, s, n, r) {
                if (void 0 === n && (n = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                if (void 0 === i || null === i) {
                    if (!r) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                    i = e + r
                }
                var a = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: this._withSyncPointDepth > 0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (s)
                    for (var o in s) a[o] = s[o];
                var h = this.getAssetIndex(t, e);
                if (n && h > -1) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(a), this._totalFileCount++) : this._fileList[h] = a
                } else -1 === h && (this._fileList.push(a), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(t, e, i, s) {
                return this.addToFileList(t, e, i, s, !0)
            },
            pack: function(t, e, i, s) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                var n = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: s
                };
                i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
                for (var r = 0; r < this._fileList.length + 1; r++) {
                    var a = this._fileList[r];
                    if (!a || !a.loaded && !a.loading && "packfile" !== a.type) {
                        this._fileList.splice(r, 0, n), this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(t, e, i) {
                return Array.isArray(e) ? this.imageset(t, e, i) : "object" == typeof e ? this.texture(t, e, i) : this.addToFileList("image", t, e, void 0, i, ".png")
            },
            imageset: function(t, e, i) {
                var s = e[e.length - 1],
                    n = "string" == typeof s ? s : s.url;
                return this.addToFileList("imageset", t, n, {
                    sources: e
                }, i)
            },
            imageFromBitmapData: function(t, e, i) {
                return this.image(t, e.canvas.toDataURL("image/png"), i)
            },
            imageFromGrid: function(t, e, i, s, n, r) {
                return this.imageFromBitmapData(t, this.game.create.grid(t, e, i, s, n, r, !1))
            },
            imageFromTexture: function(t, e, i, s, n) {
                return this.imageFromBitmapData(t, this.game.create.texture(t, e, i, s, n, !1))
            },
            texture: function(t, i, s) {
                if (this.game.renderType === e.WEBGL) {
                    var n, r = this.game.renderer.extensions.compression;
                    for (n in i)
                        if (n.toUpperCase() in r) return this.addToFileList("texture", t, i[n], void 0, s, ".pvr")
                }
                return i.truecolor && this.addToFileList("image", t, i.truecolor, void 0, s, ".png"), this
            },
            images: function(t, e) {
                if (Array.isArray(e))
                    for (i = 0; i < t.length; i++) this.image(t[i], e[i]);
                else
                    for (var i = 0; i < t.length; i++) this.image(t[i]);
                return this
            },
            text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            },
            json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            },
            shader: function(t, e, i) {
                return this.addToFileList("shader", t, e, void 0, i, ".frag")
            },
            xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            },
            script: function(t, e, i, s) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: s
                }, !1, ".js")
            },
            binary: function(t, e, i, s) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: s
                }, !1, ".bin")
            },
            spritesheet: function(t, e, i, s, n, r, a, o) {
                return void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === o && (o = 0), this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: s,
                    frameMax: n,
                    margin: r,
                    spacing: a,
                    skipFrames: o
                }, !1, ".png")
            },
            audio: function(t, e, i) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                    buffer: null,
                    autoDecode: i
                }))
            },
            audioSprite: function(t, e, i, s, n) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
            },
            audiosprite: function(t, e, i, s, n) {
                return this.audioSprite(t, e, i, s, n)
            },
            video: function(t, e, i, s) {
                return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                    buffer: null,
                    asBlob: s,
                    loadEvent: i
                })
            },
            tilemap: function(t, i, s, n) {
                if (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = e.Tilemap.CSV), i || s || (i = n === e.Tilemap.CSV ? t + ".csv" : t + ".json"), s) {
                    switch (n) {
                        case e.Tilemap.CSV:
                            break;
                        case e.Tilemap.TILED_JSON:
                            "string" == typeof s && (s = JSON.parse(s))
                    }
                    this.cache.addTilemap(t, null, s, n)
                } else this.addToFileList("tilemap", t, i, {
                    format: n
                });
                return this
            },
            tilemapCSV: function(t, i, s) {
                return this.tilemap(t, i, s, e.Tilemap.CSV)
            },
            tilemapTiledJSON: function(t, i, s) {
                return this.tilemap(t, i, s, e.Tilemap.TILED_JSON)
            },
            physics: function(t, i, s, n) {
                return void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = e.Physics.LIME_CORONA_JSON), i || s || (i = t + ".json"), s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addPhysicsData(t, null, s, n)) : this.addToFileList("physics", t, i, {
                    format: n
                }), this
            },
            bitmapFont: function(t, e, i, s, n, r) {
                if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                    atlasURL: i,
                    xSpacing: n,
                    ySpacing: r
                });
                else if ("string" == typeof s) {
                    var a, o;
                    try {
                        a = JSON.parse(s)
                    } catch (t) {
                        o = this.parseXml(s)
                    }
                    if (!o && !a) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: a || o,
                        atlasType: a ? "json" : "xml",
                        xSpacing: n,
                        ySpacing: r
                    })
                }
                return this
            },
            atlasJSONArray: function(t, i, s, n) {
                return this.atlas(t, i, s, n, e.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(t, i, s, n) {
                return this.atlas(t, i, s, n, e.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(t, i, s, n) {
                return void 0 === s && (s = null), void 0 === n && (n = null), s || n || (s = t + ".xml"), this.atlas(t, i, s, n, e.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(t, i, s, n, r) {
                if (void 0 !== i && null !== i || (i = t + ".png"), void 0 === s && (s = null), void 0 === n && (n = null), void 0 === r && (r = e.Loader.TEXTURE_ATLAS_JSON_ARRAY), s || n || (s = r === e.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), s) this.addToFileList("textureatlas", t, i, {
                    atlasURL: s,
                    format: r
                });
                else {
                    switch (r) {
                        case e.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof n && (n = JSON.parse(n));
                            break;
                        case e.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof n) {
                                var a = this.parseXml(n);
                                if (!a) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                n = a
                            }
                    }
                    this.addToFileList("textureatlas", t, i, {
                        atlasURL: null,
                        atlasData: n,
                        format: r
                    })
                }
                return this
            },
            withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0), this
            },
            removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (this.game.isBooted) {
                    if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                    for (i = 0; i < this._flightQueue.length; i++)((s = this._flightQueue[i]).loaded || s.error) && (this._flightQueue.splice(i, 1), i--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)));
                    for (var t = !1, e = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1, i = this._processingHead; i < this._fileList.length; i++) {
                        var s = this._fileList[i];
                        if ("packfile" === s.type && !s.error && s.loaded && i === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? i === this._processingHead && (this._processingHead = i + 1) : !s.loading && this._flightQueue.length < e && ("packfile" !== s.type || s.data ? t || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (t = !0), this._flightQueue.length >= e || t && this._loadedPackCount === this._totalPackCount) break
                    }
                    if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                    else if (!this._flightQueue.length) {
                        console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                        var n = this;
                        setTimeout(function() {
                            n.finishedLoading(!0)
                        }, 2e3)
                    }
                }
            },
            finishedLoading: function(t) {
                !this.hasLoaded && this.game.state && (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.game.state.loadUpdate(), this.onBeforeLoadComplete.dispatch(), this.reset(), this.onLoadComplete.dispatch(), this.game.state.loadComplete())
            },
            asyncComplete: function(t, e) {
                void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
            },
            processPack: function(t) {
                var i = t.data[t.key];
                if (i)
                    for (var s = 0; s < i.length; s++) {
                        var n = i[s];
                        switch (n.type) {
                            case "image":
                                this.image(n.key, n.url, n.overwrite);
                                break;
                            case "text":
                                this.text(n.key, n.url, n.overwrite);
                                break;
                            case "json":
                                this.json(n.key, n.url, n.overwrite);
                                break;
                            case "xml":
                                this.xml(n.key, n.url, n.overwrite);
                                break;
                            case "script":
                                this.script(n.key, n.url, n.callback, t.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(n.key, n.url, n.callback, t.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(n.key, n.url, n.frameWidth, n.frameHeight, n.frameMax, n.margin, n.spacing, n.skipFrames);
                                break;
                            case "video":
                                this.video(n.key, n.urls);
                                break;
                            case "audio":
                                this.audio(n.key, n.urls, n.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(n.key, n.urls, n.jsonURL, n.jsonData, n.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(n.key, n.url, n.data, e.Tilemap[n.format]);
                                break;
                            case "physics":
                                this.physics(n.key, n.url, n.data, e.Loader[n.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(n.key, n.textureURL, n.atlasURL, n.atlasData, n.xSpacing, n.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                break;
                            case "atlas":
                                this.atlas(n.key, n.textureURL, n.atlasURL, n.atlasData, e.Loader[n.format]);
                                break;
                            case "shader":
                                this.shader(n.key, n.url, n.overwrite)
                        }
                    } else console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key")
            },
            transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            },
            loadFile: function(t) {
                switch (t.type) {
                    case "packfile":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(t);
                        break;
                    case "imageset":
                        this.loadPictureTag(t);
                        break;
                    case "audio":
                        t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        t.format === e.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === e.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "texture":
                        "truecolor" === t.key.split("_").pop() ? this.loadImageTag(t) : this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(t) {
                var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            },
            loadPictureTag: function(t) {
                for (var i = this, s = document.createElement("picture"), n = t.sources, r = e.Loader._getSource(n.pop()), a = 0, o = n.length; a < o; a++) {
                    var h = e.Loader._getSource(n[a]);
                    h.type && h.url || console.warn('Skipping an invalid source for image "%s" (url: "%s", type: "%s")', t.key, h.url, h.type);
                    var l = document.createElement("source");
                    l.setAttribute("type", h.type), l.setAttribute("srcset", this.transformUrl(h.url, t)), s.appendChild(l)
                }
                t.data = document.createElement("img"), t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, t.url = t.data.currentSrc, i.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, t.url = t.data.currentSrc, i.fileError(t))
                }, s.appendChild(t.data), t.data.src = this.transformUrl(r.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            },
            loadVideoTag: function(t) {
                var i = this;
                t.data = document.createElement("video"), t.data.name = t.key, t.data.crossOrigin = this.crossOrigin, t.data.controls = !1, t.data.autoplay = !1, t.data.playsInline = !0;
                var s = function() {
                    t.data.removeEventListener(t.loadEvent, s, !1), t.data.onerror = null, t.data.canplay = !0, e.GAMES[i.game.id].load.fileComplete(t)
                };
                t.data.onerror = function() {
                    t.data.removeEventListener(t.loadEvent, s, !1), t.data.onerror = null, t.data.canplay = !1, i.fileError(t)
                }, t.data.addEventListener(t.loadEvent, s, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
            },
            loadAudioTag: function(t) {
                var e = this;
                if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                else {
                    t.data = new Audio, t.data.name = t.key;
                    var i = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                    }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                }
            },
            xhrLoad: function(t, e, i, s, n) {
                var r = new XMLHttpRequest;
                r.open("GET", e, !0), r.responseType = i, !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]), n = n || this.fileError;
                var a = this;
                r.onload = function() {
                    try {
                        return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? n.call(a, t, r) : s.call(a, t, r)
                    } catch (e) {
                        a.hasLoaded ? console.error(e) : a.asyncComplete(t, e.message || "Exception")
                    }
                }, r.onerror = function() {
                    try {
                        return n.call(a, t, r)
                    } catch (e) {
                        a.hasLoaded ? console.error(e) : a.asyncComplete(t, e.message || "Exception")
                    }
                }, t.requestObject = r, t.requestUrl = e, r.send()
            },
            getVideoURL: function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                        if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                    }
                }
                return null
            },
            getAudioURL: function(t) {
                if (this.game.sound.noAudio) return null;
                for (var e = 0; e < t.length; e++) {
                    var i, s = t[e];
                    if (s.uri) {
                        if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                    } else {
                        if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                        if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                    }
                }
                return null
            },
            fileError: function(t, e, i) {
                var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
            },
            fileComplete: function(t, i) {
                if (this.game.isBooted) {
                    var s = !0;
                    switch (t.type) {
                        case "packfile":
                            r = JSON.parse(i.responseText);
                            t.data = r || {};
                            break;
                        case "texture":
                            var n = /\.([^.]+)$/.exec(t.url.split("?", 1)[0])[1].toLowerCase();
                            null !== t.data ? this.cache.addCompressedTextureMetaData(t.key, t.url, n, t.data) : this.cache.addCompressedTextureMetaData(t.key, t.url, n, i.response);
                            break;
                        case "image":
                        case "imageset":
                            this.cache.addImage(t.key, t.url, t.data);
                            break;
                        case "spritesheet":
                            this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing, t.skipFrames);
                            break;
                        case "textureatlas":
                            if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                            else if (s = !1, t.format === e.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === e.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === e.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                            else {
                                if (t.format !== e.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                                this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                            }
                            break;
                        case "bitmapfont":
                            t.atlasURL ? (s = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                                var i;
                                try {
                                    i = JSON.parse(e.responseText)
                                } catch (t) {}
                                i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                            })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                            break;
                        case "video":
                            if (t.asBlob) try {
                                t.data = i.response
                            } catch (e) {
                                throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                            }
                            this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                            break;
                        case "audio":
                            this.game.sound.usingWebAudio ? (t.data = i.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                            break;
                        case "text":
                            t.data = i.responseText, this.cache.addText(t.key, t.url, t.data);
                            break;
                        case "shader":
                            t.data = i.responseText, this.cache.addShader(t.key, t.url, t.data);
                            break;
                        case "physics":
                            var r = JSON.parse(i.responseText);
                            this.cache.addPhysicsData(t.key, t.url, r, t.format);
                            break;
                        case "script":
                            t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = i.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, i.responseText));
                            break;
                        case "binary":
                            t.callback ? t.data = t.callback.call(t.callbackContext, t.key, i.response) : t.data = i.response, this.cache.addBinary(t.key, t.data)
                    }
                    s && this.asyncComplete(t)
                }
            },
            jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
            },
            csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
            },
            xmlLoadComplete: function(t, e) {
                var i = e.responseText,
                    s = this.parseXml(i);
                if (!s) {
                    var n = e.responseType || e.contentType;
                    return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"), void this.asyncComplete(t, "invalid XML")
                }
                "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
            },
            parseXml: function(t) {
                var e;
                try {
                    if (window.DOMParser) {
                        var i = new DOMParser;
                        e = i.parseFromString(t, "text/xml")
                    } else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
                } catch (t) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        }, Object.defineProperty(e.Loader.prototype, "progressFloat", {
            get: function() {
                var t = this._loadedFileCount / this._totalFileCount * 100;
                return e.Math.clamp(t || 0, 0, 100)
            }
        }), Object.defineProperty(e.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }), e.Loader.prototype.constructor = e.Loader, e.LoaderParser = {
            bitmapFont: function(t, e, i, s, n, r) {
                return this.xmlBitmapFont(t, e, i, s, n, r)
            },
            xmlBitmapFont: function(t, e, i, s, n, r) {
                null == r && (r = 1);
                var a = {},
                    o = t.getElementsByTagName("info")[0],
                    h = t.getElementsByTagName("common")[0];
                a.font = o.getAttribute("face"), a.size = parseInt(o.getAttribute("size"), 10), a.lineHeight = parseInt(h.getAttribute("lineHeight"), 10) + s, a.chars = {};
                for (var l = t.getElementsByTagName("char"), u = n ? n.x : 0, c = n ? n.y : 0, d = 0; d < l.length; d++) {
                    var p = parseInt(l[d].getAttribute("id"), 10),
                        f = a.chars[p] = {
                            x: parseInt(l[d].getAttribute("x"), 10),
                            y: parseInt(l[d].getAttribute("y"), 10),
                            width: parseInt(l[d].getAttribute("width"), 10),
                            height: parseInt(l[d].getAttribute("height"), 10),
                            xOffset: parseInt(l[d].getAttribute("xoffset"), 10) / r,
                            yOffset: parseInt(l[d].getAttribute("yoffset"), 10) / r,
                            xAdvance: (parseInt(l[d].getAttribute("xadvance"), 10) + i) / r,
                            kerning: {}
                        };
                    if (n && n.trimmed) {
                        if (f.x + f.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (f.width -= f.x + f.width - n.spriteSourceSizeX - n.spriteSourceSizeW), f.y + f.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (f.height -= f.y + f.height - n.spriteSourceSizeY - n.spriteSourceSizeH), f.x < n.spriteSourceSizeX) {
                            m = n.spriteSourceSizeX - f.x;
                            f.x = 0, f.width -= m, f.xOffset += m
                        }
                        if (f.y < n.spriteSourceSizeY) {
                            var m = n.spriteSourceSizeY - f.y;
                            f.y = 0, f.height -= m, f.yOffset += m
                        }
                    }
                    f.x += u, f.y += c
                }
                var g = t.getElementsByTagName("kerning");
                for (d = 0; d < g.length; d++) {
                    var v = parseInt(g[d].getAttribute("first"), 10),
                        y = parseInt(g[d].getAttribute("second"), 10),
                        _ = parseInt(g[d].getAttribute("amount"), 10) / r;
                    a.chars[y] && (a.chars[y].kerning[v] = _)
                }
                return this.finalizeBitmapFont(e, a)
            },
            jsonBitmapFont: function(t, e, i, s, n, r) {
                null == r && (r = 1);
                var a = {
                        font: t.font.info._face,
                        size: parseInt(t.font.info._size, 10),
                        lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                        chars: {}
                    },
                    o = n ? n.x : 0,
                    h = n ? n.y : 0;
                return t.font.chars.char.forEach(function(t) {
                    var e = parseInt(t._id, 10),
                        s = a.chars[e] = {
                            x: parseInt(t._x, 10),
                            y: parseInt(t._y, 10),
                            width: parseInt(t._width, 10),
                            height: parseInt(t._height, 10),
                            xOffset: parseInt(t._xoffset, 10) / r,
                            yOffset: parseInt(t._yoffset, 10) / r,
                            xAdvance: (parseInt(t._xadvance, 10) + i) / r,
                            kerning: {}
                        };
                    if (n && n.trimmed) {
                        if (s.x + s.width > n.spriteSourceSizeX + n.spriteSourceSizeW && (s.width -= s.x + s.width - n.spriteSourceSizeX - n.spriteSourceSizeW), s.y + s.height > n.spriteSourceSizeY + n.spriteSourceSizeH && (s.height -= s.y + s.height - n.spriteSourceSizeY - n.spriteSourceSizeH), s.x < n.spriteSourceSizeX) {
                            l = n.spriteSourceSizeX - s.x;
                            s.x = 0, s.width -= l, s.xOffset += l
                        }
                        if (s.y < n.spriteSourceSizeY) {
                            var l = n.spriteSourceSizeY - s.y;
                            s.y = 0, s.height -= l, s.yOffset += l
                        }
                    }
                    s.x += o, s.y += h
                }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    a.chars[t._second] && (a.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) / r)
                }), this.finalizeBitmapFont(e, a)
            },
            finalizeBitmapFont: function(t, i) {
                return Object.keys(i.chars).forEach(function(s) {
                    var n = i.chars[s];
                    n.texture = new PIXI.Texture(t, new e.Rectangle(n.x, n.y, n.width, n.height))
                }), i
            },
            pvr: function(t) {
                var e, i = new Uint32Array(t.slice(0, 52)),
                    s = new Uint8Array(t),
                    n = null,
                    r = i[3] << 32 | i[2],
                    a = 0;
                if (55727696 === i[0] && [0, 1, 2, 3, 6, 7, 9, 11].indexOf(r) >= 0) {
                    switch (r >= 0 && r <= 3 ? e = "PVRTC" : r >= 7 && r <= 11 ? e = "S3TC" : 6 === r && (e = "ETC1"), r) {
                        case 0:
                            a = 35841;
                            break;
                        case 1:
                            a = 35843;
                            break;
                        case 2:
                            a = 35840;
                            break;
                        case 3:
                            a = 35842;
                            break;
                        case 6:
                            a = 36196;
                            break;
                        case 7:
                            a = 33777;
                            break;
                        case 9:
                            a = 33778;
                            break;
                        case 11:
                            a = 33779;
                            break;
                        default:
                            a = -1
                    }
                    n = {
                        complete: !0,
                        fileFormat: "PVR",
                        compressionAlgorithm: e,
                        flags: i[1],
                        pixelFormat: r,
                        colorSpace: i[4],
                        channelType: i[5],
                        height: i[6],
                        width: i[7],
                        depth: i[8],
                        numberOfSurfaces: i[9],
                        numberOfFaces: i[10],
                        numberOfMipmaps: i[11],
                        metaDataSize: i[12],
                        textureData: s.subarray(52 + i[12], s.byteLength),
                        glExtensionFormat: a
                    }
                }
                return n
            },
            dds: function(t) {
                var e = new Uint8Array(t),
                    i = new Uint32Array(t),
                    s = null;
                return 68 === e[0] && 68 === e[1] && 83 === e[2] && 32 === e[3] && ("DX10" === (s = {
                    complete: !0,
                    fileFormat: "DDS",
                    compressionAlgorithm: "S3TC",
                    size: i[1],
                    flags: i[2],
                    height: i[3],
                    width: i[4],
                    pitch: i[5],
                    depth: i[6],
                    mipmapCount: i[7],
                    formatSize: i[19],
                    formatFlag: i[19],
                    formatFourCC: [String.fromCharCode(e[84]), String.fromCharCode(e[85]), String.fromCharCode(e[86]), String.fromCharCode(e[87])].join(""),
                    formatBitCount: i[21],
                    formatRBitMask: i[22],
                    formatGBitMask: i[23],
                    formatBBitMask: i[24],
                    formatABitMask: i[25],
                    caps1: i[26],
                    caps2: i[27],
                    caps3: i[28],
                    caps4: i[29],
                    reserved2: i[30],
                    DXGIFormat: null,
                    resourceDimension: null,
                    miscFlag: null,
                    arraySize: null,
                    textureData: e.subarray(i[1] + 4, e.byteLength)
                }).formatFourCC ? (s.DXGIFormat = i[31], s.resourceDimension = i[32], s.miscFlag = i[33], s.arraySize = i[34], s.miscFlag = i[35]) : "DXT5" === s.formatFourCC ? s.glExtensionFormat = 33779 : "DXT3" === s.formatFourCC && (s.glExtensionFormat = 33778)), s
            },
            ktx: function(t) {
                var e = new Uint8Array(t),
                    i = new Uint32Array(t),
                    s = null,
                    n = 16 + i[15] / 4 | 0,
                    r = i[n],
                    a = i[7],
                    o = 0;
                if (171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 49 === e[5] && 49 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11] && [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(a) >= 0) {
                    switch (a) {
                        case 36196:
                            o = "ETC1";
                            break;
                        case 35840:
                        case 35841:
                        case 35842:
                        case 35843:
                            o = "PVRTC";
                            break;
                        case 33776:
                        case 33777:
                        case 33778:
                        case 33779:
                            o = "S3TC"
                    }
                    s = {
                        complete: !0,
                        fileFormat: "KTX",
                        compressionAlgorithm: o,
                        endianness: i[3],
                        glType: i[4],
                        glTypeSize: i[5],
                        glFormat: i[6],
                        glInternalFormat: i[7],
                        glBaseInternalFormat: i[8],
                        width: i[9],
                        height: i[10],
                        pixelDepth: i[11],
                        numberOfArrayElements: i[12],
                        numberOfFaces: i[13],
                        numberOfMipmapLevels: i[14],
                        bytesOfKeyValueData: i[15],
                        keyAndValueByteSize: i[16],
                        imageSize: r,
                        textureData: e.subarray(4 * (n + 1), r + 100)
                    }
                }
                return s
            },
            pkm: function(t) {
                var e = new Uint8Array(t),
                    i = null;
                return 80 === e[0] && 75 === e[1] && 77 === e[2] && 32 === e[3] && (i = {
                    complete: !0,
                    fileFormat: "PKM",
                    compressionAlgorithm: "ETC1",
                    format: 65535 & (e[6] << 8 | e[7]),
                    width: 65535 & (e[8] << 8 | e[9]),
                    height: 65535 & (e[10] << 8 | e[11]),
                    originalWidth: 65535 & (e[12] << 8 | e[13]),
                    originalHeight: 65535 & (e[14] << 8 | e[15]),
                    textureData: e.subarray(16, e.length)
                }), i
            }
        }, e.AudioSprite = function(t, e) {
            this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
            for (var i in this.config.spritemap) {
                var s = this.config.spritemap[i],
                    n = this.game.add.sound(this.key);
                n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, e.AudioSprite.prototype = {
            play: function(t, e) {
                return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
            },
            stop: function(t) {
                if (t) this.sounds[t].stop();
                else
                    for (var e in this.sounds) this.sounds[e].stop()
            },
            get: function(t) {
                return this.sounds[t]
            }
        }, e.AudioSprite.prototype.constructor = e.AudioSprite, e.Sound = function(t, i, s, n, r) {
            void 0 === s && (s = 1), void 0 === n && (n = !1), void 0 === r && (r = t.sound.connectToMaster), this.game = t, this.name = i, this.key = i, this.loop = n, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.playOnce = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this._globalVolume = 1, this._markedToDelete = !1, this._pendingStart = !1, this._removeFromSoundManager = !1, this._sourceId = 0, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = s, r && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(i) && this.game.cache.isSoundReady(i) ? (this._sound = this.game.cache.getSoundData(i), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new e.Signal, this.onPlay = new e.Signal, this.onPause = new e.Signal, this.onResume = new e.Signal, this.onLoop = new e.Signal, this.onStop = new e.Signal, this.onMute = new e.Signal, this.onMarkerComplete = new e.Signal, this.onFadeComplete = new e.Signal, this._volume = s, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
        }, e.Sound.prototype = {
            soundHasUnlocked: function(t) {
                t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
            },
            addMarker: function(t, e, i, s, n) {
                void 0 !== i && null !== i || (i = 1), void 0 !== s && null !== s || (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                    name: t,
                    start: e,
                    stop: e + i,
                    volume: s,
                    duration: i,
                    durationMS: 1e3 * i,
                    loop: n
                }
            },
            removeMarker: function(t) {
                delete this.markers[t]
            },
            onEndedHandler: function() {
                this._sound && (this._removeOnEndedHandler(), this.isPlaying = !1, this.currentTime = this.durationMS, this.stop(), this.playOnce && (this._markedToDelete = !0, this._removeFromSoundManager = !0), this._markedToDelete && (this._disconnectSource(), this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())))
            },
            update: function() {
                if (this.game.cache.checkSoundKey(this.key)) {
                    this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop));
                    var t = this.game.time.time;
                    if (this.isPlaying) {
                        if (this._pendingStart) {
                            var e = this._sound.currentTime;
                            if (!(e > ((this.paused ? this._tempPause : 0) || this.position || 0))) return;
                            this._pendingStart = !1, this.startTime = t - 1e3 * e, this.stopTime = this.startTime + this.durationMS
                        }
                        this.currentTime = t - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = t, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0, !1))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = t), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0, !1)) : this.stop())
                    }
                } else this.destroy()
            },
            loopFull: function(t) {
                return this.play(null, 0, t, !0)
            },
            play: function(t, e, i, s, n, r) {
                if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), void 0 === r && (r = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n) && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0), this.isPlaying = !1), "" === t && Object.keys(this.markers).length > 0) return this;
                if ("" !== t) {
                    if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                    this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._createSourceAndConnect(), this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || this._addOnEndedHandler(), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), this.loop && "" === t ? this._startSource(0, 0) : this._startSource(0, this.position, this.duration), this.isPlaying = !0, this.paused = !1, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, r && this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this._sound.loop = this.loop, this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._globalVolume = this.game.sound.volume, this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume * this._globalVolume, this._pendingStart = !this.currentMarker, this.isPlaying = !0, this.paused = !1, this._tempPause = 0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, r && this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this.playOnce && (this.loop && console.warn("Phaser.Sound.play: audio clip " + this.name + " cannot be deleted while looping."), this._markedToDelete = !0, this._removeFromSoundManager = !0), this
            },
            restart: function(t, e, i, s) {
                t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
            },
            pause: function() {
                this.isPlaying && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
            },
            resume: function() {
                if (this.paused) {
                    if (this.usingWebAudio) {
                        var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._createSourceAndConnect(), "" === this.currentMarker && (this.loop ? this._sound.loop = !0 : this._addOnEndedHandler());
                        var e = this.duration - this.pausedPosition / 1e3;
                        this.loop && "" === this.currentMarker ? this._startSource(0, t) : this._startSource(0, t, e)
                    } else this._pendingStart = !this.currentMarker, this._sound.currentTime = this._tempPause, this._tempPause = 0, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound && (this.usingWebAudio ? this._stopSourceAndDisconnect() : this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0)), this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                    var t = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                }
            },
            fadeIn: function(t, e, i) {
                void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
            },
            fadeOut: function(t) {
                this.fadeTo(t, 0)
            },
            fadeTo: function(t, i) {
                this.isPlaying && !this.paused && i !== this.volume && (void 0 === t && (t = 1e3), void 0 !== i ? (this.fadeTween = this.game.add.tween(this).to({
                    volume: i
                }, t, e.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(t) {
                this.usingAudioTag && this._sound && (this._globalVolume = t, this._sound.volume = this._globalVolume * this._volume)
            },
            destroy: function(t) {
                void 0 === t && (t = !0), this._markedToDelete = !0, this._removeFromSoundManager = t, this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
            },
            _createSourceAndConnect: function() {
                this._sound = this.context.createBufferSource(), this._sound.connect(this.externalNode || this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this._sourceId++
            },
            _disconnectSource: function() {
                this._sound.disconnect(this.externalNode || this.gainNode)
            },
            _startSource: function(t, e, i) {
                void 0 === i ? this._sound.start(t || 0, e || 0) : this._sound.start(t || 0, e || 0, i)
            },
            _stopSourceAndDisconnect: function() {
                this._removeOnEndedHandler();
                try {
                    this._sound.stop(0)
                } catch (t) {}
                this._disconnectSource(), this._sound = null
            },
            _addOnEndedHandler: function() {
                this._sound.onended = this.onEndedHandler.bind(this)
            },
            _removeOnEndedHandler: function() {
                this._sound.onended = null
            }
        }, e.Sound.prototype.constructor = e.Sound, Object.defineProperty(e.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }), Object.defineProperty(e.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }), Object.defineProperty(e.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
            }
        }), Object.defineProperty(e.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = this._globalVolume * t))
            }
        }), Object.defineProperty(e.Sound.prototype, "sourceId", {
            get: function() {
                return this._sound ? this._sourceId : null
            }
        }), e.SoundManager = function(t) {
            this.game = t, this.onSoundDecode = new e.Signal, this.onVolumeChange = new e.Signal, this.onMute = new e.Signal, this.onUnMute = new e.Signal, this.onTouchUnlock = new e.Signal, this.onStateChange = new e.Signal, this.context = null, this.baseLatency = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new e.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null, this._onClick = this._onClick.bind(this), this._onStateChange = this._onStateChange.bind(this)
        }, e.SoundManager.prototype = {
            boot: function() {
                var t = this.game.device,
                    e = window.PhaserGlobal;
                if (t.iOS && !1 === t.webAudio && (this.channels = 1), e) {
                    if (!0 === e.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                    if (!0 === e.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                }
                if (e && e.audioContext) this.context = e.audioContext;
                else {
                    var i = window.AudioContext || window.webkitAudioContext;
                    if (i) try {
                        this.context = new i
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1, console.warn(t)
                    }
                }
                if (null === this.context) {
                    if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0
                } else this.usingWebAudio = !0, this.baseLatency = this.context.baseLatency || 256 / (this.context.sampleRate || 44100), void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination), this.context.onstatechange = this._onStateChange, "suspended" === this.context.state && this.game.canvas.addEventListener("click", this._onClick);
                this.noAudio || t.needsTouchUnlock() && this.setTouchLock(), this.usingWebAudio && t.chrome && t.chromeVersion <= 65 && console.log('A "GainNode.gain.value setter smoothing is deprecated" notice in Chrome is normal. <https://github.com/photonstorm/phaser-ce/issues/385>')
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0)
            },
            setTouchUnlock: function() {
                this.touchLocked = !1, this._unlockSource = null, this.onTouchUnlock.dispatch()
            },
            webAudioIsSuspended: function() {
                return this.usingWebAudio && "suspended" === this.context.state
            },
            resumeWebAudio: function() {
                if (this.usingWebAudio) return this.context.resume()
            },
            resumeWebAudioIfSuspended: function() {
                if (this.webAudioIsSuspended()) return this.context.resume()
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.setTouchUnlock();
                else if (this.usingWebAudio) {
                    var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination);
                    var e = this;
                    this._unlockSource.onended = function() {
                        e.setTouchUnlock(), e.resumeWebAudioIfSuspended()
                    }, void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), this.resumeWebAudioIfSuspended()
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
            },
            decode: function(t, e) {
                e = e || null;
                var i = this.game.cache.getSoundData(t);
                if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                    this.game.cache.updateSound(t, "isDecoding", !0);
                    var s = this;
                    try {
                        this.context.decodeAudioData(i, function(i) {
                            s.game.isBooted && i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                        })
                    } catch (t) {}
                }
            },
            setDecodedCallback: function(t, i, s) {
                "string" == typeof t && (t = [t]), this._watchList.reset();
                for (var n = 0; n < t.length; n++) t[n] instanceof e.Sound ? this.game.cache.isSoundDecoded(t[n].key) || this._watchList.add(t[n].key) : this.game.cache.isSoundDecoded(t[n]) || this._watchList.add(t[n]);
                0 === this._watchList.total ? (this._watching = !1, i.call(s)) : (this._watching = !0, this._watchCallback = i, this._watchContext = s)
            },
            update: function() {
                if (!this.noAudio) {
                    if (!this.webAudioIsSuspended())
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                    if (this._watching) {
                        for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(t, i, s, n) {
                void 0 === i && (i = 1), void 0 === s && (s = !1), void 0 === n && (n = this.connectToMaster);
                var r = new e.Sound(this.game, t, i, s, n);
                return this._sounds.push(r), r
            },
            addSprite: function(t) {
                return new e.AudioSprite(this.game, t)
            },
            remove: function(t) {
                for (var e = this._sounds.length; e--;)
                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                return !1
            },
            removeAll: function() {
                this.stopAll();
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                this._sounds.length = 0
            },
            removeByKey: function(t) {
                for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                return i
            },
            play: function(t, e, i) {
                if (!this.noAudio) {
                    var s = this.add(t, e, i);
                    return s.play(), s
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            gamePaused: function() {
                this.muteOnPause && this.setMute()
            },
            gameResumed: function() {
                this.resumeWebAudio(), this.muteOnPause && this.unsetMute()
            },
            destroy: function() {
                this.removeAll(), this.onMute.dispose(), this.onSoundDecode.dispose(), this.onStateChange.dispose(), this.onTouchUnlock.dispose(), this.onUnMute.dispose(), this.onVolumeChange.dispose(), this.game.canvas.removeEventListener("click", this._onClick), this.context && (this.context.onstatechange = null, window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close(), this.context = null)
            },
            _onStateChange: function() {
                this.onStateChange.dispatch(this.context.state)
            },
            _onClick: function() {
                this.resumeWebAudioIfSuspended(), this.game.canvas.removeEventListener("click", this._onClick)
            }
        }, e.SoundManager.prototype.constructor = e.SoundManager, Object.defineProperty(e.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(e.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                    if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t)
                }
            }
        }), e.ScaleManager = function(t, i, s) {
            this.game = t, this.dom = e.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new e.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new e.Signal, this.enterIncorrectOrientation = new e.Signal, this.leaveIncorrectOrientation = new e.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new e.Signal, this.onFullScreenChange = new e.Signal, this.onFullScreenError = new e.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new e.Point(1, 1), this.scaleFactorInversed = new e.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new e.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = e.ScaleManager.NO_SCALE, this._fullScreenScaleMode = e.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new e.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new e.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new e.Rectangle, this._userScaleFactor = new e.Point(1, 1), this._userScaleTrim = new e.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new e.Rectangle, this._tempBounds = new e.Rectangle, this._lastReportedCanvasSize = new e.Rectangle, this._lastReportedGameSize = new e.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(i, s)
        }, e.ScaleManager.EXACT_FIT = 0, e.ScaleManager.NO_SCALE = 1, e.ScaleManager.SHOW_ALL = 2, e.ScaleManager.RESIZE = 3, e.ScaleManager.USER_SCALE = 4, e.ScaleManager.MODES = ["EXACT_FIT", "NO_SCALE", "SHOW_ALL", "RESIZE", "USER_SCALE"], e.ScaleManager.prototype = {
            boot: function() {
                var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new e.Point(0, 1) : t.scrollTo = new e.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                var i = this;
                this._orientationChange = function(t) {
                    return i.orientationChange(t)
                }, this._windowResize = function(t) {
                    return i.windowResize(t)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return i.fullScreenChange(t)
                }, this._fullScreenError = function(t) {
                    return i.fullScreenError(t)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), e.FlexGrid && (this.grid = new e.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget), this.pageAlignHorizontally = t.alignH || !1, this.pageAlignVertically = t.alignV || !1, t.scaleH && t.scaleV && this.setUserScale(t.scaleH, t.scaleV, t.trimH, t.trimV)
            },
            setupScale: function(t, i) {
                var s, n = new e.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? s = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (s = this.game.parent)), s ? (this.parentNode = s, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds, this.parentNode), n.width = this._parentBounds.width, n.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, n.width = this.dom.visualBounds.width, n.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var r = 0,
                    a = 0;
                "number" == typeof t ? r = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, r = n.width * this.parentScaleFactor.x), "number" == typeof i ? a = i : (this.parentScaleFactor.y = parseInt(i, 10) / 100, a = n.height * this.parentScaleFactor.y), r = Math.floor(r), a = Math.floor(a), this._gameSize.setTo(0, 0, r, a), this.updateDimensions(r, a, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(t, i) {
                this._gameSize.setTo(0, 0, t, i), this.currentScaleMode !== e.ScaleManager.RESIZE && this.updateDimensions(t, i, !0), this.queueUpdate(!0)
            },
            setUserScale: function(t, e, i, s, n, r) {
                this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), void 0 === n && (n = !0), void 0 === r && (r = !0), n && this.queueUpdate(r)
            },
            setResizeCallback: function(t, e) {
                this.onResize = t, this.onResizeContext = e
            },
            signalSizeChange: function() {
                if (!e.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !e.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var t = this.width,
                        i = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, i), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, i), this.onSizeChange.dispatch(this, t, i), this.currentScaleMode === e.ScaleManager.RESIZE && (this.game.state.resize(t, i), this.game.load.resize(t, i))
                }
            },
            setMinMax: function(t, e, i, s) {
                this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var t = this._updateThrottle;
                    this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var i = this._parentBounds.width,
                        s = this._parentBounds.height,
                        n = this.getParentBounds(this._parentBounds),
                        r = n.width !== i || n.height !== s,
                        a = this.updateOrientationState();
                    (r || a) && (this.onResize && this.onResize.call(this.onResizeContext, this, n), this.updateLayout(), this.signalSizeChange());
                    var o = 2 * this._updateThrottle;
                    this._updateThrottle < t && (o = Math.min(t, this._updateThrottleReset)), this._updateThrottle = e.Math.clamp(o, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(t, e) {
                void 0 === e && (e = !1), !0 !== t || !0 !== e ? (this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)) : console.warn("Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.")
            },
            classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            },
            updateOrientationState: function() {
                var t = this.screenOrientation,
                    e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation,
                    s = e !== this.incorrectOrientation;
                return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
            },
            orientationChange: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            windowResize: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            },
            refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            },
            updateLayout: function() {
                var t = this.currentScaleMode;
                if (t !== e.ScaleManager.RESIZE) {
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === e.ScaleManager.EXACT_FIT ? this.setExactFit() : t === e.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === e.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === e.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === e.ScaleManager.SHOW_ALL || t === e.ScaleManager.USER_SCALE)) {
                        var i = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, i.width), this.height = Math.min(this.height, i.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                } else this.reflowGame()
            },
            getParentBounds: function(t, i) {
                var s = t || new e.Rectangle,
                    n = i || this.boundingParent,
                    r = this.dom.visualBounds,
                    a = this.dom.layoutBounds;
                if (n) {
                    var o = n.getBoundingClientRect(),
                        h = n.offsetParent ? n.offsetParent.getBoundingClientRect() : n.getBoundingClientRect();
                    s.setTo(o.left - h.left, o.top - h.top, o.width, o.height);
                    var l = this.windowConstraints;
                    if (l.right) {
                        u = "layout" === l.right ? a : r;
                        s.right = Math.min(s.right, u.width)
                    }
                    if (l.bottom) {
                        var u = "layout" === l.bottom ? a : r;
                        s.bottom = Math.min(s.bottom, u.height)
                    }
                } else s.setTo(0, 0, r.width, r.height);
                return s.setTo(Math.round(s.x), Math.round(s.y), Math.round(s.width), Math.round(s.height)), s
            },
            align: function(t, e) {
                null != t && (this.pageAlignHorizontally = t), null != e && (this.pageAlignVertically = e)
            },
            alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds),
                    s = this.game.canvas,
                    n = this.margin;
                if (t) {
                    n.left = n.right = 0;
                    h = s.getBoundingClientRect();
                    if (this.width < i.width && !this.incorrectOrientation) {
                        var r = h.left - i.x,
                            a = i.width / 2 - this.width / 2,
                            o = (a = Math.max(a, 0)) - r;
                        n.left = Math.round(o)
                    }
                    s.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - h.width - n.left), s.style.marginRight = n.right + "px")
                }
                if (e) {
                    n.top = n.bottom = 0;
                    var h = s.getBoundingClientRect();
                    if (this.height < i.height && !this.incorrectOrientation) {
                        var r = h.top - i.y,
                            a = i.height / 2 - this.height / 2,
                            o = (a = Math.max(a, 0)) - r;
                        n.top = Math.round(o)
                    }
                    s.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - h.height - n.top), s.style.marginBottom = n.bottom + "px")
                }
                n.x = n.left, n.y = n.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = e.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = e.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            },
            resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
            },
            queueUpdate: function(t) {
                t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            },
            reset: function(t) {
                t && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            },
            setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds),
                    s = i.width,
                    n = i.height;
                e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
            },
            setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
            },
            startFullScreen: function(t, i, s) {
                if (this.isFullScreen) return !1; {
                    if (this.compatibility.supportsFullScreen) {
                        if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                            var n = this.game.input;
                            if (n.activePointer && n.activePointer !== n.mousePointer && (i || !1 !== i)) return void n.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                        }
                        void 0 !== t && this.game.renderType === e.CANVAS && (this.game.stage.smoothed = t);
                        var r = this.fullScreenTarget;
                        r || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), r = this._createdFullScreenTarget);
                        var a = {
                            targetElement: r
                        };
                        if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, a), this._createdFullScreenTarget) {
                            var o = this.game.canvas;
                            o.parentNode.insertBefore(r, o), r.appendChild(o)
                        }
                        return void 0 === s && (s = {
                            navigationUI: "hide"
                        }), this.game.device.fullscreenKeyboard ? r[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : r[this.game.device.requestFullscreen](s), !0
                    }
                    var h = this;
                    setTimeout(function() {
                        h.fullScreenError()
                    }, 10)
                }
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
            },
            cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if (t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(t) {
                var i = !!this._createdFullScreenTarget,
                    s = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? (i || this.fullScreenScaleMode === e.ScaleManager.EXACT_FIT) && s !== this.game.canvas && (this._fullScreenRestore = {
                    targetWidth: s.style.width,
                    targetHeight: s.style.height
                }, s.style.width = "100%", s.style.height = "100%") : (this._fullScreenRestore && (s.style.width = this._fullScreenRestore.targetWidth, s.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(t) {
                this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(t) {
                this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(t, e, i, s) {
                if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                var n = e,
                    r = t.height * e / t.width,
                    a = t.width * i / t.height,
                    o = i,
                    h = a > e;
                return (h = h ? s : !s) ? (t.width = Math.floor(n), t.height = Math.floor(r)) : (t.width = Math.floor(a), t.height = Math.floor(o)), t
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        }, e.ScaleManager.prototype.constructor = e.ScaleManager, Object.defineProperty(e.ScaleManager.prototype, "boundingParent", {
            get: function() {
                return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }), Object.defineProperty(e.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }), e.Utils.Debug = function(t) {
            this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px monospace", this.columnWidth = 100, this.lineHeight = 16, this.lineWidth = 1, this.renderShadow = !0, this.currentColor = null, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1, this.isDisabled = !1, this._line = null, this._rect = null
        }, e.Utils.Debug.GEOM_AUTO = 0, e.Utils.Debug.GEOM_RECTANGLE = 1, e.Utils.Debug.GEOM_CIRCLE = 2, e.Utils.Debug.GEOM_POINT = 3, e.Utils.Debug.GEOM_LINE = 4, e.Utils.Debug.GEOM_ELLIPSE = 5, e.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === e.CANVAS ? this.context = this.game.context : (this.bmd = new e.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = e.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")), this._line = new e.Line, this._rect = new e.Rectangle
            },
            resize: function() {
                this.bmd.resize(this.game.width, this.game.height), this.canvas.width = this.game.width, this.canvas.height = this.game.height
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
            },
            start: function(t, e, i, s) {
                "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                this.currentY += this.lineHeight
            },
            gameInfo: function(t, e, i) {
                var s = this.game;
                this.start(t, e, i), this.line("Game ID " + s.id), this.line({
                    1: "Canvas",
                    2: "WebGL",
                    3: "Headless",
                    4: "WebGL Multitexture"
                }[s.renderType] + " (" + s.width + " x " + s.height + ")"), this.line("Paused: " + s.paused), this.line("Stepping: " + s.stepping + " (" + s.stepCount + ")"), this.stop()
            },
            state: function(t, e, i) {
                var s = this.game.state,
                    n = Object.keys(s.states);
                this.start(t, e, i);
                for (var r = 0; r < n.length; r++) {
                    var a = n[r];
                    a === s.current ? this.line((s._created ? "* " : "> ") + a) : a === s._pendingState ? this.line("+ " + a) : this.line("  " + a)
                }
                this.stop()
            },
            sound: function(t, e, i) {
                var s = this.game.sound;
                this.start(t, e, i), s.noAudio ? this.line("Audio is disabled") : (this.line("Volume: " + s.volume.toFixed(2) + (s.mute ? " (Mute)" : "")), this.line("Mute on pause: " + s.muteOnPause), this.line("Using: " + (s.usingWebAudio ? "Web Audio - " + s.context.state : "Audio Tag")), this.line("Touch locked: " + s.touchLocked), this.line("Sounds: " + s._sounds.length)), this.stop()
            },
            soundInfo: function(t, e, i, s) {
                if (this.start(e, i, s), this.line("Sound: " + t.key + "  Touch locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + "  Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + "  Decoding: " + t.isDecoding), this.line("Playing: " + t.isPlaying + "  Loop: " + t.loop), this.line("Time: " + (t.currentTime / 1e3).toFixed(3) + "s  Total: " + t.totalDuration.toFixed(3) + "s"), this.line("Volume: " + t.volume.toFixed(2) + (t.mute ? " (Mute)" : "")), this.line("Using: " + (t.usingWebAudio ? "Web Audio" : "Audio Tag")), t.usingWebAudio && this.line("  Source: " + (t.sourceId || "none")), t.usingAudioTag && t._sound) {
                    var n = t._sound;
                    this.line("  currentSrc: " + n.currentSrc), this.line("  currentTime: " + n.currentTime), this.line("  duration: " + n.duration), this.line("  ended: " + n.ended), this.line("  loop: " + n.loop), this.line("  muted: " + n.muted), this.line("  paused: " + n.paused)
                }
                "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + "  Duration: " + t.duration.toFixed(3) + "s (" + t.durationMS + "ms)"), this.line("Start: " + t.markers[t.currentMarker].start.toFixed(3) + "  Stop: " + t.markers[t.currentMarker].stop.toFixed(3)), this.line("Position: " + t.position.toFixed(3))), this.stop()
            },
            camera: function(t, e, i) {
                var s = t.deadzone,
                    n = t.target,
                    r = t.view;
                s && (this._rect.setTo(r.x + s.x, r.y + s.y, s.width, s.height), this.rectangle(this._rect, e, i)), n && (this._line.setTo(r.centerX, r.centerY, n.x, n.y), this.geom(this._line, e, i), this.geom(n, e, !1, 3))
            },
            cameraInfo: function(t, e, i, s) {
                var n = t.bounds,
                    r = t.deadzone,
                    a = t.target,
                    o = t.view;
                this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("x: " + t.x + " y: " + t.y), this.line("Bounds: " + (n ? "x: " + n.x + " y: " + n.y + " w: " + n.width + " h: " + n.height : "none")), this.line("View: x: " + o.x + " y: " + o.y + " w: " + o.width + " h: " + o.height), this.line("Center: x: " + t.centerX + " y: " + t.centerY), this.line("Deadzone: " + (r ? "x: " + r.x + " y: " + r.y + " w: " + r.width + " h: " + r.height : r)), this.line("Total in view: " + t.totalInView), this.line("At limit: x: " + t.atLimit.x + " y: " + t.atLimit.y), this.line("Target: " + (a ? a.name || a : "none")), this.stop()
            },
            timer: function(t, e, i, s) {
                this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
            },
            pointer: function(t, e, i, s, n, r) {
                if (null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,255,0,0.5)", r = r || "rgba(255,0,0,0.5)", !0 !== e || !0 !== t.isUp)) {
                    this.start(t.x, t.y - 150, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = t.isDown ? i : s : this.context.fillStyle = r, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath();
                    var a = t.movementX,
                        o = t.movementY;
                    (a || o) && (this.context.beginPath(), this.context.moveTo(a + t.position.x, o + t.position.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath()), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX.toFixed(1) + " World Y: " + t.worldY.toFixed(1)), this.line("Screen X: " + t.x.toFixed(1) + " Screen Y: " + t.y.toFixed(1) + " In: " + t.withinGame), this.line("Movement: X: " + a + " Y: " + o), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.line("Identifier: " + t.identifier + " Pointer ID: " + t.pointerId), t.isMouse && this.line("Buttons: " + this._pointerButtonIcon(t.leftButton) + " " + this._pointerButtonIcon(t.middleButton) + " " + this._pointerButtonIcon(t.rightButton)), this.stop()
                }
            },
            _pointerButtonIcon: function(t) {
                return t.isDown ? "x" : t.isUp ? "o" : "-"
            },
            spriteInputInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
            },
            key: function(t, e, i, s) {
                this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
            },
            inputInfo: function(t, i, s, n) {
                var r = this.game.input;
                if (void 0 === n && (n = !0), this.start(t, i, s), this.line("Input"), this.line("X: " + r.x + " Y: " + r.y), this.line("World X: " + r.worldX + " World Y: " + r.worldY), this.line("Scale X: " + r.scale.x.toFixed(2) + " Scale Y: " + r.scale.x.toFixed(2)), this.line("Screen X: " + r.activePointer.screenX.toFixed(1) + " Screen Y: " + r.activePointer.screenY.toFixed(1)), n) {
                    this.line("Sources:"), this.line("  " + this._inputHandler(r.mouse, "mouse")), this.line("  " + this._inputHandler(r.mspointer, "mspointer")), this.line("  " + this._inputHandler(r.touch, "touch"));
                    var a = r.pointers,
                        o = r.mousePointer,
                        h = e.PointerModes,
                        l = 0,
                        u = 0;
                    this.line("Pointers:"), this.line("  " + (o.isDown ? "x" : "o") + " " + h[o.pointerMode] + " " + o.identifier);
                    for (var c = 0; c < a.length; c++) {
                        var d = a[c];
                        this.line("  " + (d.active ? "+" : "-") + " " + h[d.pointerMode] + " " + d.identifier), d.active ? l += 1 : u += 1
                    }
                    this.line("  Active: " + l + " Free: " + u + " Max: " + r.maxPointers), this.stop()
                } else this.stop()
            },
            inputHandler: function(t, e, i, s, n) {
                this.start(i, s, n), this.line(e || "?"), this.line("active: " + t.active), t.active ? (this.line("enabled: " + t.enabled), "capture" in t && this.line("capture: " + t.capture), "preventDefault" in t && this.line("preventDefault: " + t.preventDefault), "event" in t && this.line("event: " + (t.event ? t.event.type : t.event)), this.stop()) : this.stop()
            },
            _inputHandler: function(t, e) {
                return this._inputHandlerStatusIcon(t) + " " + e + " " + this._inputHandlerCaptureIcon(t)
            },
            _inputHandlerStatusIcon: function(t) {
                return t.active ? t.enabled ? "+" : "-" : " "
            },
            _inputHandlerCaptureIcon: function(t) {
                return t.active && (t.capture || t.preventDefault) ? "*" : " "
            },
            spriteBounds: function(t, e, i) {
                var s = t.getBounds();
                s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
            },
            ropeSegments: function(t, e, i) {
                var s = this;
                t.segments.forEach(function(t) {
                    s.rectangle(t, e, i)
                }, this)
            },
            spriteInfo: function(t, e, i, s) {
                this.start(e, i, s), this.line("Sprite: " + (t.name || "") + " (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.line("parent: " + (t.parent ? t.parent.name || "(DisplayObject)" : "(none)")), this.stop()
            },
            spriteCoords: function(t, e, i, s) {
                this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
            },
            lineInfo: function(t, e, i, s) {
                this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
            },
            pixel: function(t, e, i, s) {
                s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
            },
            geom: function(t, i, s, n) {
                void 0 === s && (s = !0), void 0 === n && (n = 0), i = i || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = i, this.context.strokeStyle = i, this.context.lineWidth = this.lineWidth;
                var r = e.Utils.Debug;
                n === r.GEOM_RECTANGLE || t instanceof e.Rectangle ? s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : n === r.GEOM_CIRCLE || t instanceof e.Circle ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()) : n === r.GEOM_POINT || t instanceof e.Point ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : n === r.GEOM_LINE || t instanceof e.Line ? (this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()) : (n === r.GEOM_ELLIPSE || t instanceof e.Ellipse) && (this.context.beginPath(), this.context.ellipse(t.centerX - this.game.camera.x, t.centerY - this.game.camera.y, t.width / 2, t.height / 2, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()), this.stop()
            },
            rectangle: function(t, e, i) {
                void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.lineWidth = this.lineWidth, this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
            },
            text: function(t, e, i, s, n) {
                s = s || "rgb(255,255,255)", n = n || this.font, this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
            },
            quadTree: function(t, e) {
                e = e || "rgba(255,0,0,0.3)", this.start();
                var i = t.bounds;
                if (0 === t.nodes.length) {
                    this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                    for (s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                } else
                    for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                this.stop()
            },
            body: function(t, i, s) {
                t.body && (this.start(), t.body.type === e.Physics.ARCADE ? e.Physics.Arcade.Body.render(this.context, t.body, i, s, this.lineWidth) : t.body.type === e.Physics.NINJA ? e.Physics.Ninja.Body.render(this.context, t.body, i, s) : t.body.type === e.Physics.BOX2D && e.Physics.Box2D.renderBody(this.context, t.body, i), this.stop())
            },
            bodyInfo: function(t, i, s, n) {
                t.body && (this.start(i, s, n, 210), t.body.type === e.Physics.ARCADE ? e.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === e.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
            },
            box2dWorld: function() {
                this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
            },
            box2dBody: function(t, i) {
                this.start(), e.Physics.Box2D.renderBody(this.context, t, i), this.stop()
            },
            displayList: function(t) {
                if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && t.children.length > 0)
                    for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
            },
            renderer: function(t, e, i) {
                var s = this.game.renderer,
                    n = s.renderSession;
                if (this.start(t, e, i), this.line((s.gl ? "WebGL" : "Canvas") + " Renderer (" + s.width + " x " + s.height + ")"), this.line("autoResize: " + s.autoResize), this.line("clearBeforeRender: " + s.clearBeforeRender), this.line("resolution: " + s.resolution), this.line("transparent: " + s.transparent), this.line("renderSession:"), s.gl) {
                    this.line("  currentBatchedTextures: (" + s.currentBatchedTextures.length + ")");
                    for (var r = 0; r < s.currentBatchedTextures.length; r++) this.line("    " + s.currentBatchedTextures[r]);
                    this.line("  drawCount: " + n.drawCount), this.line("  maxTextures: " + s.maxTextures), this.line("  maxTextureSize: " + s.maxTextureSize), this.line("  maxTextureAvailableSpace: " + n.maxTextureAvailableSpace), this.line("  roundPixels: " + n.roundPixels)
                } else this.line("  roundPixels: " + n.roundPixels), this.line("  scaleMode: " + (0 === n.scaleMode ? "LINEAR" : 1 === n.scaleMode ? "NEAREST" : n.scaleMode));
                this.stop()
            },
            canvasPool: function(t, i, s, n) {
                var r = e.CanvasPool;
                this.start(t, i, s, n || 100), this.line("Canvas Pool"), this.line("Used:", r.getTotal()), this.line("Free:", r.getFree()), this.line("Total:", r.length), this.stop()
            },
            physicsGroup: function(t, e, i, s) {
                t.forEach(this.body, this, s, e, i)
            },
            phaser: function(t, i, s) {
                this.text("Phaser v" + e.VERSION + " " + (this.game.renderType === e.WEBGL ? "WebGL" : "Canvas") + " " + (this.game.device.webAudio ? "WebAudio" : "HTML Audio"), t, i, s, this.font)
            },
            scale: function(t, i, s) {
                this.start(t, i, s);
                var n = this.game.scale,
                    r = n.scaleFactorInversed,
                    a = n._parentBounds,
                    t = " x ";
                this.line("Game: " + this.game.width + t + this.game.height), this.line("Canvas: " + n.width + t + n.height + " (" + r.x.toFixed(2) + t + r.y.toFixed(2) + ") [" + n.aspectRatio.toFixed(2) + "]"), this.line("Mode: " + e.ScaleManager.MODES[n.currentScaleMode] + (n.currentScaleMode === e.ScaleManager.USER_SCALE ? " (" + n._userScaleFactor.x + t + n._userScaleFactor.y + ")" : "")), this.line("Parent: " + (n.parentIsWindow ? "window" : n.parentNode) + (a.empty ? "" : " (" + a.width + t + a.height + ")")), this.line("Screen: " + n.classifyOrientation(n.screenOrientation) + (n.incorrectOrientation ? " (incorrect)" : "")), this.stop()
            },
            loader: function(t, i, s, n) {
                var r = e.Utils.pad;
                this.start(i, s, n), t.hasLoaded ? this.line("Complete" + (t.resetLocked ? " [locked]" : "")) : t.isLoading ? this.line("Loading") : this.line("Not started"), t.hasLoaded && !t.resetLocked || (this.line("Progress: " + r(t.progress, 3) + "%"), this.line("Files: " + t._loadedFileCount + " of " + t._totalFileCount), this.line("Packs: " + t._loadedPackCount + " of " + t._loadedPackCount)), this.stop()
            },
            device: function(t, e, i) {
                var s = this.game.device;
                this.start(t, e, i), this.line("Device"), this.line("Pointer Events: " + s.mspointer), this.line("Touch: " + s.touch), this.line("Web Audio: " + s.webAudio), this.line("WebGL: " + s.webGL), this.stop()
            },
            destroy: function() {
                e.CanvasPool.remove(this)
            }
        }, e.Utils.Debug.prototype.constructor = e.Utils.Debug, e.DOM = {
            getOffset: function(t, i) {
                i = i || new e.Point;
                var s = t.getBoundingClientRect(),
                    n = e.DOM.scrollY,
                    r = e.DOM.scrollX,
                    a = document.documentElement.clientTop,
                    o = document.documentElement.clientLeft;
                return i.x = s.left + r - o, i.y = s.top + n - a, i
            },
            getBounds: function(t, e) {
                return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            },
            calibrate: function(t, e) {
                e = +e || 0;
                var i = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
            },
            getAspectRatio: function(t) {
                var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                    i = t.height;
                return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
            },
            inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(t) {
                var e = window.screen,
                    i = e.orientation || e.mozOrientation || e.msOrientation;
                if (i && "string" == typeof i.type) return i.type;
                if ("string" == typeof i) return i;
                var s = "portrait-primary",
                    n = "landscape-primary";
                if ("screen" === t) return e.height > e.width ? s : n;
                if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : n;
                if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : n;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) return s;
                    if (window.matchMedia("(orientation: landscape)").matches) return n
                }
                return this.visualBounds.height > this.visualBounds.width ? s : n
            },
            visualBounds: new e.Rectangle,
            layoutBounds: new e.Rectangle,
            documentBounds: new e.Rectangle
        }, e.Device.whenReady(function(t) {
            var i = window && "pageXOffset" in window ? function() {
                    return window.pageXOffset
                } : function() {
                    return document.documentElement.scrollLeft
                },
                s = window && "pageYOffset" in window ? function() {
                    return window.pageYOffset
                } : function() {
                    return document.documentElement.scrollTop
                };
            if (Object.defineProperty(e.DOM, "scrollX", {
                    get: i
                }), Object.defineProperty(e.DOM, "scrollY", {
                    get: s
                }), Object.defineProperty(e.DOM.visualBounds, "x", {
                    get: i
                }), Object.defineProperty(e.DOM.visualBounds, "y", {
                    get: s
                }), Object.defineProperty(e.DOM.layoutBounds, "x", {
                    value: 0
                }), Object.defineProperty(e.DOM.layoutBounds, "y", {
                    value: 0
                }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                var n = function() {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth)
                    },
                    r = function() {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight)
                    };
                Object.defineProperty(e.DOM.visualBounds, "width", {
                    get: n
                }), Object.defineProperty(e.DOM.visualBounds, "height", {
                    get: r
                }), Object.defineProperty(e.DOM.layoutBounds, "width", {
                    get: n
                }), Object.defineProperty(e.DOM.layoutBounds, "height", {
                    get: r
                })
            } else Object.defineProperty(e.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(e.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(e.DOM.layoutBounds, "width", {
                get: function() {
                    var t = document.documentElement.clientWidth,
                        e = window.innerWidth;
                    return t < e ? e : t
                }
            }), Object.defineProperty(e.DOM.layoutBounds, "height", {
                get: function() {
                    var t = document.documentElement.clientHeight,
                        e = window.innerHeight;
                    return t < e ? e : t
                }
            });
            Object.defineProperty(e.DOM.documentBounds, "x", {
                value: 0
            }), Object.defineProperty(e.DOM.documentBounds, "y", {
                value: 0
            }), Object.defineProperty(e.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }), Object.defineProperty(e.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0), e.ArraySet = function(t) {
            this.position = 0, this.list = t || []
        }, e.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t), t
            },
            getIndex: function(t) {
                return this.list.indexOf(t)
            },
            getByKey: function(t, e) {
                for (var i = this.list.length; i--;)
                    if (this.list[i][t] === e) return this.list[i];
                return null
            },
            exists: function(t) {
                return this.list.indexOf(t) > -1
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(t) {
                var e = this.list.indexOf(t);
                if (e > -1) return this.list.splice(e, 1), t
            },
            setAll: function(t, e) {
                for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
            },
            callAll: function(t) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            },
            removeAll: function(t) {
                void 0 === t && (t = !1);
                for (var e = this.list.length; e--;)
                    if (this.list[e]) {
                        var i = this.remove(this.list[e]);
                        t && i.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(e.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(e.ArraySet.prototype, "first", {
            get: function() {
                return this.position = 0, this.list.length > 0 ? this.list[0] : null
            }
        }), Object.defineProperty(e.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), e.ArraySet.prototype.constructor = e.ArraySet, e.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if (null === t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                return void 0 === t[s] ? null : t[s]
            },
            removeRandomItem: function(t, e, i) {
                if (null == t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var s = e + Math.floor(Math.random() * i);
                if (s < t.length) {
                    var n = t.splice(s, 1);
                    return void 0 === n[0] ? null : n[0]
                }
                return null
            },
            remove: function(t, e, i) {
                var s = t.length;
                if (!(e >= s || 0 === i)) {
                    null == i && (i = 1);
                    for (var n = s - i, r = e; r < n; ++r) t[r] = t[r + i];
                    t.length = n
                }
            },
            shuffle: function(t) {
                for (var e = t.length - 1; e > 0; e--) {
                    var i = Math.floor(Math.random() * (e + 1)),
                        s = t[e];
                    t[e] = t[i], t[i] = s
                }
                return t
            },
            transposeMatrix: function(t) {
                for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                    s[n] = new Array(e);
                    for (var r = e - 1; r > -1; r--) s[n][r] = t[r][n]
                }
                return s
            },
            rotateMatrix: function(t, i) {
                if ("string" != typeof i && (i = (i % 360 + 360) % 360), 90 === i || -270 === i || "rotateLeft" === i) t = (t = e.ArrayUtils.transposeMatrix(t)).reverse();
                else if (-90 === i || 270 === i || "rotateRight" === i) t = t.reverse(), t = e.ArrayUtils.transposeMatrix(t);
                else if (180 === Math.abs(i) || "rotate180" === i) {
                    for (var s = 0; s < t.length; s++) t[s].reverse();
                    t = t.reverse()
                }
                return t
            },
            findClosest: function(t, e) {
                if (!e.length) return NaN;
                if (1 === e.length || t < e[0]) return e[0];
                for (var i = 1; e[i] < t;) i++;
                var s = e[i - 1],
                    n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return n - t <= t - s ? n : s
            },
            rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e), e
            },
            rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            numberArray: function(t, e) {
                void 0 !== e && null !== e || (e = t, t = 0);
                for (var i = [], s = t; s <= e; s++) i.push(s);
                return i
            },
            numberArrayStep: function(t, i, s) {
                void 0 !== t && null !== t || (t = 0), void 0 !== i && null !== i || (i = t, t = 0), void 0 === s && (s = 1);
                for (var n = [], r = Math.max(e.Math.roundAwayFromZero((i - t) / (s || 1)), 0), a = 0; a < r; a++) n.push(t), t += s;
                return n
            }
        }, e.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, e.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
            },
            reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            },
            remove: function(t) {
                if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
            },
            callAll: function(t) {
                if (this.first && this.last) {
                    var e = this.first;
                    do {
                        e && e[t] && e[t].call(e), e = e.next
                    } while (e !== this.last.next)
                }
            }
        }, e.LinkedList.prototype.constructor = e.LinkedList, e.Create = function(t) {
            this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, e.Create.PALETTE_ARNE = 0, e.Create.PALETTE_JMP = 1, e.Create.PALETTE_CGA = 2, e.Create.PALETTE_C64 = 3, e.Create.PALETTE_JAPANESE_MACHINE = 4, e.Create.prototype = {
            texture: function(t, e, i, s, n, r, a, o) {
                void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0), void 0 === r && (r = !0);
                var h = e[0].length * i,
                    l = e.length * s;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(h, l), this.bmd.clear();
                for (var u = 0; u < e.length; u++)
                    for (var c = e[u], d = 0; d < c.length; d++) {
                        var p = c[d];
                        "." !== p && " " !== p && (this.ctx.fillStyle = this.palettes[n][p], this.ctx.fillRect(d * i, u * s, i, s))
                    }
                return r ? this.bmd.generateTexture(t, a, o) : this.copy()
            },
            grid: function(t, e, i, s, n, r, a, o, h) {
                void 0 === a && (a = !0), null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
                for (var l = 0; l < i; l += n) this.ctx.fillRect(0, l, e, 1);
                for (var u = 0; u < e; u += s) this.ctx.fillRect(u, 0, 1, i);
                return a ? this.bmd.generateTexture(t, o, h) : this.copy()
            },
            copy: function(t, e, i, s, n, r, a) {
                return null == t && (t = this.game.make.bitmapData()), t.resize(this.bmd.width, this.bmd.height), t.draw(this.bmd, e, i, s, n, r, a)
            }
        }, e.Create.prototype.constructor = e.Create, e.Color = {
            RED: 16711680,
            ORANGE: 16750848,
            YELLOW: 16776960,
            GREEN: 65280,
            AQUA: 65535,
            BLUE: 255,
            VIOLET: 16711935,
            WHITE: 16777215,
            BLACK: 0,
            GRAY: 6710886,
            packPixel: function(t, i, s, n) {
                return e.Device.LITTLE_ENDIAN ? (n << 24 | s << 16 | i << 8 | t) >>> 0 : (t << 24 | i << 16 | s << 8 | n) >>> 0
            },
            unpackPixel: function(t, i, s, n) {
                return void 0 !== i && null !== i || (i = e.Color.createColor()), void 0 !== s && null !== s || (s = !1), void 0 !== n && null !== n || (n = !1), e.Device.LITTLE_ENDIAN ? (i.a = (4278190080 & t) >>> 24, i.b = (16711680 & t) >>> 16, i.g = (65280 & t) >>> 8, i.r = 255 & t) : (i.r = (4278190080 & t) >>> 24, i.g = (16711680 & t) >>> 16, i.b = (65280 & t) >>> 8, i.a = 255 & t), i.color = t, i.rgba = "rgba(" + i.r + "," + i.g + "," + i.b + "," + i.a / 255 + ")", s && e.Color.RGBtoHSL(i.r, i.g, i.b, i), n && e.Color.RGBtoHSV(i.r, i.g, i.b, i), i
            },
            fromRGBA: function(t, i) {
                return i || (i = e.Color.createColor()), i.r = (4278190080 & t) >>> 24, i.g = (16711680 & t) >>> 16, i.b = (65280 & t) >>> 8, i.a = 255 & t, i.rgba = "rgba(" + i.r + "," + i.g + "," + i.b + "," + i.a + ")", i
            },
            toRGBA: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            toABGR: function(t, e, i, s) {
                return (s << 24 | i << 16 | e << 8 | t) >>> 0
            },
            hexToRGBArray: function(t) {
                return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
            },
            RGBArrayToHex: function(t) {
                return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
            },
            RGBtoHSL: function(t, i, s, n) {
                n || (n = e.Color.createColor(t, i, s, 1)), t /= 255, i /= 255, s /= 255;
                var r = Math.min(t, i, s),
                    a = Math.max(t, i, s);
                if (n.h = 0, n.s = 0, n.l = (a + r) / 2, a !== r) {
                    var o = a - r;
                    n.s = n.l > .5 ? o / (2 - a - r) : o / (a + r), a === t ? n.h = (i - s) / o + (i < s ? 6 : 0) : a === i ? n.h = (s - t) / o + 2 : a === s && (n.h = (t - i) / o + 4), n.h /= 6
                }
                return n
            },
            HSLtoRGB: function(t, i, s, n) {
                if (n ? (n.r = s, n.g = s, n.b = s) : n = e.Color.createColor(s, s, s), 0 !== i) {
                    var r = s < .5 ? s * (1 + i) : s + i - s * i,
                        a = 2 * s - r;
                    n.r = e.Color.hueToColor(a, r, t + 1 / 3), n.g = e.Color.hueToColor(a, r, t), n.b = e.Color.hueToColor(a, r, t - 1 / 3)
                }
                return n.r = Math.floor(255 * n.r | 0), n.g = Math.floor(255 * n.g | 0), n.b = Math.floor(255 * n.b | 0), e.Color.updateColor(n), n
            },
            RGBtoHSV: function(t, i, s, n) {
                n || (n = e.Color.createColor(t, i, s, 255)), t /= 255, i /= 255, s /= 255;
                var r = Math.min(t, i, s),
                    a = Math.max(t, i, s),
                    o = a - r;
                return n.h = 0, n.s = 0 === a ? 0 : o / a, n.v = a, a !== r && (a === t ? n.h = (i - s) / o + (i < s ? 6 : 0) : a === i ? n.h = (s - t) / o + 2 : a === s && (n.h = (t - i) / o + 4), n.h /= 6), n
            },
            HSVtoRGB: function(t, i, s, n) {
                void 0 === n && (n = e.Color.createColor(0, 0, 0, 1, t, i, 0, s));
                var r, a, o, h = Math.floor(6 * t),
                    l = 6 * t - h,
                    u = s * (1 - i),
                    c = s * (1 - l * i),
                    d = s * (1 - (1 - l) * i);
                switch (h % 6) {
                    case 0:
                        r = s, a = d, o = u;
                        break;
                    case 1:
                        r = c, a = s, o = u;
                        break;
                    case 2:
                        r = u, a = s, o = d;
                        break;
                    case 3:
                        r = u, a = c, o = s;
                        break;
                    case 4:
                        r = d, a = u, o = s;
                        break;
                    case 5:
                        r = s, a = u, o = c
                }
                return n.r = Math.floor(255 * r), n.g = Math.floor(255 * a), n.b = Math.floor(255 * o), e.Color.updateColor(n), n
            },
            hueToColor: function(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            },
            createColor: function(t, i, s, n, r, a, o, h) {
                var l = {
                    r: t || 0,
                    g: i || 0,
                    b: s || 0,
                    a: n || 1,
                    h: r || 0,
                    s: a || 0,
                    l: o || 0,
                    v: h || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return e.Color.updateColor(l)
            },
            updateColor: function(t) {
                return t.rgba = "rgba(" + t.r.toFixed() + "," + t.g.toFixed() + "," + t.b.toFixed() + "," + t.a.toString() + ")", t.color = e.Color.getColor(t.r, t.g, t.b), t.color32 = e.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
            },
            getColor32: function(t, e, i, s) {
                return t << 24 | e << 16 | i << 8 | s
            },
            getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            },
            RGBtoString: function(t, i, s, n, r) {
                return void 0 === n && (n = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (i << 8) + s).toString(16).slice(1) : "0x" + e.Color.componentToHex(n) + e.Color.componentToHex(t) + e.Color.componentToHex(i) + e.Color.componentToHex(s)
            },
            hexToRGB: function(t) {
                var i = e.Color.hexToColor(t);
                if (i) return e.Color.getColor32(i.a, i.r, i.g, i.b)
            },
            hexToColor: function(t, i) {
                t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                    return e + e + i + i + s + s
                });
                var s = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                if (s) {
                    var n = parseInt(s[1], 16),
                        r = parseInt(s[2], 16),
                        a = parseInt(s[3], 16);
                    i ? (i.r = n, i.g = r, i.b = a) : i = e.Color.createColor(n, r, a)
                }
                return i
            },
            webToColor: function(t, i) {
                i || (i = e.Color.createColor());
                var s = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                return s && (i.r = ~~Number(s[1]), i.g = ~~Number(s[2]), i.b = ~~Number(s[3]), i.a = void 0 !== s[4] ? Number(s[4]) : 1, e.Color.updateColor(i)), i
            },
            valueToColor: function(t, i) {
                if (i || (i = e.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? e.Color.webToColor(t, i) : (i.a = 1, e.Color.hexToColor(t, i));
                if ("number" == typeof t) {
                    var s = e.Color.getRGB(t);
                    return i.r = s.r, i.g = s.g, i.b = s.b, i.a = s.a / 255, i
                }
                return i
            },
            componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            },
            HSVColorWheel: function(t, i) {
                void 0 === t && (t = 1), void 0 === i && (i = 1);
                for (var s = [], n = 0; n <= 359; n++) s.push(e.Color.HSVtoRGB(n / 359, t, i));
                return s
            },
            HSLColorWheel: function(t, i) {
                void 0 === t && (t = .5), void 0 === i && (i = .5);
                for (var s = [], n = 0; n <= 359; n++) s.push(e.Color.HSLtoRGB(n / 359, t, i));
                return s
            },
            interpolateColor: function(t, i, s, n, r, a) {
                void 0 === r && (r = 255), void 0 === a && (a = 0);
                var o = e.Color.getRGB(t),
                    h = e.Color.getRGB(i);
                if (0 === a) var l = (h.red - o.red) * n / s + o.red,
                    u = (h.green - o.green) * n / s + o.green,
                    c = (h.blue - o.blue) * n / s + o.blue;
                if (1 === a) {
                    var d, p = e.Color.RGBtoHSV(o.r, o.g, o.b),
                        f = e.Color.RGBtoHSV(h.r, h.g, h.b),
                        m = f.h - p.h;
                    if (p.h > f.h) {
                        var g = f.h;
                        f.h = p.h, p.h = g, m = -m, n = s - n
                    }
                    m > .5 && (p.h = p.h + 1, d = ((f.h - p.h) * n / s + p.h) % 1), m <= .5 && (d = (f.h - p.h) * n / s + p.h);
                    var v = (f.s - p.s) * n / s + p.s,
                        y = (f.v - p.v) * n / s + p.v,
                        _ = e.Color.HSVtoRGB(d, v, y, _),
                        l = _.r,
                        u = _.g,
                        c = _.b
                }
                return e.Color.getColor32(r, l, u, c)
            },
            interpolateColorWithRGB: function(t, i, s, n, r, a) {
                var o = e.Color.getRGB(t),
                    h = (i - o.red) * a / r + o.red,
                    l = (s - o.green) * a / r + o.green,
                    u = (n - o.blue) * a / r + o.blue;
                return e.Color.getColor(h, l, u)
            },
            interpolateRGB: function(t, i, s, n, r, a, o, h) {
                var l = (n - t) * h / o + t,
                    u = (r - i) * h / o + i,
                    c = (a - s) * h / o + s;
                return e.Color.getColor(l, u, c)
            },
            linear: function(t, e, i) {
                return this.interpolateColor(t, e, 1, i)
            },
            linearInterpolation: function(t, i) {
                var s = e.Math.linear(0, t.length - 1, i),
                    n = t[Math.floor(s)],
                    r = t[Math.ceil(s)];
                return this.linear(n, r, s % 1)
            },
            getRandomColor: function(t, i, s) {
                if (void 0 === t && (t = 0), void 0 === i && (i = 255), void 0 === s && (s = 255), i > 255 || t > i) return e.Color.getColor(255, 255, 255);
                var n = t + Math.round(Math.random() * (i - t)),
                    r = t + Math.round(Math.random() * (i - t)),
                    a = t + Math.round(Math.random() * (i - t));
                return e.Color.getColor32(s, n, r, a)
            },
            getRGB: function(t) {
                return t > 16777215 ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            },
            getWebRGB: function(t) {
                if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                var i = e.Color.getRGB(t);
                return "rgba(" + i.r.toString() + "," + i.g.toString() + "," + i.b.toString() + "," + (i.a / 255).toString() + ")"
            },
            getAlpha: function(t) {
                return t >>> 24
            },
            getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            },
            getRed: function(t) {
                return t >> 16 & 255
            },
            getGreen: function(t) {
                return t >> 8 & 255
            },
            getBlue: function(t) {
                return 255 & t
            },
            blendNormal: function(t) {
                return t
            },
            blendLighten: function(t, e) {
                return e > t ? e : t
            },
            blendDarken: function(t, e) {
                return e > t ? t : e
            },
            blendMultiply: function(t, e) {
                return t * e / 255
            },
            blendAverage: function(t, e) {
                return (t + e) / 2
            },
            blendAdd: function(t, e) {
                return Math.min(255, t + e)
            },
            blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            },
            blendDifference: function(t, e) {
                return Math.abs(t - e)
            },
            blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            },
            blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            },
            blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            },
            blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            },
            blendSoftLight: function(t, e) {
                return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
            },
            blendHardLight: function(t, i) {
                return e.Color.blendOverlay(i, t)
            },
            blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            },
            blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            },
            blendLinearDodge: function(t, i) {
                return e.Color.blendAdd(t, i)
            },
            blendLinearBurn: function(t, i) {
                return e.Color.blendSubtract(t, i)
            },
            blendLinearLight: function(t, i) {
                return i < 128 ? e.Color.blendLinearBurn(t, 2 * i) : e.Color.blendLinearDodge(t, 2 * (i - 128))
            },
            blendVividLight: function(t, i) {
                return i < 128 ? e.Color.blendColorBurn(t, 2 * i) : e.Color.blendColorDodge(t, 2 * (i - 128))
            },
            blendPinLight: function(t, i) {
                return i < 128 ? e.Color.blendDarken(t, 2 * i) : e.Color.blendLighten(t, 2 * (i - 128))
            },
            blendHardMix: function(t, i) {
                return e.Color.blendVividLight(t, i) < 128 ? 0 : 255
            },
            blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            },
            blendGlow: function(t, i) {
                return e.Color.blendReflect(i, t)
            },
            blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        }, e.Physics = function(t, e) {
            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, e.Physics.ARCADE = 0, e.Physics.P2JS = 1, e.Physics.NINJA = 2, e.Physics.BOX2D = 3, e.Physics.CHIPMUNK = 4, e.Physics.MATTERJS = 5, e.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !e.Physics.hasOwnProperty("Arcade") || (this.arcade = new e.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && e.Physics.hasOwnProperty("Ninja") && (this.ninja = new e.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && e.Physics.hasOwnProperty("P2") && (this.p2 = new e.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && e.Physics.hasOwnProperty("BOX2D") && (this.box2d = new e.Physics.Box2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && e.Physics.hasOwnProperty("Matter") && (this.matter = new e.Physics.Matter(this.game, this.config))
            },
            startSystem: function(t) {
                t === e.Physics.ARCADE ? this.arcade = new e.Physics.Arcade(this.game) : t === e.Physics.P2JS ? null === this.p2 ? this.p2 = new e.Physics.P2(this.game, this.config) : this.p2.reset() : t === e.Physics.NINJA ? this.ninja = new e.Physics.Ninja(this.game) : t === e.Physics.BOX2D ? null === this.box2d ? this.box2d = new e.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === e.Physics.MATTERJS && (null === this.matter ? this.matter = new e.Physics.Matter(this.game, this.config) : this.matter.reset())
            },
            enable: function(t, i, s) {
                void 0 === i && (i = e.Physics.ARCADE), void 0 === s && (s = !1), i === e.Physics.ARCADE ? this.arcade.enable(t) : i === e.Physics.P2JS && this.p2 ? this.p2.enable(t, s) : i === e.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : i === e.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : i === e.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
            }
        }, e.Physics.prototype.constructor = e.Physics, e.Particles = function(t) {
            this.game = t, this.emitters = {}, this.ID = 0
        }, e.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.id] = t, t
            },
            remove: function(t) {
                delete this.emitters[t.id]
            }
        }, e.Particles.prototype.constructor = e.Particles, PIXI.CreatureShader = function(t) {
            this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["//CreatureShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"], this.vertexSrc = ["//CreatureShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform vec3 tint;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = vec4(tint[0], tint[1], tint[2], 1.0) * aColor.a * alpha;", "}"], this.init()
        }, PIXI.CreatureShader.prototype.constructor = PIXI.CreatureShader, PIXI.CreatureShader.prototype.init = function() {
            var t = this.gl,
                e = PIXI.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = PIXI._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.tintColor = t.getUniformLocation(e, "tint"), this.program = e
        }, PIXI.CreatureShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, e.Creature = function(t, i, s, n, r, a, o) {
            if (this.game = t, void 0 === a && (a = "default"), void 0 === o && (o = !1), this.type = e.CREATURE, t.cache.checkJSONKey(r)) {
                var h = t.cache.getJSON(r, !0);
                if (this._creature = new Creature(h, o), this.animation = new CreatureAnimation(h, a, o), this.manager = new CreatureManager(this._creature), this.timeDelta = .05, "string" == typeof n) l = new PIXI.Texture(t.cache.getBaseTexture(n));
                else var l = n;
                this.texture = l, PIXI.DisplayObjectContainer.call(this), this.dirty = !0, this.blendMode = PIXI.blendModes.NORMAL, this.creatureBoundsMin = new e.Point, this.creatureBoundsMax = new e.Point;
                var u = this.manager.target_creature;
                this.vertices = new Float32Array(2 * u.total_num_pts), this.uvs = new Float32Array(2 * u.total_num_pts), this.indices = new Uint16Array(u.global_indices.length);
                for (var c = 0; c < this.indices.length; c++) this.indices[c] = u.global_indices[c];
                this.colors = new Float32Array(4 * u.total_num_pts);
                for (var d = 0; d < this.colors.length; d++) this.colors[d] = 1;
                this.updateRenderData(u.global_pts, u.global_uvs), this.manager.AddAnimation(this.animation), this.manager.SetActiveAnimationName(a, !1), e.Component.Core.init.call(this, t, i, s), this.data.tint = 16777215, this.data.alpha = 1
            } else console.warn("Phaser.Creature: Invalid mesh key given. Not found in Phaser.Cache")
        }, e.Creature.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), e.Creature.prototype.constructor = e.Creature, e.Component.Core.install.call(e.Creature.prototype, ["Angle", "AutoCull", "BringToTop", "Destroy", "FixedToCamera", "LifeSpan", "Reset", "InputEnabled"]), e.Creature.prototype.preUpdateInWorld = e.Component.InWorld.preUpdate, e.Creature.prototype.preUpdateCore = e.Component.Core.preUpdate, e.Creature.prototype.preUpdate = function() {
            return !!this.preUpdateInWorld() && (this.manager.Update(this.timeDelta), this.updateData(), this.preUpdateCore())
        }, e.Creature.prototype._initWebGL = function(t) {
            var e = t.gl;
            this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
        }, e.Creature.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.creatureShader), this._renderCreature(t), t.spriteBatch.start())
        }, e.Creature.prototype._renderCreature = function(t) {
            var i = t.gl,
                s = t.projection,
                n = t.offset,
                r = t.shaderManager.creatureShader;
            t.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(r.projectionVector, s.x, -s.y), i.uniform2f(r.offsetVector, -n.x, -n.y), i.uniform1f(r.alpha, this.worldAlpha), i.uniform3fv(r.tintColor, e.Color.hexToRGBArray(this.tint)), i.uniform1f(r.alpha, this.alpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.DYNAMIC_DRAW), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.DYNAMIC_DRAW), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._colorBuffer), i.bufferData(i.ARRAY_BUFFER, this.colors, i.STATIC_DRAW), i.vertexAttribPointer(r.colorAttribute, 4, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._colorBuffer), i.bufferData(i.ARRAY_BUFFER, this.colors, i.STATIC_DRAW), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(i.TRIANGLES, this.indices.length, i.UNSIGNED_SHORT, 0)
        }, e.Creature.prototype.updateCreatureBounds = function() {
            var t = this.manager.target_creature;
            t.ComputeBoundaryMinMax(), this.creatureBoundsMin.set(t.boundary_min[0], -t.boundary_min[1]), this.creatureBoundsMax.set(t.boundary_max[0], -t.boundary_max[1]), this.worldTransform.apply(this.creatureBoundsMin, this.creatureBoundsMin), this.worldTransform.apply(this.creatureBoundsMax, this.creatureBoundsMax)
        }, e.Creature.prototype.updateData = function() {
            var t = this.manager.target_creature,
                e = t.render_pts,
                i = t.global_uvs;
            this.updateRenderData(e, i), this.updateCreatureBounds(), this.dirty = !0
        }, e.Creature.prototype.updateRenderData = function(t, e) {
            for (var i = this.manager.target_creature, s = 0, n = 0, r = 0, a = 0; a < i.total_num_pts; a++) this.vertices[r] = t[s], this.vertices[r + 1] = -t[s + 1], this.uvs[n] = e[n], this.uvs[n + 1] = e[n + 1], s += 3, n += 2, r += 2;
            var o = i.render_composition.getRegionsMap();
            for (var h in o)
                for (var l = o[h], u = l.getStartPtIndex(), c = l.getEndPtIndex() + 1, d = .01 * l.opacity, a = 4 * u; a <= 4 * c; a++) this.colors[a] = d
        }, e.Creature.prototype.setAnimation = function(t) {
            this.data.anchorY = null, this.data.anchorX = null, this.data.animation = t, this.manager.SetActiveAnimationName(t, !0)
        }, e.Creature.prototype.setAnimationPlaySpeed = function(t) {
            t && (this.timeDelta = t)
        }, e.Creature.prototype.play = function(t) {
            void 0 === t && (t = !1), this.loop = t, this.manager.SetIsPlaying(!0), this.manager.RunAtTime(0)
        }, e.Creature.prototype.stop = function() {
            this.manager.SetIsPlaying(!1)
        }, Object.defineProperty(e.Creature.prototype, "isPlaying", {
            get: function() {
                return this.manager.GetIsPlaying()
            },
            set: function(t) {
                this.manager.SetIsPlaying(t)
            }
        }), Object.defineProperty(e.Creature.prototype, "loop", {
            get: function() {
                return this.manager.should_loop
            },
            set: function(t) {
                this.manager.SetShouldLoop(t)
            }
        }), Object.defineProperty(e.Creature.prototype, "height", {
            get: function() {
                return this.data.height
            },
            set: function(t) {
                var e = this.manager.target_creature,
                    i = this.data.width ? this.data.width : 0,
                    s = e.GetPixelScaling(i, t);
                this.scale.set(s[0], s[1]), this.data.height = t
            }
        }), Object.defineProperty(e.Creature.prototype, "width", {
            get: function() {
                return this.data.width
            },
            set: function(t) {
                var e = this.manager.target_creature,
                    i = this.data.height ? this.data.height : 0,
                    s = e.GetPixelScaling(t, i);
                this.scale.set(s[0], s[1]), this.data.width = t
            }
        }), Object.defineProperty(e.Creature.prototype, "anchorX", {
            get: function() {
                return this.data.anchorX
            },
            set: function(t) {
                if (0 === t && (t = .01), 1 === t && (t = .99), t !== this.data.anchorX) {
                    var e = this.manager.target_creature;
                    this.stop(), this.manager.RunAtTime(0), this.data.anchorX && (e.SetAnchorPoint(-this.data.anchorX, null, this.data.animation), this.play(!0), this.stop(), this.manager.RunAtTime(0)), e.SetAnchorPoint(t, null, this.data.animation), this.play(!0), this.data.anchorX = t
                }
            }
        }), Object.defineProperty(e.Creature.prototype, "anchorY", {
            get: function() {
                return this.data.anchorY
            },
            set: function(t) {
                if (0 === t && (t = .01), 1 === t && (t = .99), t !== this.data.anchorY) {
                    var e = this.manager.target_creature;
                    this.stop(), this.manager.RunAtTime(0), this.data.anchorY && (e.SetAnchorPoint(null, -this.data.anchorY, this.data.animation), this.play(!0), this.stop(), this.manager.RunAtTime(0)), e.SetAnchorPoint(null, t, this.data.animation), this.play(!0), this.data.anchorY = t
                }
            }
        }), Object.defineProperty(e.Creature.prototype, "tint", {
            get: function() {
                return this.data.tint
            },
            set: function(t) {
                this.data.tint = t
            }
        }), Object.defineProperty(e.Creature.prototype, "alpha", {
            get: function() {
                return this.data.alpha
            },
            set: function(t) {
                this.data.alpha = t
            }
        }), e.Creature.prototype.setAnchorPointEnabled = function(t) {
            this.manager.target_creature.SetAnchorPointEnabled(t)
        }, e.Creature.prototype.createAllAnimations = function(t) {
            if (this.game.cache.checkJSONKey(t)) {
                var e = this.game.cache.getJSON(t, !0);
                this.manager.CreateAllAnimations(e)
            } else console.warn("Phaser.Creature: Invalid mesh key given. Not found in Phaser.Cache")
        }, e.Creature.prototype.setMetaData = function(t) {
            if (this.game.cache.checkJSONKey(t)) {
                var e = this.game.cache.getJSON(t, !0),
                    i = CreatureModuleUtils.BuildCreatureMetaData(e);
                this._creature.SetMetaData(i)
            } else console.warn("Phaser.Creature: Invalid meta key given. Not found in Phaser.Cache")
        }, e.Creature.prototype.enableSkinSwap = function(t, e) {
            var i = this.manager.target_creature;
            if (null !== i.creature_meta_data) {
                i.EnableSkinSwap(t, e), this.indices = new Uint16Array(i.final_skin_swap_indices.length);
                for (var s = 0; s < this.indices.length; s++) this.indices[s] = i.final_skin_swap_indices[s]
            } else console.warn("Phaser.Creature: Attempting to use skin swapping before setting the meta data. You must use {@link #setMetaData} before using skin swapping functionality.")
        }, e.Creature.prototype.disableSkinSwap = function() {
            var t = this.manager.target_creature;
            if (null !== t.creature_meta_data) {
                t.DisableSkinSwap(), this.indices = new Uint16Array(t.global_indices.length);
                for (var e = 0; e < this.indices.length; e++) this.indices[e] = t.global_indices[e]
            } else console.warn("Phaser.Creature: Attempting to use skin swapping before setting the meta data. You must use {@link #setMetaData} before using skin swapping functionality.")
        }, e.Creature.prototype.setActiveItemSwap = function(t, e) {
            this.manager.target_creature.active_uv_swap_actions[t] = e
        }, e.Creature.prototype.removeActiveItemSwap = function(t) {
            delete this.manager.target_creature.active_uv_swap_actions[t]
        }, void 0 === PIXI.blendModes && (PIXI.blendModes = e.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = e.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new e.Matrix), PIXI.TextureSilentFail = !0, PIXI.canUseNewCanvasBlendModes = function() {
            return e.Device.canUseMultiply
        }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = e), exports.Phaser = e) : "undefined" != typeof define && define.amd ? define("Phaser", t.Phaser = e) : t.Phaser = e, e
    }.call(this);
//# sourceMappingURL=custom-phaser.map