// Generated by Construct 3, the game and app creator :: https://www.construct.net
'use strict';
"use strict";
(function(e, d) {
    "object" === typeof exports && "undefined" !== typeof module ? d(exports) : "function" === typeof define && define.amd ? define(["exports"], d) : (e = e || self, d(e.glMatrix = {}))
})(this, function(e) {
    function d(l, n, v) {
        var z = n[0],
            D = n[1],
            E = n[2];
        n = n[3];
        var I = v[0],
            L = v[1],
            O = v[2];
        v = v[3];
        l[0] = z * I + E * L;
        l[1] = D * I + n * L;
        l[2] = z * O + E * v;
        l[3] = D * O + n * v;
        return l
    }

    function a(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        l[2] = n[2] - v[2];
        l[3] = n[3] - v[3];
        return l
    }

    function b(l, n, v) {
        var z = n[0],
            D = n[1],
            E = n[2],
            I = n[3],
            L = n[4];
        n = n[5];
        var O = v[0],
            Q = v[1],
            S = v[2],
            T = v[3],
            Y = v[4];
        v = v[5];
        l[0] = z * O + E * Q;
        l[1] = D * O + I * Q;
        l[2] = z * S + E * T;
        l[3] = D * S + I * T;
        l[4] = z * Y + E * v + L;
        l[5] = D * Y + I * v + n;
        return l
    }

    function c(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        l[2] = n[2] - v[2];
        l[3] = n[3] - v[3];
        l[4] = n[4] - v[4];
        l[5] = n[5] - v[5];
        return l
    }

    function f() {
        var l = new ra(9);
        ra != Float32Array && (l[1] = 0, l[2] = 0, l[3] = 0, l[5] = 0, l[6] = 0, l[7] = 0);
        l[0] = 1;
        l[4] = 1;
        l[8] = 1;
        return l
    }

    function h(l, n, v) {
        var z = n[0],
            D = n[1],
            E = n[2],
            I = n[3],
            L = n[4],
            O = n[5],
            Q = n[6],
            S = n[7];
        n = n[8];
        var T = v[0],
            Y = v[1],
            X = v[2],
            ea = v[3],
            ca = v[4],
            aa = v[5],
            wa = v[6],
            pa =
            v[7];
        v = v[8];
        l[0] = T * z + Y * I + X * Q;
        l[1] = T * D + Y * L + X * S;
        l[2] = T * E + Y * O + X * n;
        l[3] = ea * z + ca * I + aa * Q;
        l[4] = ea * D + ca * L + aa * S;
        l[5] = ea * E + ca * O + aa * n;
        l[6] = wa * z + pa * I + v * Q;
        l[7] = wa * D + pa * L + v * S;
        l[8] = wa * E + pa * O + v * n;
        return l
    }

    function g(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        l[2] = n[2] - v[2];
        l[3] = n[3] - v[3];
        l[4] = n[4] - v[4];
        l[5] = n[5] - v[5];
        l[6] = n[6] - v[6];
        l[7] = n[7] - v[7];
        l[8] = n[8] - v[8];
        return l
    }

    function k(l) {
        l[0] = 1;
        l[1] = 0;
        l[2] = 0;
        l[3] = 0;
        l[4] = 0;
        l[5] = 1;
        l[6] = 0;
        l[7] = 0;
        l[8] = 0;
        l[9] = 0;
        l[10] = 1;
        l[11] = 0;
        l[12] = 0;
        l[13] = 0;
        l[14] = 0;
        l[15] = 1;
        return l
    }

    function m(l,
        n, v) {
        var z = n[0],
            D = n[1],
            E = n[2],
            I = n[3],
            L = n[4],
            O = n[5],
            Q = n[6],
            S = n[7],
            T = n[8],
            Y = n[9],
            X = n[10],
            ea = n[11],
            ca = n[12],
            aa = n[13],
            wa = n[14];
        n = n[15];
        var pa = v[0],
            ua = v[1],
            va = v[2],
            ta = v[3];
        l[0] = pa * z + ua * L + va * T + ta * ca;
        l[1] = pa * D + ua * O + va * Y + ta * aa;
        l[2] = pa * E + ua * Q + va * X + ta * wa;
        l[3] = pa * I + ua * S + va * ea + ta * n;
        pa = v[4];
        ua = v[5];
        va = v[6];
        ta = v[7];
        l[4] = pa * z + ua * L + va * T + ta * ca;
        l[5] = pa * D + ua * O + va * Y + ta * aa;
        l[6] = pa * E + ua * Q + va * X + ta * wa;
        l[7] = pa * I + ua * S + va * ea + ta * n;
        pa = v[8];
        ua = v[9];
        va = v[10];
        ta = v[11];
        l[8] = pa * z + ua * L + va * T + ta * ca;
        l[9] = pa * D + ua * O + va * Y + ta * aa;
        l[10] = pa *
            E + ua * Q + va * X + ta * wa;
        l[11] = pa * I + ua * S + va * ea + ta * n;
        pa = v[12];
        ua = v[13];
        va = v[14];
        ta = v[15];
        l[12] = pa * z + ua * L + va * T + ta * ca;
        l[13] = pa * D + ua * O + va * Y + ta * aa;
        l[14] = pa * E + ua * Q + va * X + ta * wa;
        l[15] = pa * I + ua * S + va * ea + ta * n;
        return l
    }

    function r(l, n, v) {
        var z = n[0],
            D = n[1],
            E = n[2],
            I = n[3],
            L = z + z,
            O = D + D,
            Q = E + E;
        n = z * L;
        var S = z * O;
        z *= Q;
        var T = D * O;
        D *= Q;
        E *= Q;
        L *= I;
        O *= I;
        I *= Q;
        l[0] = 1 - (T + E);
        l[1] = S + I;
        l[2] = z - O;
        l[3] = 0;
        l[4] = S - I;
        l[5] = 1 - (n + E);
        l[6] = D + L;
        l[7] = 0;
        l[8] = z + O;
        l[9] = D - L;
        l[10] = 1 - (n + T);
        l[11] = 0;
        l[12] = v[0];
        l[13] = v[1];
        l[14] = v[2];
        l[15] = 1;
        return l
    }

    function w(l,
        n) {
        l[0] = n[12];
        l[1] = n[13];
        l[2] = n[14];
        return l
    }

    function p(l, n) {
        var v = n[4],
            z = n[5],
            D = n[6],
            E = n[8],
            I = n[9],
            L = n[10];
        l[0] = Math.hypot(n[0], n[1], n[2]);
        l[1] = Math.hypot(v, z, D);
        l[2] = Math.hypot(E, I, L);
        return l
    }

    function t(l, n) {
        var v = new ra(3);
        p(v, n);
        var z = 1 / v[0],
            D = 1 / v[1],
            E = 1 / v[2],
            I = n[0] * z;
        v = n[1] * D;
        var L = n[2] * E,
            O = n[4] * z,
            Q = n[5] * D,
            S = n[6] * E;
        z *= n[8];
        D *= n[9];
        n = n[10] * E;
        E = I + Q + n;
        0 < E ? (I = 2 * Math.sqrt(E + 1), l[3] = .25 * I, l[0] = (S - D) / I, l[1] = (z - L) / I, l[2] = (v - O) / I) : I > Q && I > n ? (I = 2 * Math.sqrt(1 + I - Q - n), l[3] = (S - D) / I, l[0] = .25 * I, l[1] = (v + O) / I,
            l[2] = (z + L) / I) : Q > n ? (I = 2 * Math.sqrt(1 + Q - I - n), l[3] = (z - L) / I, l[0] = (v + O) / I, l[1] = .25 * I, l[2] = (S + D) / I) : (I = 2 * Math.sqrt(1 + n - I - Q), l[3] = (v - O) / I, l[0] = (z + L) / I, l[1] = (S + D) / I, l[2] = .25 * I);
        return l
    }

    function u(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        l[2] = n[2] - v[2];
        l[3] = n[3] - v[3];
        l[4] = n[4] - v[4];
        l[5] = n[5] - v[5];
        l[6] = n[6] - v[6];
        l[7] = n[7] - v[7];
        l[8] = n[8] - v[8];
        l[9] = n[9] - v[9];
        l[10] = n[10] - v[10];
        l[11] = n[11] - v[11];
        l[12] = n[12] - v[12];
        l[13] = n[13] - v[13];
        l[14] = n[14] - v[14];
        l[15] = n[15] - v[15];
        return l
    }

    function q() {
        var l = new ra(3);
        ra != Float32Array &&
            (l[0] = 0, l[1] = 0, l[2] = 0);
        return l
    }

    function x(l) {
        return Math.hypot(l[0], l[1], l[2])
    }

    function y(l, n, v) {
        var z = new ra(3);
        z[0] = l;
        z[1] = n;
        z[2] = v;
        return z
    }

    function B(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        l[2] = n[2] - v[2];
        return l
    }

    function F(l, n, v) {
        l[0] = n[0] * v[0];
        l[1] = n[1] * v[1];
        l[2] = n[2] * v[2];
        return l
    }

    function H(l, n, v) {
        l[0] = n[0] / v[0];
        l[1] = n[1] / v[1];
        l[2] = n[2] / v[2];
        return l
    }

    function K(l, n) {
        return Math.hypot(n[0] - l[0], n[1] - l[1], n[2] - l[2])
    }

    function C(l, n) {
        var v = n[0] - l[0],
            z = n[1] - l[1];
        l = n[2] - l[2];
        return v * v + z * z + l * l
    }

    function A(l) {
        var n =
            l[0],
            v = l[1];
        l = l[2];
        return n * n + v * v + l * l
    }

    function G(l, n) {
        var v = n[0],
            z = n[1],
            D = n[2];
        v = v * v + z * z + D * D;
        0 < v && (v = 1 / Math.sqrt(v));
        l[0] = n[0] * v;
        l[1] = n[1] * v;
        l[2] = n[2] * v;
        return l
    }

    function J(l, n) {
        return l[0] * n[0] + l[1] * n[1] + l[2] * n[2]
    }

    function M(l, n, v) {
        var z = n[0],
            D = n[1];
        n = n[2];
        var E = v[0],
            I = v[1];
        v = v[2];
        l[0] = D * v - n * I;
        l[1] = n * E - z * v;
        l[2] = z * I - D * E;
        return l
    }

    function R() {
        var l = new ra(4);
        ra != Float32Array && (l[0] = 0, l[1] = 0, l[2] = 0, l[3] = 0);
        return l
    }

    function U(l) {
        var n = new ra(4);
        n[0] = l[0];
        n[1] = l[1];
        n[2] = l[2];
        n[3] = l[3];
        return n
    }

    function V(l,
        n, v, z) {
        var D = new ra(4);
        D[0] = l;
        D[1] = n;
        D[2] = v;
        D[3] = z;
        return D
    }

    function ba(l, n) {
        l[0] = n[0];
        l[1] = n[1];
        l[2] = n[2];
        l[3] = n[3];
        return l
    }

    function ia(l, n, v, z, D) {
        l[0] = n;
        l[1] = v;
        l[2] = z;
        l[3] = D;
        return l
    }

    function ja(l, n, v) {
        l[0] = n[0] + v[0];
        l[1] = n[1] + v[1];
        l[2] = n[2] + v[2];
        l[3] = n[3] + v[3];
        return l
    }

    function qa(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        l[2] = n[2] - v[2];
        l[3] = n[3] - v[3];
        return l
    }

    function za(l, n, v) {
        l[0] = n[0] * v[0];
        l[1] = n[1] * v[1];
        l[2] = n[2] * v[2];
        l[3] = n[3] * v[3];
        return l
    }

    function Ca(l, n, v) {
        l[0] = n[0] / v[0];
        l[1] = n[1] / v[1];
        l[2] =
            n[2] / v[2];
        l[3] = n[3] / v[3];
        return l
    }

    function Ma(l, n, v) {
        l[0] = n[0] * v;
        l[1] = n[1] * v;
        l[2] = n[2] * v;
        l[3] = n[3] * v;
        return l
    }

    function Fa(l, n) {
        return Math.hypot(n[0] - l[0], n[1] - l[1], n[2] - l[2], n[3] - l[3])
    }

    function La(l, n) {
        var v = n[0] - l[0],
            z = n[1] - l[1],
            D = n[2] - l[2];
        l = n[3] - l[3];
        return v * v + z * z + D * D + l * l
    }

    function na(l) {
        return Math.hypot(l[0], l[1], l[2], l[3])
    }

    function Sa(l) {
        var n = l[0],
            v = l[1],
            z = l[2];
        l = l[3];
        return n * n + v * v + z * z + l * l
    }

    function Aa(l, n) {
        var v = n[0],
            z = n[1],
            D = n[2];
        n = n[3];
        var E = v * v + z * z + D * D + n * n;
        0 < E && (E = 1 / Math.sqrt(E));
        l[0] =
            v * E;
        l[1] = z * E;
        l[2] = D * E;
        l[3] = n * E;
        return l
    }

    function Na(l, n) {
        return l[0] * n[0] + l[1] * n[1] + l[2] * n[2] + l[3] * n[3]
    }

    function lb(l, n, v, z) {
        var D = n[0],
            E = n[1],
            I = n[2];
        n = n[3];
        l[0] = D + z * (v[0] - D);
        l[1] = E + z * (v[1] - E);
        l[2] = I + z * (v[2] - I);
        l[3] = n + z * (v[3] - n);
        return l
    }

    function mb(l, n) {
        return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3]
    }

    function nb(l, n) {
        var v = l[0],
            z = l[1],
            D = l[2];
        l = l[3];
        var E = n[0],
            I = n[1],
            L = n[2];
        n = n[3];
        return Math.abs(v - E) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(E)) && Math.abs(z - I) <= 1E-6 * Math.max(1, Math.abs(z),
            Math.abs(I)) && Math.abs(D - L) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(L)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
    }

    function ab() {
        var l = new ra(4);
        ra != Float32Array && (l[0] = 0, l[1] = 0, l[2] = 0);
        l[3] = 1;
        return l
    }

    function ob(l, n, v) {
        v *= .5;
        var z = Math.sin(v);
        l[0] = z * n[0];
        l[1] = z * n[1];
        l[2] = z * n[2];
        l[3] = Math.cos(v);
        return l
    }

    function pb(l, n, v) {
        var z = n[0],
            D = n[1],
            E = n[2];
        n = n[3];
        var I = v[0],
            L = v[1],
            O = v[2];
        v = v[3];
        l[0] = z * v + n * I + D * O - E * L;
        l[1] = D * v + n * L + E * I - z * O;
        l[2] = E * v + n * O + z * L - D * I;
        l[3] = n * v - z * I - D * L - E * O;
        return l
    }

    function qb(l,
        n, v) {
        v *= .5;
        var z = n[0],
            D = n[1],
            E = n[2];
        n = n[3];
        var I = Math.sin(v);
        v = Math.cos(v);
        l[0] = z * v + n * I;
        l[1] = D * v + E * I;
        l[2] = E * v - D * I;
        l[3] = n * v - z * I;
        return l
    }

    function rb(l, n, v) {
        v *= .5;
        var z = n[0],
            D = n[1],
            E = n[2];
        n = n[3];
        var I = Math.sin(v);
        v = Math.cos(v);
        l[0] = z * v - E * I;
        l[1] = D * v + n * I;
        l[2] = E * v + z * I;
        l[3] = n * v - D * I;
        return l
    }

    function sb(l, n, v) {
        v *= .5;
        var z = n[0],
            D = n[1],
            E = n[2];
        n = n[3];
        var I = Math.sin(v);
        v = Math.cos(v);
        l[0] = z * v + D * I;
        l[1] = D * v - z * I;
        l[2] = E * v + n * I;
        l[3] = n * v - E * I;
        return l
    }

    function tb(l, n) {
        var v = n[0],
            z = n[1],
            D = n[2],
            E = Math.sqrt(v * v + z * z + D * D);
        n = Math.exp(n[3]);
        var I = 0 < E ? n * Math.sin(E) / E : 0;
        l[0] = v * I;
        l[1] = z * I;
        l[2] = D * I;
        l[3] = n * Math.cos(E);
        return l
    }

    function ub(l, n) {
        var v = n[0],
            z = n[1],
            D = n[2];
        n = n[3];
        var E = Math.sqrt(v * v + z * z + D * D);
        E = 0 < E ? Math.atan2(E, n) / E : 0;
        l[0] = v * E;
        l[1] = z * E;
        l[2] = D * E;
        l[3] = .5 * Math.log(v * v + z * z + D * D + n * n);
        return l
    }

    function bb(l, n, v, z) {
        var D = n[0],
            E = n[1],
            I = n[2];
        n = n[3];
        var L = v[0],
            O = v[1],
            Q = v[2];
        v = v[3];
        var S = D * L + E * O + I * Q + n * v;
        0 > S && (S = -S, L = -L, O = -O, Q = -Q, v = -v);
        if (1E-6 < 1 - S) {
            var T = Math.acos(S);
            var Y = Math.sin(T);
            S = Math.sin((1 - z) * T) / Y;
            z = Math.sin(z * T) /
                Y
        } else S = 1 - z;
        l[0] = S * D + z * L;
        l[1] = S * E + z * O;
        l[2] = S * I + z * Q;
        l[3] = S * n + z * v;
        return l
    }

    function vb(l, n) {
        var v = n[0] + n[4] + n[8];
        if (0 < v) v = Math.sqrt(v + 1), l[3] = .5 * v, v = .5 / v, l[0] = (n[5] - n[7]) * v, l[1] = (n[6] - n[2]) * v, l[2] = (n[1] - n[3]) * v;
        else {
            var z = 0;
            n[4] > n[0] && (z = 1);
            n[8] > n[3 * z + z] && (z = 2);
            var D = (z + 1) % 3,
                E = (z + 2) % 3;
            v = Math.sqrt(n[3 * z + z] - n[3 * D + D] - n[3 * E + E] + 1);
            l[z] = .5 * v;
            v = .5 / v;
            l[3] = (n[3 * D + E] - n[3 * E + D]) * v;
            l[D] = (n[3 * D + z] + n[3 * z + D]) * v;
            l[E] = (n[3 * E + z] + n[3 * z + E]) * v
        }
        return l
    }

    function wb(l, n, v) {
        var z = .5 * v[0],
            D = .5 * v[1];
        v = .5 * v[2];
        var E = n[0],
            I = n[1],
            L = n[2];
        n = n[3];
        l[0] = E;
        l[1] = I;
        l[2] = L;
        l[3] = n;
        l[4] = z * n + D * L - v * I;
        l[5] = D * n + v * E - z * L;
        l[6] = v * n + z * I - D * E;
        l[7] = -z * E - D * I - v * L;
        return l
    }

    function xb(l, n) {
        l[0] = n[0];
        l[1] = n[1];
        l[2] = n[2];
        l[3] = n[3];
        l[4] = n[4];
        l[5] = n[5];
        l[6] = n[6];
        l[7] = n[7];
        return l
    }

    function yb(l, n, v) {
        var z = n[0],
            D = n[1],
            E = n[2],
            I = n[3],
            L = v[4],
            O = v[5],
            Q = v[6],
            S = v[7],
            T = n[4],
            Y = n[5],
            X = n[6];
        n = n[7];
        var ea = v[0],
            ca = v[1],
            aa = v[2];
        v = v[3];
        l[0] = z * v + I * ea + D * aa - E * ca;
        l[1] = D * v + I * ca + E * ea - z * aa;
        l[2] = E * v + I * aa + z * ca - D * ea;
        l[3] = I * v - z * ea - D * ca - E * aa;
        l[4] = z * S + I * L + D * Q - E * O + T * v + n * ea + Y * aa - X *
            ca;
        l[5] = D * S + I * O + E * L - z * Q + Y * v + n * ca + X * ea - T * aa;
        l[6] = E * S + I * Q + z * O - D * L + X * v + n * aa + T * ca - Y * ea;
        l[7] = I * S - z * L - D * O - E * Q + n * v - T * ea - Y * ca - X * aa;
        return l
    }

    function cb() {
        var l = new ra(2);
        ra != Float32Array && (l[0] = 0, l[1] = 0);
        return l
    }

    function Xa(l, n, v) {
        l[0] = n[0] - v[0];
        l[1] = n[1] - v[1];
        return l
    }

    function db(l, n, v) {
        l[0] = n[0] * v[0];
        l[1] = n[1] * v[1];
        return l
    }

    function eb(l, n, v) {
        l[0] = n[0] / v[0];
        l[1] = n[1] / v[1];
        return l
    }

    function Ya(l, n) {
        return Math.hypot(n[0] - l[0], n[1] - l[1])
    }

    function fb(l, n) {
        var v = n[0] - l[0];
        l = n[1] - l[1];
        return v * v + l * l
    }

    function Ta(l) {
        return Math.hypot(l[0],
            l[1])
    }

    function gb(l) {
        var n = l[0];
        l = l[1];
        return n * n + l * l
    }
    var ra = "undefined" !== typeof Float32Array ? Float32Array : Array,
        Qa = Math.random,
        zb = Math.PI / 180;
    Math.hypot || (Math.hypot = function() {
        for (var l = 0, n = arguments.length; n--;) l += arguments[n] * arguments[n];
        return Math.sqrt(l)
    });
    var Ab = Object.freeze({
            __proto__: null,
            EPSILON: 1E-6,
            get ARRAY_TYPE() {
                return ra
            },
            RANDOM: Qa,
            setMatrixArrayType: function(l) {
                ra = l
            },
            toRadian: function(l) {
                return l * zb
            },
            equals: function(l, n) {
                return Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
            }
        }),
        Db = Object.freeze({
            __proto__: null,
            create: function() {
                var l = new ra(4);
                ra != Float32Array && (l[1] = 0, l[2] = 0);
                l[0] = 1;
                l[3] = 1;
                return l
            },
            clone: function(l) {
                var n = new ra(4);
                n[0] = l[0];
                n[1] = l[1];
                n[2] = l[2];
                n[3] = l[3];
                return n
            },
            copy: function(l, n) {
                l[0] = n[0];
                l[1] = n[1];
                l[2] = n[2];
                l[3] = n[3];
                return l
            },
            identity: function(l) {
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] = 1;
                return l
            },
            fromValues: function(l, n, v, z) {
                var D = new ra(4);
                D[0] = l;
                D[1] = n;
                D[2] = v;
                D[3] = z;
                return D
            },
            set: function(l, n, v, z, D) {
                l[0] = n;
                l[1] = v;
                l[2] = z;
                l[3] = D;
                return l
            },
            transpose: function(l,
                n) {
                if (l === n) {
                    var v = n[1];
                    l[1] = n[2];
                    l[2] = v
                } else l[0] = n[0], l[1] = n[2], l[2] = n[1], l[3] = n[3];
                return l
            },
            invert: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2];
                n = n[3];
                var E = v * n - D * z;
                if (!E) return null;
                E = 1 / E;
                l[0] = n * E;
                l[1] = -z * E;
                l[2] = -D * E;
                l[3] = v * E;
                return l
            },
            adjoint: function(l, n) {
                var v = n[0];
                l[0] = n[3];
                l[1] = -n[1];
                l[2] = -n[2];
                l[3] = v;
                return l
            },
            determinant: function(l) {
                return l[0] * l[3] - l[2] * l[1]
            },
            multiply: d,
            rotate: function(l, n, v) {
                var z = n[0],
                    D = n[1],
                    E = n[2];
                n = n[3];
                var I = Math.sin(v);
                v = Math.cos(v);
                l[0] = z * v + E * I;
                l[1] = D * v + n * I;
                l[2] = z * -I +
                    E * v;
                l[3] = D * -I + n * v;
                return l
            },
            scale: function(l, n, v) {
                var z = n[1],
                    D = n[2],
                    E = n[3],
                    I = v[0];
                v = v[1];
                l[0] = n[0] * I;
                l[1] = z * I;
                l[2] = D * v;
                l[3] = E * v;
                return l
            },
            fromRotation: function(l, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                l[0] = n;
                l[1] = v;
                l[2] = -v;
                l[3] = n;
                return l
            },
            fromScaling: function(l, n) {
                l[0] = n[0];
                l[1] = 0;
                l[2] = 0;
                l[3] = n[1];
                return l
            },
            str: function(l) {
                return "mat2(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")"
            },
            frob: function(l) {
                return Math.hypot(l[0], l[1], l[2], l[3])
            },
            LDU: function(l, n, v, z) {
                l[2] = z[2] / z[0];
                v[0] = z[0];
                v[1] = z[1];
                v[3] = z[3] - l[2] *
                    v[1];
                return [l, n, v]
            },
            add: function(l, n, v) {
                l[0] = n[0] + v[0];
                l[1] = n[1] + v[1];
                l[2] = n[2] + v[2];
                l[3] = n[3] + v[3];
                return l
            },
            subtract: a,
            exactEquals: function(l, n) {
                return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3]
            },
            equals: function(l, n) {
                var v = l[0],
                    z = l[1],
                    D = l[2];
                l = l[3];
                var E = n[0],
                    I = n[1],
                    L = n[2];
                n = n[3];
                return Math.abs(v - E) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(E)) && Math.abs(z - I) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(I)) && Math.abs(D - L) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(L)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l),
                    Math.abs(n))
            },
            multiplyScalar: function(l, n, v) {
                l[0] = n[0] * v;
                l[1] = n[1] * v;
                l[2] = n[2] * v;
                l[3] = n[3] * v;
                return l
            },
            multiplyScalarAndAdd: function(l, n, v, z) {
                l[0] = n[0] + v[0] * z;
                l[1] = n[1] + v[1] * z;
                l[2] = n[2] + v[2] * z;
                l[3] = n[3] + v[3] * z;
                return l
            },
            mul: d,
            sub: a
        }),
        Eb = Object.freeze({
            __proto__: null,
            create: function() {
                var l = new ra(6);
                ra != Float32Array && (l[1] = 0, l[2] = 0, l[4] = 0, l[5] = 0);
                l[0] = 1;
                l[3] = 1;
                return l
            },
            clone: function(l) {
                var n = new ra(6);
                n[0] = l[0];
                n[1] = l[1];
                n[2] = l[2];
                n[3] = l[3];
                n[4] = l[4];
                n[5] = l[5];
                return n
            },
            copy: function(l, n) {
                l[0] =
                    n[0];
                l[1] = n[1];
                l[2] = n[2];
                l[3] = n[3];
                l[4] = n[4];
                l[5] = n[5];
                return l
            },
            identity: function(l) {
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] = 1;
                l[4] = 0;
                l[5] = 0;
                return l
            },
            fromValues: function(l, n, v, z, D, E) {
                var I = new ra(6);
                I[0] = l;
                I[1] = n;
                I[2] = v;
                I[3] = z;
                I[4] = D;
                I[5] = E;
                return I
            },
            set: function(l, n, v, z, D, E, I) {
                l[0] = n;
                l[1] = v;
                l[2] = z;
                l[3] = D;
                l[4] = E;
                l[5] = I;
                return l
            },
            invert: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4];
                n = n[5];
                var L = v * E - z * D;
                if (!L) return null;
                L = 1 / L;
                l[0] = E * L;
                l[1] = -z * L;
                l[2] = -D * L;
                l[3] = v * L;
                l[4] = (D * n - E * I) * L;
                l[5] = (z * I - v * n) * L;
                return l
            },
            determinant: function(l) {
                return l[0] * l[3] - l[1] * l[2]
            },
            multiply: b,
            rotate: function(l, n, v) {
                var z = n[0],
                    D = n[1],
                    E = n[2],
                    I = n[3],
                    L = n[4];
                n = n[5];
                var O = Math.sin(v);
                v = Math.cos(v);
                l[0] = z * v + E * O;
                l[1] = D * v + I * O;
                l[2] = z * -O + E * v;
                l[3] = D * -O + I * v;
                l[4] = L;
                l[5] = n;
                return l
            },
            scale: function(l, n, v) {
                var z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4],
                    L = n[5],
                    O = v[0];
                v = v[1];
                l[0] = n[0] * O;
                l[1] = z * O;
                l[2] = D * v;
                l[3] = E * v;
                l[4] = I;
                l[5] = L;
                return l
            },
            translate: function(l, n, v) {
                var z = n[0],
                    D = n[1],
                    E = n[2],
                    I = n[3],
                    L = n[4];
                n = n[5];
                var O = v[0];
                v = v[1];
                l[0] = z;
                l[1] = D;
                l[2] = E;
                l[3] = I;
                l[4] =
                    z * O + E * v + L;
                l[5] = D * O + I * v + n;
                return l
            },
            fromRotation: function(l, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                l[0] = n;
                l[1] = v;
                l[2] = -v;
                l[3] = n;
                l[4] = 0;
                l[5] = 0;
                return l
            },
            fromScaling: function(l, n) {
                l[0] = n[0];
                l[1] = 0;
                l[2] = 0;
                l[3] = n[1];
                l[4] = 0;
                l[5] = 0;
                return l
            },
            fromTranslation: function(l, n) {
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] = 1;
                l[4] = n[0];
                l[5] = n[1];
                return l
            },
            str: function(l) {
                return "mat2d(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ")"
            },
            frob: function(l) {
                return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], 1)
            },
            add: function(l, n, v) {
                l[0] =
                    n[0] + v[0];
                l[1] = n[1] + v[1];
                l[2] = n[2] + v[2];
                l[3] = n[3] + v[3];
                l[4] = n[4] + v[4];
                l[5] = n[5] + v[5];
                return l
            },
            subtract: c,
            multiplyScalar: function(l, n, v) {
                l[0] = n[0] * v;
                l[1] = n[1] * v;
                l[2] = n[2] * v;
                l[3] = n[3] * v;
                l[4] = n[4] * v;
                l[5] = n[5] * v;
                return l
            },
            multiplyScalarAndAdd: function(l, n, v, z) {
                l[0] = n[0] + v[0] * z;
                l[1] = n[1] + v[1] * z;
                l[2] = n[2] + v[2] * z;
                l[3] = n[3] + v[3] * z;
                l[4] = n[4] + v[4] * z;
                l[5] = n[5] + v[5] * z;
                return l
            },
            exactEquals: function(l, n) {
                return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5]
            },
            equals: function(l, n) {
                var v =
                    l[0],
                    z = l[1],
                    D = l[2],
                    E = l[3],
                    I = l[4];
                l = l[5];
                var L = n[0],
                    O = n[1],
                    Q = n[2],
                    S = n[3],
                    T = n[4];
                n = n[5];
                return Math.abs(v - L) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(L)) && Math.abs(z - O) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(O)) && Math.abs(D - Q) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(Q)) && Math.abs(E - S) <= 1E-6 * Math.max(1, Math.abs(E), Math.abs(S)) && Math.abs(I - T) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(T)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
            },
            mul: b,
            sub: c
        }),
        Fb = Object.freeze({
            __proto__: null,
            create: f,
            fromMat4: function(l,
                n) {
                l[0] = n[0];
                l[1] = n[1];
                l[2] = n[2];
                l[3] = n[4];
                l[4] = n[5];
                l[5] = n[6];
                l[6] = n[8];
                l[7] = n[9];
                l[8] = n[10];
                return l
            },
            clone: function(l) {
                var n = new ra(9);
                n[0] = l[0];
                n[1] = l[1];
                n[2] = l[2];
                n[3] = l[3];
                n[4] = l[4];
                n[5] = l[5];
                n[6] = l[6];
                n[7] = l[7];
                n[8] = l[8];
                return n
            },
            copy: function(l, n) {
                l[0] = n[0];
                l[1] = n[1];
                l[2] = n[2];
                l[3] = n[3];
                l[4] = n[4];
                l[5] = n[5];
                l[6] = n[6];
                l[7] = n[7];
                l[8] = n[8];
                return l
            },
            fromValues: function(l, n, v, z, D, E, I, L, O) {
                var Q = new ra(9);
                Q[0] = l;
                Q[1] = n;
                Q[2] = v;
                Q[3] = z;
                Q[4] = D;
                Q[5] = E;
                Q[6] = I;
                Q[7] = L;
                Q[8] = O;
                return Q
            },
            set: function(l, n,
                v, z, D, E, I, L, O, Q) {
                l[0] = n;
                l[1] = v;
                l[2] = z;
                l[3] = D;
                l[4] = E;
                l[5] = I;
                l[6] = L;
                l[7] = O;
                l[8] = Q;
                return l
            },
            identity: function(l) {
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 1;
                l[5] = 0;
                l[6] = 0;
                l[7] = 0;
                l[8] = 1;
                return l
            },
            transpose: function(l, n) {
                if (l === n) {
                    var v = n[1],
                        z = n[2],
                        D = n[5];
                    l[1] = n[3];
                    l[2] = n[6];
                    l[3] = v;
                    l[5] = n[7];
                    l[6] = z;
                    l[7] = D
                } else l[0] = n[0], l[1] = n[3], l[2] = n[6], l[3] = n[1], l[4] = n[4], l[5] = n[7], l[6] = n[2], l[7] = n[5], l[8] = n[8];
                return l
            },
            invert: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4],
                    L = n[5],
                    O = n[6],
                    Q = n[7];
                n = n[8];
                var S = n * I - L * Q,
                    T = -n * E + L * O,
                    Y = Q * E - I * O,
                    X = v * S + z * T + D * Y;
                if (!X) return null;
                X = 1 / X;
                l[0] = S * X;
                l[1] = (-n * z + D * Q) * X;
                l[2] = (L * z - D * I) * X;
                l[3] = T * X;
                l[4] = (n * v - D * O) * X;
                l[5] = (-L * v + D * E) * X;
                l[6] = Y * X;
                l[7] = (-Q * v + z * O) * X;
                l[8] = (I * v - z * E) * X;
                return l
            },
            adjoint: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4],
                    L = n[5],
                    O = n[6],
                    Q = n[7];
                n = n[8];
                l[0] = I * n - L * Q;
                l[1] = D * Q - z * n;
                l[2] = z * L - D * I;
                l[3] = L * O - E * n;
                l[4] = v * n - D * O;
                l[5] = D * E - v * L;
                l[6] = E * Q - I * O;
                l[7] = z * O - v * Q;
                l[8] = v * I - z * E;
                return l
            },
            determinant: function(l) {
                var n = l[3],
                    v = l[4],
                    z = l[5],
                    D = l[6],
                    E = l[7],
                    I = l[8];
                return l[0] * (I *
                    v - z * E) + l[1] * (-I * n + z * D) + l[2] * (E * n - v * D)
            },
            multiply: h,
            translate: function(l, n, v) {
                var z = n[0],
                    D = n[1],
                    E = n[2],
                    I = n[3],
                    L = n[4],
                    O = n[5],
                    Q = n[6],
                    S = n[7];
                n = n[8];
                var T = v[0];
                v = v[1];
                l[0] = z;
                l[1] = D;
                l[2] = E;
                l[3] = I;
                l[4] = L;
                l[5] = O;
                l[6] = T * z + v * I + Q;
                l[7] = T * D + v * L + S;
                l[8] = T * E + v * O + n;
                return l
            },
            rotate: function(l, n, v) {
                var z = n[0],
                    D = n[1],
                    E = n[2],
                    I = n[3],
                    L = n[4],
                    O = n[5],
                    Q = n[6],
                    S = n[7];
                n = n[8];
                var T = Math.sin(v);
                v = Math.cos(v);
                l[0] = v * z + T * I;
                l[1] = v * D + T * L;
                l[2] = v * E + T * O;
                l[3] = v * I - T * z;
                l[4] = v * L - T * D;
                l[5] = v * O - T * E;
                l[6] = Q;
                l[7] = S;
                l[8] = n;
                return l
            },
            scale: function(l,
                n, v) {
                var z = v[0];
                v = v[1];
                l[0] = z * n[0];
                l[1] = z * n[1];
                l[2] = z * n[2];
                l[3] = v * n[3];
                l[4] = v * n[4];
                l[5] = v * n[5];
                l[6] = n[6];
                l[7] = n[7];
                l[8] = n[8];
                return l
            },
            fromTranslation: function(l, n) {
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 1;
                l[5] = 0;
                l[6] = n[0];
                l[7] = n[1];
                l[8] = 1;
                return l
            },
            fromRotation: function(l, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                l[0] = n;
                l[1] = v;
                l[2] = 0;
                l[3] = -v;
                l[4] = n;
                l[5] = 0;
                l[6] = 0;
                l[7] = 0;
                l[8] = 1;
                return l
            },
            fromScaling: function(l, n) {
                l[0] = n[0];
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = n[1];
                l[5] = 0;
                l[6] = 0;
                l[7] = 0;
                l[8] = 1;
                return l
            },
            fromMat2d: function(l,
                n) {
                l[0] = n[0];
                l[1] = n[1];
                l[2] = 0;
                l[3] = n[2];
                l[4] = n[3];
                l[5] = 0;
                l[6] = n[4];
                l[7] = n[5];
                l[8] = 1;
                return l
            },
            fromQuat: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2];
                n = n[3];
                var E = v + v,
                    I = z + z,
                    L = D + D;
                v *= E;
                var O = z * E;
                z *= I;
                var Q = D * E,
                    S = D * I;
                D *= L;
                E *= n;
                I *= n;
                n *= L;
                l[0] = 1 - z - D;
                l[3] = O - n;
                l[6] = Q + I;
                l[1] = O + n;
                l[4] = 1 - v - D;
                l[7] = S - E;
                l[2] = Q - I;
                l[5] = S + E;
                l[8] = 1 - v - z;
                return l
            },
            normalFromMat4: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4],
                    L = n[5],
                    O = n[6],
                    Q = n[7],
                    S = n[8],
                    T = n[9],
                    Y = n[10],
                    X = n[11],
                    ea = n[12],
                    ca = n[13],
                    aa = n[14];
                n = n[15];
                var wa = v * L - z * I,
                    pa = v * O - D *
                    I,
                    ua = v * Q - E * I,
                    va = z * O - D * L,
                    ta = z * Q - E * L,
                    Ga = D * Q - E * O,
                    Ha = S * ca - T * ea,
                    Ia = S * aa - Y * ea;
                S = S * n - X * ea;
                var Ja = T * aa - Y * ca;
                T = T * n - X * ca;
                Y = Y * n - X * aa;
                X = wa * Y - pa * T + ua * Ja + va * S - ta * Ia + Ga * Ha;
                if (!X) return null;
                X = 1 / X;
                l[0] = (L * Y - O * T + Q * Ja) * X;
                l[1] = (O * S - I * Y - Q * Ia) * X;
                l[2] = (I * T - L * S + Q * Ha) * X;
                l[3] = (D * T - z * Y - E * Ja) * X;
                l[4] = (v * Y - D * S + E * Ia) * X;
                l[5] = (z * S - v * T - E * Ha) * X;
                l[6] = (ca * Ga - aa * ta + n * va) * X;
                l[7] = (aa * ua - ea * Ga - n * pa) * X;
                l[8] = (ea * ta - ca * ua + n * wa) * X;
                return l
            },
            projection: function(l, n, v) {
                l[0] = 2 / n;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = -2 / v;
                l[5] = 0;
                l[6] = -1;
                l[7] = 1;
                l[8] = 1;
                return l
            },
            str: function(l) {
                return "mat3(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ", " + l[6] + ", " + l[7] + ", " + l[8] + ")"
            },
            frob: function(l) {
                return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8])
            },
            add: function(l, n, v) {
                l[0] = n[0] + v[0];
                l[1] = n[1] + v[1];
                l[2] = n[2] + v[2];
                l[3] = n[3] + v[3];
                l[4] = n[4] + v[4];
                l[5] = n[5] + v[5];
                l[6] = n[6] + v[6];
                l[7] = n[7] + v[7];
                l[8] = n[8] + v[8];
                return l
            },
            subtract: g,
            multiplyScalar: function(l, n, v) {
                l[0] = n[0] * v;
                l[1] = n[1] * v;
                l[2] = n[2] * v;
                l[3] = n[3] * v;
                l[4] = n[4] * v;
                l[5] = n[5] * v;
                l[6] = n[6] * v;
                l[7] = n[7] *
                    v;
                l[8] = n[8] * v;
                return l
            },
            multiplyScalarAndAdd: function(l, n, v, z) {
                l[0] = n[0] + v[0] * z;
                l[1] = n[1] + v[1] * z;
                l[2] = n[2] + v[2] * z;
                l[3] = n[3] + v[3] * z;
                l[4] = n[4] + v[4] * z;
                l[5] = n[5] + v[5] * z;
                l[6] = n[6] + v[6] * z;
                l[7] = n[7] + v[7] * z;
                l[8] = n[8] + v[8] * z;
                return l
            },
            exactEquals: function(l, n) {
                return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5] && l[6] === n[6] && l[7] === n[7] && l[8] === n[8]
            },
            equals: function(l, n) {
                var v = l[0],
                    z = l[1],
                    D = l[2],
                    E = l[3],
                    I = l[4],
                    L = l[5],
                    O = l[6],
                    Q = l[7];
                l = l[8];
                var S = n[0],
                    T = n[1],
                    Y = n[2],
                    X = n[3],
                    ea = n[4],
                    ca = n[5],
                    aa = n[6],
                    wa = n[7];
                n = n[8];
                return Math.abs(v - S) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(S)) && Math.abs(z - T) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(T)) && Math.abs(D - Y) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(Y)) && Math.abs(E - X) <= 1E-6 * Math.max(1, Math.abs(E), Math.abs(X)) && Math.abs(I - ea) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(ea)) && Math.abs(L - ca) <= 1E-6 * Math.max(1, Math.abs(L), Math.abs(ca)) && Math.abs(O - aa) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(aa)) && Math.abs(Q - wa) <= 1E-6 * Math.max(1, Math.abs(Q), Math.abs(wa)) &&
                    Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
            },
            mul: h,
            sub: g
        }),
        Gb = Object.freeze({
            __proto__: null,
            create: function() {
                var l = new ra(16);
                ra != Float32Array && (l[1] = 0, l[2] = 0, l[3] = 0, l[4] = 0, l[6] = 0, l[7] = 0, l[8] = 0, l[9] = 0, l[11] = 0, l[12] = 0, l[13] = 0, l[14] = 0);
                l[0] = 1;
                l[5] = 1;
                l[10] = 1;
                l[15] = 1;
                return l
            },
            clone: function(l) {
                var n = new ra(16);
                n[0] = l[0];
                n[1] = l[1];
                n[2] = l[2];
                n[3] = l[3];
                n[4] = l[4];
                n[5] = l[5];
                n[6] = l[6];
                n[7] = l[7];
                n[8] = l[8];
                n[9] = l[9];
                n[10] = l[10];
                n[11] = l[11];
                n[12] = l[12];
                n[13] = l[13];
                n[14] = l[14];
                n[15] = l[15];
                return n
            },
            copy: function(l, n) {
                l[0] = n[0];
                l[1] = n[1];
                l[2] = n[2];
                l[3] = n[3];
                l[4] = n[4];
                l[5] = n[5];
                l[6] = n[6];
                l[7] = n[7];
                l[8] = n[8];
                l[9] = n[9];
                l[10] = n[10];
                l[11] = n[11];
                l[12] = n[12];
                l[13] = n[13];
                l[14] = n[14];
                l[15] = n[15];
                return l
            },
            fromValues: function(l, n, v, z, D, E, I, L, O, Q, S, T, Y, X, ea, ca) {
                var aa = new ra(16);
                aa[0] = l;
                aa[1] = n;
                aa[2] = v;
                aa[3] = z;
                aa[4] = D;
                aa[5] = E;
                aa[6] = I;
                aa[7] = L;
                aa[8] = O;
                aa[9] = Q;
                aa[10] = S;
                aa[11] = T;
                aa[12] = Y;
                aa[13] = X;
                aa[14] = ea;
                aa[15] = ca;
                return aa
            },
            set: function(l, n, v, z, D, E, I, L, O, Q, S, T, Y, X, ea, ca, aa) {
                l[0] = n;
                l[1] = v;
                l[2] = z;
                l[3] = D;
                l[4] =
                    E;
                l[5] = I;
                l[6] = L;
                l[7] = O;
                l[8] = Q;
                l[9] = S;
                l[10] = T;
                l[11] = Y;
                l[12] = X;
                l[13] = ea;
                l[14] = ca;
                l[15] = aa;
                return l
            },
            identity: k,
            transpose: function(l, n) {
                if (l === n) {
                    var v = n[1],
                        z = n[2],
                        D = n[3],
                        E = n[6],
                        I = n[7],
                        L = n[11];
                    l[1] = n[4];
                    l[2] = n[8];
                    l[3] = n[12];
                    l[4] = v;
                    l[6] = n[9];
                    l[7] = n[13];
                    l[8] = z;
                    l[9] = E;
                    l[11] = n[14];
                    l[12] = D;
                    l[13] = I;
                    l[14] = L
                } else l[0] = n[0], l[1] = n[4], l[2] = n[8], l[3] = n[12], l[4] = n[1], l[5] = n[5], l[6] = n[9], l[7] = n[13], l[8] = n[2], l[9] = n[6], l[10] = n[10], l[11] = n[14], l[12] = n[3], l[13] = n[7], l[14] = n[11], l[15] = n[15];
                return l
            },
            invert: function(l,
                n) {
                var v = n[0],
                    z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4],
                    L = n[5],
                    O = n[6],
                    Q = n[7],
                    S = n[8],
                    T = n[9],
                    Y = n[10],
                    X = n[11],
                    ea = n[12],
                    ca = n[13],
                    aa = n[14];
                n = n[15];
                var wa = v * L - z * I,
                    pa = v * O - D * I,
                    ua = v * Q - E * I,
                    va = z * O - D * L,
                    ta = z * Q - E * L,
                    Ga = D * Q - E * O,
                    Ha = S * ca - T * ea,
                    Ia = S * aa - Y * ea,
                    Ja = S * n - X * ea,
                    Oa = T * aa - Y * ca,
                    Va = T * n - X * ca,
                    Wa = Y * n - X * aa,
                    Ba = wa * Wa - pa * Va + ua * Oa + va * Ja - ta * Ia + Ga * Ha;
                if (!Ba) return null;
                Ba = 1 / Ba;
                l[0] = (L * Wa - O * Va + Q * Oa) * Ba;
                l[1] = (D * Va - z * Wa - E * Oa) * Ba;
                l[2] = (ca * Ga - aa * ta + n * va) * Ba;
                l[3] = (Y * ta - T * Ga - X * va) * Ba;
                l[4] = (O * Ja - I * Wa - Q * Ia) * Ba;
                l[5] = (v * Wa - D * Ja + E * Ia) * Ba;
                l[6] = (aa * ua -
                    ea * Ga - n * pa) * Ba;
                l[7] = (S * Ga - Y * ua + X * pa) * Ba;
                l[8] = (I * Va - L * Ja + Q * Ha) * Ba;
                l[9] = (z * Ja - v * Va - E * Ha) * Ba;
                l[10] = (ea * ta - ca * ua + n * wa) * Ba;
                l[11] = (T * ua - S * ta - X * wa) * Ba;
                l[12] = (L * Ia - I * Oa - O * Ha) * Ba;
                l[13] = (v * Oa - z * Ia + D * Ha) * Ba;
                l[14] = (ca * pa - ea * va - aa * wa) * Ba;
                l[15] = (S * va - T * pa + Y * wa) * Ba;
                return l
            },
            adjoint: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2],
                    E = n[3],
                    I = n[4],
                    L = n[5],
                    O = n[6],
                    Q = n[7],
                    S = n[8],
                    T = n[9],
                    Y = n[10],
                    X = n[11],
                    ea = n[12],
                    ca = n[13],
                    aa = n[14];
                n = n[15];
                l[0] = L * (Y * n - X * aa) - T * (O * n - Q * aa) + ca * (O * X - Q * Y);
                l[1] = -(z * (Y * n - X * aa) - T * (D * n - E * aa) + ca * (D * X - E * Y));
                l[2] =
                    z * (O * n - Q * aa) - L * (D * n - E * aa) + ca * (D * Q - E * O);
                l[3] = -(z * (O * X - Q * Y) - L * (D * X - E * Y) + T * (D * Q - E * O));
                l[4] = -(I * (Y * n - X * aa) - S * (O * n - Q * aa) + ea * (O * X - Q * Y));
                l[5] = v * (Y * n - X * aa) - S * (D * n - E * aa) + ea * (D * X - E * Y);
                l[6] = -(v * (O * n - Q * aa) - I * (D * n - E * aa) + ea * (D * Q - E * O));
                l[7] = v * (O * X - Q * Y) - I * (D * X - E * Y) + S * (D * Q - E * O);
                l[8] = I * (T * n - X * ca) - S * (L * n - Q * ca) + ea * (L * X - Q * T);
                l[9] = -(v * (T * n - X * ca) - S * (z * n - E * ca) + ea * (z * X - E * T));
                l[10] = v * (L * n - Q * ca) - I * (z * n - E * ca) + ea * (z * Q - E * L);
                l[11] = -(v * (L * X - Q * T) - I * (z * X - E * T) + S * (z * Q - E * L));
                l[12] = -(I * (T * aa - Y * ca) - S * (L * aa - O * ca) + ea * (L * Y - O * T));
                l[13] = v *
                    (T * aa - Y * ca) - S * (z * aa - D * ca) + ea * (z * Y - D * T);
                l[14] = -(v * (L * aa - O * ca) - I * (z * aa - D * ca) + ea * (z * O - D * L));
                l[15] = v * (L * Y - O * T) - I * (z * Y - D * T) + S * (z * O - D * L);
                return l
            },
            determinant: function(l) {
                var n = l[0],
                    v = l[1],
                    z = l[2],
                    D = l[3],
                    E = l[4],
                    I = l[5],
                    L = l[6],
                    O = l[7],
                    Q = l[8],
                    S = l[9],
                    T = l[10],
                    Y = l[11],
                    X = l[12],
                    ea = l[13],
                    ca = l[14];
                l = l[15];
                return (n * I - v * E) * (T * l - Y * ca) - (n * L - z * E) * (S * l - Y * ea) + (n * O - D * E) * (S * ca - T * ea) + (v * L - z * I) * (Q * l - Y * X) - (v * O - D * I) * (Q * ca - T * X) + (z * O - D * L) * (Q * ea - S * X)
            },
            multiply: m,
            translate: function(l, n, v) {
                var z = v[0],
                    D = v[1];
                v = v[2];
                if (n === l) l[12] = n[0] *
                    z + n[4] * D + n[8] * v + n[12], l[13] = n[1] * z + n[5] * D + n[9] * v + n[13], l[14] = n[2] * z + n[6] * D + n[10] * v + n[14], l[15] = n[3] * z + n[7] * D + n[11] * v + n[15];
                else {
                    var E = n[0];
                    var I = n[1];
                    var L = n[2];
                    var O = n[3];
                    var Q = n[4];
                    var S = n[5];
                    var T = n[6];
                    var Y = n[7];
                    var X = n[8];
                    var ea = n[9];
                    var ca = n[10];
                    var aa = n[11];
                    l[0] = E;
                    l[1] = I;
                    l[2] = L;
                    l[3] = O;
                    l[4] = Q;
                    l[5] = S;
                    l[6] = T;
                    l[7] = Y;
                    l[8] = X;
                    l[9] = ea;
                    l[10] = ca;
                    l[11] = aa;
                    l[12] = E * z + Q * D + X * v + n[12];
                    l[13] = I * z + S * D + ea * v + n[13];
                    l[14] = L * z + T * D + ca * v + n[14];
                    l[15] = O * z + Y * D + aa * v + n[15]
                }
                return l
            },
            scale: function(l, n, v) {
                var z = v[0],
                    D = v[1];
                v = v[2];
                l[0] = n[0] * z;
                l[1] = n[1] * z;
                l[2] = n[2] * z;
                l[3] = n[3] * z;
                l[4] = n[4] * D;
                l[5] = n[5] * D;
                l[6] = n[6] * D;
                l[7] = n[7] * D;
                l[8] = n[8] * v;
                l[9] = n[9] * v;
                l[10] = n[10] * v;
                l[11] = n[11] * v;
                l[12] = n[12];
                l[13] = n[13];
                l[14] = n[14];
                l[15] = n[15];
                return l
            },
            rotate: function(l, n, v, z) {
                var D = z[0],
                    E = z[1];
                z = z[2];
                var I = Math.hypot(D, E, z);
                if (1E-6 > I) return null;
                I = 1 / I;
                D *= I;
                E *= I;
                z *= I;
                var L = Math.sin(v);
                var O = Math.cos(v);
                var Q = 1 - O;
                v = n[0];
                I = n[1];
                var S = n[2];
                var T = n[3];
                var Y = n[4];
                var X = n[5];
                var ea = n[6];
                var ca = n[7];
                var aa = n[8];
                var wa = n[9];
                var pa = n[10];
                var ua =
                    n[11];
                var va = D * D * Q + O;
                var ta = E * D * Q + z * L;
                var Ga = z * D * Q - E * L;
                var Ha = D * E * Q - z * L;
                var Ia = E * E * Q + O;
                var Ja = z * E * Q + D * L;
                var Oa = D * z * Q + E * L;
                D = E * z * Q - D * L;
                E = z * z * Q + O;
                l[0] = v * va + Y * ta + aa * Ga;
                l[1] = I * va + X * ta + wa * Ga;
                l[2] = S * va + ea * ta + pa * Ga;
                l[3] = T * va + ca * ta + ua * Ga;
                l[4] = v * Ha + Y * Ia + aa * Ja;
                l[5] = I * Ha + X * Ia + wa * Ja;
                l[6] = S * Ha + ea * Ia + pa * Ja;
                l[7] = T * Ha + ca * Ia + ua * Ja;
                l[8] = v * Oa + Y * D + aa * E;
                l[9] = I * Oa + X * D + wa * E;
                l[10] = S * Oa + ea * D + pa * E;
                l[11] = T * Oa + ca * D + ua * E;
                n !== l && (l[12] = n[12], l[13] = n[13], l[14] = n[14], l[15] = n[15]);
                return l
            },
            rotateX: function(l, n, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var D = n[4],
                    E = n[5],
                    I = n[6],
                    L = n[7],
                    O = n[8],
                    Q = n[9],
                    S = n[10],
                    T = n[11];
                n !== l && (l[0] = n[0], l[1] = n[1], l[2] = n[2], l[3] = n[3], l[12] = n[12], l[13] = n[13], l[14] = n[14], l[15] = n[15]);
                l[4] = D * v + O * z;
                l[5] = E * v + Q * z;
                l[6] = I * v + S * z;
                l[7] = L * v + T * z;
                l[8] = O * v - D * z;
                l[9] = Q * v - E * z;
                l[10] = S * v - I * z;
                l[11] = T * v - L * z;
                return l
            },
            rotateY: function(l, n, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var D = n[0],
                    E = n[1],
                    I = n[2],
                    L = n[3],
                    O = n[8],
                    Q = n[9],
                    S = n[10],
                    T = n[11];
                n !== l && (l[4] = n[4], l[5] = n[5], l[6] = n[6], l[7] = n[7], l[12] = n[12], l[13] = n[13], l[14] = n[14], l[15] = n[15]);
                l[0] = D * v - O * z;
                l[1] = E * v - Q * z;
                l[2] = I * v - S * z;
                l[3] = L * v - T * z;
                l[8] = D * z + O * v;
                l[9] = E * z + Q * v;
                l[10] = I * z + S * v;
                l[11] = L * z + T * v;
                return l
            },
            rotateZ: function(l, n, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var D = n[0],
                    E = n[1],
                    I = n[2],
                    L = n[3],
                    O = n[4],
                    Q = n[5],
                    S = n[6],
                    T = n[7];
                n !== l && (l[8] = n[8], l[9] = n[9], l[10] = n[10], l[11] = n[11], l[12] = n[12], l[13] = n[13], l[14] = n[14], l[15] = n[15]);
                l[0] = D * v + O * z;
                l[1] = E * v + Q * z;
                l[2] = I * v + S * z;
                l[3] = L * v + T * z;
                l[4] = O * v - D * z;
                l[5] = Q * v - E * z;
                l[6] = S * v - I * z;
                l[7] = T * v - L * z;
                return l
            },
            fromTranslation: function(l, n) {
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] =
                    0;
                l[4] = 0;
                l[5] = 1;
                l[6] = 0;
                l[7] = 0;
                l[8] = 0;
                l[9] = 0;
                l[10] = 1;
                l[11] = 0;
                l[12] = n[0];
                l[13] = n[1];
                l[14] = n[2];
                l[15] = 1;
                return l
            },
            fromScaling: function(l, n) {
                l[0] = n[0];
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 0;
                l[5] = n[1];
                l[6] = 0;
                l[7] = 0;
                l[8] = 0;
                l[9] = 0;
                l[10] = n[2];
                l[11] = 0;
                l[12] = 0;
                l[13] = 0;
                l[14] = 0;
                l[15] = 1;
                return l
            },
            fromRotation: function(l, n, v) {
                var z = v[0],
                    D = v[1];
                v = v[2];
                var E = Math.hypot(z, D, v);
                if (1E-6 > E) return null;
                E = 1 / E;
                z *= E;
                D *= E;
                v *= E;
                E = Math.sin(n);
                n = Math.cos(n);
                var I = 1 - n;
                l[0] = z * z * I + n;
                l[1] = D * z * I + v * E;
                l[2] = v * z * I - D * E;
                l[3] = 0;
                l[4] = z * D * I - v * E;
                l[5] =
                    D * D * I + n;
                l[6] = v * D * I + z * E;
                l[7] = 0;
                l[8] = z * v * I + D * E;
                l[9] = D * v * I - z * E;
                l[10] = v * v * I + n;
                l[11] = 0;
                l[12] = 0;
                l[13] = 0;
                l[14] = 0;
                l[15] = 1;
                return l
            },
            fromXRotation: function(l, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                l[0] = 1;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 0;
                l[5] = n;
                l[6] = v;
                l[7] = 0;
                l[8] = 0;
                l[9] = -v;
                l[10] = n;
                l[11] = 0;
                l[12] = 0;
                l[13] = 0;
                l[14] = 0;
                l[15] = 1;
                return l
            },
            fromYRotation: function(l, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                l[0] = n;
                l[1] = 0;
                l[2] = -v;
                l[3] = 0;
                l[4] = 0;
                l[5] = 1;
                l[6] = 0;
                l[7] = 0;
                l[8] = v;
                l[9] = 0;
                l[10] = n;
                l[11] = 0;
                l[12] = 0;
                l[13] = 0;
                l[14] = 0;
                l[15] = 1;
                return l
            },
            fromZRotation: function(l, n) {
                var v = Math.sin(n);
                n = Math.cos(n);
                l[0] = n;
                l[1] = v;
                l[2] = 0;
                l[3] = 0;
                l[4] = -v;
                l[5] = n;
                l[6] = 0;
                l[7] = 0;
                l[8] = 0;
                l[9] = 0;
                l[10] = 1;
                l[11] = 0;
                l[12] = 0;
                l[13] = 0;
                l[14] = 0;
                l[15] = 1;
                return l
            },
            fromRotationTranslation: r,
            fromQuat2: function(l, n) {
                var v = new ra(3),
                    z = -n[0],
                    D = -n[1],
                    E = -n[2],
                    I = n[3],
                    L = n[4],
                    O = n[5],
                    Q = n[6],
                    S = n[7],
                    T = z * z + D * D + E * E + I * I;
                0 < T ? (v[0] = 2 * (L * I + S * z + O * E - Q * D) / T, v[1] = 2 * (O * I + S * D + Q * z - L * E) / T, v[2] = 2 * (Q * I + S * E + L * D - O * z) / T) : (v[0] = 2 * (L * I + S * z + O * E - Q * D), v[1] = 2 * (O * I + S * D + Q * z - L * E), v[2] = 2 * (Q * I + S * E + L * D - O * z));
                r(l, n,
                    v);
                return l
            },
            getTranslation: w,
            getScaling: p,
            getRotation: t,
            fromRotationTranslationScale: function(l, n, v, z) {
                var D = n[0],
                    E = n[1],
                    I = n[2],
                    L = n[3],
                    O = D + D,
                    Q = E + E,
                    S = I + I;
                n = D * O;
                var T = D * Q;
                D *= S;
                var Y = E * Q;
                E *= S;
                I *= S;
                O *= L;
                Q *= L;
                L *= S;
                S = z[0];
                var X = z[1];
                z = z[2];
                l[0] = (1 - (Y + I)) * S;
                l[1] = (T + L) * S;
                l[2] = (D - Q) * S;
                l[3] = 0;
                l[4] = (T - L) * X;
                l[5] = (1 - (n + I)) * X;
                l[6] = (E + O) * X;
                l[7] = 0;
                l[8] = (D + Q) * z;
                l[9] = (E - O) * z;
                l[10] = (1 - (n + Y)) * z;
                l[11] = 0;
                l[12] = v[0];
                l[13] = v[1];
                l[14] = v[2];
                l[15] = 1;
                return l
            },
            fromRotationTranslationScaleOrigin: function(l, n, v, z, D) {
                var E = n[0],
                    I = n[1],
                    L = n[2],
                    O = n[3],
                    Q = E + E,
                    S = I + I,
                    T = L + L;
                n = E * Q;
                var Y = E * S,
                    X = E * T;
                E = I * S;
                I *= T;
                var ea = L * T;
                L = O * Q;
                S *= O;
                var ca = O * T,
                    aa = z[0],
                    wa = z[1];
                T = z[2];
                z = D[0];
                O = D[1];
                D = D[2];
                Q = (1 - (E + ea)) * aa;
                var pa = (Y + ca) * aa;
                aa *= X - S;
                Y = (Y - ca) * wa;
                ea = (1 - (n + ea)) * wa;
                wa *= I + L;
                X = (X + S) * T;
                I = (I - L) * T;
                n = (1 - (n + E)) * T;
                l[0] = Q;
                l[1] = pa;
                l[2] = aa;
                l[3] = 0;
                l[4] = Y;
                l[5] = ea;
                l[6] = wa;
                l[7] = 0;
                l[8] = X;
                l[9] = I;
                l[10] = n;
                l[11] = 0;
                l[12] = v[0] + z - (Q * z + Y * O + X * D);
                l[13] = v[1] + O - (pa * z + ea * O + I * D);
                l[14] = v[2] + D - (aa * z + wa * O + n * D);
                l[15] = 1;
                return l
            },
            fromQuat: function(l, n) {
                var v = n[0],
                    z = n[1],
                    D = n[2];
                n = n[3];
                var E = v + v,
                    I = z + z,
                    L = D + D;
                v *= E;
                var O = z * E;
                z *= I;
                var Q = D * E,
                    S = D * I;
                D *= L;
                E *= n;
                I *= n;
                n *= L;
                l[0] = 1 - z - D;
                l[1] = O + n;
                l[2] = Q - I;
                l[3] = 0;
                l[4] = O - n;
                l[5] = 1 - v - D;
                l[6] = S + E;
                l[7] = 0;
                l[8] = Q + I;
                l[9] = S - E;
                l[10] = 1 - v - z;
                l[11] = 0;
                l[12] = 0;
                l[13] = 0;
                l[14] = 0;
                l[15] = 1;
                return l
            },
            frustum: function(l, n, v, z, D, E, I) {
                var L = 1 / (v - n),
                    O = 1 / (D - z),
                    Q = 1 / (E - I);
                l[0] = 2 * E * L;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 0;
                l[5] = 2 * E * O;
                l[6] = 0;
                l[7] = 0;
                l[8] = (v + n) * L;
                l[9] = (D + z) * O;
                l[10] = (I + E) * Q;
                l[11] = -1;
                l[12] = 0;
                l[13] = 0;
                l[14] = I * E * 2 * Q;
                l[15] = 0;
                return l
            },
            perspective: function(l, n, v, z, D) {
                n = 1 / Math.tan(n /
                    2);
                l[0] = n / v;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 0;
                l[5] = n;
                l[6] = 0;
                l[7] = 0;
                l[8] = 0;
                l[9] = 0;
                l[11] = -1;
                l[12] = 0;
                l[13] = 0;
                l[15] = 0;
                null != D && Infinity !== D ? (v = 1 / (z - D), l[10] = (D + z) * v, l[14] = 2 * D * z * v) : (l[10] = -1, l[14] = -2 * z);
                return l
            },
            perspectiveFromFieldOfView: function(l, n, v, z) {
                var D = Math.tan(n.upDegrees * Math.PI / 180),
                    E = Math.tan(n.downDegrees * Math.PI / 180),
                    I = Math.tan(n.leftDegrees * Math.PI / 180);
                n = Math.tan(n.rightDegrees * Math.PI / 180);
                var L = 2 / (I + n),
                    O = 2 / (D + E);
                l[0] = L;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 0;
                l[5] = O;
                l[6] = 0;
                l[7] = 0;
                l[8] = -((I - n) * L * .5);
                l[9] = (D - E) * O * .5;
                l[10] = z / (v - z);
                l[11] = -1;
                l[12] = 0;
                l[13] = 0;
                l[14] = z * v / (v - z);
                l[15] = 0;
                return l
            },
            ortho: function(l, n, v, z, D, E, I) {
                var L = 1 / (n - v),
                    O = 1 / (z - D),
                    Q = 1 / (E - I);
                l[0] = -2 * L;
                l[1] = 0;
                l[2] = 0;
                l[3] = 0;
                l[4] = 0;
                l[5] = -2 * O;
                l[6] = 0;
                l[7] = 0;
                l[8] = 0;
                l[9] = 0;
                l[10] = 2 * Q;
                l[11] = 0;
                l[12] = (n + v) * L;
                l[13] = (D + z) * O;
                l[14] = (I + E) * Q;
                l[15] = 1;
                return l
            },
            lookAt: function(l, n, v, z) {
                var D = n[0],
                    E = n[1];
                n = n[2];
                var I = z[0];
                var L = z[1];
                var O = z[2];
                var Q = v[0];
                z = v[1];
                var S = v[2];
                if (1E-6 > Math.abs(D - Q) && 1E-6 > Math.abs(E - z) && 1E-6 > Math.abs(n - S)) return k(l);
                v = D - Q;
                z =
                    E - z;
                Q = n - S;
                var T = 1 / Math.hypot(v, z, Q);
                v *= T;
                z *= T;
                Q *= T;
                S = L * Q - O * z;
                O = O * v - I * Q;
                I = I * z - L * v;
                (T = Math.hypot(S, O, I)) ? (T = 1 / T, S *= T, O *= T, I *= T) : I = O = S = 0;
                L = z * I - Q * O;
                var Y = Q * S - v * I;
                var X = v * O - z * S;
                (T = Math.hypot(L, Y, X)) ? (T = 1 / T, L *= T, Y *= T, X *= T) : X = Y = L = 0;
                l[0] = S;
                l[1] = L;
                l[2] = v;
                l[3] = 0;
                l[4] = O;
                l[5] = Y;
                l[6] = z;
                l[7] = 0;
                l[8] = I;
                l[9] = X;
                l[10] = Q;
                l[11] = 0;
                l[12] = -(S * D + O * E + I * n);
                l[13] = -(L * D + Y * E + X * n);
                l[14] = -(v * D + z * E + Q * n);
                l[15] = 1;
                return l
            },
            targetTo: function(l, n, v, z) {
                var D = n[0],
                    E = n[1];
                n = n[2];
                var I = z[0],
                    L = z[1],
                    O = z[2];
                z = D - v[0];
                var Q = E - v[1];
                v = n - v[2];
                var S =
                    z * z + Q * Q + v * v;
                0 < S && (S = 1 / Math.sqrt(S), z *= S, Q *= S, v *= S);
                var T = L * v - O * Q;
                O = O * z - I * v;
                I = I * Q - L * z;
                S = T * T + O * O + I * I;
                0 < S && (S = 1 / Math.sqrt(S), T *= S, O *= S, I *= S);
                l[0] = T;
                l[1] = O;
                l[2] = I;
                l[3] = 0;
                l[4] = Q * I - v * O;
                l[5] = v * T - z * I;
                l[6] = z * O - Q * T;
                l[7] = 0;
                l[8] = z;
                l[9] = Q;
                l[10] = v;
                l[11] = 0;
                l[12] = D;
                l[13] = E;
                l[14] = n;
                l[15] = 1;
                return l
            },
            str: function(l) {
                return "mat4(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ", " + l[6] + ", " + l[7] + ", " + l[8] + ", " + l[9] + ", " + l[10] + ", " + l[11] + ", " + l[12] + ", " + l[13] + ", " + l[14] + ", " + l[15] + ")"
            },
            frob: function(l) {
                return Math.hypot(l[0],
                    l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9], l[10], l[11], l[12], l[13], l[14], l[15])
            },
            add: function(l, n, v) {
                l[0] = n[0] + v[0];
                l[1] = n[1] + v[1];
                l[2] = n[2] + v[2];
                l[3] = n[3] + v[3];
                l[4] = n[4] + v[4];
                l[5] = n[5] + v[5];
                l[6] = n[6] + v[6];
                l[7] = n[7] + v[7];
                l[8] = n[8] + v[8];
                l[9] = n[9] + v[9];
                l[10] = n[10] + v[10];
                l[11] = n[11] + v[11];
                l[12] = n[12] + v[12];
                l[13] = n[13] + v[13];
                l[14] = n[14] + v[14];
                l[15] = n[15] + v[15];
                return l
            },
            subtract: u,
            multiplyScalar: function(l, n, v) {
                l[0] = n[0] * v;
                l[1] = n[1] * v;
                l[2] = n[2] * v;
                l[3] = n[3] * v;
                l[4] = n[4] * v;
                l[5] = n[5] * v;
                l[6] = n[6] * v;
                l[7] =
                    n[7] * v;
                l[8] = n[8] * v;
                l[9] = n[9] * v;
                l[10] = n[10] * v;
                l[11] = n[11] * v;
                l[12] = n[12] * v;
                l[13] = n[13] * v;
                l[14] = n[14] * v;
                l[15] = n[15] * v;
                return l
            },
            multiplyScalarAndAdd: function(l, n, v, z) {
                l[0] = n[0] + v[0] * z;
                l[1] = n[1] + v[1] * z;
                l[2] = n[2] + v[2] * z;
                l[3] = n[3] + v[3] * z;
                l[4] = n[4] + v[4] * z;
                l[5] = n[5] + v[5] * z;
                l[6] = n[6] + v[6] * z;
                l[7] = n[7] + v[7] * z;
                l[8] = n[8] + v[8] * z;
                l[9] = n[9] + v[9] * z;
                l[10] = n[10] + v[10] * z;
                l[11] = n[11] + v[11] * z;
                l[12] = n[12] + v[12] * z;
                l[13] = n[13] + v[13] * z;
                l[14] = n[14] + v[14] * z;
                l[15] = n[15] + v[15] * z;
                return l
            },
            exactEquals: function(l, n) {
                return l[0] ===
                    n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5] && l[6] === n[6] && l[7] === n[7] && l[8] === n[8] && l[9] === n[9] && l[10] === n[10] && l[11] === n[11] && l[12] === n[12] && l[13] === n[13] && l[14] === n[14] && l[15] === n[15]
            },
            equals: function(l, n) {
                var v = l[0],
                    z = l[1],
                    D = l[2],
                    E = l[3],
                    I = l[4],
                    L = l[5],
                    O = l[6],
                    Q = l[7],
                    S = l[8],
                    T = l[9],
                    Y = l[10],
                    X = l[11],
                    ea = l[12],
                    ca = l[13],
                    aa = l[14];
                l = l[15];
                var wa = n[0],
                    pa = n[1],
                    ua = n[2],
                    va = n[3],
                    ta = n[4],
                    Ga = n[5],
                    Ha = n[6],
                    Ia = n[7],
                    Ja = n[8],
                    Oa = n[9],
                    Va = n[10],
                    Wa = n[11],
                    Ba = n[12],
                    Bb = n[13],
                    Cb = n[14];
                n = n[15];
                return Math.abs(v -
                    wa) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(wa)) && Math.abs(z - pa) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(pa)) && Math.abs(D - ua) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(ua)) && Math.abs(E - va) <= 1E-6 * Math.max(1, Math.abs(E), Math.abs(va)) && Math.abs(I - ta) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(ta)) && Math.abs(L - Ga) <= 1E-6 * Math.max(1, Math.abs(L), Math.abs(Ga)) && Math.abs(O - Ha) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(Ha)) && Math.abs(Q - Ia) <= 1E-6 * Math.max(1, Math.abs(Q), Math.abs(Ia)) && Math.abs(S - Ja) <= 1E-6 * Math.max(1, Math.abs(S),
                    Math.abs(Ja)) && Math.abs(T - Oa) <= 1E-6 * Math.max(1, Math.abs(T), Math.abs(Oa)) && Math.abs(Y - Va) <= 1E-6 * Math.max(1, Math.abs(Y), Math.abs(Va)) && Math.abs(X - Wa) <= 1E-6 * Math.max(1, Math.abs(X), Math.abs(Wa)) && Math.abs(ea - Ba) <= 1E-6 * Math.max(1, Math.abs(ea), Math.abs(Ba)) && Math.abs(ca - Bb) <= 1E-6 * Math.max(1, Math.abs(ca), Math.abs(Bb)) && Math.abs(aa - Cb) <= 1E-6 * Math.max(1, Math.abs(aa), Math.abs(Cb)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
            },
            mul: m,
            sub: u
        }),
        hb = function() {
            var l = q();
            return function(n, v, z, D, E, I) {
                v ||
                    (v = 3);
                z || (z = 0);
                for (D = D ? Math.min(D * v + z, n.length) : n.length; z < D; z += v) l[0] = n[z], l[1] = n[z + 1], l[2] = n[z + 2], E(l, l, I), n[z] = l[0], n[z + 1] = l[1], n[z + 2] = l[2];
                return n
            }
        }();
    hb = Object.freeze({
        __proto__: null,
        create: q,
        clone: function(l) {
            var n = new ra(3);
            n[0] = l[0];
            n[1] = l[1];
            n[2] = l[2];
            return n
        },
        length: x,
        fromValues: y,
        copy: function(l, n) {
            l[0] = n[0];
            l[1] = n[1];
            l[2] = n[2];
            return l
        },
        set: function(l, n, v, z) {
            l[0] = n;
            l[1] = v;
            l[2] = z;
            return l
        },
        add: function(l, n, v) {
            l[0] = n[0] + v[0];
            l[1] = n[1] + v[1];
            l[2] = n[2] + v[2];
            return l
        },
        subtract: B,
        multiply: F,
        divide: H,
        ceil: function(l, n) {
            l[0] = Math.ceil(n[0]);
            l[1] = Math.ceil(n[1]);
            l[2] = Math.ceil(n[2]);
            return l
        },
        floor: function(l, n) {
            l[0] = Math.floor(n[0]);
            l[1] = Math.floor(n[1]);
            l[2] = Math.floor(n[2]);
            return l
        },
        min: function(l, n, v) {
            l[0] = Math.min(n[0], v[0]);
            l[1] = Math.min(n[1], v[1]);
            l[2] = Math.min(n[2], v[2]);
            return l
        },
        max: function(l, n, v) {
            l[0] = Math.max(n[0], v[0]);
            l[1] = Math.max(n[1], v[1]);
            l[2] = Math.max(n[2], v[2]);
            return l
        },
        round: function(l, n) {
            l[0] = Math.round(n[0]);
            l[1] = Math.round(n[1]);
            l[2] = Math.round(n[2]);
            return l
        },
        scale: function(l, n, v) {
            l[0] = n[0] * v;
            l[1] = n[1] * v;
            l[2] = n[2] * v;
            return l
        },
        scaleAndAdd: function(l, n, v, z) {
            l[0] = n[0] + v[0] * z;
            l[1] = n[1] + v[1] * z;
            l[2] = n[2] + v[2] * z;
            return l
        },
        distance: K,
        squaredDistance: C,
        squaredLength: A,
        negate: function(l, n) {
            l[0] = -n[0];
            l[1] = -n[1];
            l[2] = -n[2];
            return l
        },
        inverse: function(l, n) {
            l[0] = 1 / n[0];
            l[1] = 1 / n[1];
            l[2] = 1 / n[2];
            return l
        },
        normalize: G,
        dot: J,
        cross: M,
        lerp: function(l, n, v, z) {
            var D = n[0],
                E = n[1];
            n = n[2];
            l[0] = D + z * (v[0] - D);
            l[1] = E + z * (v[1] - E);
            l[2] = n + z * (v[2] - n);
            return l
        },
        hermite: function(l, n, v, z, D,
            E) {
            var I = E * E,
                L = I * (2 * E - 3) + 1,
                O = I * (E - 2) + E,
                Q = I * (E - 1);
            E = I * (3 - 2 * E);
            l[0] = n[0] * L + v[0] * O + z[0] * Q + D[0] * E;
            l[1] = n[1] * L + v[1] * O + z[1] * Q + D[1] * E;
            l[2] = n[2] * L + v[2] * O + z[2] * Q + D[2] * E;
            return l
        },
        bezier: function(l, n, v, z, D, E) {
            var I = 1 - E,
                L = I * I,
                O = E * E,
                Q = L * I;
            L *= 3 * E;
            I *= 3 * O;
            E *= O;
            l[0] = n[0] * Q + v[0] * L + z[0] * I + D[0] * E;
            l[1] = n[1] * Q + v[1] * L + z[1] * I + D[1] * E;
            l[2] = n[2] * Q + v[2] * L + z[2] * I + D[2] * E;
            return l
        },
        random: function(l, n) {
            n = n || 1;
            var v = 2 * Qa() * Math.PI,
                z = 2 * Qa() - 1,
                D = Math.sqrt(1 - z * z) * n;
            l[0] = Math.cos(v) * D;
            l[1] = Math.sin(v) * D;
            l[2] = z * n;
            return l
        },
        transformMat4: function(l,
            n, v) {
            var z = n[0],
                D = n[1];
            n = n[2];
            var E = v[3] * z + v[7] * D + v[11] * n + v[15];
            E = E || 1;
            l[0] = (v[0] * z + v[4] * D + v[8] * n + v[12]) / E;
            l[1] = (v[1] * z + v[5] * D + v[9] * n + v[13]) / E;
            l[2] = (v[2] * z + v[6] * D + v[10] * n + v[14]) / E;
            return l
        },
        transformMat3: function(l, n, v) {
            var z = n[0],
                D = n[1];
            n = n[2];
            l[0] = z * v[0] + D * v[3] + n * v[6];
            l[1] = z * v[1] + D * v[4] + n * v[7];
            l[2] = z * v[2] + D * v[5] + n * v[8];
            return l
        },
        transformQuat: function(l, n, v) {
            var z = v[0],
                D = v[1],
                E = v[2],
                I = n[0],
                L = n[1];
            n = n[2];
            var O = D * n - E * L,
                Q = E * I - z * n,
                S = z * L - D * I;
            v = 2 * v[3];
            l[0] = I + O * v + 2 * (D * S - E * Q);
            l[1] = L + Q * v + 2 * (E * O - z * S);
            l[2] =
                n + S * v + 2 * (z * Q - D * O);
            return l
        },
        rotateX: function(l, n, v, z) {
            var D = [],
                E = [];
            D[0] = n[0] - v[0];
            D[1] = n[1] - v[1];
            D[2] = n[2] - v[2];
            E[0] = D[0];
            E[1] = D[1] * Math.cos(z) - D[2] * Math.sin(z);
            E[2] = D[1] * Math.sin(z) + D[2] * Math.cos(z);
            l[0] = E[0] + v[0];
            l[1] = E[1] + v[1];
            l[2] = E[2] + v[2];
            return l
        },
        rotateY: function(l, n, v, z) {
            var D = [],
                E = [];
            D[0] = n[0] - v[0];
            D[1] = n[1] - v[1];
            D[2] = n[2] - v[2];
            E[0] = D[2] * Math.sin(z) + D[0] * Math.cos(z);
            E[1] = D[1];
            E[2] = D[2] * Math.cos(z) - D[0] * Math.sin(z);
            l[0] = E[0] + v[0];
            l[1] = E[1] + v[1];
            l[2] = E[2] + v[2];
            return l
        },
        rotateZ: function(l,
            n, v, z) {
            var D = [],
                E = [];
            D[0] = n[0] - v[0];
            D[1] = n[1] - v[1];
            D[2] = n[2] - v[2];
            E[0] = D[0] * Math.cos(z) - D[1] * Math.sin(z);
            E[1] = D[0] * Math.sin(z) + D[1] * Math.cos(z);
            E[2] = D[2];
            l[0] = E[0] + v[0];
            l[1] = E[1] + v[1];
            l[2] = E[2] + v[2];
            return l
        },
        angle: function(l, n) {
            var v = l[0],
                z = l[1],
                D = l[2],
                E = n[0],
                I = n[1],
                L = n[2];
            l = (v = Math.sqrt(v * v + z * z + D * D) * Math.sqrt(E * E + I * I + L * L)) && J(l, n) / v;
            return Math.acos(Math.min(Math.max(l, -1), 1))
        },
        zero: function(l) {
            l[0] = 0;
            l[1] = 0;
            l[2] = 0;
            return l
        },
        str: function(l) {
            return "vec3(" + l[0] + ", " + l[1] + ", " + l[2] + ")"
        },
        exactEquals: function(l,
            n) {
            return l[0] === n[0] && l[1] === n[1] && l[2] === n[2]
        },
        equals: function(l, n) {
            var v = l[0],
                z = l[1];
            l = l[2];
            var D = n[0],
                E = n[1];
            n = n[2];
            return Math.abs(v - D) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(z - E) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(E)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
        },
        sub: B,
        mul: F,
        div: H,
        dist: K,
        sqrDist: C,
        len: x,
        sqrLen: A,
        forEach: hb
    });
    var ib = function() {
        var l = R();
        return function(n, v, z, D, E, I) {
            v || (v = 4);
            z || (z = 0);
            for (D = D ? Math.min(D * v + z, n.length) : n.length; z < D; z += v) l[0] = n[z], l[1] =
                n[z + 1], l[2] = n[z + 2], l[3] = n[z + 3], E(l, l, I), n[z] = l[0], n[z + 1] = l[1], n[z + 2] = l[2], n[z + 3] = l[3];
            return n
        }
    }();
    ib = Object.freeze({
        __proto__: null,
        create: R,
        clone: U,
        fromValues: V,
        copy: ba,
        set: ia,
        add: ja,
        subtract: qa,
        multiply: za,
        divide: Ca,
        ceil: function(l, n) {
            l[0] = Math.ceil(n[0]);
            l[1] = Math.ceil(n[1]);
            l[2] = Math.ceil(n[2]);
            l[3] = Math.ceil(n[3]);
            return l
        },
        floor: function(l, n) {
            l[0] = Math.floor(n[0]);
            l[1] = Math.floor(n[1]);
            l[2] = Math.floor(n[2]);
            l[3] = Math.floor(n[3]);
            return l
        },
        min: function(l, n, v) {
            l[0] = Math.min(n[0], v[0]);
            l[1] = Math.min(n[1],
                v[1]);
            l[2] = Math.min(n[2], v[2]);
            l[3] = Math.min(n[3], v[3]);
            return l
        },
        max: function(l, n, v) {
            l[0] = Math.max(n[0], v[0]);
            l[1] = Math.max(n[1], v[1]);
            l[2] = Math.max(n[2], v[2]);
            l[3] = Math.max(n[3], v[3]);
            return l
        },
        round: function(l, n) {
            l[0] = Math.round(n[0]);
            l[1] = Math.round(n[1]);
            l[2] = Math.round(n[2]);
            l[3] = Math.round(n[3]);
            return l
        },
        scale: Ma,
        scaleAndAdd: function(l, n, v, z) {
            l[0] = n[0] + v[0] * z;
            l[1] = n[1] + v[1] * z;
            l[2] = n[2] + v[2] * z;
            l[3] = n[3] + v[3] * z;
            return l
        },
        distance: Fa,
        squaredDistance: La,
        length: na,
        squaredLength: Sa,
        negate: function(l,
            n) {
            l[0] = -n[0];
            l[1] = -n[1];
            l[2] = -n[2];
            l[3] = -n[3];
            return l
        },
        inverse: function(l, n) {
            l[0] = 1 / n[0];
            l[1] = 1 / n[1];
            l[2] = 1 / n[2];
            l[3] = 1 / n[3];
            return l
        },
        normalize: Aa,
        dot: Na,
        cross: function(l, n, v, z) {
            var D = v[0] * z[1] - v[1] * z[0],
                E = v[0] * z[2] - v[2] * z[0],
                I = v[0] * z[3] - v[3] * z[0],
                L = v[1] * z[2] - v[2] * z[1],
                O = v[1] * z[3] - v[3] * z[1];
            v = v[2] * z[3] - v[3] * z[2];
            z = n[0];
            var Q = n[1],
                S = n[2];
            n = n[3];
            l[0] = Q * v - S * O + n * L;
            l[1] = -(z * v) + S * I - n * E;
            l[2] = z * O - Q * I + n * D;
            l[3] = -(z * L) + Q * E - S * D;
            return l
        },
        lerp: lb,
        random: function(l, n) {
            n = n || 1;
            do {
                var v = 2 * Qa() - 1;
                var z = 2 * Qa() - 1;
                var D = v * v + z * z
            } while (1 <= D);
            do {
                var E = 2 * Qa() - 1;
                var I = 2 * Qa() - 1;
                var L = E * E + I * I
            } while (1 <= L);
            D = Math.sqrt((1 - D) / L);
            l[0] = n * v;
            l[1] = n * z;
            l[2] = n * E * D;
            l[3] = n * I * D;
            return l
        },
        transformMat4: function(l, n, v) {
            var z = n[0],
                D = n[1],
                E = n[2];
            n = n[3];
            l[0] = v[0] * z + v[4] * D + v[8] * E + v[12] * n;
            l[1] = v[1] * z + v[5] * D + v[9] * E + v[13] * n;
            l[2] = v[2] * z + v[6] * D + v[10] * E + v[14] * n;
            l[3] = v[3] * z + v[7] * D + v[11] * E + v[15] * n;
            return l
        },
        transformQuat: function(l, n, v) {
            var z = n[0],
                D = n[1],
                E = n[2],
                I = v[0],
                L = v[1],
                O = v[2];
            v = v[3];
            var Q = v * z + L * E - O * D,
                S = v * D + O * z - I * E,
                T = v * E + I * D - L * z;
            z = -I * z -
                L * D - O * E;
            l[0] = Q * v + z * -I + S * -O - T * -L;
            l[1] = S * v + z * -L + T * -I - Q * -O;
            l[2] = T * v + z * -O + Q * -L - S * -I;
            l[3] = n[3];
            return l
        },
        zero: function(l) {
            l[0] = 0;
            l[1] = 0;
            l[2] = 0;
            l[3] = 0;
            return l
        },
        str: function(l) {
            return "vec4(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")"
        },
        exactEquals: mb,
        equals: nb,
        sub: qa,
        mul: za,
        div: Ca,
        dist: Fa,
        sqrDist: La,
        len: na,
        sqrLen: Sa,
        forEach: ib
    });
    var jb = function() {
            var l = q(),
                n = y(1, 0, 0),
                v = y(0, 1, 0);
            return function(z, D, E) {
                var I = J(D, E);
                if (-.999999 > I) return M(l, n, D), 1E-6 > x(l) && M(l, v, D), G(l, l), ob(z, l, Math.PI), z;
                if (.999999 < I) return z[0] =
                    0, z[1] = 0, z[2] = 0, z[3] = 1, z;
                M(l, D, E);
                z[0] = l[0];
                z[1] = l[1];
                z[2] = l[2];
                z[3] = 1 + I;
                return Aa(z, z)
            }
        }(),
        kb = function() {
            var l = ab(),
                n = ab();
            return function(v, z, D, E, I, L) {
                bb(l, z, I, L);
                bb(n, D, E, L);
                bb(v, l, n, 2 * L * (1 - L));
                return v
            }
        }(),
        Za = function() {
            var l = f();
            return function(n, v, z, D) {
                l[0] = z[0];
                l[3] = z[1];
                l[6] = z[2];
                l[1] = D[0];
                l[4] = D[1];
                l[7] = D[2];
                l[2] = -v[0];
                l[5] = -v[1];
                l[8] = -v[2];
                return Aa(n, vb(n, l))
            }
        }();
    jb = Object.freeze({
        __proto__: null,
        create: ab,
        identity: function(l) {
            l[0] = 0;
            l[1] = 0;
            l[2] = 0;
            l[3] = 1;
            return l
        },
        setAxisAngle: ob,
        getAxisAngle: function(l,
            n) {
            var v = 2 * Math.acos(n[3]),
                z = Math.sin(v / 2);
            1E-6 < z ? (l[0] = n[0] / z, l[1] = n[1] / z, l[2] = n[2] / z) : (l[0] = 1, l[1] = 0, l[2] = 0);
            return v
        },
        getAngle: function(l, n) {
            l = Na(l, n);
            return Math.acos(2 * l * l - 1)
        },
        multiply: pb,
        rotateX: qb,
        rotateY: rb,
        rotateZ: sb,
        calculateW: function(l, n) {
            var v = n[0],
                z = n[1];
            n = n[2];
            l[0] = v;
            l[1] = z;
            l[2] = n;
            l[3] = Math.sqrt(Math.abs(1 - v * v - z * z - n * n));
            return l
        },
        exp: tb,
        ln: ub,
        pow: function(l, n, v) {
            ub(l, n);
            Ma(l, l, v);
            tb(l, l);
            return l
        },
        slerp: bb,
        random: function(l) {
            var n = Qa(),
                v = Qa(),
                z = Qa(),
                D = Math.sqrt(1 - n);
            n = Math.sqrt(n);
            l[0] = D * Math.sin(2 * Math.PI * v);
            l[1] = D * Math.cos(2 * Math.PI * v);
            l[2] = n * Math.sin(2 * Math.PI * z);
            l[3] = n * Math.cos(2 * Math.PI * z);
            return l
        },
        invert: function(l, n) {
            var v = n[0],
                z = n[1],
                D = n[2];
            n = n[3];
            var E = v * v + z * z + D * D + n * n;
            E = E ? 1 / E : 0;
            l[0] = -v * E;
            l[1] = -z * E;
            l[2] = -D * E;
            l[3] = n * E;
            return l
        },
        conjugate: function(l, n) {
            l[0] = -n[0];
            l[1] = -n[1];
            l[2] = -n[2];
            l[3] = n[3];
            return l
        },
        fromMat3: vb,
        fromEuler: function(l, n, v, z) {
            var D = .5 * Math.PI / 180;
            n *= D;
            v *= D;
            z *= D;
            D = Math.sin(n);
            n = Math.cos(n);
            var E = Math.sin(v);
            v = Math.cos(v);
            var I = Math.sin(z);
            z = Math.cos(z);
            l[0] = D * v * z - n * E * I;
            l[1] = n * E * z + D * v * I;
            l[2] = n * v * I - D * E * z;
            l[3] = n * v * z + D * E * I;
            return l
        },
        str: function(l) {
            return "quat(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")"
        },
        clone: U,
        fromValues: V,
        copy: ba,
        set: ia,
        add: ja,
        mul: pb,
        scale: Ma,
        dot: Na,
        lerp: lb,
        length: na,
        len: na,
        squaredLength: Sa,
        sqrLen: Sa,
        normalize: Aa,
        exactEquals: mb,
        equals: nb,
        rotationTo: jb,
        sqlerp: kb,
        setAxes: Za
    });
    kb = Object.freeze({
        __proto__: null,
        create: function() {
            var l = new ra(8);
            ra != Float32Array && (l[0] = 0, l[1] = 0, l[2] = 0, l[4] = 0, l[5] = 0, l[6] = 0, l[7] = 0);
            l[3] = 1;
            return l
        },
        clone: function(l) {
            var n =
                new ra(8);
            n[0] = l[0];
            n[1] = l[1];
            n[2] = l[2];
            n[3] = l[3];
            n[4] = l[4];
            n[5] = l[5];
            n[6] = l[6];
            n[7] = l[7];
            return n
        },
        fromValues: function(l, n, v, z, D, E, I, L) {
            var O = new ra(8);
            O[0] = l;
            O[1] = n;
            O[2] = v;
            O[3] = z;
            O[4] = D;
            O[5] = E;
            O[6] = I;
            O[7] = L;
            return O
        },
        fromRotationTranslationValues: function(l, n, v, z, D, E, I) {
            var L = new ra(8);
            L[0] = l;
            L[1] = n;
            L[2] = v;
            L[3] = z;
            D *= .5;
            E *= .5;
            I *= .5;
            L[4] = D * z + E * v - I * n;
            L[5] = E * z + I * l - D * v;
            L[6] = I * z + D * n - E * l;
            L[7] = -D * l - E * n - I * v;
            return L
        },
        fromRotationTranslation: wb,
        fromTranslation: function(l, n) {
            l[0] = 0;
            l[1] = 0;
            l[2] = 0;
            l[3] = 1;
            l[4] =
                .5 * n[0];
            l[5] = .5 * n[1];
            l[6] = .5 * n[2];
            l[7] = 0;
            return l
        },
        fromRotation: function(l, n) {
            l[0] = n[0];
            l[1] = n[1];
            l[2] = n[2];
            l[3] = n[3];
            l[4] = 0;
            l[5] = 0;
            l[6] = 0;
            l[7] = 0;
            return l
        },
        fromMat4: function(l, n) {
            var v = ab();
            t(v, n);
            var z = new ra(3);
            w(z, n);
            wb(l, v, z);
            return l
        },
        copy: xb,
        identity: function(l) {
            l[0] = 0;
            l[1] = 0;
            l[2] = 0;
            l[3] = 1;
            l[4] = 0;
            l[5] = 0;
            l[6] = 0;
            l[7] = 0;
            return l
        },
        set: function(l, n, v, z, D, E, I, L, O) {
            l[0] = n;
            l[1] = v;
            l[2] = z;
            l[3] = D;
            l[4] = E;
            l[5] = I;
            l[6] = L;
            l[7] = O;
            return l
        },
        getReal: ba,
        getDual: function(l, n) {
            l[0] = n[4];
            l[1] = n[5];
            l[2] = n[6];
            l[3] =
                n[7];
            return l
        },
        setReal: ba,
        setDual: function(l, n) {
            l[4] = n[0];
            l[5] = n[1];
            l[6] = n[2];
            l[7] = n[3];
            return l
        },
        getTranslation: function(l, n) {
            var v = n[4],
                z = n[5],
                D = n[6],
                E = n[7],
                I = -n[0],
                L = -n[1],
                O = -n[2];
            n = n[3];
            l[0] = 2 * (v * n + E * I + z * O - D * L);
            l[1] = 2 * (z * n + E * L + D * I - v * O);
            l[2] = 2 * (D * n + E * O + v * L - z * I);
            return l
        },
        translate: function(l, n, v) {
            var z = n[0],
                D = n[1],
                E = n[2],
                I = n[3],
                L = .5 * v[0],
                O = .5 * v[1];
            v = .5 * v[2];
            var Q = n[4],
                S = n[5],
                T = n[6];
            n = n[7];
            l[0] = z;
            l[1] = D;
            l[2] = E;
            l[3] = I;
            l[4] = I * L + D * v - E * O + Q;
            l[5] = I * O + E * L - z * v + S;
            l[6] = I * v + z * O - D * L + T;
            l[7] = -z * L - D * O - E * v + n;
            return l
        },
        rotateX: function(l, n, v) {
            var z = -n[0],
                D = -n[1],
                E = -n[2],
                I = n[3],
                L = n[4],
                O = n[5],
                Q = n[6],
                S = n[7],
                T = L * I + S * z + O * E - Q * D,
                Y = O * I + S * D + Q * z - L * E,
                X = Q * I + S * E + L * D - O * z;
            L = S * I - L * z - O * D - Q * E;
            qb(l, n, v);
            z = l[0];
            D = l[1];
            E = l[2];
            I = l[3];
            l[4] = T * I + L * z + Y * E - X * D;
            l[5] = Y * I + L * D + X * z - T * E;
            l[6] = X * I + L * E + T * D - Y * z;
            l[7] = L * I - T * z - Y * D - X * E;
            return l
        },
        rotateY: function(l, n, v) {
            var z = -n[0],
                D = -n[1],
                E = -n[2],
                I = n[3],
                L = n[4],
                O = n[5],
                Q = n[6],
                S = n[7],
                T = L * I + S * z + O * E - Q * D,
                Y = O * I + S * D + Q * z - L * E,
                X = Q * I + S * E + L * D - O * z;
            L = S * I - L * z - O * D - Q * E;
            rb(l, n, v);
            z = l[0];
            D = l[1];
            E = l[2];
            I = l[3];
            l[4] = T * I + L * z +
                Y * E - X * D;
            l[5] = Y * I + L * D + X * z - T * E;
            l[6] = X * I + L * E + T * D - Y * z;
            l[7] = L * I - T * z - Y * D - X * E;
            return l
        },
        rotateZ: function(l, n, v) {
            var z = -n[0],
                D = -n[1],
                E = -n[2],
                I = n[3],
                L = n[4],
                O = n[5],
                Q = n[6],
                S = n[7],
                T = L * I + S * z + O * E - Q * D,
                Y = O * I + S * D + Q * z - L * E,
                X = Q * I + S * E + L * D - O * z;
            L = S * I - L * z - O * D - Q * E;
            sb(l, n, v);
            z = l[0];
            D = l[1];
            E = l[2];
            I = l[3];
            l[4] = T * I + L * z + Y * E - X * D;
            l[5] = Y * I + L * D + X * z - T * E;
            l[6] = X * I + L * E + T * D - Y * z;
            l[7] = L * I - T * z - Y * D - X * E;
            return l
        },
        rotateByQuatAppend: function(l, n, v) {
            var z = v[0],
                D = v[1],
                E = v[2];
            v = v[3];
            var I = n[0],
                L = n[1],
                O = n[2],
                Q = n[3];
            l[0] = I * v + Q * z + L * E - O * D;
            l[1] = L * v +
                Q * D + O * z - I * E;
            l[2] = O * v + Q * E + I * D - L * z;
            l[3] = Q * v - I * z - L * D - O * E;
            I = n[4];
            L = n[5];
            O = n[6];
            Q = n[7];
            l[4] = I * v + Q * z + L * E - O * D;
            l[5] = L * v + Q * D + O * z - I * E;
            l[6] = O * v + Q * E + I * D - L * z;
            l[7] = Q * v - I * z - L * D - O * E;
            return l
        },
        rotateByQuatPrepend: function(l, n, v) {
            var z = n[0],
                D = n[1],
                E = n[2];
            n = n[3];
            var I = v[0],
                L = v[1],
                O = v[2],
                Q = v[3];
            l[0] = z * Q + n * I + D * O - E * L;
            l[1] = D * Q + n * L + E * I - z * O;
            l[2] = E * Q + n * O + z * L - D * I;
            l[3] = n * Q - z * I - D * L - E * O;
            I = v[4];
            L = v[5];
            O = v[6];
            Q = v[7];
            l[4] = z * Q + n * I + D * O - E * L;
            l[5] = D * Q + n * L + E * I - z * O;
            l[6] = E * Q + n * O + z * L - D * I;
            l[7] = n * Q - z * I - D * L - E * O;
            return l
        },
        rotateAroundAxis: function(l,
            n, v, z) {
            if (1E-6 > Math.abs(z)) return xb(l, n);
            var D = Math.hypot(v[0], v[1], v[2]);
            z *= .5;
            var E = Math.sin(z),
                I = E * v[0] / D,
                L = E * v[1] / D;
            v = E * v[2] / D;
            z = Math.cos(z);
            D = n[0];
            E = n[1];
            var O = n[2],
                Q = n[3];
            l[0] = D * z + Q * I + E * v - O * L;
            l[1] = E * z + Q * L + O * I - D * v;
            l[2] = O * z + Q * v + D * L - E * I;
            l[3] = Q * z - D * I - E * L - O * v;
            D = n[4];
            E = n[5];
            O = n[6];
            n = n[7];
            l[4] = D * z + n * I + E * v - O * L;
            l[5] = E * z + n * L + O * I - D * v;
            l[6] = O * z + n * v + D * L - E * I;
            l[7] = n * z - D * I - E * L - O * v;
            return l
        },
        add: function(l, n, v) {
            l[0] = n[0] + v[0];
            l[1] = n[1] + v[1];
            l[2] = n[2] + v[2];
            l[3] = n[3] + v[3];
            l[4] = n[4] + v[4];
            l[5] = n[5] + v[5];
            l[6] = n[6] +
                v[6];
            l[7] = n[7] + v[7];
            return l
        },
        multiply: yb,
        mul: yb,
        scale: function(l, n, v) {
            l[0] = n[0] * v;
            l[1] = n[1] * v;
            l[2] = n[2] * v;
            l[3] = n[3] * v;
            l[4] = n[4] * v;
            l[5] = n[5] * v;
            l[6] = n[6] * v;
            l[7] = n[7] * v;
            return l
        },
        dot: Na,
        lerp: function(l, n, v, z) {
            var D = 1 - z;
            0 > Na(n, v) && (z = -z);
            l[0] = n[0] * D + v[0] * z;
            l[1] = n[1] * D + v[1] * z;
            l[2] = n[2] * D + v[2] * z;
            l[3] = n[3] * D + v[3] * z;
            l[4] = n[4] * D + v[4] * z;
            l[5] = n[5] * D + v[5] * z;
            l[6] = n[6] * D + v[6] * z;
            l[7] = n[7] * D + v[7] * z;
            return l
        },
        invert: function(l, n) {
            var v = Sa(n);
            l[0] = -n[0] / v;
            l[1] = -n[1] / v;
            l[2] = -n[2] / v;
            l[3] = n[3] / v;
            l[4] = -n[4] / v;
            l[5] = -n[5] /
                v;
            l[6] = -n[6] / v;
            l[7] = n[7] / v;
            return l
        },
        conjugate: function(l, n) {
            l[0] = -n[0];
            l[1] = -n[1];
            l[2] = -n[2];
            l[3] = n[3];
            l[4] = -n[4];
            l[5] = -n[5];
            l[6] = -n[6];
            l[7] = n[7];
            return l
        },
        length: na,
        len: na,
        squaredLength: Sa,
        sqrLen: Sa,
        normalize: function(l, n) {
            var v = Sa(n);
            if (0 < v) {
                v = Math.sqrt(v);
                var z = n[0] / v,
                    D = n[1] / v,
                    E = n[2] / v,
                    I = n[3] / v,
                    L = n[4],
                    O = n[5],
                    Q = n[6];
                n = n[7];
                var S = z * L + D * O + E * Q + I * n;
                l[0] = z;
                l[1] = D;
                l[2] = E;
                l[3] = I;
                l[4] = (L - z * S) / v;
                l[5] = (O - D * S) / v;
                l[6] = (Q - E * S) / v;
                l[7] = (n - I * S) / v
            }
            return l
        },
        str: function(l) {
            return "quat2(" + l[0] + ", " + l[1] + ", " + l[2] +
                ", " + l[3] + ", " + l[4] + ", " + l[5] + ", " + l[6] + ", " + l[7] + ")"
        },
        exactEquals: function(l, n) {
            return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5] && l[6] === n[6] && l[7] === n[7]
        },
        equals: function(l, n) {
            var v = l[0],
                z = l[1],
                D = l[2],
                E = l[3],
                I = l[4],
                L = l[5],
                O = l[6];
            l = l[7];
            var Q = n[0],
                S = n[1],
                T = n[2],
                Y = n[3],
                X = n[4],
                ea = n[5],
                ca = n[6];
            n = n[7];
            return Math.abs(v - Q) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(Q)) && Math.abs(z - S) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(S)) && Math.abs(D - T) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(T)) &&
                Math.abs(E - Y) <= 1E-6 * Math.max(1, Math.abs(E), Math.abs(Y)) && Math.abs(I - X) <= 1E-6 * Math.max(1, Math.abs(I), Math.abs(X)) && Math.abs(L - ea) <= 1E-6 * Math.max(1, Math.abs(L), Math.abs(ea)) && Math.abs(O - ca) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(ca)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
        }
    });
    Za = function() {
        var l = cb();
        return function(n, v, z, D, E, I) {
            v || (v = 2);
            z || (z = 0);
            for (D = D ? Math.min(D * v + z, n.length) : n.length; z < D; z += v) l[0] = n[z], l[1] = n[z + 1], E(l, l, I), n[z] = l[0], n[z + 1] = l[1];
            return n
        }
    }();
    Za = Object.freeze({
        __proto__: null,
        create: cb,
        clone: function(l) {
            var n = new ra(2);
            n[0] = l[0];
            n[1] = l[1];
            return n
        },
        fromValues: function(l, n) {
            var v = new ra(2);
            v[0] = l;
            v[1] = n;
            return v
        },
        copy: function(l, n) {
            l[0] = n[0];
            l[1] = n[1];
            return l
        },
        set: function(l, n, v) {
            l[0] = n;
            l[1] = v;
            return l
        },
        add: function(l, n, v) {
            l[0] = n[0] + v[0];
            l[1] = n[1] + v[1];
            return l
        },
        subtract: Xa,
        multiply: db,
        divide: eb,
        ceil: function(l, n) {
            l[0] = Math.ceil(n[0]);
            l[1] = Math.ceil(n[1]);
            return l
        },
        floor: function(l, n) {
            l[0] = Math.floor(n[0]);
            l[1] = Math.floor(n[1]);
            return l
        },
        min: function(l, n, v) {
            l[0] = Math.min(n[0],
                v[0]);
            l[1] = Math.min(n[1], v[1]);
            return l
        },
        max: function(l, n, v) {
            l[0] = Math.max(n[0], v[0]);
            l[1] = Math.max(n[1], v[1]);
            return l
        },
        round: function(l, n) {
            l[0] = Math.round(n[0]);
            l[1] = Math.round(n[1]);
            return l
        },
        scale: function(l, n, v) {
            l[0] = n[0] * v;
            l[1] = n[1] * v;
            return l
        },
        scaleAndAdd: function(l, n, v, z) {
            l[0] = n[0] + v[0] * z;
            l[1] = n[1] + v[1] * z;
            return l
        },
        distance: Ya,
        squaredDistance: fb,
        length: Ta,
        squaredLength: gb,
        negate: function(l, n) {
            l[0] = -n[0];
            l[1] = -n[1];
            return l
        },
        inverse: function(l, n) {
            l[0] = 1 / n[0];
            l[1] = 1 / n[1];
            return l
        },
        normalize: function(l,
            n) {
            var v = n[0],
                z = n[1];
            v = v * v + z * z;
            0 < v && (v = 1 / Math.sqrt(v));
            l[0] = n[0] * v;
            l[1] = n[1] * v;
            return l
        },
        dot: function(l, n) {
            return l[0] * n[0] + l[1] * n[1]
        },
        cross: function(l, n, v) {
            n = n[0] * v[1] - n[1] * v[0];
            l[0] = l[1] = 0;
            l[2] = n;
            return l
        },
        lerp: function(l, n, v, z) {
            var D = n[0];
            n = n[1];
            l[0] = D + z * (v[0] - D);
            l[1] = n + z * (v[1] - n);
            return l
        },
        random: function(l, n) {
            n = n || 1;
            var v = 2 * Qa() * Math.PI;
            l[0] = Math.cos(v) * n;
            l[1] = Math.sin(v) * n;
            return l
        },
        transformMat2: function(l, n, v) {
            var z = n[0];
            n = n[1];
            l[0] = v[0] * z + v[2] * n;
            l[1] = v[1] * z + v[3] * n;
            return l
        },
        transformMat2d: function(l,
            n, v) {
            var z = n[0];
            n = n[1];
            l[0] = v[0] * z + v[2] * n + v[4];
            l[1] = v[1] * z + v[3] * n + v[5];
            return l
        },
        transformMat3: function(l, n, v) {
            var z = n[0];
            n = n[1];
            l[0] = v[0] * z + v[3] * n + v[6];
            l[1] = v[1] * z + v[4] * n + v[7];
            return l
        },
        transformMat4: function(l, n, v) {
            var z = n[0];
            n = n[1];
            l[0] = v[0] * z + v[4] * n + v[12];
            l[1] = v[1] * z + v[5] * n + v[13];
            return l
        },
        rotate: function(l, n, v, z) {
            var D = n[0] - v[0];
            n = n[1] - v[1];
            var E = Math.sin(z);
            z = Math.cos(z);
            l[0] = D * z - n * E + v[0];
            l[1] = D * E + n * z + v[1];
            return l
        },
        angle: function(l, n) {
            var v = l[0];
            l = l[1];
            var z = n[0];
            n = n[1];
            var D = Math.sqrt(v * v +
                l * l) * Math.sqrt(z * z + n * n);
            return Math.acos(Math.min(Math.max(D && (v * z + l * n) / D, -1), 1))
        },
        zero: function(l) {
            l[0] = 0;
            l[1] = 0;
            return l
        },
        str: function(l) {
            return "vec2(" + l[0] + ", " + l[1] + ")"
        },
        exactEquals: function(l, n) {
            return l[0] === n[0] && l[1] === n[1]
        },
        equals: function(l, n) {
            var v = l[0];
            l = l[1];
            var z = n[0];
            n = n[1];
            return Math.abs(v - z) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(z)) && Math.abs(l - n) <= 1E-6 * Math.max(1, Math.abs(l), Math.abs(n))
        },
        len: Ta,
        sub: Xa,
        mul: db,
        div: eb,
        dist: Ya,
        sqrDist: fb,
        sqrLen: gb,
        forEach: Za
    });
    e.glMatrix = Ab;
    e.mat2 =
        Db;
    e.mat2d = Eb;
    e.mat3 = Fb;
    e.mat4 = Gb;
    e.quat = jb;
    e.quat2 = kb;
    e.vec2 = Za;
    e.vec3 = hb;
    e.vec4 = ib;
    Object.defineProperty(e, "__esModule", {
        value: !0
    })
}); {
    "use strict";

    function e(A, G, J) {
        var M = [0, 0];
        var R = A[1][1] - A[0][1];
        var U = A[0][0] - A[1][0];
        A = R * A[0][0] + U * A[0][1];
        var V = G[1][1] - G[0][1];
        var ba = G[0][0] - G[1][0];
        G = V * G[0][0] + ba * G[0][1];
        var ia = R * ba - V * U;
        K(ia, 0, J || 0) || (M[0] = (ba * A - U * G) / ia, M[1] = (R * G - V * A) / ia);
        return M
    }

    function d(A, G, J, M) {
        var R = G[0] - A[0];
        G = G[1] - A[1];
        var U = M[0] - J[0],
            V = M[1] - J[1];
        if (0 === U * G - V * R) return !1;
        M = (R * (J[1] - A[1]) + G * (A[0] - J[0])) / (U * G - V * R);
        A = (U * (A[1] - J[1]) + V * (J[0] - A[0])) / (V * R - U * G);
        return 0 <= M && 1 >= M && 0 <= A && 1 >= A
    }

    function a(A, G, J) {
        return (G[0] - A[0]) *
            (J[1] - A[1]) - (J[0] - A[0]) * (G[1] - A[1])
    }

    function b(A, G, J) {
        return 0 < a(A, G, J)
    }

    function c(A, G, J) {
        return 0 <= a(A, G, J)
    }

    function f(A, G, J) {
        return 0 > a(A, G, J)
    }

    function h(A, G, J) {
        return 0 >= a(A, G, J)
    }
    var tmpPoint1$$module$str$c3runtime = [],
        tmpPoint2$$module$str$c3runtime = [];

    function g(A, G, J, M) {
        if (M) {
            var R = tmpPoint1$$module$str$c3runtime,
                U = tmpPoint2$$module$str$c3runtime;
            R[0] = G[0] - A[0];
            R[1] = G[1] - A[1];
            U[0] = J[0] - G[0];
            U[1] = J[1] - G[1];
            return Math.acos((R[0] * U[0] + R[1] * U[1]) / (Math.sqrt(R[0] * R[0] + R[1] * R[1]) * Math.sqrt(U[0] * U[0] +
                U[1] * U[1]))) < M
        }
        return 0 === a(A, G, J)
    }

    function k(A, G) {
        var J = G[0] - A[0];
        A = G[1] - A[1];
        return J * J + A * A
    }

    function m(A, G) {
        var J = A.length;
        return A[0 > G ? G % J + J : G % J]
    }

    function r(A) {
        A.length = 0
    }

    function w(A, G, J, M) {
        for (; J < M; J++) A.push(G[J])
    }

    function p(A) {
        for (var G = [], J = A.length, M = 0; M !== J; M++) G.push(A.pop());
        for (M = 0; M !== J; M++) A[M] = G[M]
    }

    function t(A, G) {
        return f(m(A, G - 1), m(A, G), m(A, G + 1))
    }
    var tmpLine1$$module$str$c3runtime = [],
        tmpLine2$$module$str$c3runtime = [];

    function u(A, G, J) {
        var M = tmpLine1$$module$str$c3runtime,
            R = tmpLine2$$module$str$c3runtime;
        if (c(m(A, G + 1), m(A, G), m(A, J)) && h(m(A, G - 1), m(A, G), m(A, J))) return !1;
        var U = k(m(A, G), m(A, J));
        for (var V = 0; V !== A.length; ++V)
            if ((V + 1) % A.length !== G && V !== G && c(m(A, G), m(A, J), m(A, V + 1)) && h(m(A, G), m(A, J), m(A, V))) {
                M[0] = m(A, G);
                M[1] = m(A, J);
                R[0] = m(A, V);
                R[1] = m(A, V + 1);
                var ba = e(M, R);
                if (k(m(A, G), ba) < U) return !1
            }
        return !0
    }

    function q(A, G, J) {
        for (var M = 0; M !== A.length; ++M)
            if (M !== G && M !== J && (M + 1) % A.length !== G && (M + 1) % A.length !== J && d(m(A, G), m(A, J), m(A, M), m(A, M + 1))) return !1;
        return !0
    }

    function x(A, G, J, M) {
        M = M || [];
        r(M);
        if (G < J)
            for (var R =
                    G; R <= J; R++) M.push(A[R]);
        else {
            for (R = 0; R <= J; R++) M.push(A[R]);
            for (R = G; R < A.length; R++) M.push(A[R])
        }
        return M
    }

    function y(A) {
        for (var G = [], J, M, R = [], U = Number.MAX_VALUE, V = 0; V < A.length; ++V)
            if (t(A, V))
                for (var ba = 0; ba < A.length; ++ba)
                    if (u(A, V, ba)) {
                        J = y(x(A, V, ba, R));
                        M = y(x(A, ba, V, R));
                        for (var ia = 0; ia < M.length; ia++) J.push(M[ia]);
                        J.length < U && (G = J, U = J.length, G.push([m(A, V), m(A, ba)]))
                    }
        return G
    }

    function B(A, G) {
        if (0 === G.length) return [A];
        if (G instanceof Array && G.length && G[0] instanceof Array && 2 === G[0].length && G[0][0] instanceof Array) {
            A = [A];
            for (var J = 0; J < G.length; J++)
                for (var M = G[J], R = 0; R < A.length; R++) {
                    var U = B(A[R], M);
                    if (U) {
                        A.splice(R, 1);
                        A.push(U[0], U[1]);
                        break
                    }
                }
            return A
        }
        M = G;
        J = A.indexOf(M[0]);
        R = A.indexOf(M[1]);
        return -1 !== J && -1 !== R ? [x(A, J, R), x(A, R, J)] : !1
    }

    function F(A, G, J, M, R) {
        var U = G[1] - A[1];
        G = A[0] - G[0];
        A = U * A[0] + G * A[1];
        var V = M[1] - J[1];
        M = J[0] - M[0];
        J = V * J[0] + M * J[1];
        var ba = U * M - V * G;
        return K(ba, 0, R || 0) ? [0, 0] : [(M * A - G * J) / ba, (U * J - V * A) / ba]
    }

    function H(A, G, J, M, R, U, V) {
        U = U || 100;
        V = V || 0;
        R = R || 25;
        G = "undefined" !== typeof G ? G : [];
        J = J || [];
        M = M || [];
        var ba = [0, 0],
            ia = [0, 0],
            ja = [0, 0],
            qa, za = 0,
            Ca = 0,
            Ma = 0,
            Fa = [],
            La = [];
        if (3 > A.length) return G;
        V++;
        if (V > U) return console.warn("quickDecomp: max level (" + U + ") reached."), G;
        for (var na = 0; na < A.length; ++na)
            if (t(A, na)) {
                J.push(A[na]);
                var Sa = qa = Number.MAX_VALUE;
                for (var Aa = 0; Aa < A.length; ++Aa) {
                    if (b(m(A, na - 1), m(A, na), m(A, Aa)) && h(m(A, na - 1), m(A, na), m(A, Aa - 1)) && (ja = F(m(A, na - 1), m(A, na), m(A, Aa), m(A, Aa - 1)), f(m(A, na + 1), m(A, na), ja))) {
                        var Na = k(A[na], ja);
                        Na < qa && (qa = Na, ia = ja, Ca = Aa)
                    }
                    b(m(A, na + 1), m(A, na), m(A, Aa + 1)) && h(m(A, na + 1),
                        m(A, na), m(A, Aa)) && (ja = F(m(A, na + 1), m(A, na), m(A, Aa), m(A, Aa + 1)), b(m(A, na - 1), m(A, na), ja) && (Na = k(A[na], ja), Na < Sa && (Sa = Na, ba = ja, za = Aa)))
                }
                if (Ca === (za + 1) % A.length) ja[0] = (ia[0] + ba[0]) / 2, ja[1] = (ia[1] + ba[1]) / 2, M.push(ja), na < za ? (w(Fa, A, na, za + 1), Fa.push(ja), La.push(ja), 0 !== Ca && w(La, A, Ca, A.length), w(La, A, 0, na + 1)) : (0 !== na && w(Fa, A, na, A.length), w(Fa, A, 0, za + 1), Fa.push(ja), La.push(ja), w(La, A, Ca, na + 1));
                else {
                    Ca > za && (za += A.length);
                    ba = Number.MAX_VALUE;
                    if (za < Ca) return G;
                    for (Aa = Ca; Aa <= za; ++Aa) c(m(A, na - 1), m(A, na), m(A, Aa)) &&
                        h(m(A, na + 1), m(A, na), m(A, Aa)) && (Na = k(m(A, na), m(A, Aa)), Na < ba && q(A, na, Aa) && (ba = Na, Ma = Aa % A.length));
                    na < Ma ? (w(Fa, A, na, Ma + 1), 0 !== Ma && w(La, A, Ma, A.length), w(La, A, 0, na + 1)) : (0 !== na && w(Fa, A, na, A.length), w(Fa, A, 0, Ma + 1), w(La, A, Ma, na + 1))
                }
                Fa.length < La.length ? (H(Fa, G, J, M, R, U, V), H(La, G, J, M, R, U, V)) : (H(La, G, J, M, R, U, V), H(Fa, G, J, M, R, U, V));
                return G
            }
        G.push(A);
        return G
    }

    function K(A, G, J) {
        return Math.abs(A - G) <= (J || 0)
    }

    function C(A, G, J) {
        return K(A[0], G[0], J) && K(A[1], G[1], J)
    }
    self.polyDecomp = {
        decomp: function(A) {
            var G = y(A);
            return 0 <
                G.length ? B(A, G) : [A]
        },
        quickDecomp: H,
        isSimple: function(A) {
            var G;
            for (G = 0; G < A.length - 1; G++)
                for (var J = 0; J < G - 1; J++)
                    if (d(A[G], A[G + 1], A[J], A[J + 1])) return !1;
            for (G = 1; G < A.length - 2; G++)
                if (d(A[0], A[A.length - 1], A[G], A[G + 1])) return !1;
            return !0
        },
        removeCollinearPoints: function(A, G) {
            for (var J = 0, M = A.length - 1; 3 < A.length && 0 <= M; --M) g(m(A, M - 1), m(A, M), m(A, M + 1), G) && (A.splice(M % A.length, 1), J++);
            return J
        },
        removeDuplicatePoints: function(A, G) {
            for (var J = A.length - 1; 1 <= J; --J)
                for (var M = A[J], R = J - 1; 0 <= R; --R) C(M, A[R], G) && A.splice(J,
                    1)
        },
        makeCCW: function(A) {
            for (var G = 0, J = 1; J < A.length; ++J)
                if (A[J][1] < A[G][1] || A[J][1] === A[G][1] && A[J][0] > A[G][0]) G = J;
            if (b(m(A, G - 1), m(A, G), m(A, G + 1))) return !1;
            p(A);
            return !0
        }
    }
} {
    "use strict";
    let e = !1,
        d = !1,
        a = "dev";
    const b = self.C3 = class {
        constructor() {
            throw TypeError("static class can't be instantiated");
        }
        static SetReady() {
            e = !0
        }
        static IsReady() {
            return e
        }
        static SetAppStarted() {
            d = !0
        }
        static HasAppStarted() {
            return d
        }
        static SetBuildMode(c) {
            a = c
        }
        static GetBuildMode() {
            return a
        }
        static IsReleaseBuild() {
            return "final" === a
        }
    };
    b.isDebug = !1;
    b.isDebugDefend = !1;
    b.hardwareConcurrency = navigator.hardwareConcurrency || 2;
    self.C3X = {}
} {
    "use strict";
    const e = self.C3;
    e.QueryParser = class {
        constructor(d) {
            this._queryString = d;
            this._parameters = new Map;
            this._Parse()
        }
        _Parse() {
            var d = this._queryString;
            if (d.startsWith("?") || d.startsWith("#")) d = d.substr(1);
            d = d.split("&");
            for (const a of d) this._ParseParameter(a)
        }
        _ParseParameter(d) {
            if (d)
                if (d.includes("=")) {
                    var a = d.indexOf("="),
                        b = decodeURIComponent(d.substring(0, a));
                    d = decodeURIComponent(d.substring(a + 1));
                    this._parameters.set(b, d)
                } else this._parameters.set(d, null)
        }
        LogAll() {
            for (const d of this._parameters) console.log("[QueryParser] Parameter '" +
                d[0] + "' = " + (null === d[1] ? "null" : "'" + d[1] + "'"))
        }
        Has(d) {
            return this._parameters.has(d)
        }
        Get(d) {
            d = this._parameters.get(d);
            return "undefined" === typeof d ? null : d
        }
        ClearHash() {
            history.replaceState("", document.title, location.pathname + location.search)
        }
        Reparse(d) {
            this._queryString = d;
            this._parameters.clear();
            this._Parse()
        }
    };
    e.QueryString = new e.QueryParser(location.search);
    e.LocationHashString = new e.QueryParser(location.hash);
    "dev" !== e.QueryString.Get("mode") && e.SetBuildMode("final")
} {
    "use strict";
    const e = self.C3,
        d = navigator.userAgent;
    let a = {
        linux: /linux|openbsd|freebsd|netbsd/i.test(d),
        chromeOS: /CrOS/.test(d),
        windowsTizen: /trident|iemobile|msie|tizen/i.test(d),
        genericMS: /trident|iemobile|msie|edge\//i.test(d),
        opera: /OPR\//.test(d),
        blackberry: /bb10/i.test(d),
        edge: /edge\//i.test(d),
        trident: /trident/i.test(d),
        webkit: /webkit/i.test(d),
        safari: /safari\//i.test(d),
        chrome: /chrome\//i.test(d),
        chromium: /chromium\//i.test(d),
        crosswalk: /crosswalk|xwalk/i.test(d),
        nwjs: /nwjs/i.test(d),
        amazonwebapp: /amazonwebappplatform/i.test(d),
        webview: /wv\)/.test(d),
        android: /android/i.test(d),
        nokia: /nokiabrowser\/[0-9.]+/i.test(d)
    };
    var JSCompiler_object_inline_windows_0 = /windows\s+nt\s+\d+\.\d+/i.exec(d),
        JSCompiler_object_inline_OSX_1 = /mac\s+os\s+x\s+[0-9_]+/i.exec(d),
        JSCompiler_object_inline_android_2 = /android\s+[0-9.]+/i.exec(d),
        JSCompiler_object_inline_opera_3 = /OPR\/[0-9.]+/.exec(d),
        JSCompiler_object_inline_tizen_4 = /tizen\s+[0-9.]+/i.exec(d),
        JSCompiler_object_inline_iphone_5 = /iphone\s+os\s+[0-9_]+/i.exec(d),
        JSCompiler_object_inline_ipad_6 =
        /ipad[^)]*os\s+[0-9_]+/i.exec(d),
        JSCompiler_object_inline_winPhone_7 = /windows\s+phone\s+[0-9.]+/i.exec(d),
        JSCompiler_object_inline_winPhoneOS_8 = /windows\s+phone\s+os\s+[0-9.]+/i.exec(d),
        JSCompiler_object_inline_chrome_9 = /chrome\/[0-9.]+/i.exec(d),
        JSCompiler_object_inline_chromium_10 = /chromium\/[0-9.]+/i.exec(d),
        JSCompiler_object_inline_nwjs_11 = /nwjs\/[0-9.]+/i.exec(d),
        JSCompiler_object_inline_firefox_12 = /firefox\/[0-9.]+/i.exec(d),
        JSCompiler_object_inline_ie_13 = /msie\s+[0-9.]+/i.exec(d),
        JSCompiler_object_inline_edge_14 =
        /edge\/[0-9.]+/i.exec(d),
        JSCompiler_object_inline_edgeChromium_15 = /edg\/[0-9.]+/i.exec(d),
        JSCompiler_object_inline_silk_16 = /silk\/[0-9.]+/i.exec(d);
    let b = "(unknown)",
        c = "(unknown)",
        f = "(unknown)",
        h = "(unknown)",
        g = "(unknown)",
        k = "browser",
        m = !1,
        r = !1,
        w = new Map;

    function p(u, q, x) {
        !0 === q ? (x(), w.set(u, !0)) : q && q.length && (x(q[0]), w.set(u, !0))
    }
    p("isWindows", JSCompiler_object_inline_windows_0, u => {
        b = "Windows";
        if (u = u.split(" ")[2]) switch (u) {
            case "5.0":
                c = "2000";
                break;
            case "5.1":
                c = "XP";
                break;
            case "5.2":
                c = "XP";
                break;
            case "6.0":
                c = "Vista";
                break;
            case "6.1":
                c = "7";
                break;
            case "6.2":
                c = "8";
                break;
            case "6.3":
                c = "8.1";
                break;
            case "10.0":
                c = "10"
        }
    });
    p("isOSX", JSCompiler_object_inline_OSX_1, u => {
        b = "Mac OS X";
        (u = u.split(" ")[3]) && (c = u.replace("_", "."))
    });
    p("isLinux", a.linux, () => {
        b = "Linux"
    });
    p("isChromeOS", a.chromeOS, () => {
        b = "Chrome OS"
    });
    p("isAndroid", !a.windowsTizen && JSCompiler_object_inline_android_2, u => {
        b = "Android";
        (u = u.split(" ")[1]) && (c = u)
    });
    p("isTizen", JSCompiler_object_inline_tizen_4, u => {
        b = "Tizen";
        (u = u.split(" ")[1]) && (c =
            u)
    });
    p("isIPhone", !a.windowsTizen && JSCompiler_object_inline_iphone_5, u => {
        b = "iOS";
        (u = u.split(" ")[2]) && (c = u.replace("_", "."))
    });
    p("isIPad", !a.windowsTizen && JSCompiler_object_inline_ipad_6, u => {
        b = "iOS";
        (u = u.split(" ")[3]) && (c = u.replace("_", "."))
    });
    p("isWindowsPhone", JSCompiler_object_inline_winPhone_7, u => {
        b = "Windows Phone";
        (u = u.split(" ")[2]) && (c = u)
    });
    p("isWindowsPhoneOS", JSCompiler_object_inline_winPhoneOS_8, u => {
        b = "Windows Phone";
        (u = u.split(" ")[3]) && (c = u)
    });
    p("isBlackberry", a.blackberry, () => {
        b = "Blackberry";
        c = "10";
        f = "stock";
        g = "webkit"
    });
    p("isChrome", !a.edge && !a.opera && JSCompiler_object_inline_chrome_9, u => {
        f = "Chrome";
        g = "Chromium";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isOpera", JSCompiler_object_inline_opera_3, u => {
        f = "Opera";
        g = "Chromium";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isChromium", JSCompiler_object_inline_chromium_10, u => {
        g = f = "Chromium";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isFirefox", JSCompiler_object_inline_firefox_12, u => {
        f = "Firefox";
        g = "Gecko";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isInternetExplorer", JSCompiler_object_inline_ie_13,
        u => {
            f = "Internet Explorer";
            g = "Trident";
            (u = u.split(" ")[1]) && (h = u)
        });
    p("isTrident", "Internet Explorer" !== f && a.trident, () => {
        g = "Trident";
        var u = /rv:[0-9.]+/i.exec(d);
        u && u.length && (f = "Internet Explorer", (u = u[0].split(":")[1]) && (h = u))
    });
    p("isEdge", JSCompiler_object_inline_edge_14, u => {
        g = f = "Edge";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isEdgeChromium", JSCompiler_object_inline_edgeChromium_15, u => {
        f = "Edge";
        g = "Chromium";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isSafari", a.safari && !a.nokia && !a.chrome && !a.chromium && !a.genericIE &&
        !a.blackberry, () => {
            f = "Safari";
            g = "WebKit";
            var u = /version\/[0-9.]+/i.exec(d),
                q = /crios\/[0-9.]+/i.exec(d),
                x = /fxios\/[0-9.]+/i.exec(d);
            u && u.length && (u = u[0].split("/")[1]) && (h = u);
            q && q.length && (f = "Chrome for iOS", (q = q[0].split("/")[1]) && (h = q));
            x && x.length && (f = "Firefox for iOS", (x = x[0].split("/")[1]) && (h = x))
        });
    p("isSilk", JSCompiler_object_inline_silk_16, u => {
        f = "Silk";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isCrosswalk", a.crosswalk, () => k = "crosswalk");
    p("isCordova", self.device && (self.device.cordova || self.device.phonegap),
        () => k = "cordova");
    p("isNWJS", JSCompiler_object_inline_nwjs_11, u => {
        k = "nwjs";
        f = "NW.js";
        g = "Chromium";
        (u = u.split("/")[1]) && (h = u)
    });
    p("isAmazonWebApp", a.amazonwebapp, () => k = "webapp");
    p("isHomeScreenWebApp", "nwjs" !== k && "undefined" !== typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone), () => k = "webapp");
    p("isFalseSafari", "Safari" === f && ("Android" === b || "Tizen" === b || "Blackberry" === b), () => f = "stock");
    p("isAndroidWebview", "Chrome" === f && "browser" === k && a.webview,
        () => k = "webview");
    p("isFirefoxOS", "Firefox" === f && "(unknown)" === b, () => b = "Firefox OS");
    p("isAndroidFallback", "(unknown)" === b && !a.windowsTizen && a.android, () => b = "Android");
    p("isTridentFallback", "(unknown)" === b && a.trident, () => g = "Trident");
    p("isWebkitFallback", "(unknown)" === b && a.webkit, () => g = "WebKit");
    p("isDesktop", (() => "Windows" === b || "Mac OS X" === b || "Linux" === b || "Chrome OS" === b || "nwjs" === k)(), () => m = !0);
    r = "nwjs" === k;
    const t = "Mac OS X" === b && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints;
    t && (b = "iOS",
        c = h, r = m = !1);
    e.Platform = {
        OS: b,
        OSVersion: c,
        Browser: f,
        BrowserVersion: h,
        BrowserVersionNumber: parseFloat(h),
        BrowserEngine: g,
        Context: k,
        IsDesktop: m,
        IsMobile: !m,
        IsDesktopApp: r,
        IsChromeWebStore: !!(self.chrome && self.chrome.runtime && self.chrome.runtime.id),
        IsAppleOS: "Mac OS X" === b || "iOS" === b,
        IsIpadOS: t,
        IsLinux: "Linux" === b
    }
}
"use strict"; {
    const e = new Map,
        d = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAll,
        a = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAllKeys;

    function b(t) {
        return new Promise((u, q) => {
            t.onsuccess = () => u(t.result);
            t.onerror = () => q(t.error)
        })
    }

    function c(t) {
        return new Promise((u, q) => {
            t.oncomplete = () => u();
            t.onerror = () => q(t.error);
            t.onabort = () => q(t.error)
        })
    }

    function f(t, u) {
        return g(t, u)
    }

    function h(t, u) {
        return g(t, u, !0)
    }
    async function g(t, u, q = !1,
        x = !0) {
        const y = await k(t);
        try {
            const B = y.transaction(["keyvaluepairs"], q ? "readwrite" : "readonly");
            return u(B)
        } catch (B) {
            if (x && "InvalidStateError" === B.name) return e.delete(t), g(t, u, q, !1);
            throw B;
        }
    }

    function k(t) {
        r(t);
        let u = e.get(t);
        u instanceof Promise || (u = m(t), e.set(t, u), u.catch(q => e.delete(t)));
        return u
    }
    async function m(t) {
        r(t);
        const u = indexedDB.open(t, 2);
        u.addEventListener("upgradeneeded", q => {
            try {
                q.target.result.createObjectStore("keyvaluepairs")
            } catch (x) {
                console.error(`Failed to create objectstore for database ${t}`,
                    x)
            }
        });
        return b(u)
    }

    function r(t) {
        if ("string" !== typeof t) throw new TypeError("expected string");
    }

    function w(t, u) {
        const q = t.objectStore("keyvaluepairs").openCursor();
        return new Promise(x => {
            const y = [];
            q.onsuccess = B => {
                if (B = B.target.result) {
                    switch (u) {
                        case "entries":
                            y.push([B.key, B.value]);
                            break;
                        case "keys":
                            y.push(B.key);
                            break;
                        case "values":
                            y.push(B.value)
                    }
                    B.continue()
                } else x(y)
            }
        })
    }
    class p {
        constructor(t) {
            r(t);
            this.name = t
        }
        async ready() {
            await k(this.name)
        }
        set(t, u) {
            r(t);
            return h(this.name, async q => {
                var x = q.objectStore("keyvaluepairs").put(u,
                    t);
                x = b(x);
                q = c(q);
                await Promise.all([q, x])
            })
        }
        get(t) {
            r(t);
            return f(this.name, async u => {
                var q = u.objectStore("keyvaluepairs").get(t);
                q = b(q);
                u = c(u);
                [, u] = await Promise.all([u, q]);
                return u
            })
        }
        delete(t) {
            r(t);
            return h(this.name, async u => {
                var q = u.objectStore("keyvaluepairs").delete(t);
                q = b(q);
                u = c(u);
                await Promise.all([u, q])
            })
        }
        clear() {
            return h(this.name, async t => {
                var u = t.objectStore("keyvaluepairs").clear();
                u = b(u);
                t = c(t);
                await Promise.all([t, u])
            })
        }
        keys() {
            return f(this.name, async t => {
                if (a) {
                    var u = t.objectStore("keyvaluepairs").getAllKeys();
                    u = b(u)
                } else u = w(t, "keys");
                t = c(t);
                [, t] = await Promise.all([t, u]);
                return t
            })
        }
        values() {
            return f(this.name, async t => {
                if (d) {
                    var u = t.objectStore("keyvaluepairs").getAll();
                    u = b(u)
                } else u = w(t, "values");
                t = c(t);
                [, t] = await Promise.all([t, u]);
                return t
            })
        }
        entries() {
            return f(this.name, async t => {
                var u = w(t, "entries");
                t = c(t);
                [, u] = await Promise.all([t, u]);
                return u
            })
        }
    }
    self.KVStorageContainer = p
}
"use strict"; {
    const e = self.KVStorageContainer,
        d = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i],
        a = new WeakMap;
    let b = !1;
    "undefined" === typeof indexedDB && (b = !0, console.warn("Unable to use local storage because indexedDB is not defined"));

    function c(k) {
        throw Error(`"${k}" is not implemented`);
    }

    function f(k) {
        if ("function" === typeof k) throw Error("localforage callback API is not implemented; please use the promise API instead");
    }

    function h(k) {
        return "object" === typeof k ? new Promise(m => {
            const {
                port1: r,
                port2: w
            } = new MessageChannel;
            w.onmessage = p => m(p.data);
            r.postMessage(k)
        }) : Promise.resolve(k)
    }
    class g {
        constructor(k) {
            this._inst = k;
            a.set(this, new Map)
        }
        _MaybeSwitchToMemoryFallback(k) {
            if (!b)
                for (const m of d)
                    if (k && m.test(k.message)) {
                        console.error("Unable to use local storage, reverting to in-memory store: ",
                            k, k.message);
                        b = !0;
                        break
                    }
        }
        async _getItemFallback(k) {
            k = a.get(this).get(k);
            k = await h(k);
            return "undefined" === typeof k ? null : k
        }
        async _setItemFallback(k, m) {
            m = await h(m);
            a.get(this).set(k, m)
        }
        _removeItemFallback(k) {
            a.get(this).delete(k)
        }
        _clearFallback() {
            a.get(this).clear()
        }
        _keysFallback() {
            return Array.from(a.get(this).keys())
        }
        IsUsingFallback() {
            return b
        }
        async getItem(k, m) {
            f(m);
            if (b) return await this._getItemFallback(k);
            let r;
            try {
                r = await this._inst.get(k)
            } catch (w) {
                this._MaybeSwitchToMemoryFallback(w);
                if (b) return await this._getItemFallback(k);
                console.error(`Error reading '${k}' from storage, returning null: `, w);
                return null
            }
            return "undefined" === typeof r ? null : r
        }
        async setItem(k, m, r) {
            f(r);
            "undefined" === typeof m && (m = null);
            if (b) await this._setItemFallback(k, m);
            else try {
                await this._inst.set(k, m)
            } catch (w) {
                if (this._MaybeSwitchToMemoryFallback(w), b) await this._setItemFallback(k, m);
                else throw w;
            }
        }
        async removeItem(k, m) {
            f(m);
            if (b) this._removeItemFallback(k);
            else try {
                await this._inst.delete(k)
            } catch (r) {
                this._MaybeSwitchToMemoryFallback(r), b ? this._removeItemFallback(k) :
                    console.error(`Error removing '${k}' from storage: `, r)
            }
        }
        async clear(k) {
            f(k);
            if (b) this._clearFallback();
            else try {
                await this._inst.clear()
            } catch (m) {
                this._MaybeSwitchToMemoryFallback(m), b ? this._clearFallback() : console.error("Error clearing storage: ", m)
            }
        }
        async keys(k) {
            f(k);
            if (b) return this._keysFallback();
            k = [];
            try {
                k = await this._inst.keys()
            } catch (m) {
                this._MaybeSwitchToMemoryFallback(m);
                if (b) return this._keysFallback();
                console.error("Error getting storage keys: ", m)
            }
            return k
        }
        ready(k) {
            f(k);
            return b ? Promise.resolve(!0) :
                this._inst.ready()
        }
        createInstance(k) {
            if ("object" !== typeof k) throw new TypeError("invalid options object");
            k = k.name;
            if ("string" !== typeof k) throw new TypeError("invalid store name");
            k = new e(k);
            return new g(k)
        }
        length(k) {
            c("localforage.length()")
        }
        key(k, m) {
            c("localforage.key()")
        }
        iterate(k, m) {
            c("localforage.iterate()")
        }
        setDriver(k) {
            c("localforage.setDriver()")
        }
        config(k) {
            c("localforage.config()")
        }
        defineDriver(k) {
            c("localforage.defineDriver()")
        }
        driver() {
            c("localforage.driver()")
        }
        supports(k) {
            c("localforage.supports()")
        }
        dropInstance() {
            c("localforage.dropInstance()")
        }
        disableMemoryMode() {
            b = !1
        }
    }
    self.localforage = new g(new e("localforage"))
} {
    "use strict";
    const e = self.C3;
    e.Supports = {};
    e.Supports.WebAnimations = (() => {
        try {
            if ("Safari" === e.Platform.Browser || "undefined" === typeof document) return !1;
            const d = document.createElement("div");
            return "undefined" === typeof d.animate ? !1 : "undefined" !== typeof d.animate([{
                opacity: "0"
            }, {
                opacity: "1"
            }], 1E3).reverse
        } catch (d) {
            return !1
        }
    })();
    e.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
    e.Supports.RequestIdleCallback = !!self.requestIdleCallback;
    e.Supports.ImageBitmap = !!self.createImageBitmap;
    e.Supports.ImageBitmapOptions = !1;
    if (e.Supports.ImageBitmap) try {
        self.createImageBitmap(new ImageData(32, 32), {
            premultiplyAlpha: "none"
        }).then(d => {
            e.Supports.ImageBitmapOptions = !0
        }).catch(d => {
            e.Supports.ImageBitmapOptions = !1
        })
    } catch (d) {
        e.Supports.ImageBitmapOptions = !1
    }
    e.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText || "Firefox" === e.Platform.Browser);
    e.Supports.PermissionsQuery = !(!navigator.permissions || !navigator.permissions.query);
    e.Supports.Proxies = "undefined" !== typeof Proxy;
    e.Supports.DownloadAttribute =
        (() => "undefined" === typeof document ? !1 : "undefined" !== typeof document.createElement("a").download)();
    e.Supports.CanvasToBlob = (() => "undefined" !== typeof HTMLCanvasElement && HTMLCanvasElement.prototype.toBlob)();
    e.Supports.Fetch = "function" === typeof fetch;
    e.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== e.Platform.Browser && navigator.storage && navigator.storage.persist);
    e.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate);
    e.Supports.Fullscreen =
        (() => {
            if ("undefined" === typeof document || "iOS" === e.Platform.OS) return !1;
            const d = document.documentElement;
            return !!(d.requestFullscreen || d.msRequestFullscreen || d.mozRequestFullScreen || d.webkitRequestFullscreen)
        })();
    e.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
    e.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
    e.Supports.NavigatorFontsQuery = !(!navigator.fonts || !navigator.fonts.query)
} {
    "use strict";
    const e = self.C3;
    if (!String.prototype.trimStart) {
        const d = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function() {
            return this.replace(d, "")
        }
    }
    if (!String.prototype.trimEnd) {
        const d = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function() {
            return this.replace(d,
                "")
        }
    }
    String.prototype.replaceAll || (String.prototype.replaceAll = function(d, a) {
        return this.replace(new RegExp(e.EscapeRegex(d), "g"), a)
    });
    Array.prototype.values || (Array.prototype.values = function*() {
        for (const d of this) yield d
    });
    if (!Array.prototype.flat) {
        function d(a, b) {
            return a.reduce((c, f) => {
                0 < b && Array.isArray(f) ? Array.prototype.push.apply(c, d(f, b - 1)) : c.push(f);
                return c
            }, [])
        }
        Array.prototype.flat = function(a = 1) {
            return d(this, a)
        }
    }
    Array.prototype.at || (Array.prototype.at = function(d) {
        d = Math.trunc(d) || 0;
        0 >
            d && (d += this.length);
        if (!(0 > d || d >= this.length)) return this[d]
    });
    String.prototype.at || (String.prototype.at = function(d) {
        d = Math.trunc(d) || 0;
        0 > d && (d += this.length);
        if (!(0 > d || d >= this.length)) return this[d]
    });
    RegExp.escape || (RegExp.escape = function(d) {
        return String(d).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
    });
    navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
        return new Promise((d, a) => navigator.webkitTemporaryStorage.queryUsageAndQuota((b,
            c) => d({
            usage: b,
            quota: c
        }), a))
    });
    "undefined" === typeof self.isSecureContext && (self.isSecureContext = "https:" === location.protocol);
    "undefined" === typeof self.globalThis && (self.globalThis = self)
} {
    "use strict";
    const e = self.C3;

    function d(a) {
        let b = e.GetCallStack();
        console.error("Assertion failure: " + a + "\n\nStack trace:\n" + b)
    }
    self.assert = function(a, b) {
        a || d(b)
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X;
    e.IsNumber = function(b) {
        return "number" === typeof b
    };
    e.IsFiniteNumber = function(b) {
        return e.IsNumber(b) && isFinite(b)
    };
    e.RequireNumber = function(b) {
        if (!e.IsNumber(b)) throw new TypeError("expected number");
    };
    e.RequireOptionalNumber = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.RequireNumberInRange = function(b, c, f) {
        if (!e.IsNumber(b) || isNaN(b) || c > b || f < b) throw new RangeError("number outside of range");
    };
    e.RequireAllNumber = function(...b) {
        for (let c of b);
    };
    e.RequireFiniteNumber =
        function(b) {
            if (!e.IsFiniteNumber(b)) throw new TypeError("expected finite number");
        };
    e.RequireOptionalFiniteNumber = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.RequireAllFiniteNumber = function(...b) {
        for (let c of b);
    };
    e.IsString = function(b) {
        return "string" === typeof b
    };
    e.RequireString = function(b) {
        if (!e.IsString(b)) throw new TypeError("expected string");
    };
    e.RequireOptionalString = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.RequireAllString = function(...b) {
        for (let c of b);
    };
    e.IsSimpleObject = function(b) {
        return "object" !==
            typeof b || null === b ? !1 : (b = Object.getPrototypeOf(b)) ? b.constructor === Object : null === b
    };
    e.RequireSimpleObject = function(b) {
        if (!e.IsSimpleObject(b)) throw new TypeError("expected simple object");
    };
    e.RequireOptionalSimpleObject = function(b) {
        if (!e.IsNullOrUndefined(b) && !e.IsSimpleObject(b)) throw new TypeError("expected simple object");
    };
    e.IsObject = function(b) {
        return "object" === typeof b && null !== b && !Array.isArray(b)
    };
    e.RequireObject = function(b) {
        if (!e.IsObject(b)) throw new TypeError("expected object");
    };
    e.RequireOptionalObject =
        function(b) {
            e.IsNullOrUndefined(b)
        };
    e.RequireAllObject = function(...b) {
        for (let c of b);
    };
    e.IsFileLike = function(b) {
        return e.IsInstanceOf(b, Blob) && "string" === typeof b.name
    };
    e.RequireFileLike = function(b) {
        if (!e.IsFileLike(b)) throw new TypeError("expected file");
    };
    e.RequireOptionalFileLike = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.IsArray = function(b) {
        return Array.isArray(b)
    };
    e.RequireArray = function(b) {
        if (!e.IsArray(b)) throw new TypeError("expected array");
    };
    e.RequireOptionalArray = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.RequireAllArray = function(...b) {
        for (let c of b);
    };
    e.Is2DArray = function(b) {
        return e.IsArray(b) ? b.length ? e.IsArray(b[0]) ? !0 : !1 : !0 : !1
    };
    e.Require2DArray = function(b) {
        if (!e.Is2DArray(b)) throw new TypeError("expected 2d array");
        for (let c of b)
            if (!e.IsArray(c)) throw new TypeError("expected 2d array");
    };
    e.RequireOptional2DArray = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.IsFunction = function(b) {
        return "function" === typeof b
    };
    e.RequireFunction = function(b, c) {
        if (!e.IsFunction(b)) throw new TypeError("expected function");
        if (!e.IsNullOrUndefined(c) && b !== c) throw new TypeError("expected same function reference");
    };
    e.RequireOptionalFunction = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.RequireAllFunction = function(...b) {
        for (let c of b);
    };
    e.RequireAnyFunction = function(b, ...c) {
        if (!e.IsFunction(b)) throw new TypeError("expected function");
        if (!c.length) throw Error("missing comparison functions");
        for (let f of c)
            if (!e.IsNullOrUndefined(f) && b === f) return;
        throw new TypeError("expected same function reference");
    };
    e.RequireOptionalAllFunction =
        function(...b) {
            if (!e.IsNullOrUndefined(b))
                for (let c of b);
        };
    e.IsInstanceOf = function(b, c) {
        return b instanceof c
    };
    e.IsInstanceOfAny = function(b, ...c) {
        for (let f of c)
            if (e.IsInstanceOf(b, f)) return !0;
        return !1
    };
    e.RequireInstanceOf = function(b, c) {
        if (!e.IsInstanceOf(b, c)) throw new TypeError("unexpected type");
    };
    e.RequireOptionalInstanceOf = function(b, c) {
        e.IsNullOrUndefined(b)
    };
    e.RequireAllInstanceOf = function(b, ...c) {
        for (let f of c);
    };
    e.RequireAnyInstanceOf = function(b, ...c) {
        if (!e.IsInstanceOfAny(b, ...c)) throw new TypeError("unexpected type");
    };
    e.RequireAnyOptionalInstanceOf = function(b, ...c) {
        if (!e.IsNullOrUndefined(b) && !e.IsInstanceOfAny(b, ...c)) throw new TypeError("unexpected type");
    };
    e.IsArrayOf = function(b, c) {
        for (let f of b)
            if (!e.IsInstanceOf(f, c)) return !1;
        return !0
    };
    e.IsArrayOfFiniteNumbers = function(b) {
        for (let c of b)
            if (!e.IsFiniteNumber(c)) return !1;
        return !0
    };
    e.RequireArrayOf = function(b, c) {
        for (let f of b);
    };
    e.RequireOptionalArrayOf = function(b, c) {
        if (!e.IsNullOrUndefined(b))
            for (let f of b);
    };
    e.RequireArrayOfAny = function(b, ...c) {
        for (let f of b);
    };
    e.RequireOptionalArrayOfAny = function(b, ...c) {
        if (!e.IsNullOrUndefined(b))
            for (let f of b);
    };
    e.IsDOMNode = function(b, c) {
        return e.IsNullOrUndefined(b) || !e.IsString(b.nodeName) ? !1 : !c || e.equalsNoCase(b.nodeName, c)
    };
    e.RequireDOMNode = function(b, c) {
        if (e.IsNullOrUndefined(b) || !e.IsString(b.nodeName)) throw new TypeError("expected DOM node");
        if (c && !e.equalsNoCase(b.nodeName, c)) throw new TypeError(`expected DOM '${c}' node`);
    };
    e.RequireOptionalDOMNode = function(b, c) {
        e.IsNullOrUndefined(b)
    };
    e.IsHTMLElement = function(b,
        c) {
        return e.IsNullOrUndefined(b) || !e.IsString(b.tagName) ? !1 : !c || e.equalsNoCase(b.tagName, c)
    };
    e.RequireHTMLElement = function(b, c) {
        if (e.IsNullOrUndefined(b) || !e.IsString(b.tagName)) throw new TypeError("expected HTML element");
        if (c && !e.equalsNoCase(b.tagName, c)) throw new TypeError(`expected HTML '${c}' element`);
    };
    e.RequireOptionalHTMLElement = function(b, c) {
        e.IsNullOrUndefined(b)
    };
    e.IsDrawable = function(b) {
        return e.IsHTMLElement(b, "img") || e.IsHTMLElement(b, "canvas") || e.IsHTMLElement(b, "video") || "undefined" !==
            typeof OffscreenCanvas && b instanceof OffscreenCanvas || "undefined" !== typeof ImageBitmap && b instanceof ImageBitmap
    };
    e.RequireDrawable = function(b) {
        if (!e.IsDrawable(b)) throw new TypeError("expected drawable");
    };
    e.RequireOptionalDrawable = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.IsDrawableOrImageData = function(b) {
        return b instanceof ImageData ? !0 : e.IsDrawable(b)
    };
    e.RequireDrawableOrImageData = function(b) {
        if (!e.IsDrawableOrImageData(b)) throw new TypeError("expected drawable or image data");
    };
    e.RequireOptionalDrawableOrImageData =
        function(b) {
            if (!e.IsNullOrUndefined(b) && !e.IsDrawableOrImageData(b)) throw new TypeError("expected drawable or image data");
        };
    e.IsStringLike = function(b) {
        return "string" === typeof b || b instanceof e.HtmlString || b instanceof e.BBString
    };
    e.RequireStringLike = function(b) {
        if (!e.IsStringLike(b)) throw new TypeError("expected string-like");
    };
    e.RequireOptionalStringLike = function(b) {
        e.IsNullOrUndefined(b)
    };
    e.RequireAllStringLike = function(...b) {
        for (let c of b);
    };
    e.RequireOverride = function() {
        throw Error("must be overridden");
    };
    e.NotYetImplemented = function() {
        throw Error("not yet implemented");
    };
    e.IsDefined = function(b, ...c) {
        if ("undefined" === typeof b) return !1;
        for (let f of c) {
            if ("undefined" === typeof b[f]) return !1;
            b = b[f]
        }
        return !0
    };
    e.IsNullOrUndefined = function(b) {
        return "undefined" === typeof b || null === b
    };
    e.AreArrayElementsOfSameType = function(b) {
        let c = b[0].constructor;
        for (let f of b)
            if (f.constructor !== c) return !1;
        return c
    };
    e.AreArrayElementsOfType = function(b, c) {
        for (let f of b)
            if (!(f instanceof c)) return !1;
        return !0
    };
    const a = Object.getPrototypeOf(Uint8Array);
    e.IsTypedArray = function(b) {
        return e.IsInstanceOf(b, a)
    };
    e.RequireTypedArray = function(b) {};
    e.WeakRequireTypedArray = function(b) {
        e.WeakRequireInstanceOf(b, a)
    };
    e.WeakRequireAnyInstanceOf = function(b, ...c) {
        if (!e.WeakIsAnyInstanceOf(b, ...c)) throw new TypeError("unexpected type");
    };
    e.WeakIsAnyInstanceOf = function(b, ...c) {
        for (const f of c)
            if (e.WeakIsInstanceOf(b, f)) return !0;
        return !1
    };
    e.WeakRequireInstanceOf = function(b, c) {
        if (!e.WeakIsInstanceOf(b, c)) throw new TypeError("unexpected type");
    };
    e.WeakIsInstanceOf =
        function(b, c) {
            for (; b = Object.getPrototypeOf(b);)
                if (b.constructor.name === c.name) return !0;
            return !1
        };
    d.RequireNumber = e.RequireNumber;
    d.RequireOptionalNumber = e.RequireOptionalNumber;
    d.RequireFiniteNumber = e.RequireFiniteNumber;
    d.RequireOptionalFiniteNumber = e.RequireOptionalFiniteNumber;
    d.RequireString = e.RequireString;
    d.RequireOptionalString = e.RequireOptionalString;
    d.RequireObject = e.RequireObject;
    d.RequireOptionalObject = e.RequireOptionalObject;
    d.RequireArray = e.RequireArray;
    d.RequireOptionalArray = e.RequireOptionalArray;
    d.RequireFunction = e.RequireFunction;
    d.RequireOptionalFunction = e.RequireOptionalFunction;
    d.RequireInstanceOf = e.RequireInstanceOf;
    d.RequireOptionalInstanceOf = e.RequireOptionalInstanceOf;
    d.IsNullOrUndefined = e.IsNullOrUndefined
} {
    "use strict";
    const e = self.C3,
        d = new Map;
    e.RafLog = function(u, ...q) {
        d.has(u) || d.set(u, -1); - 1 === d.get(u) && d.set(u, requestAnimationFrame(() => {
            console.log(`%c${u}`, "font-weight: bold", ...q);
            d.set(u, -1)
        }))
    };
    e.GetCallStack = function() {
        return Error().stack
    };
    e.Debugger = function() {
        debugger
    };
    e.cast = function(u, q) {
        return u && u instanceof q ? u : null
    };
    e.getName = function(u) {
        return "undefined" === typeof u ? "undefined" : null === u ? "null" : "boolean" === typeof u ? "<boolean>" : e.IsNumber(u) ? "<number>" : e.IsString(u) ? "<string>" : e.IsArray(u) ?
            "<array>" : "symbol" === typeof u ? "<" + u.toString() + ">" : e.IsFunction(u) ? u.name && "Function" !== u.name ? u.name : "<anonymous function>" : "object" === typeof u ? u.constructor && u.constructor.name && "Object" !== u.constructor.name ? u.constructor.name : "<anonymous object>" : "<unknown>"
    };
    e.getType = function(u) {
        return null === u ? "null" : Array.isArray(u) ? "array" : typeof u
    };
    e.range = function*(u, q) {
        if (!isFinite(Math.abs(u - q))) throw Error("Invalid parameters");
        if (u > q)
            for (--u; u >= q; u--) yield u;
        else
            for (; u < q; u++) yield u
    };

    function a(u, q) {
        u =
            e.getType(u);
        q = e.getType(q);
        return "null" === u || "null" === q ? !0 : "undefined" === u || "undefined" === q ? !1 : u === q
    }
    let b = new Map,
        c = new Map,
        f = new WeakMap,
        h = new WeakMap;
    e.DefendHandler = {};
    const g = new Set(["then", "splice"]);

    function k(u) {
        console.warn("[Defence] " + u + " @", e.GetCallStack())
    }
    e.DefendHandler.get = function(u, q) {
        q in u || "symbol" === typeof q || g.has(q) || k(`Accessed missing property '${q}' from defended object '${e.getName(u)}', returning undefined`);
        h.has(u) && "symbol" !== typeof q && !g.has(q) && k(`Accessed property '${q}' on a released object '${e.getName(u)}'\nObject was originally released at: ${h.get(u)})\nCall stack at access: `);
        return u[q]
    };
    e.DefendHandler.set = function(u, q, x) {
        q in u || b.has(u) || k(`Set non-existent property '${q}' to '${x}' on defended object '${e.getName(u)}'`);
        a(u[q], x) || b.has(u) || k(`Set '${e.getType(u[q])}' property '${q}' to type '${e.getType(x)}' on defended object '${e.getName(u)}'`);
        h.has(u) && k(`Set property '${q}' on a released object '${e.getName(u)}'\nObject was originally released at: ${h.get(u)})\nCall stack at access: `);
        u[q] = x;
        return !0
    };
    e.DefendHandler.deleteProperty = function(u, q) {
        throw new ReferenceError(`Cannot delete property '${q}' from defended object '${e.getName(u)}'`);
    };
    e.DefendHandler.defineProperty = function(u, q, x) {
        throw new ReferenceError(`Cannot define property '${q}' on defended object '${e.getName(u)}'`);
    };
    e.DefendHandler.enumerate = function(u) {
        throw new ReferenceError(`Cannot enumerate defended object '${e.getName(u)}'`);
    };
    let m = -1;

    function r() {
        m = -1;
        if (0 < b.size || 0 < c.size) {
            let u = [...new Set([...b.keys()].map(q => e.getName(q)))].join();
            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${u}`);
            b.clear();
            c.clear()
        }
    }
    e.DefendedBase = class {
        constructor() {
            if (e.isDebugDefend && e.Supports.Proxies) {
                var u = new.target;
                u = Object.create(u.prototype);
                var q = new Proxy(u, e.DefendHandler);
                b.set(u, q);
                c.set(q, u);
                f.set(q, u); - 1 === m && (m = requestAnimationFrame(r));
                return q
            }
        }
    };
    e.debugDefend = function(u) {
        if (e.isDebugDefend && e.Supports.Proxies && u instanceof e.DefendedBase) {
            if (!c.has(u)) return u;
            let q = c.get(u);
            c.delete(u);
            b.delete(q);
            return u
        }
        return e.isDebug ? Object.seal(u) : u
    };
    e.New = function(u, ...q) {
        let x;
        try {
            x = new u(...q)
        } catch (y) {
            throw c.clear(),
                b.clear(), y;
        }
        e.isDebugDefend && t(u, x);
        return e.debugDefend(x)
    };
    e.Release = function(u) {
        (u = f.get(u)) && h.set(u, e.GetCallStack())
    };
    e.WasReleased = function(u) {
        return (u = f.get(u)) ? !!h.get(u) : !1
    };
    let w = new Map;

    function p(u) {
        let q = new Set;
        for (let x in u) q.add(x);
        return q
    }

    function t(u, q) {
        q = p(q);
        let x = w.get(u);
        if (x) {
            let y = [];
            for (let B of x.values()) q.has(B) ? q.delete(B) : y.push(B);
            e.appendArray(y, [...q]);
            y.length && console.warn(`[Defence] '${e.getName(u)}' constructor creates inconsistent properties: ${y.join(", ")}`)
        } else w.set(u,
            q)
    }
    e.PerfMark = class {
        constructor(u) {
            this._name = "";
            u && this.start(u)
        }
        start(u) {
            this._name = u;
            performance.mark(this._name + "-Start")
        }
        end() {
            performance.mark(this._name + "-End");
            performance.measure(this._name, this._name + "-Start", this._name + "-End")
        }
        next(u) {
            this.end();
            this._name = u;
            performance.mark(this._name + "-Start")
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = 2 * Math.PI,
        a = Math.PI / 180,
        b = 180 / Math.PI;
    e.wrap = function(h, g, k) {
        h = Math.floor(h);
        g = Math.floor(g);
        k = Math.floor(k);
        return h < g ? (h = k - (g - h) % (k - g), h === k ? 0 : h) : g + (h - g) % (k - g)
    };
    e.mapToRange = function(h, g, k, m, r) {
        return (h - g) * (r - m) / (k - g) + m
    };
    e.normalize = function(h, g, k) {
        return (h - g) / (k - g)
    };
    e.clamp = function(h, g, k) {
        return h < g ? g : h > k ? k : h
    };
    e.clampAngle = function(h) {
        h %= d;
        0 > h && (h += d);
        return h
    };
    e.toRadians = function(h) {
        return h * a
    };
    e.toDegrees = function(h) {
        return h * b
    };
    e.distanceTo = function(h, g, k, m) {
        return Math.hypot(k -
            h, m - g)
    };
    e.distanceSquared = function(h, g, k, m) {
        h = k - h;
        g = m - g;
        return h * h + g * g
    };
    e.angleTo = function(h, g, k, m) {
        return Math.atan2(m - g, k - h)
    };
    e.angleDiff = function(h, g) {
        if (h === g) return 0;
        h = Math.sin(h) * Math.sin(g) + Math.cos(h) * Math.cos(g);
        return 1 <= h ? 0 : -1 >= h ? Math.PI : Math.acos(h)
    };
    e.angleRotate = function(h, g, k) {
        let m = Math.sin(h),
            r = Math.cos(h),
            w = Math.sin(g),
            p = Math.cos(g);
        return Math.acos(m * w + r * p) > k ? 0 < r * w - m * p ? e.clampAngle(h + k) : e.clampAngle(h - k) : e.clampAngle(g)
    };
    e.angleClockwise = function(h, g) {
        return 0 >= Math.cos(h) * Math.sin(g) -
            Math.sin(h) * Math.cos(g)
    };
    e.angleLerp = function(h, g, k, m = 0) {
        let r = e.angleDiff(h, g);
        m *= d;
        return e.angleClockwise(g, h) ? e.clampAngle(h + (r + m) * k) : e.clampAngle(h - (r + m) * k)
    };
    e.angleLerpClockwise = function(h, g, k, m = 0) {
        const r = e.angleDiff(h, g);
        m *= d;
        return e.angleClockwise(g, h) ? e.clampAngle(h + (r + m) * k) : e.clampAngle((d - r + m) * k)
    };
    e.angleLerpAntiClockwise = function(h, g, k, m = 0) {
        const r = e.angleDiff(h, g);
        m *= d;
        return e.angleClockwise(g, h) ? e.clampAngle((-d + r - m) * k) : e.clampAngle(h - (r + m) * k)
    };
    e.lerp = function(h, g, k) {
        return h + k * (g -
            h)
    };
    e.unlerp = function(h, g, k) {
        return h === g ? 0 : (k - h) / (g - h)
    };
    e.relerp = function(h, g, k, m, r) {
        return e.lerp(m, r, e.unlerp(h, g, k))
    };
    e.qarp = function(h, g, k, m) {
        return e.lerp(e.lerp(h, g, m), e.lerp(g, k, m), m)
    };
    e.cubic = function(h, g, k, m, r) {
        return e.lerp(e.qarp(h, g, k, r), e.qarp(g, k, m, r), r)
    };
    e.cosp = function(h, g, k) {
        return (h + g + (h - g) * Math.cos(k * Math.PI)) / 2
    };
    e.isPOT = function(h) {
        return 0 < h && 0 === (h - 1 & h)
    };
    e.nextHighestPowerOfTwo = function(h) {
        --h;
        for (let g = 1; 32 > g; g <<= 1) h |= h >> g;
        return h + 1
    };
    e.roundToNearestFraction = function(h, g) {
        return Math.round(h *
            g) / g
    };
    e.floorToNearestFraction = function(h, g) {
        return Math.floor(h * g) / g
    };
    e.round6dp = function(h) {
        return Math.round(1E6 * h) / 1E6
    };
    e.toFixed = function(h, g) {
        h = h.toFixed(g);
        for (g = h.length - 1; 0 <= g && "0" === h.charAt(g); --g);
        0 <= g && "." === h.charAt(g) && --g;
        return 0 > g ? h : h.substr(0, g + 1)
    };
    e.PackRGB = function(h, g, k) {
        return e.clamp(h, 0, 255) | e.clamp(g, 0, 255) << 8 | e.clamp(k, 0, 255) << 16
    };
    e.PackRGBAEx = function(h, g, k, m) {
        h = e.clamp(Math.floor(1024 * h), -8192, 8191);
        g = e.clamp(Math.floor(1024 * g), -8192, 8191);
        k = e.clamp(Math.floor(1024 * k), -8192, 8191);
        m = e.clamp(Math.floor(1023 * m), 0, 1023);
        0 > h && (h += 16384);
        0 > g && (g += 16384);
        0 > k && (k += 16384);
        return -(274877906944 * h + 16777216 * g + 1024 * k + m)
    };
    e.PackRGBEx = function(h, g, k) {
        return e.PackRGBAEx(h, g, k, 1)
    };

    function c(h) {
        return 0 === h && 0 > 1 / h
    }
    e.GetRValue = function(h) {
        if (0 <= h) return (h & 255) / 255;
        h = Math.floor(-h / 274877906944);
        8191 < h && (h -= 16384);
        return h / 1024
    };
    e.GetGValue = function(h) {
        if (0 <= h) return ((h & 65280) >> 8) / 255;
        h = Math.floor(-h % 274877906944 / 16777216);
        8191 < h && (h -= 16384);
        return h / 1024
    };
    e.GetBValue = function(h) {
        if (0 <=
            h) return ((h & 16711680) >> 16) / 255;
        h = Math.floor(-h % 16777216 / 1024);
        8191 < h && (h -= 16384);
        return h / 1024
    };
    e.GetAValue = function(h) {
        return c(h) ? 0 : 0 <= h ? 1 : Math.floor(-h % 1024) / 1023
    };
    e.greatestCommonDivisor = function(h, g) {
        h = Math.floor(h);
        for (g = Math.floor(g); 0 !== g;) {
            let k = g;
            g = h % g;
            h = k
        }
        return h
    };
    const f = [
        [3, 2],
        [4, 3],
        [5, 4],
        [5, 3],
        [6, 5],
        [14, 9],
        [16, 9],
        [16, 10],
        [21, 9]
    ];
    e.getAspectRatio = function(h, g) {
        h = Math.floor(h);
        g = Math.floor(g);
        if (h === g) return [1, 1];
        for (var k of f) {
            let m = h / k[0] * k[1];
            if (1 > Math.abs(g - m)) return k.slice(0);
            m = h / k[1] * k[0];
            if (1 > Math.abs(g - m)) return [k[1], k[0]]
        }
        k = e.greatestCommonDivisor(h, g);
        return [h / k, g / k]
    };
    e.segmentsIntersect = function(h, g, k, m, r, w, p, t) {
        var u = Math.min(h, k),
            q = Math.max(r, p);
        if (Math.max(h, k) < Math.min(r, p) || u > q) return !1;
        u = Math.min(g, m);
        q = Math.max(w, t);
        if (Math.max(g, m) < Math.min(w, t) || u > q) return !1;
        u = r - h + p - k;
        q = w - g + t - m;
        h = k - h;
        g = m - g;
        r = p - r;
        w = t - w;
        t = Math.abs(g * r - w * h);
        return Math.abs(r * q - w * u) > t ? !1 : Math.abs(h * q - g * u) <= t
    };
    e.segmentsIntersectPreCalc = function(h, g, k, m, r, w, p, t, u, q, x, y) {
        const B = Math.max(u, x);
        if (w < Math.min(u, x) || r > B) return !1;
        r = Math.max(q, y);
        if (t < Math.min(q, y) || p > r) return !1;
        p = u - h + x - k;
        t = q - g + y - m;
        h = k - h;
        g = m - g;
        u = x - u;
        q = y - q;
        y = Math.abs(g * u - q * h);
        return Math.abs(u * t - q * p) > y ? !1 : Math.abs(h * t - g * p) <= y
    };
    e.segmentIntersectsQuad = function(h, g, k, m, r) {
        const w = Math.min(h, k),
            p = Math.max(h, k),
            t = Math.min(g, m),
            u = Math.max(g, m),
            q = r.getTlx(),
            x = r.getTly(),
            y = r.getTrx(),
            B = r.getTry(),
            F = r.getBrx(),
            H = r.getBry(),
            K = r.getBlx();
        r = r.getBly();
        return e.segmentsIntersectPreCalc(h, g, k, m, w, p, t, u, q, x, y, B) || e.segmentsIntersectPreCalc(h,
            g, k, m, w, p, t, u, y, B, F, H) || e.segmentsIntersectPreCalc(h, g, k, m, w, p, t, u, F, H, K, r) || e.segmentsIntersectPreCalc(h, g, k, m, w, p, t, u, K, r, q, x)
    };
    e.segmentIntersectsAnyN = function(h, g, k, m, r) {
        const w = Math.min(h, k),
            p = Math.max(h, k),
            t = Math.min(g, m),
            u = Math.max(g, m);
        let q = 0;
        for (let x = r.length - 4; q <= x; q += 2)
            if (e.segmentsIntersectPreCalc(h, g, k, m, w, p, t, u, r[q], r[q + 1], r[q + 2], r[q + 3])) return !0;
        return e.segmentsIntersectPreCalc(h, g, k, m, w, p, t, u, r[q], r[q + 1], r[0], r[1])
    };
    e.rayIntersect = function(h, g, k, m, r, w, p, t) {
        k -= h;
        w = t - w;
        const u = k *
            w - (m - g) * (p - r);
        if (0 === u) return 2;
        m = ((g - m) * (p - h) + k * (t - g)) / u;
        return 0 < m && 1.000001 > m ? (w * (p - h) + (r - p) * (t - g)) / u : 2
    };
    e.rayIntersectExtended = function(h, g, k, m, r, w, p, t, u) {
        const q = (p - r) * u;
        u *= t - w;
        return e.rayIntersect(h, g, k, m, r - q, w - u, p + q, t + u)
    };
    e.isPointInTriangleInclusive = function(h, g, k, m, r, w, p, t) {
        r -= k;
        w -= m;
        p -= k;
        t -= m;
        h -= k;
        k = g - m;
        g = r * r + w * w;
        m = r * p + w * t;
        r = r * h + w * k;
        w = p * p + t * t;
        p = p * h + t * k;
        t = 1 / (g * w - m * m);
        w = (w * r - m * p) * t;
        r = (g * p - m * r) * t;
        return 0 <= w && 0 <= r && 1 >= w + r
    };
    e.triangleCartesianToBarycentric = function(h, g, k, m, r, w, p, t) {
        r -= k;
        w -=
            m;
        p -= k;
        t -= m;
        h -= k;
        const u = g - m;
        g = r * r + w * w;
        m = r * p + w * t;
        k = p * p + t * t;
        r = h * r + u * w;
        w = h * p + u * t;
        p = g * k - m * m;
        t = (k * r - m * w) / p;
        r = (g * w - m * r) / p;
        return [1 - t - r, t, r]
    };
    e.triangleBarycentricToCartesian = function(h, g, k, m, r, w, p, t, u) {
        return [h * m + g * w + k * t, h * r + g * p + k * u]
    }
} {
    "use strict";
    const e = self.C3;
    let d = null,
        a = "";
    if ("undefined" !== typeof document) {
        d = document;
        const k = document.querySelector("base");
        if (a = k && k.hasAttribute("href") ? k.getAttribute("href") : "") a.startsWith("/") && (a = a.substr(1)), a.endsWith("/") || (a += "/")
    }
    e.GetBaseHref = function() {
        return a
    };
    e.GetBaseURL = function() {
        if (!d) return "";
        const k = d.location;
        return e.GetPathFromURL(k.origin + k.pathname) + a
    };
    e.GetPathFromURL = function(k) {
        if (!k.length || k.endsWith("/") || k.endsWith("\\")) return k;
        const m = Math.max(k.lastIndexOf("/"),
            k.lastIndexOf("\\"));
        return -1 === m ? "" : k.substr(0, m + 1)
    };
    e.GetFilenameFromURL = function(k) {
        if (!k.length) return k;
        if (k.endsWith("/") || k.endsWith("\\")) return "";
        const m = Math.max(k.lastIndexOf("/"), k.lastIndexOf("\\"));
        return -1 === m ? k : k.substr(m + 1)
    };
    e.GetFileExtension = function(k) {
        let m = k.lastIndexOf(".");
        return 1 > m ? "" : k.substr(m)
    };
    e.GetFileNamePart = function(k) {
        let m = k.lastIndexOf(".");
        return 1 > m ? k : k.substr(0, m)
    };
    e.NormalizeFileSeparator = function(k) {
        return k.replace(/\\/g, "/")
    };
    e.IsFileExtension = function(k,
        m) {
        k = k ? e.GetFileExtension(k).slice(1) : "";
        return m === k
    };
    e.FileNameEquals = function(k, m) {
        let r, w;
        e.IsFileLike(k) && (r = e.GetFileNamePart(k.name));
        e.IsString(k) && (r = e.GetFileNamePart(k));
        e.IsFileLike(m) && (w = e.GetFileNamePart(m.name));
        e.IsString(m) && (w = e.GetFileNamePart(m));
        return r === w
    };
    e.ParseFilePath = function(k) {
        k = e.NormalizeFileSeparator(k);
        let m = /^\w:\//.exec(k);
        m ? (m = m[0], k = k.slice(3), "/" !== k[0] && (k = "/" + k)) : m = "";
        k = k.replace(/\/{2,}/g, "/");
        1 < k.length && "/" === k.slice(-1) && (k = k.slice(0, -1));
        var r = k.lastIndexOf("/") +
            1;
        let w = "",
            p = k,
            t = "";
        0 < r && (w = k.slice(0, r), p = k.slice(r));
        k = p;
        r = p.lastIndexOf(".");
        0 < r && (t = p.slice(r), k = p.slice(0, -t.length));
        return {
            dir: w,
            base: p,
            name: k,
            root: m,
            ext: t,
            full: m + w + p
        }
    };
    e.Wait = function(k, m) {
        return new Promise((r, w) => {
            self.setTimeout(r, k, m)
        })
    };
    e.swallowException = function(k) {
        try {
            k()
        } catch (m) {
            e.isDebug && console.warn("Swallowed exception: ", m)
        }
    };
    e.noop = function() {};
    e.equalsNoCase = function(k, m) {
        return "string" !== typeof k || "string" !== typeof m ? !1 : k === m || k.normalize().toLowerCase() === m.normalize().toLowerCase()
    };
    e.equalsCase = function(k, m) {
        return "string" !== typeof k || "string" !== typeof m ? !1 : k === m ? !0 : k.normalize() === m.normalize()
    };
    e.typedArraySet16 = function(k, m, r) {
        k[r++] = m[0];
        k[r++] = m[1];
        k[r++] = m[2];
        k[r++] = m[3];
        k[r++] = m[4];
        k[r++] = m[5];
        k[r++] = m[6];
        k[r++] = m[7];
        k[r++] = m[8];
        k[r++] = m[9];
        k[r++] = m[10];
        k[r++] = m[11];
        k[r++] = m[12];
        k[r++] = m[13];
        k[r++] = m[14];
        k[r] = m[15]
    };
    e.truncateArray = function(k, m) {
        k.length = m
    };
    e.clearArray = function(k) {
        k && 0 !== k.length && e.truncateArray(k, 0)
    };
    e.clear2DArray = function(k) {
        if (k) {
            for (let m = 0; m <
                k.length; m++) e.truncateArray(k[m], 0);
            e.truncateArray(k, 0)
        }
    };
    e.extendArray = function(k, m, r) {
        m |= 0;
        var w = k.length;
        if (!(m <= w))
            for (; w < m; ++w) k.push(r)
    };
    e.resizeArray = function(k, m, r) {
        m |= 0;
        const w = k.length;
        m < w ? e.truncateArray(k, m) : m > w && e.extendArray(k, m, r)
    };
    e.shallowAssignArray = function(k, m) {
        e.clearArray(k);
        e.appendArray(k, m)
    };
    e.appendArray = function(k, m) {
        if (1E4 > m.length) k.push(...m);
        else
            for (let r = 0, w = m.length; r < w; ++r) k.push(m[r])
    };
    e.arrayRemove = function(k, m) {
        m = Math.floor(m);
        if (!(0 > m || m >= k.length)) {
            for (var r =
                    k.length - 1; m < r; ++m) k[m] = k[m + 1];
            e.truncateArray(k, r)
        }
    };
    e.arrayFindRemove = function(k, m) {
        m = k.indexOf(m);
        0 <= m && k.splice(m, 1)
    };
    e.arraysEqual = function(k, m) {
        let r = k.length;
        if (m.length !== r) return !1;
        for (let w = 0; w < r; ++w)
            if (k[w] !== m[w]) return !1;
        return !0
    };
    e.arrayFilterOut = function(k, m) {
        let r = [],
            w = 0;
        for (let p = 0, t = k.length; p < t; ++p) {
            let u = k[p];
            m(u) ? r.push(u) : (k[w] = u, ++w)
        }
        e.truncateArray(k, w);
        return r
    };
    e.arrayRemoveAllInSet = function(k, m) {
        const r = k.length;
        let w = 0;
        for (let p = 0, t = k.length; p < t; ++p) {
            let u = k[p];
            m.has(u) ||
                (k[w++] = u)
        }
        e.truncateArray(k, w);
        return r - w
    };
    e.isArrayIndexInBounds = function(k, m) {
        return k !== Math.floor(k) ? !1 : 0 <= k && k < m.length
    };
    e.validateArrayIndex = function(k, m) {
        if (!e.isArrayIndexInBounds(k, m)) throw new RangeError("array index out of bounds");
    };
    e.cloneArray = function(k) {
        return k.slice()
    };
    e.deepCloneArray = function(k, m) {
        let r = [];
        for (let w of k)
            if (e.IsObject(w)) {
                k = m(w);
                if (!k) throw Error("missing clone");
                if (k.constructor !== w.constructor) throw Error("object is not a clone");
                r.push(k)
            } else e.IsArray(w) ?
                r.push(e.deepCloneArray(w, m)) : r.push(w);
        return r
    };
    e.clone2DArray = function(k) {
        let m = [];
        for (let r of k) m.push(r.slice());
        return m
    };
    e.mergeSets = function(k, m) {
        return new Set([...k, ...m])
    };
    e.mergeSetsInPlace = function(k, m) {
        for (const r of m) k.add(r);
        return k
    };
    e.first = function(k) {
        for (let m of k) return m;
        return null
    };
    e.xor = function(k, m) {
        return !k !== !m
    };
    e.compare = function(k, m, r) {
        switch (m) {
            case 0:
                return k === r;
            case 1:
                return k !== r;
            case 2:
                return k < r;
            case 3:
                return k <= r;
            case 4:
                return k > r;
            case 5:
                return k >= r;
            default:
                return !1
        }
    };
    e.hasAnyOwnProperty = function(k) {
        for (let m in k)
            if (k.hasOwnProperty(m)) return !0;
        return !1
    };
    e.PromiseAllWithProgress = function(k, m) {
        return k.length ? new Promise((r, w) => {
            const p = [];
            let t = 0,
                u = !1;
            for (let q = 0, x = k.length; q < x; ++q) p.push(void 0), k[q].then(y => {
                u || (p[q] = y, ++t, t === k.length ? r(p) : m(t, k.length))
            }).catch(y => {
                u = !0;
                w(y)
            })
        }) : Promise.resolve([])
    };
    let b = [];
    e.AddLibraryMemoryCallback = function(k) {
        b.push(k)
    };
    e.GetEstimatedLibraryMemoryUsage = function() {
        let k = 0;
        for (let m of b) {
            let r = m();
            k += r
        }
        return Math.floor(k)
    };
    let c = 1;
    const f = new Map,
        h = new MessageChannel;
    h.port2.onmessage = function(k) {
        k = k.data;
        const m = f.get(k);
        f.delete(k);
        m && m(performance.now())
    };
    e.RequestUnlimitedAnimationFrame = function(k) {
        const m = c++;
        f.set(m, k);
        h.port1.postMessage(m);
        return m
    };
    e.CancelUnlimitedAnimationFrame = function(k) {
        f.delete(k)
    };
    e.PostTask = e.RequestUnlimitedAnimationFrame;
    e.WaitForNextTask = function() {
        return new Promise(k => e.PostTask(k))
    };
    const g = new Set;
    e.RequestPostAnimationFrame = function(k) {
        const m = self.requestAnimationFrame(async r => {
            await e.WaitForNextTask();
            g.has(m) && (g.delete(m), k(r))
        });
        g.add(m);
        return m
    };
    e.CancelPostAnimationFrame = function(k) {
        g.has(k) && (self.cancelAnimationFrame(k), g.delete(k))
    }
} {
    "use strict";
    const e = self.C3;
    e.IsAbsoluteURL = function(d) {
        return /^(?:[a-z\-]+:)?\/\//.test(d) || "data:" === d.substr(0, 5) || "blob:" === d.substr(0, 5)
    };
    e.IsRelativeURL = function(d) {
        return !e.IsAbsoluteURL(d)
    };
    e.ThrowIfNotOk = function(d) {
        if (!d.ok) throw Error(`fetch '${d.url}' response returned ${d.status} ${d.statusText}`);
    };
    e.FetchOk = function(d, a) {
        return fetch(d, a).then(b => {
            e.ThrowIfNotOk(b);
            return b
        })
    };
    e.FetchText = function(d) {
        return e.FetchOk(d).then(a => a.text())
    };
    e.FetchJson = function(d) {
        return e.FetchOk(d).then(a =>
            a.json())
    };
    e.FetchBlob = function(d) {
        return e.FetchOk(d).then(a => a.blob())
    };
    e.FetchArrayBuffer = function(d) {
        return e.FetchOk(d).then(a => a.arrayBuffer())
    };
    e.FetchImage = function(d) {
        return new Promise((a, b) => {
            const c = new Image;
            c.onload = () => a(c);
            c.onerror = f => b(f);
            c.src = d
        })
    };
    e.BlobToArrayBuffer = function(d) {
        return "function" === typeof d.arrayBuffer ? d.arrayBuffer() : new Promise((a, b) => {
            const c = new FileReader;
            c.onload = () => a(c.result);
            c.onerror = () => b(c.error);
            c.readAsArrayBuffer(d)
        })
    };
    e.BlobToString = function(d) {
        return "function" ===
            typeof d.text ? d.text() : new Promise((a, b) => {
                const c = new FileReader;
                c.onload = () => a(c.result);
                c.onerror = () => b(c.error);
                c.readAsText(d)
            })
    };
    e.BlobToJson = function(d) {
        return e.BlobToString(d).then(a => JSON.parse(a))
    };
    e.BlobToImage = async function(d, a) {
        d = URL.createObjectURL(d);
        try {
            const b = await e.FetchImage(d);
            URL.revokeObjectURL(d);
            d = "";
            a && "function" === typeof b.decode && await b.decode();
            return b
        } finally {
            d && URL.revokeObjectURL(d)
        }
    };
    e.CreateCanvas = function(d, a) {
        if ("undefined" !== typeof document && "function" ===
            typeof document.createElement) {
            const b = document.createElement("canvas");
            b.width = d;
            b.height = a;
            return b
        }
        return new OffscreenCanvas(d, a)
    };
    e.CanvasToBlob = function(d, a, b) {
        "number" !== typeof b && (b = 1);
        a = a || "image/png";
        b = e.clamp(b, 0, 1);
        return d.toBlob ? new Promise(c => d.toBlob(c, a, b)) : d.convertToBlob ? d.convertToBlob({
            type: a,
            quality: b
        }) : e.Asyncify(() => e.CanvasToBlobSync(d, a, b))
    };
    e.CanvasToBlobSync = function(d, a, b) {
        "number" !== typeof b && (b = 1);
        a = a || "image/png";
        b = e.clamp(b, 0, 1);
        return e.DataURIToBinaryBlobSync(d.toDataURL(a,
            b))
    };
    e.DataURIToBinaryBlobSync = function(d) {
        d = e.ParseDataURI(d);
        return e.BinaryStringToBlob(d.data, d.mime_type)
    };
    e.ParseDataURI = function(d) {
        if ("data:" !== d.substr(0, 5)) throw new URIError("expected data: uri");
        var a = d.indexOf(",");
        if (0 > a) throw new URIError("expected comma in data: uri");
        var b = d.substring(5, a);
        d = d.substring(a + 1);
        a = b.split(";");
        b = a[0] || "";
        let c = a[2];
        d = "base64" === a[1] || "base64" === c ? atob(d) : decodeURIComponent(d);
        return {
            mime_type: b,
            data: d
        }
    };
    e.BinaryStringToBlob = function(d, a) {
        var b = d.length;
        let c = b >> 2,
            f = new Uint8Array(b),
            h = new Uint32Array(f.buffer, 0, c),
            g, k;
        for (k = g = 0; g < c; ++g) h[g] = d.charCodeAt(k++) | d.charCodeAt(k++) << 8 | d.charCodeAt(k++) << 16 | d.charCodeAt(k++) << 24;
        for (b &= 3; b--;) f[k] = d.charCodeAt(k), ++k;
        return a ? new Blob([f], {
            type: a
        }) : new Blob([f])
    };
    e.DrawableToBlob = function(d, a, b) {
        const c = e.CreateCanvas(d.width, d.height);
        c.getContext("2d").drawImage(d, 0, 0);
        return e.CanvasToBlob(c, a, b)
    };
    e.ImageDataToBlobSync = function(d, a, b) {
        const c = e.CreateCanvas(d.width, d.height);
        c.getContext("2d").putImageData(d,
            0, 0);
        return e.CanvasToBlobSync(c, a, b)
    };
    e.ImageDataToBlob = function(d, a, b) {
        if (e.Supports.ImageBitmapOptions) return createImageBitmap(d, {
            premultiplyAlpha: "none"
        }).then(c => e.DrawableToBlob(c, a, b));
        if (e.Supports.ImageBitmap) return createImageBitmap(d).then(c => e.DrawableToBlob(c, a, b)); {
            const c = e.CreateCanvas(d.width, d.height);
            c.getContext("2d").putImageData(d, 0, 0);
            return e.CanvasToBlob(c, a, b)
        }
    };
    e.CopySet = function(d, a) {
        d.clear();
        for (const b of a) d.add(b)
    };
    e.MapToObject = function(d) {
        const a = Object.create(null);
        for (const [b, c] of d.entries()) a[b] = c;
        return a
    };
    e.ObjectToMap = function(d, a) {
        a.clear();
        for (const [b, c] of Object.entries(d)) a.set(b, c)
    };
    e.ToSuperJSON = function b(a) {
        if ("object" === typeof a && null !== a) {
            if (a instanceof Set) return {
                _c3type_: "set",
                data: [...a].map(c => b(c))
            };
            if (a instanceof Map) return {
                _c3type_: "map",
                data: [...a].map(c => [c[0], b(c[1])])
            }; {
                const c = Object.create(null);
                for (const [f, h] of Object.entries(a)) c[f] = b(h);
                return c
            }
        }
        return a
    };
    e.FromSuperJSON = function c(b) {
        if ("object" === typeof b & null !== b) {
            if ("set" ===
                b._c3type_) return new Set(b.data.map(f => c(f)));
            if ("map" === b._c3type_) return new Map(b.data.map(f => [f[0], c(f[1])])); {
                const f = Object.create(null);
                for (const [h, g] of Object.entries(b)) f[h] = c(g);
                return f
            }
        }
        return b
    };
    e.CSSToCamelCase = function(b) {
        let c = "",
            f = !1;
        for (const h of b) "-" === h ? f = !0 : f ? (c += h.toUpperCase(), f = !1) : c += h;
        return c
    };
    e.IsIterator = function(b) {
        return "object" === typeof b && "function" === typeof b.next
    };
    e.MakeFilledArray = function(b, c) {
        const f = [];
        if ("function" === typeof c)
            for (var h = 0; h < b; ++h) f.push(c());
        else
            for (h = 0; h < b; ++h) f.push(c);
        return f
    }
} {
    "use strict";
    const e = self.C3,
        d = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
        a = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;

    function b(f) {
        return 0 === f.length ? "00" : 1 === f.length ? "0" + f : f
    }

    function c(f, h, g) {
        0 > g && (g += 1);
        1 < g && --g;
        return g < 1 / 6 ? f + 6 * (h - f) * g : .5 > g ? h : g < 2 / 3 ? f + (h - f) * (2 / 3 - g) * 6 : f
    }
    e.Color = class {
        constructor(f, h, g, k) {
            this._a = this._b = this._g = this._r = 0;
            f instanceof e.Color ? this.set(f) : this.setRgba(f || 0, h || 0, g || 0, k || 0)
        }
        setRgb(f, h, g) {
            this._r = +f;
            this._g = +h;
            this._b = +g;
            this.clamp();
            return this
        }
        setRgba(f, h, g, k) {
            this._r = +f;
            this._g = +h;
            this._b = +g;
            this._a = +k;
            this.clamp();
            return this
        }
        set(f) {
            this._r = f._r;
            this._g = f._g;
            this._b = f._b;
            this._a = f._a;
            return this
        }
        copy(f) {
            return this.set(f)
        }
        add(f) {
            this._r += f._r;
            this._g += f._g;
            this._b += f._b;
            this._a += f._a;
            this.clamp()
        }
        addRgb(f, h, g, k = 0) {
            this._r += +f;
            this._g += +h;
            this._b += +g;
            this._a += +k;
            this.clamp()
        }
        diff(f) {
            this.setR(Math.max(this._r, f._r) - Math.min(this._r, f._r));
            this.setG(Math.max(this._g, f._g) - Math.min(this._g, f._g));
            this.setB(Math.max(this._b, f._b) - Math.min(this._b, f._b));
            this.setA(Math.max(this._a,
                f._a) - Math.min(this._a, f._a));
            this.clamp()
        }
        copyRgb(f) {
            this._r = f._r;
            this._g = f._g;
            this._b = f._b
        }
        setR(f) {
            this._r = e.clamp(+f, 0, 1)
        }
        getR() {
            return this._r
        }
        setG(f) {
            this._g = e.clamp(+f, 0, 1)
        }
        getG() {
            return this._g
        }
        setB(f) {
            this._b = e.clamp(+f, 0, 1)
        }
        getB() {
            return this._b
        }
        setA(f) {
            this._a = e.clamp(+f, 0, 1)
        }
        getA() {
            return this._a
        }
        clone() {
            return e.New(e.Color, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(f, h) {
            f[h++] =
                this._r;
            f[h++] = this._g;
            f[h++] = this._b;
            f[h] = this._a
        }
        equals(f) {
            return this._r === f._r && this._g === f._g && this._b === f._b && this._a === f._a
        }
        equalsIgnoringAlpha(f) {
            return this._r === f._r && this._g === f._g && this._b === f._b
        }
        equalsRgb(f, h, g) {
            return this._r === f && this._g === h && this._b === g
        }
        equalsRgba(f, h, g, k) {
            return this._r === f && this._g === h && this._b === g && this._a === k
        }
        multiply(f) {
            this._r *= f._r;
            this._g *= f._g;
            this._b *= f._b;
            this._a *= f._a
        }
        multiplyAlpha(f) {
            this._r *= f;
            this._g *= f;
            this._b *= f;
            this._a *= f
        }
        premultiply() {
            this._r *= this._a;
            this._g *= this._a;
            this._b *= this._a;
            return this
        }
        unpremultiply() {
            this._r /= this._a;
            this._g /= this._a;
            this._b /= this._a;
            return this
        }
        clamp() {
            this._r = e.clamp(this._r, 0, 1);
            this._g = e.clamp(this._g, 0, 1);
            this._b = e.clamp(this._b, 0, 1);
            this._a = e.clamp(this._a, 0, 1);
            return this
        }
        setFromRgbValue(f) {
            this._r = e.GetRValue(f);
            this._g = e.GetGValue(f);
            this._b = e.GetBValue(f);
            this._a = e.GetAValue(f)
        }
        getCssRgb(f, h, g) {
            f = e.IsFiniteNumber(f) ? f : this.getR();
            h = e.IsFiniteNumber(h) ? h : this.getG();
            g = e.IsFiniteNumber(g) ? g : this.getB();
            return `rgb(${100*
f}%, ${100*h}%, ${100*g}%)`
        }
        getCssRgba(f, h, g, k) {
            f = e.IsFiniteNumber(f) ? f : this.getR();
            h = e.IsFiniteNumber(h) ? h : this.getG();
            g = e.IsFiniteNumber(g) ? g : this.getB();
            k = e.IsFiniteNumber(k) ? k : this.getA();
            return `rgba(${100*f}%, ${100*h}%, ${100*g}%, ${k})`
        }
        toHexString() {
            const f = Math.round(255 * this.getR()),
                h = Math.round(255 * this.getG()),
                g = Math.round(255 * this.getB());
            return "#" + b(f.toString(16)) + b(h.toString(16)) + b(g.toString(16))
        }
        parseHexString(f) {
            if ("string" !== typeof f) return !1;
            f = f.trim();
            "#" === f.charAt(0) && (f =
                f.substr(1));
            let h, g;
            if (3 === f.length) h = parseInt(f[0], 16) / 15, g = parseInt(f[1], 16) / 15, f = parseInt(f[2], 16) / 15;
            else if (6 === f.length) h = parseInt(f.substr(0, 2), 16) / 255, g = parseInt(f.substr(2, 2), 16) / 255, f = parseInt(f.substr(4, 2), 16) / 255;
            else return !1;
            isFinite(h) && this.setR(h);
            isFinite(g) && this.setG(g);
            isFinite(f) && this.setB(f);
            this.setA(1);
            return !0
        }
        toCommaSeparatedRgb() {
            const f = Math.round(255 * this.getR()),
                h = Math.round(255 * this.getG()),
                g = Math.round(255 * this.getB());
            return `${f}, ${h}, ${g}`
        }
        toRgbArray() {
            const f =
                Math.round(255 * this.getR()),
                h = Math.round(255 * this.getG()),
                g = Math.round(255 * this.getB());
            return [f, h, g]
        }
        parseCommaSeparatedRgb(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/^rgb\(|\)|%/, "");
            var h = f.split(",");
            if (3 > h.length) return !1;
            f = parseInt(h[0].trim(), 10) / 255;
            const g = parseInt(h[1].trim(), 10) / 255;
            h = parseInt(h[2].trim(), 10) / 255;
            isFinite(f) && this.setR(f);
            isFinite(g) && this.setG(g);
            isFinite(h) && this.setB(h);
            this.setA(1);
            return !0
        }
        parseCommaSeparatedPercentageRgb(f) {
            if ("string" !== typeof f) return !1;
            f =
                f.replace(/^rgb\(|\)|%/, "");
            var h = f.split(",");
            if (3 > h.length) return !1;
            f = parseInt(h[0].trim(), 10) / 100;
            const g = parseInt(h[1].trim(), 10) / 100;
            h = parseInt(h[2].trim(), 10) / 100;
            isFinite(f) && this.setR(f);
            isFinite(g) && this.setG(g);
            isFinite(h) && this.setB(h);
            this.setA(1);
            return !0
        }
        parseCommaSeparatedRgba(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/^rgba\(|\)|%/, "");
            var h = f.split(",");
            if (4 > h.length) return !1;
            f = parseInt(h[0].trim(), 10) / 255;
            const g = parseInt(h[1].trim(), 10) / 255,
                k = parseInt(h[2].trim(), 10) / 255;
            h =
                parseFloat(h[3].trim());
            isFinite(f) && this.setR(f);
            isFinite(g) && this.setG(g);
            isFinite(k) && this.setB(k);
            isFinite(h) && this.setA(h);
            return !0
        }
        parseCommaSeparatedPercentageRgba(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/^rgba\(|\)|%/, "");
            var h = f.split(",");
            if (4 > h.length) return !1;
            f = parseInt(h[0].trim(), 10) / 100;
            const g = parseInt(h[1].trim(), 10) / 100,
                k = parseInt(h[2].trim(), 10) / 100;
            h = parseFloat(h[3].trim());
            isFinite(f) && this.setR(f);
            isFinite(g) && this.setG(g);
            isFinite(k) && this.setB(k);
            isFinite(h) && this.setA(h);
            return !0
        }
        parseString(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/\s+/, "");
            if (f.includes(",")) {
                if (f.startsWith("rgb(")) return f.includes("%") ? this.parseCommaSeparatedPercentageRgb(f) : this.parseCommaSeparatedRgb(f);
                if (f.startsWith("rgba(")) return f.includes("%") ? this.parseCommaSeparatedPercentageRgba(f) : this.parseCommaSeparatedRgba(f);
                if (f.startsWith("hsl(") || f.startsWith("hsla(")) return this.parseHSLString(f); {
                    const h = f.split(",");
                    if (f.includes("%")) {
                        if (3 === h.length) return this.parseCommaSeparatedPercentageRgb(f);
                        if (4 === h.length) return this.parseCommaSeparatedPercentageRgba(f)
                    } else {
                        if (3 === h.length) return this.parseCommaSeparatedRgb(f);
                        if (4 === h.length) return this.parseCommaSeparatedRgba(f)
                    }
                    return !1
                }
            }
            return this.parseHexString(f)
        }
        toJSON() {
            return [this._r, this._g, this._b, this._a]
        }
        setFromHSLA(f, h, g, k) {
            f %= 360;
            h = e.clamp(h, 0, 100);
            g = e.clamp(g, 0, 100);
            k = e.clamp(k, 0, 1);
            f /= 360;
            h /= 100;
            g /= 100;
            if (0 === h) g = h = f = g;
            else {
                const m = .5 > g ? g * (1 + h) : g + h - g * h,
                    r = 2 * g - m;
                g = c(r, m, f + 1 / 3);
                h = c(r, m, f);
                f = c(r, m, f - 1 / 3)
            }
            this.setR(g);
            this.setG(h);
            this.setB(f);
            this.setA(k);
            return this
        }
        parseHSLString(f) {
            var h = f.replace(/ |hsl|hsla|\(|\)|;/gi, "");
            f = d.exec(h);
            h = a.exec(h);
            return f && 4 === f.length ? (this.setFromHSLA(+f[1], +f[2], +f[3], 1), !0) : h && 5 === h.length ? (this.setFromHSLA(+f[1], +f[2], +f[3], +f[4]), !0) : !1
        }
        toHSLAString() {
            var f = this._r;
            const h = this._g,
                g = this._b,
                k = this._a,
                m = e.Color.GetHue(f, h, g),
                r = e.Color.GetSaturation(f, h, g);
            f = e.Color.GetLuminosity(f, h, g);
            return `hsla(${m}, ${r}%, ${f}%, ${k})`
        }
        toHSLAArray() {
            const f = this._r,
                h = this._g,
                g = this._b;
            return [e.Color.GetHue(f,
                h, g), e.Color.GetSaturation(f, h, g), e.Color.GetLuminosity(f, h, g), this._a]
        }
        setFromJSON(f) {
            !Array.isArray(f) || 3 > f.length || (this._r = f[0], this._g = f[1], this._b = f[2], this._a = 4 <= f.length ? f[3] : 1)
        }
        set r(f) {
            this.setR(f)
        }
        get r() {
            return this.getR()
        }
        set g(f) {
            this.setG(f)
        }
        get g() {
            return this.getG()
        }
        set b(f) {
            this.setB(f)
        }
        get b() {
            return this.getB()
        }
        set a(f) {
            this.setA(f)
        }
        get a() {
            return this.getA()
        }
        setAtIndex(f, h) {
            switch (f) {
                case 0:
                    this.setR(h);
                    break;
                case 1:
                    this.setG(h);
                    break;
                case 2:
                    this.setB(h);
                    break;
                case 3:
                    this.setA(h);
                    break;
                default:
                    throw new RangeError("invalid color index");
            }
        }
        getAtIndex(f) {
            switch (f) {
                case 0:
                    return this.getR();
                case 1:
                    return this.getG();
                case 2:
                    return this.getB();
                case 3:
                    return this.getA();
                default:
                    throw new RangeError("invalid color index");
            }
        }
        static Equals(f, h) {
            let g;
            if (Array.isArray(f)) g = new e.Color, g.setFromJSON(f);
            else if (f instanceof e.Color) g = f;
            else throw Error("unexpected type");
            if (Array.isArray(h)) f = new e.Color, f.setFromJSON(h);
            else if (h instanceof e.Color) f = h;
            else throw Error("unexpected type");
            return g.equals(f)
        }
        static DiffChannel(f, h) {
            return e.clamp(Math.max(f, h) - Math.min(f, h), 0, 1)
        }
        static Diff(f, h) {
            const g = new e.Color;
            g.setR(Math.max(f._r, h._r) - Math.min(f._r, h._r));
            g.setG(Math.max(f._g, h._g) - Math.min(f._g, h._g));
            g.setB(Math.max(f._b, h._b) - Math.min(f._b, h._b));
            g.setA(Math.max(f._a, h._a) - Math.min(f._a, h._a));
            return g
        }
        static DiffNoAlpha(f, h) {
            const g = new e.Color(0, 0, 0, 1);
            g.setR(Math.max(f._r, h._r) - Math.min(f._r, h._r));
            g.setG(Math.max(f._g, h._g) - Math.min(f._g, h._g));
            g.setB(Math.max(f._b, h._b) -
                Math.min(f._b, h._b));
            return g
        }
        static GetHue(f, h, g) {
            const k = Math.max(f, h, g),
                m = Math.min(f, h, g);
            if (k === m) return 0;
            let r = 0;
            switch (k) {
                case f:
                    r = (h - g) / (k - m) + (h < g ? 6 : 0);
                    break;
                case h:
                    r = (g - f) / (k - m) + 2;
                    break;
                case g:
                    r = (f - h) / (k - m) + 4
            }
            return Math.round(r / 6 * 360)
        }
        static GetSaturation(f, h, g) {
            const k = Math.max(f, h, g);
            f = Math.min(f, h, g);
            if (k === f) return 0;
            h = k - f;
            return Math.round(100 * (.5 < (k + f) / 2 ? h / (2 - k - f) : h / (k + f)))
        }
        static GetLuminosity(f, h, g) {
            const k = Math.max(f, h, g);
            return k ? Math.round((k + Math.min(f, h, g)) / 2 * 100) : 0
        }
    };
    e.Color.White =
        Object.freeze(e.New(e.Color, 1, 1, 1, 1));
    e.Color.Black = Object.freeze(e.New(e.Color, 0, 0, 0, 1));
    e.Color.TransparentBlack = Object.freeze(e.New(e.Color, 0, 0, 0, 0))
} {
    "use strict";
    const e = self.C3;
    e.Vector2 = class {
        constructor(d, a) {
            this._y = this._x = 0;
            d instanceof e.Vector2 ? this.copy(d) : this.set(d || 0, a || 0)
        }
        set(d, a) {
            this._x = +d;
            this._y = +a
        }
        copy(d) {
            this._x = d._x;
            this._y = d._y
        }
        equals(d) {
            return this._x === d._x && this._y === d._y
        }
        equalsValues(d, a) {
            return this._x === d && this._y === a
        }
        setX(d) {
            this._x = +d
        }
        getX() {
            return this._x
        }
        setY(d) {
            this._y = +d
        }
        getY() {
            return this._y
        }
        toArray() {
            return [this._x, this._y]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(d, a) {
            d[a++] =
                this._x;
            d[a] = this._y
        }
        offset(d, a) {
            this._x += +d;
            this._y += +a
        }
        scale(d, a) {
            this._x *= d;
            this._y *= a
        }
        divide(d, a) {
            this._x /= d;
            this._y /= a
        }
        round() {
            this._x = Math.round(this._x);
            this._y = Math.round(this._y)
        }
        floor() {
            this._x = Math.floor(this._x);
            this._y = Math.floor(this._y)
        }
        ceil() {
            this._x = Math.ceil(this._x);
            this._y = Math.ceil(this._y)
        }
        angle() {
            return e.angleTo(0, 0, this._x, this._y)
        }
        lengthSquared() {
            return this._x * this._x + this._y * this._y
        }
        length() {
            return Math.sqrt(this.lengthSquared())
        }
        rotatePrecalc(d, a) {
            const b = this._x * a - this._y *
                d;
            this._y = this._y * a + this._x * d;
            this._x = b
        }
        rotate(d) {
            0 !== d && this.rotatePrecalc(Math.sin(d), Math.cos(d))
        }
        rotateAbout(d, a, b) {
            0 === d || a === this._x && b === this._y || (this._x -= a, this._y -= b, this.rotatePrecalc(Math.sin(d), Math.cos(d)), this._x += +a, this._y += +b)
        }
        move(d, a) {
            0 !== a && (this._x += Math.cos(d) * a, this._y += Math.sin(d) * a)
        }
        normalize() {
            const d = this.length();
            0 !== d && 1 !== d && (this._x /= d, this._y /= d)
        }
        clamp(d, a) {
            this._x = e.clamp(this._x, d, a);
            this._y = e.clamp(this._y, d, a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Rect = class {
        constructor(d, a, b, c) {
            this._bottom = this._right = this._top = this._left = 0;
            d instanceof e.Rect ? this.copy(d) : this.set(d || 0, a || 0, b || 0, c || 0)
        }
        set(d, a, b, c) {
            this._left = +d;
            this._top = +a;
            this._right = +b;
            this._bottom = +c
        }
        setWH(d, a, b, c) {
            d = +d;
            a = +a;
            this._left = d;
            this._top = a;
            this._right = d + +b;
            this._bottom = a + +c
        }
        copy(d) {
            this._left = +d._left;
            this._top = +d._top;
            this._right = +d._right;
            this._bottom = +d._bottom
        }
        clone() {
            return new e.Rect(this._left, this._top, this._right, this._bottom)
        }
        static Merge(d,
            a) {
            const b = new e.Rect;
            b.setLeft(Math.min(d._left, a._left));
            b.setTop(Math.min(d._top, a._top));
            b.setRight(Math.max(d._right, a._right));
            b.setBottom(Math.max(d._bottom, a._bottom));
            return b
        }
        static FromObject(d) {
            return new e.Rect(d.left, d.top, d.right, d.bottom)
        }
        equals(d) {
            return this._left === d._left && this._top === d._top && this._right === d._right && this._bottom === d._bottom
        }
        equalsWH(d, a, b, c) {
            return this._left === d && this._top === a && this.width() === b && this.height() === c
        }
        setLeft(d) {
            this._left = +d
        }
        getLeft() {
            return this._left
        }
        setTop(d) {
            this._top = +d
        }
        getTop() {
            return this._top
        }
        setRight(d) {
            this._right = +d
        }
        getRight() {
            return this._right
        }
        setBottom(d) {
            this._bottom = +d
        }
        getBottom() {
            return this._bottom
        }
        toArray() {
            return [this._left, this._top, this._right, this._bottom]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        toDOMRect() {
            return new DOMRect(this._left, this._top, this.width(), this.height())
        }
        writeToTypedArray(d, a) {
            d[a++] = this._left;
            d[a++] = this._top;
            d[a++] = this._right;
            d[a] = this._bottom
        }
        writeAsQuadToTypedArray(d, a) {
            d[a++] = this._left;
            d[a++] = this._top;
            d[a++] = this._right;
            d[a++] = this._top;
            d[a++] = this._right;
            d[a++] = this._bottom;
            d[a++] = this._left;
            d[a] = this._bottom
        }
        writeAsQuadToTypedArray3D(d, a, b) {
            d[a++] = this._left;
            d[a++] = this._top;
            d[a++] = b;
            d[a++] = this._right;
            d[a++] = this._top;
            d[a++] = b;
            d[a++] = this._right;
            d[a++] = this._bottom;
            d[a++] = b;
            d[a++] = this._left;
            d[a++] = this._bottom;
            d[a] = b
        }
        width() {
            return this._right - this._left
        }
        height() {
            return this._bottom - this._top
        }
        midX() {
            return (this._left + this._right) / 2
        }
        midY() {
            return (this._top + this._bottom) / 2
        }
        offset(d, a) {
            d = +d;
            a = +a;
            this._left += d;
            this._top += a;
            this._right += d;
            this._bottom += a
        }
        offsetLeft(d) {
            this._left += +d
        }
        offsetTop(d) {
            this._top += +d
        }
        offsetRight(d) {
            this._right += +d
        }
        offsetBottom(d) {
            this._bottom += +d
        }
        toSquare(d) {
            if ("x" !== d) throw Error("invalid axis, only 'x' supported");
            this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() : this._left < this._right ? this._top - this.width() : this._top + this.width()
        }
        inflate(d, a) {
            d = +d;
            a = +a;
            this._left -= d;
            this._top -= a;
            this._right += d;
            this._bottom +=
                a
        }
        deflate(d, a) {
            d = +d;
            a = +a;
            this._left += d;
            this._top += a;
            this._right -= d;
            this._bottom -= a
        }
        multiply(d, a) {
            this._left *= d;
            this._top *= a;
            this._right *= d;
            this._bottom *= a
        }
        divide(d, a) {
            this._left /= d;
            this._top /= a;
            this._right /= d;
            this._bottom /= a
        }
        mirrorAround(d) {
            this._left = +d - this._left;
            this._right = +d - this._right
        }
        flipAround(d) {
            this._top = +d - this._top;
            this._bottom = +d - this._bottom
        }
        swapLeftRight() {
            const d = this._left;
            this._left = this._right;
            this._right = d
        }
        swapTopBottom() {
            const d = this._top;
            this._top = this._bottom;
            this._bottom =
                d
        }
        shuntY(d) {
            const a = this._top;
            this._top = +d - this._bottom;
            this._bottom = +d - a
        }
        round() {
            this._left = Math.round(this._left);
            this._top = Math.round(this._top);
            this._right = Math.round(this._right);
            this._bottom = Math.round(this._bottom)
        }
        roundInner() {
            this._left = Math.ceil(this._left);
            this._top = Math.ceil(this._top);
            this._right = Math.floor(this._right);
            this._bottom = Math.floor(this._bottom)
        }
        roundOuter() {
            this._left = Math.floor(this._left);
            this._top = Math.floor(this._top);
            this._right = Math.ceil(this._right);
            this._bottom = Math.ceil(this._bottom)
        }
        floor() {
            this._left =
                Math.floor(this._left);
            this._top = Math.floor(this._top);
            this._right = Math.floor(this._right);
            this._bottom = Math.floor(this._bottom)
        }
        ceil() {
            this._left = Math.ceil(this._left);
            this._top = Math.ceil(this._top);
            this._right = Math.ceil(this._right);
            this._bottom = Math.ceil(this._bottom)
        }
        clamp(d, a, b, c) {
            this._left < d && (this._left = +d);
            this._top < a && (this._top = +a);
            this._right > b && (this._right = +b);
            this._bottom > c && (this._bottom = +c)
        }
        clampFlipped(d, a, b, c) {
            this._left < d && (this._left = +d);
            this._top > a && (this._top = +a);
            this._right >
                b && (this._right = +b);
            this._bottom < c && (this._bottom = +c)
        }
        normalize() {
            this._left > this._right && this.swapLeftRight();
            this._top > this._bottom && this.swapTopBottom()
        }
        intersectsRect(d) {
            return !(d._right < this._left || d._bottom < this._top || d._left > this._right || d._top > this._bottom)
        }
        intersectsRectOffset(d, a, b) {
            return !(d._right + a < this._left || d._bottom + b < this._top || d._left + a > this._right || d._top + b > this._bottom)
        }
        containsPoint(d, a) {
            return d >= this._left && d <= this._right && a >= this._top && a <= this._bottom
        }
        containsRect(d) {
            return d._left >=
                this._left && d._top >= this._top && d._right <= this._right && d._bottom <= this._bottom
        }
        expandToContain(d) {
            d._left < this._left && (this._left = +d._left);
            d._top < this._top && (this._top = +d._top);
            d._right > this._right && (this._right = +d._right);
            d._bottom > this._bottom && (this._bottom = +d._bottom)
        }
        lerpInto(d) {
            this._left = e.lerp(d._left, d._right, this._left);
            this._top = e.lerp(d._top, d._bottom, this._top);
            this._right = e.lerp(d._left, d._right, this._right);
            this._bottom = e.lerp(d._top, d._bottom, this._bottom)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Quad = class {
        constructor(d, a, b, c, f, h, g, k) {
            this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0;
            d instanceof e.Quad ? this.copy(d) : this.set(d || 0, a || 0, b || 0, c || 0, f || 0, h || 0, g || 0, k || 0)
        }
        set(d, a, b, c, f, h, g, k) {
            this._tlx = +d;
            this._tly = +a;
            this._trx = +b;
            this._try = +c;
            this._brx = +f;
            this._bry = +h;
            this._blx = +g;
            this._bly = +k
        }
        setRect(d, a, b, c) {
            this.set(d, a, b, a, b, c, d, c)
        }
        copy(d) {
            this._tlx = d._tlx;
            this._tly = d._tly;
            this._trx = d._trx;
            this._try = d._try;
            this._brx = d._brx;
            this._bry =
                d._bry;
            this._blx = d._blx;
            this._bly = d._bly
        }
        equals(d) {
            return this._tlx === d._tlx && this._tly === d._tly && this._trx === d._trx && this._try === d._try && this._brx === d._brx && this._bry === d._bry && this._blx === d._blx && this._bly === d._bly
        }
        setTlx(d) {
            this._tlx = +d
        }
        getTlx() {
            return this._tlx
        }
        setTly(d) {
            this._tly = +d
        }
        getTly() {
            return this._tly
        }
        setTrx(d) {
            this._trx = +d
        }
        getTrx() {
            return this._trx
        }
        setTry(d) {
            this._try = +d
        }
        getTry() {
            return this._try
        }
        setBrx(d) {
            this._brx = +d
        }
        getBrx() {
            return this._brx
        }
        setBry(d) {
            this._bry = +d
        }
        getBry() {
            return this._bry
        }
        setBlx(d) {
            this._blx = +d
        }
        getBlx() {
            return this._blx
        }
        setBly(d) {
            this._bly = +d
        }
        getBly() {
            return this._bly
        }
        toDOMQuad() {
            return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly))
        }
        toArray() {
            return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(d, a) {
            d[a++] = this._tlx;
            d[a++] = this._tly;
            d[a++] = this._trx;
            d[a++] = this._try;
            d[a++] = this._brx;
            d[a++] = this._bry;
            d[a++] = this._blx;
            d[a] = this._bly
        }
        writeToTypedArray3D(d, a, b) {
            d[a++] = this._tlx;
            d[a++] = this._tly;
            d[a++] = b;
            d[a++] = this._trx;
            d[a++] = this._try;
            d[a++] = b;
            d[a++] = this._brx;
            d[a++] = this._bry;
            d[a++] = b;
            d[a++] = this._blx;
            d[a++] = this._bly;
            d[a] = b
        }
        offset(d, a) {
            d = +d;
            a = +a;
            this._tlx += d;
            this._tly += a;
            this._trx += d;
            this._try += a;
            this._brx += d;
            this._bry += a;
            this._blx += d;
            this._bly += a
        }
        round() {
            this._tlx = Math.round(this._tlx);
            this._tly = Math.round(this._tly);
            this._trx = Math.round(this._trx);
            this._try = Math.round(this._try);
            this._brx = Math.round(this._brx);
            this._bry = Math.round(this._bry);
            this._blx = Math.round(this._blx);
            this._bly = Math.round(this._bly)
        }
        floor() {
            this._tlx = Math.floor(this._tlx);
            this._tly = Math.floor(this._tly);
            this._trx = Math.floor(this._trx);
            this._try = Math.floor(this._try);
            this._brx = Math.floor(this._brx);
            this._bry = Math.floor(this._bry);
            this._blx = Math.floor(this._blx);
            this._bly = Math.floor(this._bly)
        }
        ceil() {
            this._tlx = Math.ceil(this._tlx);
            this._tly = Math.ceil(this._tly);
            this._trx = Math.ceil(this._trx);
            this._try =
                Math.ceil(this._try);
            this._brx = Math.ceil(this._brx);
            this._bry = Math.ceil(this._bry);
            this._blx = Math.ceil(this._blx);
            this._bly = Math.ceil(this._bly)
        }
        setFromRect(d) {
            this._tlx = d._left;
            this._tly = d._top;
            this._trx = d._right;
            this._try = d._top;
            this._brx = d._right;
            this._bry = d._bottom;
            this._blx = d._left;
            this._bly = d._bottom
        }
        setFromRotatedRect(d, a) {
            0 === a ? this.setFromRect(d) : this.setFromRotatedRectPrecalc(d, Math.sin(a), Math.cos(a))
        }
        setFromRotatedRectPrecalc(d, a, b) {
            const c = d._left * a,
                f = d._top * a,
                h = d._right * a;
            a *= d._bottom;
            const g = d._left * b,
                k = d._top * b,
                m = d._right * b;
            d = d._bottom * b;
            this._tlx = g - f;
            this._tly = k + c;
            this._trx = m - f;
            this._try = k + h;
            this._brx = m - a;
            this._bry = d + h;
            this._blx = g - a;
            this._bly = d + c
        }
        getBoundingBox(d) {
            d.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
        }
        containsPoint(d, a) {
            var b = this._trx - this._tlx,
                c = this._try - this._tly;
            const f = this._brx - this._tlx,
                h = this._bry - this._tly;
            d -= this._tlx;
            a -= this._tly;
            var g = b * b + c * c;
            let k = b * f + c * h;
            c = b * d + c * a;
            const m = f * f + h * h,
                r = f * d + h * a;
            let w = 1 / (g * m - k * k);
            b = (m * c - k * r) * w;
            g = (g * r - k * c) * w;
            if (0 <= b && 0 < g && 1 > b + g) return !0;
            b = this._blx - this._tlx;
            c = this._bly - this._tly;
            g = b * b + c * c;
            k = b * f + c * h;
            c = b * d + c * a;
            w = 1 / (g * m - k * k);
            b = (m * c - k * r) * w;
            g = (g * r - k * c) * w;
            return 0 <= b && 0 < g && 1 > b + g
        }
        midX() {
            return (this._tlx + this._trx + this._brx + this._blx) / 4
        }
        midY() {
            return (this._tly + this._try + this._bry + this._bly) / 4
        }
        intersectsSegment(d, a, b, c) {
            return this.containsPoint(d, a) || this.containsPoint(b, c) ?
                !0 : e.segmentIntersectsQuad(d, a, b, c, this)
        }
        intersectsQuad(d) {
            var a = d.midX(),
                b = d.midY();
            if (this.containsPoint(a, b)) return !0;
            a = this.midX();
            b = this.midY();
            if (d.containsPoint(a, b)) return !0;
            a = this._tlx;
            b = this._tly;
            const c = this._trx,
                f = this._try,
                h = this._brx,
                g = this._bry,
                k = this._blx,
                m = this._bly;
            return e.segmentIntersectsQuad(a, b, c, f, d) || e.segmentIntersectsQuad(c, f, h, g, d) || e.segmentIntersectsQuad(h, g, k, m, d) || e.segmentIntersectsQuad(k, m, a, b, d)
        }
        rotatePointsAnticlockwise() {
            const d = this._tlx,
                a = this._tly;
            this._tlx =
                this._trx;
            this._tly = this._try;
            this._trx = this._brx;
            this._try = this._bry;
            this._brx = this._blx;
            this._bry = this._bly;
            this._blx = d;
            this._bly = a
        }
        mirror() {
            this._swap(0, 2);
            this._swap(1, 3);
            this._swap(6, 4);
            this._swap(7, 5)
        }
        flip() {
            this._swap(0, 6);
            this._swap(1, 7);
            this._swap(2, 4);
            this._swap(3, 5)
        }
        diag() {
            this._swap(2, 6);
            this._swap(3, 7)
        }
        _swap(d, a) {
            const b = this._getAtIndex(d);
            this._setAtIndex(d, this._getAtIndex(a));
            this._setAtIndex(a, b)
        }
        _getAtIndex(d) {
            switch (d) {
                case 0:
                    return this._tlx;
                case 1:
                    return this._tly;
                case 2:
                    return this._trx;
                case 3:
                    return this._try;
                case 4:
                    return this._brx;
                case 5:
                    return this._bry;
                case 6:
                    return this._blx;
                case 7:
                    return this._bly;
                default:
                    throw new RangeError("invalid quad point index");
            }
        }
        _setAtIndex(d, a) {
            a = +a;
            switch (d) {
                case 0:
                    this._tlx = a;
                    break;
                case 1:
                    this._tly = a;
                    break;
                case 2:
                    this._trx = a;
                    break;
                case 3:
                    this._try = a;
                    break;
                case 4:
                    this._brx = a;
                    break;
                case 5:
                    this._bry = a;
                    break;
                case 6:
                    this._blx = a;
                    break;
                case 7:
                    this._bly = a;
                    break;
                default:
                    throw new RangeError("invalid quad point index");
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [0, 0, 1, 0, 1, 1, 0, 1],
        a = e.New(e.Quad);
    e.CollisionPoly = class extends e.DefendedBase {
        constructor(b, c = !0) {
            super();
            b || (b = d);
            this._ptsArr = Float64Array.from(b);
            this._bbox = new e.Rect;
            this._isBboxChanged = !0;
            this._enabled = c
        }
        Release() {}
        pointsArr() {
            return this._ptsArr
        }
        pointCount() {
            return this._ptsArr.length / 2
        }
        setPoints(b) {
            this._ptsArr.length === b.length ? this._ptsArr.set(b) : this._ptsArr = Float64Array.from(b);
            this._isBboxChanged = !0
        }
        setDefaultPoints() {
            this.setPoints(d)
        }
        copy(b) {
            this.setPoints(b._ptsArr)
        }
        setBboxChanged() {
            this._isBboxChanged = !0
        }
        _updateBbox() {
            if (this._isBboxChanged) {
                var b = this._ptsArr,
                    c = b[0],
                    f = b[1],
                    h = c,
                    g = f;
                for (let k = 0, m = b.length; k < m; k += 2) {
                    const r = b[k],
                        w = b[k + 1];
                    r < c && (c = r);
                    r > h && (h = r);
                    w < f && (f = w);
                    w > g && (g = w)
                }
                this._bbox.set(c, f, h, g);
                this._isBboxChanged = !1
            }
        }
        setFromRect(b, c, f) {
            let h = this._ptsArr;
            8 !== h.length && (this._ptsArr = h = new Float64Array(8));
            h[0] = b.getLeft() - c;
            h[1] = b.getTop() - f;
            h[2] = b.getRight() - c;
            h[3] = b.getTop() - f;
            h[4] = b.getRight() - c;
            h[5] = b.getBottom() - f;
            h[6] = b.getLeft() - c;
            h[7] = b.getBottom() - f;
            this._bbox.copy(b);
            0 === c && 0 ===
                f || this._bbox.offset(-c, -f);
            this._isBboxChanged = !1
        }
        setFromQuad(b, c, f) {
            a.copy(b);
            a.offset(c, f);
            this.setPoints(a.toArray());
            this._isBboxChanged = !0
        }
        transform(b, c, f) {
            let h = 0,
                g = 1;
            0 !== f && (h = Math.sin(f), g = Math.cos(f));
            this.transformPrecalc(b, c, h, g)
        }
        transformPrecalc(b, c, f, h) {
            const g = this._ptsArr;
            for (let k = 0, m = g.length; k < m; k += 2) {
                const r = k + 1,
                    w = g[k] * b,
                    p = g[r] * c;
                g[k] = w * h - p * f;
                g[r] = p * h + w * f
            }
            this._isBboxChanged = !0
        }
        offset(b, c) {
            const f = this._ptsArr;
            for (let h = 0, g = f.length; h < g; h += 2) f[h] += b, f[h + 1] += c
        }
        containsPoint(b, c) {
            const f =
                this._ptsArr;
            if (b === f[0] && c === f[1]) return !0;
            this._updateBbox();
            var h = this._bbox;
            const g = h.getLeft() - 110,
                k = h.getTop() - 101,
                m = h.getRight() + 131;
            h = h.getBottom() + 120;
            let r, w, p, t, u, q, x, y;
            g < b ? (r = g, p = b) : (r = b, p = g);
            k < c ? (w = k, t = c) : (w = c, t = k);
            m < b ? (u = m, x = b) : (u = b, x = m);
            h < c ? (q = h, y = c) : (q = c, y = h);
            let B = 0,
                F = 0;
            for (let K = 0, C = f.length; K < C; K += 2) {
                var H = (K + 2) % C;
                const A = f[K],
                    G = f[K + 1],
                    J = f[H];
                H = f[H + 1];
                e.segmentsIntersectPreCalc(g, k, b, c, r, p, w, t, A, G, J, H) && ++B;
                e.segmentsIntersectPreCalc(m, h, b, c, u, x, q, y, A, G, J, H) && ++F
            }
            return 1 === B % 2 ||
                1 === F % 2
        }
        intersectsPoly(b, c, f) {
            const h = b._ptsArr,
                g = this._ptsArr;
            if (this.containsPoint(h[0] + c, h[1] + f) || b.containsPoint(g[0] - c, g[1] - f)) return !0;
            for (let m = 0, r = g.length; m < r; m += 2) {
                var k = (m + 2) % r;
                b = g[m];
                const w = g[m + 1],
                    p = g[k];
                k = g[k + 1];
                let t, u, q, x;
                b < p ? (t = b, q = p) : (t = p, q = b);
                w < k ? (u = w, x = k) : (u = k, x = w);
                for (let y = 0, B = h.length; y < B; y += 2) {
                    const F = (y + 2) % B;
                    if (e.segmentsIntersectPreCalc(b, w, p, k, t, q, u, x, h[y] + c, h[y + 1] + f, h[F] + c, h[F + 1] + f)) return !0
                }
            }
            return !1
        }
        intersectsSegment(b, c, f, h, g, k) {
            if (this.containsPoint(f - b, h - c) || this.containsPoint(g -
                    b, k - c)) return !0;
            let m, r, w, p;
            f < g ? (m = f, w = g) : (m = g, w = f);
            h < k ? (r = h, p = k) : (r = k, p = h);
            const t = this._ptsArr;
            for (let u = 0, q = t.length; u < q; u += 2) {
                const x = (u + 2) % q;
                if (e.segmentsIntersectPreCalc(f, h, g, k, m, w, r, p, t[u] + b, t[u + 1] + c, t[x] + b, t[x + 1] + c)) return !0
            }
            return !1
        }
        mirror(b) {
            const c = this._ptsArr;
            for (let f = 0, h = c.length; f < h; f += 2) c[f] = 2 * b - c[f];
            this._isBboxChanged = !0
        }
        flip(b) {
            const c = this._ptsArr;
            for (let f = 0, h = c.length; f < h; f += 2) {
                const g = f + 1;
                c[g] = 2 * b - c[g]
            }
            this._isBboxChanged = !0
        }
        diag() {
            const b = this._ptsArr;
            for (let c = 0, f = b.length; c <
                f; c += 2) {
                const h = c + 1,
                    g = b[c];
                b[c] = b[h];
                b[h] = g
            }
            this._isBboxChanged = !0
        }
        GetMidX() {
            const b = this._ptsArr;
            let c = 0;
            for (let f = 0, h = b.length; f < h; f += 2) c += b[f];
            return c / this.pointCount()
        }
        GetMidY() {
            const b = this._ptsArr;
            let c = 0;
            for (let f = 0, h = b.length; f < h; f += 2) c += b[f + 1];
            return c / this.pointCount()
        }
        GetPointsArray() {
            return this._ptsArr
        }
        GetPointCount() {
            return this.pointCount()
        }
        IsEnabled() {
            return this._enabled
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PairMap = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._firstMap = new Map;
            if (d)
                for (const [a, b, c] of d) this.Set(a, b, c)
        }
        Release() {
            this.Clear();
            this._firstMap = null
        }
        Clear() {
            const d = this._firstMap;
            for (const a of d.values()) a.clear();
            d.clear()
        }
        Set(d, a, b) {
            const c = this._firstMap;
            let f = c.get(d);
            f || (f = new Map, c.set(d, f));
            f.set(a, b)
        }
        Get(d, a) {
            return (d = this._firstMap.get(d)) ? d.get(a) : d
        }
        Has(d, a) {
            return (d = this._firstMap.get(d)) ? d.has(a) : !1
        }
        Delete(d, a) {
            const b = this._firstMap,
                c = b.get(d);
            if (!c) return !1;
            (a = c.delete(a)) && 0 === c.size && b.delete(d);
            return a
        }
        DeleteEither(d) {
            const a = this._firstMap,
                b = a.get(d);
            b && (b.clear(), a.delete(d));
            for (const [c, f] of a.entries()) f.delete(d) && 0 === f.size && a.delete(c)
        }
        GetSize() {
            let d = 0;
            for (const a of this._firstMap.values()) d += a.size;
            return d
        }* values() {
            for (const d of this._firstMap.values()) yield* d.values()
        }* keyPairs() {
            for (const [d, a] of this._firstMap.entries())
                for (const b of a.keys()) yield [d, b]
        }* entries() {
            for (const [d, a] of this._firstMap.entries())
                for (const [b,
                        c
                    ] of a.entries()) yield [d, b, c]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ArraySet = class extends e.DefendedBase {
        constructor() {
            super();
            this._set = new Set;
            this._arr = [];
            this._needToRebuildArray = !1
        }
        Release() {
            this.Clear()
        }
        Clear() {
            this._set.clear();
            e.clearArray(this._arr);
            this._needToRebuildArray = !1
        }
        Add(d) {
            this._set.has(d) || (this._set.add(d), this._needToRebuildArray || this._arr.push(d))
        }
        Has(d) {
            return this._set.has(d)
        }
        Delete(d) {
            this._set.delete(d) && (this._needToRebuildArray = !0)
        }
        GetSize() {
            return this._set.size
        }
        IsEmpty() {
            return 0 === this._set.size
        }
        GetArray() {
            this._needToRebuildArray &&
                (this._RebuildArray(), this._needToRebuildArray = !1);
            return this._arr
        }
        _RebuildArray() {
            const d = this._arr;
            e.clearArray(d);
            for (const a of this._set) d.push(a)
        }
    }
} {
    "use strict";
    const e = new Map,
        d = new Map,
        a = new Map,
        b = new Map,
        c = new Map,
        f = new Map;
    f.set("linear", "noease");
    f.set("default", "noease");
    self.Ease = class p {
        constructor() {}
        static InheritEase() {
            return "default"
        }
        static DefaultEase() {
            return "noease"
        }
        static GetEditorEaseNames(t, ...u) {
            this._CreateEaseMap();
            a.has(t) || a.set(t, new Map);
            t = [...a.get(t).keys()];
            t.sort();
            return [...d.keys()].concat(t).filter(q => !u.includes(q))
        }
        static GetRuntimeEaseNames() {
            this._CreateEaseMap();
            const t = [...b.keys()];
            t.sort();
            return [...d.keys()].concat(t)
        }
        static IsNamePredefined(t) {
            this._CreateEaseMap();
            return [...d.keys()].includes(t)
        }
        static _GetEase(t) {
            const u = f.get(t);
            if (u) return e.get(u);
            if (p.IsNamePredefined(t)) return e.get(t);
            if (c.has(t)) return c.get(t)
        }
        static GetEditorEase(t, u) {
            this._CreateEaseMap();
            const q = p._GetEase(t);
            return q ? q : a.get(u).get(t)
        }
        static GetRuntimeEase(t) {
            this._CreateEaseMap();
            const u = p._GetEase(t);
            return u ? u : b.get(t)
        }
        static GetEaseFromIndex(t) {
            this._CreateEaseMap();
            return this.GetRuntimeEaseNames()[t]
        }
        static GetIndexForEase(t, u) {
            this._CreateEaseMap();
            return this.GetEditorEaseNames(u).indexOf(t)
        }
        static _CreateEaseMap() {
            0 ===
                e.size && (this._AddPredifinedEase("default", () => {}), this._AddPredifinedEase("noease", this.NoEase), this._AddPredifinedEase("easeinsine", this.EaseInSine), this._AddPredifinedEase("easeoutsine", this.EaseOutSine), this._AddPredifinedEase("easeinoutsine", this.EaseInOutSine), this._AddPredifinedEase("easeinelastic", this.EaseInElastic), this._AddPredifinedEase("easeoutelastic", this.EaseOutElastic), this._AddPredifinedEase("easeinoutelastic", this.EaseInOutElastic), this._AddPredifinedEase("easeinback", this.EaseInBack),
                    this._AddPredifinedEase("easeoutback", this.EaseOutBack), this._AddPredifinedEase("easeinoutback", this.EaseInOutBack), this._AddPredifinedEase("easeinbounce", this.EaseInBounce), this._AddPredifinedEase("easeoutbounce", this.EaseOutBounce), this._AddPredifinedEase("easeinoutbounce", this.EaseInOutBounce), this._AddPredifinedEase("easeincubic", this.EaseInCubic), this._AddPredifinedEase("easeoutcubic", this.EaseOutCubic), this._AddPredifinedEase("easeinoutcubic", this.EaseInOutCubic), this._AddPredifinedEase("easeinquad",
                        this.EaseInQuad), this._AddPredifinedEase("easeoutquad", this.EaseOutQuad), this._AddPredifinedEase("easeinoutquad", this.EaseInOutQuad), this._AddPredifinedEase("easeinquart", this.EaseInQuart), this._AddPredifinedEase("easeoutquart", this.EaseOutQuart), this._AddPredifinedEase("easeinoutquart", this.EaseInOutQuart), this._AddPredifinedEase("easeinquint", this.EaseInQuint), this._AddPredifinedEase("easeoutquint", this.EaseOutQuint), this._AddPredifinedEase("easeinoutquint", this.EaseInOutQuint), this._AddPredifinedEase("easeincirc",
                        this.EaseInCirc), this._AddPredifinedEase("easeoutcirc", this.EaseOutCirc), this._AddPredifinedEase("easeinoutcirc", this.EaseInOutCirc), this._AddPredifinedEase("easeinexpo", this.EaseInExpo), this._AddPredifinedEase("easeoutexpo", this.EaseOutExpo), this._AddPredifinedEase("easeinoutexpo", this.EaseInOutExpo), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline))
        }
        static _AddPredifinedEase(t, u) {
            p._AddEase(t, u, "predefined")
        }
        static _AddPrivateCustomEase(t,
            u) {
            p._AddEase(t, u, "private")
        }
        static AddCustomEase(t, u, q) {
            this._CreateEaseMap();
            p._AddEase(t, u, "custom", q)
        }
        static RemoveCustomEase(t, u) {
            this.IsNamePredefined(t) || [...c.keys()].includes(t) || (u = a.get(u)) && u.delete(t)
        }
        static _AddEase(t, u, q, x) {
            switch (q) {
                case "predefined":
                    e.set(t, u);
                    d.set(t, u);
                    break;
                case "custom":
                    x ? (a.has(x) || a.set(x, new Map), a.get(x).set(t, u)) : b.set(t, u);
                    break;
                case "private":
                    e.set(t, u);
                    c.set(t, u);
                    break;
                default:
                    throw Error("unexpected ease mode");
            }
        }
        static NoEase(t, u, q, x) {
            return q * t / x + u
        }
        static EaseInQuad(t,
            u, q, x) {
            return q * (t /= x) * t + u
        }
        static EaseOutQuad(t, u, q, x) {
            return -q * (t /= x) * (t - 2) + u
        }
        static EaseInOutQuad(t, u, q, x) {
            return 1 > (t /= x / 2) ? q / 2 * t * t + u : -q / 2 * (--t * (t - 2) - 1) + u
        }
        static EaseInCubic(t, u, q, x) {
            return q * (t /= x) * t * t + u
        }
        static EaseOutCubic(t, u, q, x) {
            return q * ((t = t / x - 1) * t * t + 1) + u
        }
        static EaseInOutCubic(t, u, q, x) {
            return 1 > (t /= x / 2) ? q / 2 * t * t * t + u : q / 2 * ((t -= 2) * t * t + 2) + u
        }
        static EaseInQuart(t, u, q, x) {
            return q * (t /= x) * t * t * t + u
        }
        static EaseOutQuart(t, u, q, x) {
            return -q * ((t = t / x - 1) * t * t * t - 1) + u
        }
        static EaseInOutQuart(t, u, q, x) {
            return 1 > (t /=
                x / 2) ? q / 2 * t * t * t * t + u : -q / 2 * ((t -= 2) * t * t * t - 2) + u
        }
        static EaseInQuint(t, u, q, x) {
            return q * (t /= x) * t * t * t * t + u
        }
        static EaseOutQuint(t, u, q, x) {
            return q * ((t = t / x - 1) * t * t * t * t + 1) + u
        }
        static EaseInOutQuint(t, u, q, x) {
            return 1 > (t /= x / 2) ? q / 2 * t * t * t * t * t + u : q / 2 * ((t -= 2) * t * t * t * t + 2) + u
        }
        static EaseInSine(t, u, q, x) {
            return -q * Math.cos(t / x * (Math.PI / 2)) + q + u
        }
        static EaseOutSine(t, u, q, x) {
            return q * Math.sin(t / x * (Math.PI / 2)) + u
        }
        static EaseInOutSine(t, u, q, x) {
            return -q / 2 * (Math.cos(Math.PI * t / x) - 1) + u
        }
        static EaseInExpo(t, u, q, x) {
            return 0 === t ? u : q * Math.pow(2,
                10 * (t / x - 1)) + u
        }
        static EaseOutExpo(t, u, q, x) {
            return t === x ? u + q : q * (-Math.pow(2, -10 * t / x) + 1) + u
        }
        static EaseInOutExpo(t, u, q, x) {
            return 0 === t ? u : t === x ? u + q : 1 > (t /= x / 2) ? q / 2 * Math.pow(2, 10 * (t - 1)) + u : q / 2 * (-Math.pow(2, -10 * --t) + 2) + u
        }
        static EaseInCirc(t, u, q, x) {
            return -q * (Math.sqrt(1 - (t /= x) * t) - 1) + u
        }
        static EaseOutCirc(t, u, q, x) {
            return q * Math.sqrt(1 - (t = t / x - 1) * t) + u
        }
        static EaseInOutCirc(t, u, q, x) {
            return 1 > (t /= x / 2) ? -q / 2 * (Math.sqrt(1 - t * t) - 1) + u : q / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + u
        }
        static EaseInElastic(t, u, q, x) {
            let y = 0,
                B = q;
            if (0 === t) return u;
            if (1 === (t /= x)) return u + q;
            y || (y = .3 * x);
            B < Math.abs(q) ? (B = q, q = y / 4) : q = y / (2 * Math.PI) * Math.asin(q / B);
            return -(B * Math.pow(2, 10 * --t) * Math.sin(2 * (t * x - q) * Math.PI / y)) + u
        }
        static EaseOutElastic(t, u, q, x) {
            let y, B = 0,
                F = q;
            if (0 === t) return u;
            if (1 === (t /= x)) return u + q;
            B || (B = .3 * x);
            F < Math.abs(q) ? (F = q, y = B / 4) : y = B / (2 * Math.PI) * Math.asin(q / F);
            return F * Math.pow(2, -10 * t) * Math.sin(2 * (t * x - y) * Math.PI / B) + q + u
        }
        static EaseInOutElastic(t, u, q, x) {
            let y, B = 0,
                F = q;
            if (0 === t) return u;
            if (2 === (t /= x / 2)) return u + q;
            B || (B = .3 * x * 1.5);
            F < Math.abs(q) ? (F = q,
                y = B / 4) : y = B / (2 * Math.PI) * Math.asin(q / F);
            return 1 > t ? -.5 * F * Math.pow(2, 10 * --t) * Math.sin(2 * (t * x - y) * Math.PI / B) + u : F * Math.pow(2, -10 * --t) * Math.sin(2 * (t * x - y) * Math.PI / B) * .5 + q + u
        }
        static EaseInBack(t, u, q, x, y) {
            void 0 === y && (y = 1.70158);
            return q * (t /= x) * t * ((y + 1) * t - y) + u
        }
        static EaseOutBack(t, u, q, x, y) {
            void 0 === y && (y = 1.70158);
            return q * ((t = t / x - 1) * t * ((y + 1) * t + y) + 1) + u
        }
        static EaseInOutBack(t, u, q, x, y) {
            void 0 === y && (y = 1.70158);
            return 1 > (t /= x / 2) ? q / 2 * t * t * (((y *= 1.525) + 1) * t - y) + u : q / 2 * ((t -= 2) * t * (((y *= 1.525) + 1) * t + y) + 2) + u
        }
        static EaseInBounce(t,
            u, q, x) {
            return q - p.EaseOutBounce(x - t, 0, q, x) + u
        }
        static EaseOutBounce(t, u, q, x) {
            return (t /= x) < 1 / 2.75 ? 7.5625 * q * t * t + u : t < 2 / 2.75 ? q * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + u : t < 2.5 / 2.75 ? q * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + u : q * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + u
        }
        static EaseInOutBounce(t, u, q, x) {
            return t < x / 2 ? .5 * p.EaseInBounce(2 * t, 0, q, x) + u : .5 * p.EaseOutBounce(2 * t - x, 0, q, x) + .5 * q + u
        }
        static EaseCubicBezier(t, u, q, x, y) {
            return u + 3 * t * (q - u) + 3 * t ** 2 * (u + x - 2 * q) + t ** 3 * (y - u + 3 * q - 3 * x)
        }
        static EaseSpline(t, u, q, x, y, B, F, H, K, C) {
            if (x === y && B === F) return t;
            t = w(t, u, x, B, H, C);
            u = h(q, y, F, K);
            x = g(q, y, F, K);
            q = k(q, y, F, K);
            return m(t, u, x, q)
        }
        static GetBezierSamples(t, u, q, x) {
            const y = [],
                B = h(t, u, q, x),
                F = g(t, u, q, x);
            t = k(t, u, q, x);
            for (u = 0; 11 > u; ++u) q = m(.1 * u, B, F, t), y.push(q);
            return y
        }
    };
    const h = (p, t, u, q) => q - 3 * u + 3 * t - p,
        g = (p, t, u, q) => 3 * u - 6 * t + 3 * p,
        k = (p, t, u, q) => 3 * (t - p),
        m = (p, t, u, q) => ((t * p + u) * p + q) * p,
        r = (p, t, u, q) => 3 * t * p * p + 2 * u * p + q,
        w = (p, t, u, q, x, y) => {
            if (1 == p) return 1;
            for (var B = 0, F = 1, H = y[F]; 10 != F && H <= p;) F++, H = y[F], B += .1;
            F--;
            H = y[F];
            y = B + (p - H) / (y[F + 1] - H) * .1;
            F = h(t, u, q, x);
            H = g(t, u, q, x);
            t = k(t,
                u, q, x);
            u = r(y, F, H, t);
            if (0 !== u)
                if (.02 <= u)
                    for (B = 0; 4 > B; ++B) u = m(y, F, H, t) - p, q = r(y, F, H, t), y -= u / q;
                else {
                    u = B;
                    B += .1;
                    q = 0;
                    let K;
                    do y = u + (B - u) / 2, x = m(y, F, H, t) - p, 0 < x ? B = y : u = y, x = 1E-7 < Math.abs(x), K = 10 > ++q; while (x && K)
                }
            return y
        }
} {
    "use strict";
    const e = self.C3;

    function d(a) {
        e.IsString(a)
    }
    e.ProbabilityTable = class {
        constructor() {
            this._items = [];
            this._totalWeight = 0
        }
        Release() {
            this.Clear();
            this._items = null
        }
        Clear() {
            e.clear2DArray(this._items);
            this._totalWeight = 0
        }
        GetTotalWeight() {
            return this._totalWeight
        }
        Sample(a = Math.random() * this.GetTotalWeight()) {
            let b = 0;
            for (const [c, f] of this._items)
                if (b += c, a < b) return f;
            return 0
        }
        AddItem(a, b) {
            d(b);
            this._totalWeight += a;
            this._items.push([a, b])
        }
        RemoveItem(a, b) {
            d(b);
            const c = 0 === a;
            for (let f = 0; f < this._items.length; f++) {
                const h =
                    this._items[f],
                    g = h[1] === b;
                if ((c || h[0] === a) && g) {
                    this._items.splice(f, 1);
                    this._totalWeight -= h[0];
                    break
                }
            }
        }
        asJSON() {
            return JSON.stringify(this._items)
        }
        static fromJSON(a) {
            const b = new e.ProbabilityTable;
            a = JSON.parse(a);
            for (const c of a) b.AddItem(c[0], c[1]);
            return b
        }
    }
}
"use strict";
self.C3.Event = class {
    constructor(e, d) {
        this.type = e;
        this.cancelable = !!d;
        this.isAsync = this.propagationStopped = this.defaultPrevented = !1
    }
    preventDefault() {
        if (!this.cancelable) throw Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation() {
        if (!this.cancelable) throw Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync) throw Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
}; {
    "use strict";
    const e = self.C3;
    e.Event.Handler = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._type = d;
            this._captureListeners = [];
            this._captureListenersSet = new Set;
            this._listeners = [];
            this._listenersSet = new Set;
            this._fireDepth = 0;
            this._queueModifyListeners = []
        }
        Release() {
            0 < this._fireDepth || (e.clearArray(this._captureListeners), this._captureListenersSet.clear(), e.clearArray(this._listeners), this._listenersSet.clear(), e.clearArray(this._queueModifyListeners), e.Release(this))
        }
        _AddListener(d, a) {
            this._IsFiring() ?
                this._queueModifyListeners.push({
                    op: "add",
                    func: d,
                    capture: a
                }) : a ? this._captureListenersSet.has(d) || (this._captureListeners.push(d), this._captureListenersSet.add(d)) : this._listenersSet.has(d) || (this._listeners.push(d), this._listenersSet.add(d))
        }
        _RemoveListener(d, a) {
            this._IsFiring() ? this._queueModifyListeners.push({
                op: "remove",
                func: d,
                capture: a
            }) : a ? this._captureListenersSet.has(d) && (this._captureListenersSet.delete(d), e.arrayFindRemove(this._captureListeners, d)) : this._listenersSet.has(d) && (this._listenersSet.delete(d),
                e.arrayFindRemove(this._listeners, d))
        }
        _IsEmpty() {
            return !this._captureListeners.length && !this._listeners.length
        }
        _IsFiring() {
            return 0 < this._fireDepth
        }
        _ProcessQueuedListeners() {
            const d = new Set,
                a = new Set;
            for (const b of this._queueModifyListeners)
                if ("add" === b.op) this._AddListener(b.func, b.capture), b.capture ? a.delete(b.func) : d.delete(b.func);
                else if ("remove" === b.op) b.capture ? (this._captureListenersSet.delete(b.func), a.add(b.func)) : (this._listenersSet.delete(b.func), d.add(b.func));
            else throw Error("invalid op");
            e.arrayRemoveAllInSet(this._listeners, d);
            e.arrayRemoveAllInSet(this._captureListeners, a);
            e.clearArray(this._queueModifyListeners)
        }
        _FireCancellable(d) {
            this._IncreaseFireDepth();
            let a = !1;
            for (let b = 0, c = this._captureListeners.length; b < c; ++b)
                if (this._captureListeners[b](d), d.propagationStopped) {
                    a = !0;
                    break
                }
            if (!a)
                for (let b = 0, c = this._listeners.length; b < c && (this._listeners[b](d), !d.propagationStopped); ++b);
            this._DecreaseFireDepth();
            return !d.defaultPrevented
        }
        _FireNonCancellable(d) {
            this._IncreaseFireDepth();
            for (let a = 0, b = this._captureListeners.length; a < b; ++a) this._captureListeners[a](d);
            for (let a = 0, b = this._listeners.length; a < b; ++a) this._listeners[a](d);
            this._DecreaseFireDepth();
            return !0
        }
        _IncreaseFireDepth() {
            this._fireDepth++
        }
        _DecreaseFireDepth() {
            this._fireDepth--;
            0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners()
        }
        SetDelayRemoveEventsEnabled(d) {
            d ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
        }
        _FireAsync(d) {
            let a = [];
            for (let b = 0, c = this._captureListeners.length; b <
                c; ++b) {
                let f = this._captureListeners[b];
                a.push(e.Asyncify(() => f(d)))
            }
            for (let b = 0, c = this._listeners.length; b < c; ++b) {
                let f = this._listeners[b];
                a.push(e.Asyncify(() => f(d)))
            }
            return Promise.all(a).then(() => !d.defaultPrevented)
        }
        _FireAndWait_AsyncOptional(d) {
            const a = [];
            this._IncreaseFireDepth();
            for (let c = 0, f = this._captureListeners.length; c < f; ++c) {
                var b = this._captureListeners[c](d);
                b instanceof Promise && a.push(b)
            }
            for (let c = 0, f = this._listeners.length; c < f; ++c) b = this._listeners[c](d), b instanceof Promise && a.push(b);
            this._DecreaseFireDepth();
            return a.length ? Promise.all(a).then(() => !d.defaultPrevented) : !d.defaultPrevented
        }
        async _FireAndWaitAsync(d) {
            return await this._FireAndWait_AsyncOptional(d)
        }
        async _FireAndWaitAsyncSequential(d) {
            this._IncreaseFireDepth();
            for (let b = 0, c = this._captureListeners.length; b < c; ++b) {
                var a = this._captureListeners[b](d);
                a instanceof Promise && await a
            }
            for (let b = 0, c = this._listeners.length; b < c; ++b) a = this._listeners[b](d), a instanceof Promise && await a;
            this._DecreaseFireDepth();
            return !d.defaultPrevented
        }* _FireAsGenerator(d) {
            this._IncreaseFireDepth();
            for (let b = 0, c = this._captureListeners.length; b < c; ++b) {
                var a = this._captureListeners[b](d);
                e.IsIterator(a) && (yield* a)
            }
            for (let b = 0, c = this._listeners.length; b < c; ++b) a = this._listeners[b](d), e.IsIterator(a) && (yield* a);
            this._DecreaseFireDepth()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Event.Dispatcher = class extends e.DefendedBase {
        constructor() {
            super();
            this._eventHandlers = new Map;
            this._dispatcherWasReleased = !1
        }
        Release() {
            if (this._dispatcherWasReleased) throw Error("already released");
            this.ClearEvents();
            this._dispatcherWasReleased = !0;
            e.Release(this)
        }
        WasReleased() {
            return this._dispatcherWasReleased
        }
        ClearEvents() {
            for (let d of this._eventHandlers.values()) d.Release();
            this._eventHandlers.clear()
        }
        _GetHandlerByType(d, a) {
            let b = this._eventHandlers.get(d);
            return b ?
                b : a ? (b = e.New(e.Event.Handler, d), this._eventHandlers.set(d, b), b) : null
        }
        HasAnyHandlerFor(d) {
            return this._eventHandlers.has(d)
        }
        addEventListener(d, a, b) {
            this._GetHandlerByType(d, !0)._AddListener(a, !!b)
        }
        removeEventListener(d, a, b) {
            let c = this._GetHandlerByType(d, !1);
            c && (c._RemoveListener(a, !!b), c._IsEmpty() && this._eventHandlers.delete(d))
        }
        dispatchEvent(d) {
            const a = this._GetHandlerByType(d.type, !1);
            return a ? d.cancelable ? a._FireCancellable(d) : a._FireNonCancellable(d) : !0
        }
        dispatchEventAsync(d) {
            const a = this._GetHandlerByType(d.type, !1);
            if (!a) return Promise.resolve(!0);
            d.isAsync = !0;
            return a._FireAsync(d)
        }
        async dispatchEventAndClearAsync(d) {
            const a = this._GetHandlerByType(d.type, !1);
            if (!a) return !0;
            this._eventHandlers.delete(d.type);
            d.isAsync = !0;
            d = await a._FireAsync(d);
            a.Release();
            return d
        }
        async dispatchEventAndWaitAsync(d) {
            const a = this._GetHandlerByType(d.type, !1);
            return a ? await a._FireAndWaitAsync(d) : !0
        }
        dispatchEventAndWait_AsyncOptional(d) {
            const a = this._GetHandlerByType(d.type, !1);
            return a ? a._FireAndWait_AsyncOptional(d) : !0
        }
        async dispatchEventAndWaitAsyncSequential(d) {
            const a =
                this._GetHandlerByType(d.type, !1);
            return a ? await a._FireAndWaitAsyncSequential(d) : !0
        }
        dispatchGeneratorEvent(d) {
            const a = this._GetHandlerByType(d.type, !1);
            if (!a) return null;
            if (d.cancelable) throw Error("not supported");
            return a._FireAsGenerator(d)
        }
        SetDelayRemoveEventsEnabled(d) {
            for (const a of this._eventHandlers.values()) a.SetDelayRemoveEventsEnabled(d)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = "undefined" !== typeof requestIdleCallback;
    let a = [],
        b = -1,
        c = 0;

    function f(m) {
        b = d && 0 === c ? requestIdleCallback(h, {
            timeout: 35
        }) : setTimeout(h, 0 < c ? 1 : m)
    }

    function h(m) {
        b = -1;
        if (a.length) {
            var r = performance.now(),
                w = 0;
            do {
                g(a.shift());
                var p = performance.now();
                ++w;
                var t = (p - r) / w * 1.1
            } while (a.length && (d && 0 === c && "undefined" !== typeof m ? t < m.timeRemaining() : 12 > p - r + t)); - 1 === b && a.length && f(Math.max(16 - (p - r), 4))
        }
    }

    function g(m) {
        let r;
        try {
            r = m.func()
        } catch (w) {
            m.reject(w);
            return
        }
        m.resolve(r)
    }
    let k =
        e.QueryString.Has("disable-asyncify");
    k && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");
    e.Asyncify = function(m) {
        let r = null;
        e.isDebug && (r = e.GetCallStack());
        return new Promise((w, p) => {
            a.push({
                func: m,
                resolve: w,
                reject: p,
                stack: r
            });
            k ? g(a.pop()) : -1 === b && f(16)
        })
    };
    e.Asyncify.SetHighThroughputMode = function(m) {
        if (m) ++c;
        else if (--c, 0 > c) throw Error("already turned off high throughput mode");
    }
} {
    "use strict";
    const e = self.C3;
    let d = -1;

    function a() {
        d = -1
    }
    e.FastGetDateNow = function() {
        -1 === d && (d = Date.now(), self.setTimeout(a, 16));
        return d
    };
    let b = -1,
        c = -1,
        f = new Set;

    function h() {
        c = b = -1;
        let g = Date.now();
        for (let k of f)
            if (k._CheckTimeout(g)) {
                let m = k._GetDeadline();
                if (-1 === c || m < c) c = m
            } else f.delete(k); - 1 !== c && (b = self.setTimeout(h, Math.max(c - g + 100, 1E3)))
    }
    e.IdleTimeout = class {
        constructor(g, k) {
            this._callback = g;
            this._timeout = 1E3 * k;
            this._deadline = 0;
            this._isActive = !1
        }
        Reset() {
            let g = e.FastGetDateNow();
            this._deadline =
                g + this._timeout;
            this._isActive || (f.add(this), this._isActive = !0); - 1 === b ? (c = this._deadline, b = self.setTimeout(h, this._timeout + 100)) : this._deadline < c && c > g + 1E3 && (self.clearTimeout(b), c = this._deadline, b = self.setTimeout(h, this._timeout + 100))
        }
        _CheckTimeout(g) {
            return g >= this._deadline ? this._callback() ? (this._deadline = g + this._timeout, !0) : this._isActive = !1 : !0
        }
        _GetDeadline() {
            return this._deadline
        }
        Cancel() {
            this._isActive && (f.delete(this), this._isActive = !1, 0 === f.size && -1 !== b && (self.clearTimeout(b), c = b = -1))
        }
        Release() {
            this.Cancel();
            this._callback = null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Disposable = class d {
        constructor(a) {
            this._disposed = !1;
            this._disposeAction = a
        }
        Dispose() {
            this._disposed || (this._disposed = !0, this._disposeAction && (this._disposeAction(), this._disposeAction = null))
        }
        IsDisposed() {
            return this._disposed
        }
        Release() {
            this.Dispose()
        }
        static Release(a) {
            return new d(() => a.Release())
        }
        static From(a, b, c, f, h) {
            if ("undefined" === typeof f || null === f) f = !1;
            else if ("boolean" !== typeof f && "object" !== typeof f) throw new TypeError("invalid event listener options");
            h &&
                (c = c.bind(h));
            if (b.includes(" ")) {
                b = b.split(" ");
                h = new e.CompositeDisposable;
                for (let g of b) a.addEventListener(g, c, f), h.Add(e.New(e.Disposable, () => a.removeEventListener(g, c, f)));
                return h
            }
            a.addEventListener(b, c, f);
            return e.New(e.Disposable, () => a.removeEventListener(b, c, f))
        }
    };
    e.StubDisposable = class extends e.Disposable {
        SetAction(d) {
            this._disposeAction = d
        }
    };
    e.CompositeDisposable = class extends e.Disposable {
        constructor(...d) {
            super();
            this._disposables = new Set;
            for (let a of d) this.Add(a)
        }
        Add(...d) {
            if (this._disposed) throw Error("already disposed");
            for (let a of d) this._disposables.add(a)
        }
        Remove(d) {
            if (this._disposed) throw Error("already disposed");
            this._disposables.delete(d)
        }
        RemoveAll() {
            if (this._disposed) throw Error("already disposed");
            if (this._disposables) {
                for (let d of this._disposables) d.Dispose();
                this._disposables.clear()
            }
        }
        IsDisposed() {
            return this._disposed
        }
        Dispose() {
            if (this._disposed) throw Error("already disposed");
            this._disposed = !0;
            for (let d of this._disposables) d.Dispose();
            this._disposables.clear();
            this._disposables = null
        }
        Release() {
            this.Dispose()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.KahanSum = class extends e.DefendedBase {
        constructor() {
            super();
            this._sum = this._t = this._y = this._c = 0
        }
        Add(d) {
            this._y = +d - this._c;
            this._t = this._sum + this._y;
            this._c = this._t - this._sum - this._y;
            this._sum = this._t
        }
        Subtract(d) {
            this._sum -= +d
        }
        Get() {
            return this._sum
        }
        Reset() {
            this._sum = this._t = this._y = this._c = 0
        }
        Set(d) {
            this._t = this._y = this._c = 0;
            this._sum = +d
        }
        Release() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = {
            RBnode: function(a) {
                this.tree = a;
                this.left = this.right = this.tree.sentinel;
                this.parent = null;
                this.color = !1;
                this.key = null
            },
            RedBlackSet: function(a) {
                this.size = 0;
                this.sentinel = new d.RBnode(this);
                this.sentinel.color = !1;
                this.root = this.sentinel;
                this.root.parent = this.sentinel;
                this.compare = a || this.default_compare
            }
        };
    d.RedBlackSet.prototype.default_compare = function(a, b) {
        return a < b ? -1 : b < a ? 1 : 0
    };
    d.RedBlackSet.prototype.clone = function() {
        var a = new d.RedBlackSet(this.compare);
        a.insertAll(this);
        return a
    };
    d.RedBlackSet.prototype.clear = function() {
        this.size = 0;
        this.sentinel = new d.RBnode(this);
        this.sentinel.color = !1;
        this.root = this.sentinel;
        this.root.parent = this.sentinel
    };
    d.RedBlackSet.prototype.leftRotate = function(a) {
        var b = a.right;
        a.right = b.left;
        b.left != this.sentinel && (b.left.parent = a);
        b.parent = a.parent;
        a.parent == this.sentinel ? this.root = b : a == a.parent.left ? a.parent.left = b : a.parent.right = b;
        b.left = a;
        a.parent = b
    };
    d.RedBlackSet.prototype.rightRotate = function(a) {
        var b = a.left;
        a.left = b.right;
        b.right !=
            this.sentinel && (b.right.parent = a);
        b.parent = a.parent;
        a.parent == this.sentinel ? this.root = b : a == a.parent.right ? a.parent.right = b : a.parent.left = b;
        b.right = a;
        a.parent = b
    };
    d.RedBlackSet.prototype.insert = function(a) {
        if (this.contains(a)) this.get_(a).key = a;
        else {
            var b = new d.RBnode(this);
            b.key = a;
            a = this.sentinel;
            for (var c = this.root; c != this.sentinel;) a = c, c = 0 > this.compare(b.key, c.key) ? c.left : c.right;
            b.parent = a;
            a == this.sentinel ? this.root = b : 0 > this.compare(b.key, a.key) ? a.left = b : a.right = b;
            b.left = this.sentinel;
            b.right = this.sentinel;
            b.color = !0;
            this.insertFixup(b);
            this.size++
        }
    };
    d.RedBlackSet.prototype.insertFixup = function(a) {
        for (; a != this.sentinel && a != this.root && 1 == a.parent.color;)
            if (a.parent == a.parent.parent.left) {
                var b = a.parent.parent.right;
                1 == b.color ? (a.parent.color = !1, b.color = !1, a.parent.parent.color = !0, a = a.parent.parent) : (a == a.parent.right && (a = a.parent, this.leftRotate(a)), a.parent.color = !1, a.parent.parent.color = !0, a.parent.parent != this.sentinel && this.rightRotate(a.parent.parent))
            } else b = a.parent.parent.left, 1 == b.color ? (a.parent.color = !1, b.color = !1, a.parent.parent.color = !0, a = a.parent.parent) : (a == a.parent.left && (a = a.parent, this.rightRotate(a)), a.parent.color = !1, a.parent.parent.color = !0, a.parent.parent != this.sentinel && this.leftRotate(a.parent.parent));
        this.root.color = !1
    };
    d.RedBlackSet.prototype.delete_ = function(a) {
        var b = a.left == this.sentinel || a.right == this.sentinel ? a : this.successor_(a);
        var c = b.left != this.sentinel ? b.left : b.right;
        c.parent = b.parent;
        b.parent == this.sentinel ? this.root = c : b == b.parent.left ? b.parent.left = c : b.parent.right =
            c;
        b != a && (a.key = b.key);
        0 == b.color && this.deleteFixup(c);
        this.size--
    };
    d.RedBlackSet.prototype.deleteFixup = function(a) {
        for (; a != this.root && 0 == a.color;)
            if (a == a.parent.left) {
                var b = a.parent.right;
                1 == b.color && (b.color = !1, a.parent.color = !0, this.leftRotate(a.parent), b = a.parent.right);
                0 == b.left.color && 0 == b.right.color ? (b.color = !0, a = a.parent) : (0 == b.right.color && (b.left.color = !1, b.color = !0, this.rightRotate(b), b = a.parent.right), b.color = a.parent.color, a.parent.color = !1, b.right.color = !1, this.leftRotate(a.parent),
                    a = this.root)
            } else b = a.parent.left, 1 == b.color && (b.color = !1, a.parent.color = !0, this.rightRotate(a.parent), b = a.parent.left), 0 == b.right.color && 0 == b.left.color ? (b.color = !0, a = a.parent) : (0 == b.left.color && (b.right.color = !1, b.color = !0, this.leftRotate(b), b = a.parent.left), b.color = a.parent.color, a.parent.color = !1, b.left.color = !1, this.rightRotate(a.parent), a = this.root);
        a.color = !1
    };
    d.RedBlackSet.prototype.remove = function(a) {
        a = this.get_(a);
        if (a != this.sentinel) {
            var b = a.key;
            this.delete_(a);
            return b
        }
        return null
    };
    d.RedBlackSet.prototype.removeSwapped =
        function(a, b) {
            this.remove(b)
        };
    d.RedBlackSet.prototype.min = function(a) {
        for (; a.left != this.sentinel;) a = a.left;
        return a
    };
    d.RedBlackSet.prototype.max = function(a) {
        for (; a.right != this.sentinel;) a = a.right;
        return a
    };
    d.RedBlackSet.prototype.successor_ = function(a) {
        if (a.right != this.sentinel) return this.min(a.right);
        for (var b = a.parent; b != this.sentinel && a == b.right;) a = b, b = b.parent;
        return b
    };
    d.RedBlackSet.prototype.predeccessor_ = function(a) {
        if (a.left != this.sentinel) return this.max(a.left);
        for (var b = a.parent; b != this.sentinel &&
            a == b.left;) a = b, b = b.parent;
        return b
    };
    d.RedBlackSet.prototype.successor = function(a) {
        if (0 < this.size) {
            a = this.get_(a);
            if (a == this.sentinel) return null;
            if (a.right != this.sentinel) return this.min(a.right).key;
            for (var b = a.parent; b != this.sentinel && a == b.right;) a = b, b = b.parent;
            return b != this.sentinel ? b.key : null
        }
        return null
    };
    d.RedBlackSet.prototype.predecessor = function(a) {
        if (0 < this.size) {
            a = this.get_(a);
            if (a == this.sentinel) return null;
            if (a.left != this.sentinel) return this.max(a.left).key;
            for (var b = a.parent; b != this.sentinel &&
                a == b.left;) a = b, b = b.parent;
            return b != this.sentinel ? b.key : null
        }
        return null
    };
    d.RedBlackSet.prototype.getMin = function() {
        return this.min(this.root).key
    };
    d.RedBlackSet.prototype.getMax = function() {
        return this.max(this.root).key
    };
    d.RedBlackSet.prototype.get_ = function(a) {
        for (var b = this.root; b != this.sentinel && 0 != this.compare(b.key, a);) b = 0 > this.compare(a, b.key) ? b.left : b.right;
        return b
    };
    d.RedBlackSet.prototype.contains = function(a) {
        return null != this.get_(a).key
    };
    d.RedBlackSet.prototype.getValues = function() {
        var a = [];
        this.forEach(function(b) {
            a.push(b)
        });
        return a
    };
    d.RedBlackSet.prototype.insertAll = function(a) {
        if ("array" == d.typeOf(a))
            for (var b = 0; b < a.length; b++) this.insert(a[b]);
        else if ("function" == d.typeOf(a.forEach)) a.forEach(this.insert, this);
        else if ("function" == d.typeOf(a.getValues))
            for (a = a.getValues(), b = 0; b < a.length; b++) this.insert(a[b]);
        else if ("object" == d.typeOf(a))
            for (b in a) this.insert(a[b])
    };
    d.RedBlackSet.prototype.removeAll = function(a) {
        if ("array" == d.typeOf(a))
            for (var b = 0; b < a.length; b++) this.remove(a[b]);
        else if ("function" == d.typeOf(a.forEach)) a.forEach(this.removeSwapped, this);
        else if ("function" == d.typeOf(a.getValues))
            for (a = a.getValues(), b = 0; b < a.length; b++) this.remove(a[b]);
        else if ("object" == d.typeOf(a))
            for (b in a) this.remove(a[b])
    };
    d.RedBlackSet.prototype.containsAll = function(a) {
        if ("array" == d.typeOf(a)) {
            for (var b = 0; b < a.length; b++)
                if (!this.contains(a[b])) return !1;
            return !0
        }
        if ("function" == d.typeOf(a.forEach)) return a.every(this.contains, this);
        if ("function" == d.typeOf(a.getValues)) {
            a = a.getValues();
            for (b =
                0; b < a.length; b++)
                if (!this.contains(a[b])) return !1;
            return !0
        }
        if ("object" == d.typeOf(a)) {
            for (b in a)
                if (!this.contains(a[b])) return !1;
            return !0
        }
    };
    d.RedBlackSet.prototype.range = function(a, b) {
        var c = [];
        this.traverseFromTo(function(f) {
            c.push(f)
        }, a, b);
        return c
    };
    d.RedBlackSet.prototype.traverse = function(a, b) {
        if (!this.isEmpty())
            for (var c = this.min(this.root); c != this.sentinel && !a.call(b, c.key, this);) c = this.successor_(c)
    };
    d.RedBlackSet.prototype.traverseFrom = function(a, b, c) {
        if (!this.isEmpty())
            for (b = this.get_(b); b !=
                this.sentinel && !a.call(c, b.key, this);) b = this.successor_(b)
    };
    d.RedBlackSet.prototype.traverseTo = function(a, b, c) {
        if (!this.isEmpty()) {
            var f = this.min(this.root);
            for (b = this.get_(b); f != b && !a.call(c, f.key, this);) f = this.successor_(f)
        }
    };
    d.RedBlackSet.prototype.traverseFromTo = function(a, b, c, f) {
        if (!this.isEmpty())
            for (b = this.get_(b), c = this.get_(c); b != c && !a.call(f, b.key, this);) b = this.successor_(b)
    };
    d.RedBlackSet.prototype.traverseBackwards = function(a, b) {
        if (!this.isEmpty())
            for (var c = this.max(this.root); c != this.sentinel &&
                !a.call(b, c.key, this);) c = this.predeccessor_(c)
    };
    d.RedBlackSet.prototype.forEach = function(a, b) {
        if (!this.isEmpty())
            for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) a.call(b, c.key, c.key, this)
    };
    d.RedBlackSet.prototype.some = function(a, b) {
        if (this.isEmpty()) return !1;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
            if (a.call(b, c.key, c.key, this)) return !0;
        return !1
    };
    d.RedBlackSet.prototype.every = function(a, b) {
        if (this.isEmpty()) return !1;
        for (var c = this.min(this.root); c != this.sentinel; c =
            this.successor_(c))
            if (!a.call(b, c.key, c.key, this)) return !1;
        return !0
    };
    d.RedBlackSet.prototype.map = function(a, b) {
        var c = [];
        if (this.isEmpty()) return c;
        for (var f = this.min(this.root); f != this.sentinel; f = this.successor_(f)) c.push(a.call(b, f.key, f.key, this));
        return c
    };
    d.RedBlackSet.prototype.filter = function(a, b) {
        var c = [];
        if (this.isEmpty()) return c;
        for (var f = this.min(this.root); f != this.sentinel; f = this.successor_(f)) a.call(b, f.key, f.key, this) && c.push(f.key);
        return c
    };
    d.RedBlackSet.prototype.getCount = function() {
        return this.size
    };
    d.RedBlackSet.prototype.isEmpty = function() {
        return 0 == this.size
    };
    d.RedBlackSet.prototype.isSubsetOf = function(a) {
        var b = d.getCount(a);
        if (this.getCount() > b) return !1;
        b = 0;
        if (this.isEmpty()) return !0;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) d.contains.call(a, a, c.key) && b++;
        return b == this.getCount()
    };
    d.RedBlackSet.prototype.intersection = function(a) {
        var b = new d.RedBlackSet(this.compare);
        if (this.isEmpty()) return b;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) a.contains.call(a,
            c.key, c.key, this) && b.insert(c.key);
        return b
    };
    e.RedBlackSet = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._rbSet = new d.RedBlackSet(a);
            this._enableQueue = !1;
            this._queueInsert = new Set;
            this._queueRemove = new Set
        }
        Add(a) {
            this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.delete(a) : this._queueInsert.add(a) : this._rbSet.insert(a)
        }
        Remove(a) {
            this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.add(a) : this._queueInsert.delete(a) : this._rbSet.remove(a)
        }
        Has(a) {
            return this._enableQueue ? this._queueInsert.has(a) ?
                !0 : !this._queueRemove.has(a) && this._rbSet.contains(a) : this._rbSet.contains(a)
        }
        Clear() {
            this._rbSet.clear();
            this._queueInsert.clear();
            this._queueRemove.clear()
        }
        toArray() {
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            return this._rbSet.getValues()
        }
        GetSize() {
            return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
        }
        IsEmpty() {
            return 0 === this.GetSize()
        }
        Front() {
            if (this.IsEmpty()) throw Error("empty set");
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            const a = this._rbSet;
            return a.min(a.root).key
        }
        Shift() {
            if (this.IsEmpty()) throw Error("empty set");
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            const a = this.Front();
            this.Remove(a);
            return a
        }
        SetQueueingEnabled(a) {
            a = !!a;
            if (this._enableQueue !== a && (this._enableQueue = a, !a)) {
                for (const b of this._queueRemove) this._rbSet.remove(b);
                this._queueRemove.clear();
                for (const b of this._queueInsert) this._rbSet.insert(b);
                this._queueInsert.clear()
            }
        }
        ForEach(a) {
            this._rbSet.forEach(a)
        }* values() {
            if (!this.IsEmpty()) {
                var a =
                    this._rbSet;
                for (let b = a.min(a.root); b != a.sentinel; b = a.successor_(b)) yield b.key
            }
        }[Symbol.iterator]() {
            return this.values()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PromiseThrottle = class {
        constructor(d = e.hardwareConcurrency) {
            this._maxParallel = d;
            this._queue = [];
            this._activeCount = 0
        }
        Add(d) {
            return new Promise((a, b) => {
                this._queue.push({
                    func: d,
                    resolve: a,
                    reject: b
                });
                this._MaybeStartNext()
            })
        }
        _FindInQueue(d) {
            for (let a = 0, b = this._queue.length; a < b; ++a)
                if (this._queue[a].func === d) return a;
            return -1
        }
        RemoveAndResolve(d, a) {
            d = this._FindInQueue(d);
            if (-1 === d) throw Error("cannot find promise to resolve");
            this._queue[d].resolve(a);
            this._queue.splice(d,
                1)
        }
        RemoveAndReject(d, a) {
            d = this._FindInQueue(d);
            if (-1 === d) throw Error("cannot find promise to reject");
            this._queue[d].reject(a);
            this._queue.splice(d, 1)
        }
        async _MaybeStartNext() {
            if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
                this._activeCount++;
                var d = this._queue.shift();
                try {
                    const a = await d.func();
                    d.resolve(a)
                } catch (a) {
                    d.reject(a)
                }
                this._activeCount--;
                this._MaybeStartNext()
            }
        }
        static async Batch(d, a) {
            const b = [];
            let c = !1;
            const f = async g => {
                    for (;
                        (g = a.pop()) && !c;) try {
                        b.push(await g())
                    } catch (k) {
                        throw c = !0, k;
                    }
                },
                h = [];
            for (; d--;) h.push(f());
            await Promise.all(h);
            return b
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.RateLimiter = class {
        constructor(d, a, b) {
            this._callback = d;
            this._interval = a;
            this._intervalOnBattery = b || 2 * a;
            this._timerId = -1;
            this._lastCallTime = -Infinity;
            this._timerCallFunc = () => this._OnTimer();
            this._canRunImmediate = this._ignoreReset = !1;
            this._callbackArguments = null
        }
        SetCanRunImmediate(d) {
            this._canRunImmediate = !!d
        }
        _GetInterval() {
            return "undefined" !== typeof e.Battery && e.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
        }
        Call(...d) {
            if (-1 === this._timerId) {
                this._callbackArguments =
                    d;
                d = e.FastGetDateNow();
                var a = d - this._lastCallTime,
                    b = this._GetInterval();
                a >= b && this._canRunImmediate ? (this._lastCallTime = d, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(b - a, 4))
            }
        }
        _RunCallback() {
            this._ignoreReset = !0;
            const d = this._callbackArguments;
            this._callbackArguments = null;
            d ? this._callback(...d) : this._callback();
            this._ignoreReset = !1
        }
        Reset() {
            this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = e.FastGetDateNow())
        }
        _OnTimer() {
            this._timerId = -1;
            this._lastCallTime = e.FastGetDateNow();
            this._RunCallback()
        }
        _CancelTimer() {
            -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1)
        }
        Release() {
            this._CancelTimer();
            this._timerCallFunc = this._callbackArguments = this._callback = null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SVGRasterManager = class {
        constructor() {
            this._images = new Map;
            this._allowNpotSurfaces = !1;
            this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
        }
        SetNpotSurfaceAllowed(d) {
            this._allowNpotSurfaces = !!d
        }
        IsNpotSurfaceAllowed() {
            return this._allowNpotSurfaces
        }
        SetGetBaseSizeCallback(d) {
            this._getBaseSizeCallback = d
        }
        GetBaseSize(d) {
            if (!this._getBaseSizeCallback) throw Error("no get base size callback set");
            return this._getBaseSizeCallback(d)
        }
        SetRasterAtSizeCallback(d) {
            this._rasterAtSizeCallback =
                d
        }
        RasterAtSize(d, a, b, c, f, h) {
            if (!this._rasterAtSizeCallback) throw Error("no raster at size callback set");
            return this._rasterAtSizeCallback(d, a, b, c, f, h)
        }
        SetReleaseResultCallback(d) {
            this._releaseResultCallback = d
        }
        ReleaseResult(d) {
            if (!this._releaseResultCallback) throw Error("no release result callback set");
            this._releaseResultCallback(d)
        }
        SetRedrawCallback(d) {
            this._redrawCallback = d
        }
        Redraw() {
            if (!this._redrawCallback) throw Error("no redraw callback set");
            this._redrawCallback()
        }
        AddImage(d) {
            let a = this._images.get(d);
            a || (a = e.New(e.SVGRasterImage, this, d), this._images.set(d, a));
            a.IncReference();
            return a
        }
        _RemoveImage(d) {
            this._images.delete(d.GetDataSource())
        }
        OnTexturesChanged() {
            for (const d of this._images.values()) d.ReleaseRasterizedResult(), d.ForceRasterAgain()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SVGRasterImage = class {
        constructor(d, a) {
            this._manager = d;
            this._dataSource = a;
            this._baseHeight = this._baseWidth = this._refCount = 0;
            this._getBaseSizePromise = this._manager.GetBaseSize(a).then(b => {
                this._baseWidth = b[0];
                this._baseHeight = b[1];
                this._manager.Redraw()
            }).catch(b => {
                console.error("[SVG] Error loading SVG: ", b);
                this._hadError = !0;
                this._manager.Redraw()
            });
            this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0;
            this._isRasterizing = !1;
            this._rasterizedResult = null;
            this._hadError = this._forceRaster = !1
        }
        Release() {
            if (0 >= this._refCount) throw Error("already released");
            this._refCount--;
            0 === this._refCount && this._Release()
        }
        ReleaseRasterizedResult() {
            this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null)
        }
        _Release() {
            this.ReleaseRasterizedResult();
            this._manager._RemoveImage(this);
            this._manager = null
        }
        GetDataSource() {
            return this._dataSource
        }
        IncReference() {
            this._refCount++
        }
        HasReferences() {
            return 0 <
                this._refCount
        }
        GetRasterizedResult() {
            return this._rasterizedResult
        }
        ForceRasterAgain() {
            this._forceRaster = !0
        }
        async StartRasterForSize(d, a, b) {
            if (0 !== a && 0 !== b && !this._hadError && !this._isRasterizing) {
                var c = e.nextHighestPowerOfTwo(Math.ceil(a)),
                    f = e.nextHighestPowerOfTwo(Math.ceil(b)),
                    h = Math.max(c, f);
                2048 < h && (h = 2048 / h, a *= h, b *= h, c = Math.min(Math.ceil(c * h), 2048), f = Math.min(Math.ceil(f * h), 2048));
                a < c && b < f && (b = a / b, c / f > b ? (a = f * b, b = f) : (a = c, b = c / b));
                this._manager.IsNpotSurfaceAllowed() && (c = Math.ceil(a), f = Math.ceil(b));
                c <= this._rasterSurfaceWidth && f <= this._rasterSurfaceHeight && !this._forceRaster || (this._isRasterizing = !0, this._rasterSurfaceWidth = c, this._rasterSurfaceHeight = f, d = await this._manager.RasterAtSize(this._dataSource, d, this._rasterSurfaceWidth, this._rasterSurfaceHeight, a, b), this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = d, this._rasterImageWidth = a, this._rasterImageHeight = b, this._forceRaster = this._isRasterizing = !1, this._manager.Redraw()))
            }
        }
        WhenBaseSizeReady() {
            return this._getBaseSizePromise
        }
        GetBaseWidth() {
            return this._baseWidth
        }
        GetBaseHeight() {
            return this._baseHeight
        }
        GetRasterWidth() {
            return this._rasterImageWidth
        }
        GetRasterHeight() {
            return this._rasterImageHeight
        }
        HadError() {
            return this._hadError
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.UTF8_BOM = "\ufeff";
    const d = new Set([..."0123456789"]);
    e.IsNumericChar = function(m) {
        return d.has(m)
    };
    const a = new Set([..." \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000"]);
    e.IsWhitespaceChar = function(m) {
        return a.has(m)
    };
    e.FilterWhitespace = function(m) {
        return [...m].filter(r => !e.IsWhitespaceChar(r)).join("")
    };
    e.IsStringAllWhitespace = function(m) {
        for (const r of m)
            if (!e.IsWhitespaceChar(r)) return !1;
        return !0
    };
    e.IsUnprintableChar = function(m) {
        return 1 === m.length && 32 > m.charCodeAt(0)
    };
    e.FilterUnprintableChars = function(m) {
        return [...m].filter(r => !e.IsUnprintableChar(r)).join("")
    };
    const b = new Set([..."0123456789.+-e"]);
    e.IsStringNumber = function(m) {
        m = m.trim();
        if (!m.length) return !1;
        let r = m.charAt(0);
        if ("-" !== r && !d.has(r)) return !1;
        for (let w of m)
            if (!b.has(w)) return !1;
        return !0
    };
    e.RemoveTrailingDigits = function(m) {
        let r = m.length;
        for (; 0 < r;) {
            let w = m.charAt(r - 1);
            if (!e.IsNumericChar(w)) break;
            --r
        }
        return m.substr(0, r)
    };
    e.IncrementNumberAtEndOf = function(m) {
        let r = e.RemoveTrailingDigits(m);
        m = (m = m.substr(r.length)) ? (parseInt(m, 10) + 1).toString() : "2";
        return r + m
    };
    const c = new Map([
        ["&", "&amp;"],
        ["<", "&lt;"],
        [">", "&gt;"],
        ['"', "&quot;"],
        ["'", "&#39;"]
    ]);

    function f(m) {
        return c.get(m)
    }
    const h = /[&<>"']/g;
    e.EscapeHTML = function(m) {
        return m.replace(h, f)
    };
    e.EscapeJS = function(m) {
        m = e.ReplaceAll(m, "\\", "\\\\");
        m = e.ReplaceAll(m, '"', '\\"');
        m = e.ReplaceAll(m, "\t", "\\t");
        m = e.ReplaceAll(m, "\r", "");
        return e.ReplaceAll(m, "\n", "\\n")
    };
    e.EscapeXML =
        function(m) {
            m = e.ReplaceAll(m, "&", "&amp;");
            m = e.ReplaceAll(m, "<", "&lt;");
            m = e.ReplaceAll(m, ">", "&gt;");
            return e.ReplaceAll(m, '"', "&quot;")
        };
    const g = /[-[\]{}()*+?.,\\^$|#\s]/g;
    e.EscapeRegex = function(m) {
        return m.replace(g, "\\$&")
    };
    e.FindAll = function(m, r, w = !1) {
        if (!r) return [];
        w || (m = m.toLowerCase(), r = r.toLowerCase());
        w = r.length;
        var p = 0;
        let t = [];
        for (; - 1 < (p = m.indexOf(r, p));) t.push(p), p += w;
        return t
    };
    e.ReplaceAll = function(m, r, w) {
        return m.replaceAll(r, () => w)
    };
    e.ReplaceAllCaseInsensitive = function(m, r, w) {
        return m.replace(new RegExp(e.EscapeRegex(r),
            "gi"), () => w)
    };
    e.SetElementContent = function(m, r) {
        "string" === typeof r ? m.textContent = r : r.isPlainText() ? m.textContent = r.toString() : (m.innerHTML = r.toHTML(), r instanceof e.BBString && r.attachLinkHandlers(m))
    };
    e.StringLikeEquals = function(m, r) {
        return m instanceof e.HtmlString || m instanceof e.BBString ? m.equals(r) : r instanceof e.HtmlString || r instanceof e.BBString ? r.equals(m) : m === r
    };
    e.StringSubstitute = function(m, ...r) {
        let w = m;
        for (let p = 0, t = r.length; p < t; ++p) {
            const u = `{${p}}`;
            if (!m.includes(u)) throw Error(`missing placeholder '${u}' in string substitution`);
            w = w.replace(u, r[p].toString())
        }
        return w
    };
    e.StringSubstituteAllowMissing = function(m, ...r) {
        let w = m,
            p = -1,
            t = -1;
        for (let u = 0, q = r.length; u < q; ++u) {
            const x = `{${u}}`;
            m.includes(x) ? (t = u, w = w.replace(x, r[u].toString())) : -1 === p && (p = u)
        }
        if (0 <= p && 0 <= t && p < t) throw Error(`missing placeholder '${p}' in string substitution`);
        return w
    };
    e.StringSubstituteMap = function(m, r) {
        for (let [w, p] of Object.entries(r)) m = m.replaceAll(w, p.toString());
        return m
    };
    e.SortAZCaseInsensitive = function(m, r) {
        m = m.toLowerCase();
        r = r.toLowerCase();
        return m >
            r ? 1 : m < r ? -1 : 0
    };
    e.FormatDataSize = function(m, r) {
        r = "common." + (r ? "dataRates" : "dataSizes") + ".";
        const w = self.langSub;
        if (1024 > m) return w(r + "bytes", m);
        if (1048576 > m) return m /= 1024, m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m), w(r + "kilobytes", m);
        if (1073741824 > m) return m /= 1048576, m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m), w(r + "megabytes", m);
        if (1099511627776 > m) return m /= 1073741824, m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m), w(r + "gigabytes", m);
        m /= 1099511627776;
        m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m);
        return w(r + "terabytes",
            m)
    };
    const k = {
        approximate: !1,
        days: !0,
        hours: !0,
        minutes: !0,
        seconds: !0
    };
    e.FormatTime = function(m, r) {
        r = Object.assign({}, k, r);
        e.Lang.PushContext("common.time");
        const w = [],
            p = self.lang,
            t = self.langPluralSub;
        if (r.days) {
            var u = Math.floor(m / 86400);
            0 < u && (m -= 86400 * u, w.push(t(".days", null, u)))
        }
        r.hours && (u = Math.floor(m / 3600), 0 < u || w.length) && (m -= 3600 * u, w.push(t(".hours", null, u)));
        r.minutes && (u = Math.floor(m / 60), 0 < u || w.length || !r.seconds) && (m -= 60 * u, w.push(t(".minutes", null, u)));
        r.seconds && w.push(t(".seconds", null, Math.floor(m %
            60)));
        m = (r.approximate ? p(".approx-prefix") : "") + w.join(p(".separator"));
        e.Lang.PopContext();
        return m
    };
    e.ZeroPad = function(m, r) {
        let w = 0 > m ? "-" : "";
        m = Math.abs(m);
        m = m.toString();
        r -= m.length;
        for (let p = 0; p < r; ++p) w += "0";
        return w + m
    };
    e.StringToTitleCase = function(m) {
        return m.toLowerCase().replace(/\b\w/g, r => r.toUpperCase())
    };
    e.CompareVersionStrings = function(m, r) {
        m = m.split(".").map(w => w.trim());
        r = r.split(".").map(w => w.trim());
        e.resizeArray(m, 4, "0");
        e.resizeArray(r, 4, "0");
        m = m.map(w => parseInt(w, 10));
        r = r.map(w => parseInt(w,
            10));
        for (let w = 0; 4 > w; ++w) {
            const p = m[w] - r[w];
            if (0 !== p) return 0 > p ? -1 : 1
        }
        return 0
    };
    e.CreateGUID = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, m => {
            const r = Math.floor(16 * Math.random());
            return ("x" === m ? r : r & 3 | 8).toString(16)
        })
    };
    e.StringHammingDistance = function(m, r) {
        if (m.length !== r.length) throw Error("strings must be same length");
        let w = 0;
        for (let p = 0, t = m.length; p < t; ++p) m.charAt(p) !== r.charAt(p) && ++w;
        return w
    };
    e.StringLevenshteinDistance = function(m, r) {
        if (0 === m.length) return r.length;
        if (0 === r.length) return m.length;
        let w, p, t, u;
        if (m.length > r.length) {
            var q = m;
            m = r;
            r = q
        }
        u = Array(m.length + 1);
        for (q = 0; q <= m.length; q++) u[q] = q;
        for (q = 1; q <= r.length; q++) {
            p = q;
            for (w = 1; w <= m.length; w++) t = r[q - 1] === m[w - 1] ? u[w - 1] : Math.min(u[w - 1] + 1, Math.min(p + 1, u[w] + 1)), u[w - 1] = p, p = t;
            u[m.length] = p
        }
        return u[m.length]
    }
} {
    "use strict";
    const e = self.C3,
        d = new Map([
            ["b", "strong"],
            ["i", "em"],
            ["s", "s"],
            ["u", "u"],
            ["sub", "sub"],
            ["sup", "sup"],
            ["small", "small"],
            ["mark", "mark"],
            ["a1", "a"],
            ["a2", "a"],
            ["a3", "a"],
            ["a4", "a"],
            ["a5", "a"],
            ["a6", "a"],
            ["a7", "a"],
            ["a8", "a"],
            ["a9", "a"],
            ["bad", ["span", "bbCodeBad"]],
            ["good", ["span", "bbCodeGood"]],
            ["info", ["span", "bbCodeInfo"]],
            ["h1", ["span", "bbCodeH1"]],
            ["h2", ["span", "bbCodeH2"]],
            ["h3", ["span", "bbCodeH3"]],
            ["h4", ["span", "bbCodeH4"]],
            ["item", ["span", "bbCodeItem"]]
        ]),
        a = /\[(\/?)([a-zA-Z0-9]+)\]/g,
        b = /\[(\/?)([^\[]*?)\]/g;
    let c = null,
        f = 0;

    function h(k, m, r) {
        var w = d.get(r);
        if (w) {
            if ("string" === typeof w) {
                if ("a" !== w || m) return "<" + m + w + ">";
                m = parseInt(r.substring(1), 10) - 1;
                if (0 > m || m >= c.length) throw Error("invalid bbcode link substitution");
                w = c[m];
                if ("string" === typeof w) return `<a href="${c[m]}">`;
                if ("function" === typeof w) return `<a class="bblink${m}">`;
                throw new TypeError("invalid bbcode link action");
            }
            if (Array.isArray(w)) return k = w[0], w = w[1], m ? "</" + k + ">" : `<${k} class="${w}">`
        } else return "class" === r ? m ? "</span>" :
            `<span class="bbclass${f++}">` : k
    }
    const g = /\n/g;
    e.BBString = class {
        constructor(k, m) {
            this._bbstr = m && m.noEscape ? k : e.EscapeHTML(k);
            this._htmlstr = "";
            this._convertLineBreaks = !1;
            this._linkActions = [];
            if (m && (this._convertLineBreaks = !!m.convertLineBreaks, m.links)) {
                if (9 < m.links.length) throw Error("too many links");
                this._linkActions = m.links
            }
            this._hasAnyBBtags = this._bbstr.includes("[");
            this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n");
            this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion &&
                !this._bbstr.includes("&");
            this._hasParsedFragments = !1;
            this._fragments = []
        }
        toString() {
            return this._bbstr
        }
        valueOf() {
            return this._bbstr
        }
        isPlainText() {
            return this._isPlain
        }
        toPlainText() {
            return this._hasAnyBBtags ? this._bbstr.replace(a, "") : this._bbstr
        }
        toHTML() {
            if (this._isPlain) return this._bbstr;
            if (!this._htmlstr && this._bbstr) {
                let k = this._bbstr;
                this._hasAnyBBtags && (f = 0, c = this._linkActions, k = k.replace(a, h), c = null);
                this._needsLineBreakConversion && (k = k.replace(g, "<br>"));
                this._htmlstr = k
            }
            return this._htmlstr
        }
        attachLinkHandlers(k) {
            if (this._linkActions.length)
                for (let m =
                        0, r = this._linkActions.length; m < r; ++m) {
                    const w = this._linkActions[m];
                    if ("function" !== typeof w) continue;
                    const p = k.querySelector(".bblink" + m);
                    if (!p) throw Error("unable to attach BBString link handler");
                    p.onclick = w
                }
        }
        equals(k) {
            return k instanceof e.HtmlString ? this.toHTML() === k.toHTML() : k instanceof e.BBString ? this._bbstr === k._bbstr : this._bbstr === k
        }
        toFragmentList() {
            if (this._hasParsedFragments) return this._fragments;
            const k = this._bbstr,
                m = [];
            let r = b.lastIndex = 0;
            for (var w; null !== (w = b.exec(k));) {
                var p = w.index;
                if (0 < p && "\\" === k.charAt(p - 1)) continue;
                var t = w[0],
                    u = w[1];
                w = w[2];
                const q = k.substring(r, p);
                r = p + t.length;
                q && this._fragments.push({
                    text: q,
                    styles: m.slice(0)
                });
                if (w)
                    if (u)
                        for (w = w.toLowerCase(), p = m.length - 1; 0 <= p; --p) {
                            if (m[p].tag === w) {
                                m.splice(p, 1);
                                break
                            }
                        } else p = w, t = null, u = w.indexOf("="), -1 !== u ? (p = w.substring(0, u).toLowerCase(), t = w.substring(u + 1)) : p = p.toLowerCase(), m.push({
                            tag: p,
                            param: t
                        })
            }
            r < k.length && this._fragments.push({
                text: k.substring(r),
                styles: m.slice(0)
            });
            for (const q of this._fragments) q.text = this._ProcessBBCodeEscapeSequences(q.text);
            this._hasParsedFragments = !0;
            return this._fragments
        }
        _ProcessBBCodeEscapeSequences(k) {
            k = e.ReplaceAll(k, "\\[", "[");
            return e.ReplaceAll(k, "\\\\", "\\")
        }
        static StripTags(k) {
            return e.New(e.BBString, k, {
                noEscape: !0
            }).toPlainText()
        }
        static StripAnyTags(k) {
            return k.replace(b, "")
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.WordWrap = class {
        constructor() {
            this._lines = []
        }
        GetLines() {
            return this._lines
        }
        GetLineCount() {
            return this._lines.length
        }
        _MeasureLine(d, a) {
            let b = 0,
                c = 0,
                f = 0,
                h = 0,
                g = 0;
            for (const k of d) - 1 === k.width && (d = a(k.text, k.styles), k.width = d.width, k.height = d.height, k.fontBoundingBoxAscent = d.fontBoundingBoxAscent || 0, k.fontBoundingBoxDescent = d.fontBoundingBoxDescent || 0, k.topToAlphabeticDistance = d.topToAlphabeticDistance || 0), b += k.width, c = Math.max(c, k.height), f = Math.max(f, k.fontBoundingBoxAscent),
                h = Math.max(h, k.fontBoundingBoxDescent), g = Math.max(g, k.topToAlphabeticDistance);
            return {
                width: b,
                height: c,
                fontBoundingBoxAscent: f,
                fontBoundingBoxDescent: h,
                topToAlphabeticDistance: g
            }
        }
        _AddLine(d, a, b, c, f, h) {
            this._lines.push({
                fragments: d,
                width: a,
                height: b,
                fontBoundingBoxAscent: c,
                fontBoundingBoxDescent: f,
                topToAlphabeticDistance: h
            })
        }
        WordWrap(d, a, b, c, f) {
            "string" === typeof d && (d = [{
                text: d,
                styles: []
            }]);
            e.clearArray(this._lines);
            if (!(!d.length || 1 === d.length && !d[0].text.length || 2 > b)) {
                if (1 === d.length) {
                    var h = d[0];
                    const g =
                        h.text;
                    h = h.styles;
                    if (100 >= g.length && !g.includes("\n")) {
                        let {
                            width: k,
                            height: m,
                            fontBoundingBoxAscent: r,
                            fontBoundingBoxDescent: w,
                            topToAlphabeticDistance: p
                        } = a(g, h);
                        k += f;
                        r = r || 0;
                        w = w || 0;
                        p = p || 0;
                        if (k <= b) {
                            this._AddLine([{
                                text: g,
                                styles: h,
                                width: k,
                                height: m,
                                fontBoundingBoxAscent: r,
                                fontBoundingBoxDescent: w,
                                topToAlphabeticDistance: p
                            }], k, m, r, w, p);
                            return
                        }
                    }
                }
                if ("word" === c) c = this._TokeniseWords(d);
                else {
                    c = [];
                    for (const g of d) e.appendArray(c, [...g.text].map(k => [{
                        text: k,
                        styles: g.styles
                    }]))
                }
                this._WrapText(c, a, b, f)
            }
        }
        _TokeniseWords(d) {
            const a = [];
            let b = [],
                c = !1;
            for (const h of d) {
                var f = h.text;
                d = h.styles;
                for (const g of f) "\n" === g ? (0 < b.length && a.push(b), a.push([{
                    text: "\n",
                    styles: d
                }]), b = []) : 0 === b.length ? (b.push({
                    text: g,
                    styles: d
                }), c = e.IsWhitespaceChar(g)) : (f = e.IsWhitespaceChar(g), f === c ? (f = b.at(-1), f.styles === d ? f.text += g : b.push({
                    text: g,
                    styles: d
                })) : (a.push(b), b = [], b.push({
                    text: g,
                    styles: d
                }), c = f))
            }
            0 < b.length && a.push(b);
            return a
        }
        _CopyLine(d) {
            return d.map(a => ({
                text: a.text,
                styles: a.styles,
                width: a.width,
                height: a.height,
                fontBoundingBoxAscent: a.fontBoundingBoxAscent,
                fontBoundingBoxDescent: a.fontBoundingBoxDescent,
                topToAlphabeticDistance: a.topToAlphabeticDistance
            }))
        }
        _AddWordToLine(d, a) {
            var b = d.length ? d.at(-1) : null;
            let c = 0;
            b && a[0].styles === b.styles && (b.text += a[0].text, b.width = -1, b.height = -1, b.fontBoundingBoxAscent = -1, b.fontBoundingBoxDescent = -1, b.topToAlphabeticDistance = -1, c = 1);
            for (b = a.length; c < b; ++c) {
                const f = a[c];
                d.push({
                    text: f.text,
                    styles: f.styles,
                    width: -1,
                    height: -1,
                    fontBoundingBoxAscent: -1,
                    fontBoundingBoxDescent: -1,
                    topToAlphabeticDistance: -1
                })
            }
        }
        _WrapText(d,
            a, b, c) {
            let f = [],
                h = 0,
                g = 0,
                k = 0,
                m = 0;
            var r = 0;
            for (const w of d) {
                if (1 === w.length && "\n" === w[0].text) {
                    0 === g && (r = a(" ", w[0].styles), g = r.height, k = r.fontBoundingBoxAscent || 0, m = r.fontBoundingBoxDescent || 0, r = r.topToAlphabeticDistance || 0);
                    this._AddLine(f, h, g, k, m, r);
                    f = [];
                    r = m = k = g = h = 0;
                    continue
                }
                d = this._CopyLine(f);
                this._AddWordToLine(d, w);
                const p = this._MeasureLine(d, a),
                    t = p.width;
                t >= b ? (0 < f.length && this._AddLine(f, h, g, k, m, r), f = [], e.IsStringAllWhitespace(w[0].text) ? r = m = k = g = h = 0 : (this._AddWordToLine(f, w), r = this._MeasureLine(f,
                    a), h = r.width, g = r.height, k = r.fontBoundingBoxAscent, m = r.fontBoundingBoxDescent, r = r.topToAlphabeticDistance)) : (f = d, h = t, g = p.height, k = p.fontBoundingBoxAscent, m = p.fontBoundingBoxDescent, r = p.topToAlphabeticDistance)
            }
            0 < f.length && this._AddLine(f, h, g, k, m, r);
            this._TrimLinesTrailingWhitespace(a, c)
        }
        _TrimLinesTrailingWhitespace(d, a) {
            for (const c of this._lines) {
                const f = c.fragments;
                if (!f.length) continue;
                let h = f.at(-1);
                var b = h.text;
                const g = b.trimEnd();
                if (!g) c.width -= h.width, f.pop();
                else if (g.length < b.length) {
                    b = d(g,
                        h.styles).width;
                    const k = h.width - b;
                    h.width = b;
                    h.text = g;
                    c.width -= k
                }
                0 !== a && 0 < f.length && (h = f.at(-1), h.width += a, c.width += a)
            }
        }
        Clear() {
            e.clearArray(this._lines)
        }
        GetMaxLineWidth() {
            return this._lines.reduce((d, a) => Math.max(d, a.width), 0)
        }
        GetTotalLineHeight() {
            return this._lines.reduce((d, a) => d + a.height, 0)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.glMatrix,
        a = d.vec3,
        b = d.vec4,
        c = d.mat4,
        f = a.create(),
        h = a.create(),
        g = a.create(),
        k = b.create(),
        m = c.create(),
        r = a.create(),
        w = a.create(),
        p = a.create(),
        t = a.create(),
        u = a.create(),
        q = a.create(),
        x = a.create(),
        y = a.create(),
        B = b.fromValues(0, 0, 1, 1);
    e.Gfx = {
        Project(C, A, G, J, M, R, U) {
            const V = J[0] * C + J[4] * A + J[8] * G + J[12],
                ba = J[1] * C + J[5] * A + J[9] * G + J[13],
                ia = J[2] * C + J[6] * A + J[10] * G + J[14];
            J = J[3] * C + J[7] * A + J[11] * G + J[15];
            C = M[0] * V + M[4] * ba + M[8] * ia + M[12] * J;
            A = M[1] * V + M[5] * ba + M[9] * ia + M[13] * J;
            G = M[2] * V + M[6] *
                ba + M[10] * ia + M[14] * J;
            M = M[3] * V + M[7] * ba + M[11] * ia + M[15] * J;
            if (0 === M) return !1;
            M = 1 / M;
            U[0] = (C * M * .5 + .5) * R[2] + R[0];
            U[1] = (A * M * .5 + .5) * R[3] + R[1];
            U[2] = .5 * (1 + G * M);
            return !0
        },
        Unproject(C, A, G, J, M, R, U) {
            c.multiply(m, M, J);
            if (null === c.invert(m, m)) return !1;
            k[0] = (C - R[0]) / R[2] * 2 - 1;
            k[1] = (A - R[1]) / R[3] * 2 - 1;
            k[2] = 2 * G - 1;
            k[3] = 1;
            b.transformMat4(k, k, m);
            if (0 === k[3]) return !1;
            k[3] = 1 / k[3];
            U[0] = k[0] * k[3];
            U[1] = k[1] * k[3];
            U[2] = k[2] * k[3];
            return !0
        },
        UnprojectScreenToWorldZ(C, A, G, J, M, R, U) {
            if (!e.Gfx.Unproject(C, A, 0, J, M, R, f) || !e.Gfx.Unproject(C,
                    A, 1, J, M, R, h)) return !1;
            a.subtract(h, h, f);
            a.set(g, 0, 0, 1);
            C = -G;
            A = a.dot(g, h);
            G = 0;
            if (0 === A) {
                if (0 !== a.dot(g, f) + C) return !1
            } else if (G = -(a.dot(f, g) + C) / A, 0 > G) return !1;
            a.scaleAndAdd(U, f, h, G);
            return !0
        }
    };

    function F(C, A, G, J) {
        a.subtract(f, G, A);
        a.subtract(h, C, A);
        a.cross(g, f, h);
        a.normalize(g, g);
        J.set(g[0], g[1], g[2], a.dot(C, g))
    }

    function H(C, A, G, J, M, R, U) {
        const V = U.x,
            ba = U.y,
            ia = U.z,
            ja = U.w,
            qa = U.xF,
            za = U.yF;
        U = U.zF;
        const Ca = 1 - qa,
            Ma = 1 - za,
            Fa = 1 - U;
        return V * C * qa + V * J * Ca + ba * A * za + ba * M * Ma + ia * G * U + ia * R * Fa >= ja ? !0 : V * J * qa + V * C * Ca + ba * M *
            za + ba * A * Ma + ia * R * U + ia * G * Fa > ja
    }
    class K {
        constructor() {
            this.zF = this.yF = this.xF = this.w = this.z = this.y = this.x = NaN
        }
        set(C, A, G, J) {
            this.x = C;
            this.y = A;
            this.z = G;
            this.w = J;
            this.xF = 0 < C ? 1 : 0;
            this.yF = 0 < A ? 1 : 0;
            this.zF = 0 < G ? 1 : 0
        }
    }
    e.Gfx.ViewFrustum = class {
        constructor() {
            this._leftP = new K;
            this._topP = new K;
            this._rightP = new K;
            this._bottomP = new K;
            this._nearP = new K;
            this._farP = new K
        }
        CalculatePlanes(C, A) {
            e.Gfx.Unproject(0, 1, 0, C, A, B, r);
            e.Gfx.Unproject(1, 1, 0, C, A, B, w);
            e.Gfx.Unproject(0, 0, 0, C, A, B, p);
            e.Gfx.Unproject(1, 0, 0, C, A, B, t);
            e.Gfx.Unproject(0,
                1, 1, C, A, B, u);
            e.Gfx.Unproject(1, 1, 1, C, A, B, q);
            e.Gfx.Unproject(0, 0, 1, C, A, B, x);
            e.Gfx.Unproject(1, 0, 1, C, A, B, y);
            F(p, r, u, this._leftP);
            F(r, w, q, this._topP);
            F(w, t, y, this._rightP);
            F(t, p, x, this._bottomP);
            F(x, u, q, this._farP);
            F(t, w, r, this._nearP)
        }
        ContainsAABB(C, A, G, J, M, R) {
            return H(C, A, G, J, M, R, this._leftP) && H(C, A, G, J, M, R, this._topP) && H(C, A, G, J, M, R, this._rightP) && H(C, A, G, J, M, R, this._bottomP) && H(C, A, G, J, M, R, this._nearP) && H(C, A, G, J, M, R, this._farP)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.glMatrix,
        a = d.vec3,
        b = d.vec4,
        c = d.mat4,
        f = c.create(),
        h = a.fromValues(0, 0, 0),
        g = a.fromValues(0, 0, 0),
        k = a.fromValues(0, 0, 0),
        m = a.fromValues(0, 1, 0);
    b.fromValues(0, 0, 0, 0);
    const r = new e.Quad,
        w = new e.Rect,
        p = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1);
    e.Gfx.RendererBase = class {
        constructor() {
            this._height = this._width = 0;
            this._fovY = e.toRadians(45);
            this._tan_fovY_2 = Math.tan(this._fovY / 2);
            this._matP = c.create();
            this._matMV = c.create();
            this._allShaderPrograms = [];
            this._shaderProgramsByName = new Map;
            this._spSmoothLineFill =
                this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
            this._stateGroups = new Map;
            this._currentStateGroup = null;
            this._blendModeTable = [];
            this._namedBlendModeMap = new Map;
            this._currentZ = this._baseZ = 0;
            this._lineWidth = 1;
            this._lineWidthStack = [this._lineWidth];
            this._lineCap = 1;
            this._lineCapStack = [this._lineCap];
            this._lineOffset = .5;
            this._lineOffsetStack = [this._lineOffset];
            this._frameNumber = 0;
            this._enableMipmaps = !0;
            this._hasMajorPerformanceCaveat = !1
        }
        FillIndexBufferData(t) {
            let u = 0,
                q = t.length,
                x = 0;
            for (; u < q;) t[u++] = x, t[u++] = x + 1, t[u++] = x + 2, t[u++] = x, t[u++] = x + 2, t[u++] = x + 3, x += 4
        }
        _ClearState() {
            this._currentZ = this._baseZ = 0;
            this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
            this._ClearAllShaderPrograms()
        }
        InitState() {
            this._ClearState();
            this._currentStateGroup = null
        }
        OnDeviceOrContextLost() {
            for (const t of this._allShaderPrograms) t.Release();
            this._ClearState()
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetDefaultCameraZ() {
            return 100
        }
        GetNearZ() {
            return 1
        }
        GetFarZ() {
            return 1E4
        }
        GetFovY() {
            return this._fovY
        }
        _GetTanFovYDiv2() {
            return this._tan_fovY_2
        }
        CalculatePerspectiveMatrix(t, u, q = .5, x = .5) {
            const y = this.GetNearZ(),
                B = this.GetFarZ();
            q = 1 - q;
            const F = 2 * q - 2;
            q *= 2;
            const H = 2 * x - 2;
            x *= 2;
            const K = this._GetTanFovYDiv2() * y;
            u *= K;
            c.frustum(t,
                F * u, q * u, H * K, x * K, y, B)
        }
        CalculateOrthographicMatrix(t, u, q, x = 1) {
            const y = self.devicePixelRatio,
                B = 2 * this.GetDefaultCameraZ() * y * this._GetTanFovYDiv2() / q;
            u = u * B / (2 * y * x);
            q = q * B / (2 * y * x);
            c.ortho(t, -u, u, -q, q, this.GetNearZ(), this.GetFarZ())
        }
        CalculateLookAtModelView(t, u, q, x, y = this.GetScissoredViewportHeight()) {
            y = 2 * this.GetDefaultCameraZ() * self.devicePixelRatio * this._GetTanFovYDiv2() / y;
            a.set(k, y, -y, 1);
            a.multiply(h, u, k);
            a.multiply(g, q, k);
            c.lookAt(t, h, g, x || m);
            c.scale(t, t, k)
        }
        CalculateLookAtModelView2(t, u, q, x, y, B, F) {
            a.set(h,
                t, u, q);
            a.set(g, x, y, B);
            this.CalculateLookAtModelView(f, h, g, m, F);
            return f
        }
        _AddShaderProgram(t) {
            this._allShaderPrograms.push(t);
            this._shaderProgramsByName.set(t.GetName(), t)
        }
        _RemoveShaderProgram(t) {
            const u = this._allShaderPrograms.indexOf(t); - 1 !== u && this._allShaderPrograms.splice(u, 1);
            this._shaderProgramsByName.delete(t.GetName())
        }
        _ClearAllShaderPrograms() {
            e.clearArray(this._allShaderPrograms);
            this._shaderProgramsByName.clear()
        }
        GetShaderProgramByName(t) {
            return this._shaderProgramsByName.get(t) || null
        }
        GetTextureFillShaderProgram() {
            return this._spTextureFill
        }
        SetTextureFillMode() {
            this.SetProgram(this._spTextureFill)
        }
        GetPointsRenderingProgram() {
            return this._spPoints
        }
        SetPointsRenderingProgram() {
            this.SetProgram(this._spPoints)
        }
        SetTilemapFillMode() {
            this.SetProgram(this._spTilemapFill)
        }
        SetColorFillMode() {
            this.SetProgram(this._spColorFill)
        }
        SetLinearGradientFillMode() {
            this.SetProgram(this._spLinearGradientFill)
        }
        SetHardEllipseFillMode() {
            this.SetProgram(this._spHardEllipseFill)
        }
        SetHardEllipseOutlineMode() {
            this.SetProgram(this._spHardEllipseOutline)
        }
        SetSmoothEllipseFillMode() {
            this.SetProgram(this._spSmoothEllipseFill)
        }
        SetSmoothEllipseOutlineMode() {
            this.SetProgram(this._spSmoothEllipseOutline)
        }
        SetSmoothLineFillMode() {
            this.SetProgram(this._spSmoothLineFill)
        }
        _SetCurrentStateGroup(t) {
            this._currentStateGroup =
                t
        }
        GetCurrentStateGroup() {
            return this._currentStateGroup
        }
        AcquireStateGroup(t, u, q, x) {
            const y = e.Gfx.StateGroup.MakeKey(t, u, q, x);
            let B = this._stateGroups.get(y);
            B || (B = e.New(e.Gfx.StateGroup, this, t, u, q, x), this._stateGroups.set(y, B));
            B.AddRef();
            return B
        }
        ReleaseStateGroup(t) {
            t.DecRef();
            0 === t._GetRefCount() && (this._currentStateGroup === t && (this._currentStateGroup = null), this._stateGroups.delete(t.GetKey()), t.Release())
        }
        _InitBlendModeData(t) {
            e.clearArray(this._blendModeTable);
            this._namedBlendModeMap.clear();
            for (const u of t) {
                t = u[0];
                const q = u[1],
                    x = u[2];
                this._blendModeTable.push([q, x]);
                this._namedBlendModeMap.set(t, {
                    srcBlend: q,
                    destBlend: x
                })
            }
        }
        _GetBlendByIndex(t) {
            return this._blendModeTable[t]
        }
        GetSrcBlendByIndex(t) {
            return this._GetBlendByIndex(t)[0]
        }
        GetDestBlendByIndex(t) {
            return this._GetBlendByIndex(t)[1]
        }
        GetNamedBlend(t) {
            t = this._namedBlendModeMap.get(t);
            if ("undefined" === typeof t) throw Error("invalid blend name");
            return t
        }
        SetBaseZ(t) {
            this._baseZ = t
        }
        GetBaseZ() {
            return this._baseZ
        }
        SetCurrentZ(t) {
            this._currentZ =
                t;
            this._currentStateGroup = null
        }
        GetCurrentZ() {
            return this._currentZ
        }
        Line(t, u, q, x) {
            var y = e.angleTo(t, u, q, x),
                B = .5 * this._lineWidth;
            const F = Math.sin(y) * B;
            y = Math.cos(y) * B;
            B = this._lineCap;
            2 === B ? this.LinePreCalc_LineCap2(t, u, 0, q, x, 0, F, y) : 1 === B ? this.LinePreCalc_LineCap1(t, u, 0, q, x, 0, F, y) : this.LinePreCalc_LineCap0(t, u, 0, q, x, 0, F, y)
        }
        Line3D(t, u, q, x, y, B) {
            var F = e.angleTo(t, u, x, y),
                H = .5 * this._lineWidth;
            const K = Math.sin(F) * H;
            F = Math.cos(F) * H;
            H = this._lineCap;
            2 === H ? this.LinePreCalc_LineCap2(t, u, q, x, y, B, K, F) : 1 === H ? this.LinePreCalc_LineCap1(t,
                u, q, x, y, B, K, F) : this.LinePreCalc_LineCap0(t, u, q, x, y, B, K, F)
        }
        LinePreCalc_LineCap2(t, u, q, x, y, B, F, H) {
            var K = this._lineOffset;
            t = t + K - H;
            u = u + K - F;
            x = x + K + H;
            y = y + K + F;
            K = 2 * H;
            const C = 2 * F;
            this.Quad3D2(t + F, u - H, q, x + F, y - H, B, x - F - K, y + H - C, B, t - F + K, u + H + C, q, p)
        }
        LinePreCalc_LineCap1(t, u, q, x, y, B, F, H) {
            const K = this._lineOffset;
            t = t + K - H;
            u = u + K - F;
            x = x + K + H;
            y = y + K + F;
            this.Quad3D2(t + F, u - H, q, x + F, y - H, B, x - F, y + H, B, t - F, u + H, q, p)
        }
        LinePreCalc_LineCap0(t, u, q, x, y, B, F, H) {
            const K = this._lineOffset;
            t += K;
            u += K;
            x += K;
            y += K;
            this.Quad3D2(t + F, u - H, q, x + F, y - H, B, x -
                F, y + H, B, t - F, u + H, q, p)
        }
        TexturedLine(t, u, q, x, y, B) {
            var F = e.angleTo(t, u, q, x),
                H = .5 * this._lineWidth;
            const K = Math.sin(F) * H;
            F = Math.cos(F) * H;
            H = this._lineCap;
            2 === H ? this.TexturedLinePreCalc_LineCap2(t, u, q, x, K, F, y, B) : 1 === H ? this.TexturedLinePreCalc_LineCap1(t, u, q, x, K, F, y, B) : this.TexturedLinePreCalc_LineCap0(t, u, q, x, K, F, y, B)
        }
        TexturedLinePreCalc_LineCap2(t, u, q, x, y, B, F, H) {
            var K = this._lineOffset;
            t = t + K - B;
            u = u + K - y;
            q = q + K + B;
            x = x + K + y;
            K = 2 * B;
            const C = 2 * y;
            r.set(t + y, u - B, q + y, x - B, q - y - K, x + B - C, t - y + K, u + B + C);
            w.set(F, 0, H, 0);
            this.Quad3(r,
                w)
        }
        TexturedLinePreCalc_LineCap1(t, u, q, x, y, B, F, H) {
            const K = this._lineOffset;
            t = t + K - B;
            u = u + K - y;
            q = q + K + B;
            x = x + K + y;
            r.set(t + y, u - B, q + y, x - B, q - y, x + B, t - y, u + B);
            w.set(F, 0, H, 0);
            this.Quad3(r, w)
        }
        TexturedLinePreCalc_LineCap0(t, u, q, x, y, B, F, H) {
            const K = this._lineOffset;
            t += K;
            u += K;
            q += K;
            x += K;
            r.set(t + y, u - B, q + y, x - B, q - y, x + B, t - y, u + B);
            w.set(F, 0, H, 0);
            this.Quad3(r, w)
        }
        LineRect(t, u, q, x) {
            const y = .5 * this._lineWidth,
                B = this._lineCap;
            2 === B ? this._LineRectPreCalc_LineCap2(t, u, q, x, y) : 1 === B ? this._LineRectPreCalc_LineCap1(t, u, q, x, y) : this._LineRectPreCalc_LineCap0(t,
                u, q, x, y)
        }
        _LineRectPreCalc_LineCap2(t, u, q, x, y) {
            this.LinePreCalc_LineCap2(t, u, 0, q, u, 0, 0, y);
            this.LinePreCalc_LineCap2(q, u, 0, q, x, 0, y, 0);
            this.LinePreCalc_LineCap2(q, x, 0, t, x, 0, 0, -y);
            this.LinePreCalc_LineCap2(t, x, 0, t, u, 0, -y, 0)
        }
        _LineRectPreCalc_LineCap1(t, u, q, x, y) {
            this.LinePreCalc_LineCap1(t, u, 0, q, u, 0, 0, y);
            this.LinePreCalc_LineCap1(q, u, 0, q, x, 0, y, 0);
            this.LinePreCalc_LineCap1(q, x, 0, t, x, 0, 0, -y);
            this.LinePreCalc_LineCap1(t, x, 0, t, u, 0, -y, 0)
        }
        _LineRectPreCalc_LineCap0(t, u, q, x, y) {
            this.LinePreCalc_LineCap0(t, u, 0, q,
                u, 0, 0, y);
            this.LinePreCalc_LineCap0(q, u, 0, q, x, 0, y, 0);
            this.LinePreCalc_LineCap0(q, x, 0, t, x, 0, 0, -y);
            this.LinePreCalc_LineCap0(t, x, 0, t, u, 0, -y, 0)
        }
        LineRect2(t) {
            this.LineRect(t.getLeft(), t.getTop(), t.getRight(), t.getBottom())
        }
        LineQuad(t) {
            var u = e.angleTo(t.getTlx(), t.getTly(), t.getTrx(), t.getTry()),
                q = .5 * this._lineWidth;
            const x = Math.sin(u) * q;
            u = Math.cos(u) * q;
            q = this._lineCap;
            2 === q ? this._LineQuadPreCalc_LineCap2(t, x, u) : 1 === q ? this._LineQuadPreCalc_LineCap1(t, x, u) : this._LineQuadPreCalc_LineCap0(t, x, u)
        }
        _LineQuadPreCalc_LineCap2(t,
            u, q) {
            this.LinePreCalc_LineCap2(t.getTlx(), t.getTly(), 0, t.getTrx(), t.getTry(), 0, u, q);
            this.LinePreCalc_LineCap2(t.getTrx(), t.getTry(), 0, t.getBrx(), t.getBry(), 0, q, -u);
            this.LinePreCalc_LineCap2(t.getBrx(), t.getBry(), 0, t.getBlx(), t.getBly(), 0, -u, -q);
            this.LinePreCalc_LineCap2(t.getBlx(), t.getBly(), 0, t.getTlx(), t.getTly(), 0, -q, u)
        }
        _LineQuadPreCalc_LineCap1(t, u, q) {
            this.LinePreCalc_LineCap1(t.getTlx(), t.getTly(), 0, t.getTrx(), t.getTry(), 0, u, q);
            this.LinePreCalc_LineCap1(t.getTrx(), t.getTry(), 0, t.getBrx(), t.getBry(),
                0, q, -u);
            this.LinePreCalc_LineCap1(t.getBrx(), t.getBry(), 0, t.getBlx(), t.getBly(), 0, -u, -q);
            this.LinePreCalc_LineCap1(t.getBlx(), t.getBly(), 0, t.getTlx(), t.getTly(), 0, -q, u)
        }
        _LineQuadPreCalc_LineCap0(t, u, q) {
            this.LinePreCalc_LineCap0(t.getTlx(), t.getTly(), 0, t.getTrx(), t.getTry(), 0, u, q);
            this.LinePreCalc_LineCap0(t.getTrx(), t.getTry(), 0, t.getBrx(), t.getBry(), 0, q, -u);
            this.LinePreCalc_LineCap0(t.getBrx(), t.getBry(), 0, t.getBlx(), t.getBly(), 0, -u, -q);
            this.LinePreCalc_LineCap0(t.getBlx(), t.getBly(), 0, t.getTlx(),
                t.getTly(), 0, -q, u)
        }
        SetLineWidth(t) {
            this._lineWidth = t;
            this._lineWidthStack[this._lineWidthStack.length - 1] = t
        }
        GetLineWidth() {
            return this._lineWidth
        }
        PushLineWidth(t) {
            if (100 <= this._lineWidthStack.length) throw Error("pushed too many line widths - check push/pop pairs");
            this._lineWidthStack.push(t);
            this._lineWidth = t
        }
        PopLineWidth() {
            if (1 >= this._lineWidthStack.length) throw Error("cannot pop last line width - check push/pop pairs");
            this._lineWidthStack.pop();
            this._lineWidth = this._lineWidthStack.at(-1)
        }
        SetLineCapButt() {
            this._lineCap =
                0;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapSquare() {
            this._lineCap = 1;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapZag() {
            this._lineCap = 2;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        PushLineCap(t) {
            if ("butt" === t) this.PushLineCapButt();
            else if ("square" === t) this.PushLineCapSquare();
            else if ("zag" === t) this.PushLineCapZag();
            else throw Error("invalid line cap");
        }
        PushLineCapButt() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(0);
            this._lineCap = 0
        }
        PushLineCapSquare() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(1);
            this._lineCap = 1
        }
        PushLineCapZag() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(2);
            this._lineCap = 2
        }
        PopLineCap() {
            if (1 >= this._lineCapStack.length) throw Error("cannot pop last line cap - check push/pop pairs");
            this._lineCapStack.pop();
            this._lineCap =
                this._lineCapStack.at(-1)
        }
        SetLineOffset(t) {
            this._lineOffset = t;
            this._lineOffsetStack[this._lineOffsetStack.length - 1] = t
        }
        GetLineOffset() {
            return this._lineOffset
        }
        PushLineOffset(t) {
            if (100 <= this._lineOffsetStack.length) throw Error("pushed too many line offsets - check push/pop pairs");
            this._lineOffsetStack.push(t);
            this._lineOffset = t
        }
        PopLineOffset() {
            if (1 >= this._lineOffsetStack.length) throw Error("cannot pop last line offset - check push/pop pairs");
            this._lineOffsetStack.pop();
            this._lineOffset = this._lineOffsetStack.at(-1)
        }
        ConvexPoly(t) {
            var u =
                t.length / 2;
            if (3 > u) throw Error("need at least 3 points");
            u -= 2;
            const q = u - 1,
                x = t[0],
                y = t[1];
            for (let B = 0; B < u; B += 2) {
                const F = 2 * B,
                    H = t[F + 2],
                    K = t[F + 3],
                    C = t[F + 4],
                    A = t[F + 5];
                B === q ? this.Quad2(x, y, H, K, C, A, C, A) : this.Quad2(x, y, H, K, C, A, t[F + 6], t[F + 7])
            }
        }
        GetNumVertexComponents() {
            return 3
        }
        Finish() {
            this.EndBatch(!0);
            this._frameNumber++
        }
        GetFrameNumber() {
            return this._frameNumber
        }
        IncrementFrameNumber() {
            this._frameNumber++
        }
        SetMipmapsEnabled(t) {
            this._enableMipmaps = !!t
        }
        AreMipmapsEnabled() {
            return this._enableMipmaps
        }
        SetHasMajorPerformanceCaveat(t) {
            this._hasMajorPerformanceCaveat = !!t
        }
        HasMajorPerformanceCaveat() {
            return this._hasMajorPerformanceCaveat
        }
        IsWebGL() {
            return !1
        }
        IsWebGPU() {
            return !1
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Gfx.StateGroup = class {
        constructor(d, a, b, c, f) {
            this._renderer = d;
            this._refCount = 0;
            this._shaderProgram = null;
            this._shaderProgramName = "";
            this._blendMode = b;
            this._color = e.New(e.Color);
            this._color.set(c);
            this._zElevation = f;
            "string" === typeof a ? this._shaderProgramName = a : (this._shaderProgram = a, this._shaderProgramName = this._shaderProgram.GetName())
        }
        Release() {
            if (0 < this._refCount) throw Error("releasing state group still in use");
            this._shaderProgram = this._renderer = null;
            this._shaderProgramName =
                ""
        }
        Apply() {
            const d = this._renderer;
            d.SetProgram(this._shaderProgram);
            d.SetBlendMode(this._blendMode);
            d.SetColor(this._color);
            d.SetCurrentZ(this._zElevation);
            d._SetCurrentStateGroup(this)
        }
        GetKey() {
            return e.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
        }
        AddRef() {
            ++this._refCount
        }
        DecRef() {
            --this._refCount
        }
        _GetRefCount() {
            return this._refCount
        }
        OnContextLost() {
            this._shaderProgram = null
        }
        OnContextRestored(d) {
            this._shaderProgram = d.GetShaderProgramByName(this._shaderProgramName);
            if (!this._shaderProgram) throw Error("failed to restore shader program");
        }
        static MakeKey(d, a, b, c) {
            return ("string" === typeof d ? d : d.GetName()) + "," + a + "," + b.getR() + "," + b.getG() + "," + b.getB() + "," + b.getA() + "," + c
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.New(e.Quad);

    function a(b, c, f) {
        const h = f.getTlx(),
            g = f.getTly(),
            k = f.getTrx() - h,
            m = f.getTry() - g,
            r = f.getBlx() - h;
        f = f.getBly() - g;
        return [h + k * b + r * c, g + m * b + f * c]
    }
    e.Gfx.MeshPoint = class {
        constructor(b, c, f) {
            this._mesh = b;
            this._col = c;
            this._row = f;
            this._v = this._u = this._zElevation = this._y = this._x = 0
        }
        _Init(b, c, f, h) {
            this._x = b;
            this._y = c;
            this._u = f;
            this._v = h
        }
        GetX() {
            return this._x
        }
        SetX(b) {
            this._x !== b && (this._x = b, this._mesh._SetPointsChanged())
        }
        GetY() {
            return this._y
        }
        SetY(b) {
            this._y !== b && (this._y =
                b, this._mesh._SetPointsChanged())
        }
        GetZElevation() {
            return this._zElevation
        }
        SetZElevation(b) {
            this._zElevation !== b && (this._zElevation = Math.max(b, 0), this._mesh._SetPointsChanged())
        }
        GetU() {
            return this._u
        }
        SetU(b) {
            this._u = b
        }
        GetV() {
            return this._v
        }
        SetV(b) {
            this._v = b
        }
        _Interpolate_TexRect(b, c, f) {
            [this._x, this._y] = a(b._x, b._y, c);
            this._zElevation = b._zElevation;
            this._u = e.lerp(f.getLeft(), f.getRight(), b._u);
            this._v = e.lerp(f.getTop(), f.getBottom(), b._v)
        }
        _Interpolate_TexQuad(b, c, f) {
            [this._x, this._y] = a(b._x, b._y, c);
            this._zElevation = b._zElevation;
            [this._u, this._v] = a(b._u, b._v, f)
        }
        SaveToJson() {
            return {
                x: this.GetX(),
                y: this.GetY(),
                z: this.GetZElevation(),
                u: this.GetU(),
                v: this.GetV()
            }
        }
        LoadFromJson(b) {
            this.SetX(b.x);
            this.SetY(b.y);
            b.hasOwnProperty("z") && this.SetZElevation(b.z);
            this.SetU(b.u);
            this.SetV(b.v)
        }
        GetMesh() {
            return this._mesh
        }
        GetColumn() {
            return this._col
        }
        GetRow() {
            return this._row
        }
    };
    e.Gfx.Mesh = class {
        constructor(b, c, f) {
            if (2 > b || 2 > c) throw Error("invalid mesh size");
            this._hsize = b;
            this._vsize = c;
            this._owner = f || null;
            this._pts = [];
            this._minY = this._minX = 0;
            this._maxY = this._maxX = 1;
            this._maxZ = 0;
            this._pointsChanged = !1;
            f = b - 1;
            const h = c - 1;
            for (let g = 0; g < c; ++g) {
                const k = [];
                for (let m = 0; m < b; ++m) {
                    const r = e.New(e.Gfx.MeshPoint, this, m, g),
                        w = m / f,
                        p = g / h;
                    r._Init(w, p, w, p);
                    k.push(r)
                }
                this._pts.push(k)
            }
        }
        Release() {
            e.clearArray(this._pts)
        }
        GetHSize() {
            return this._hsize
        }
        GetVSize() {
            return this._vsize
        }
        GetOwner() {
            return this._owner
        }
        _GetPoints() {
            return this._pts
        }
        _SetPointsChanged() {
            this._pointsChanged = !0
        }
        _MaybeComputeBounds() {
            if (this._pointsChanged) {
                var b =
                    Infinity,
                    c = Infinity,
                    f = -Infinity,
                    h = -Infinity,
                    g = 0;
                for (const k of this._pts)
                    for (const m of k) {
                        const r = m.GetX(),
                            w = m.GetY();
                        b = Math.min(b, r);
                        c = Math.min(c, w);
                        f = Math.max(f, r);
                        h = Math.max(h, w);
                        g = Math.max(g, m.GetZElevation())
                    }
                this._minX = b;
                this._minY = c;
                this._maxX = f;
                this._maxY = h;
                this._maxZ = g;
                this._pointsChanged = !1
            }
        }
        GetMinX() {
            this._MaybeComputeBounds();
            return this._minX
        }
        GetMinY() {
            this._MaybeComputeBounds();
            return this._minY
        }
        GetMaxX() {
            this._MaybeComputeBounds();
            return this._maxX
        }
        GetMaxY() {
            this._MaybeComputeBounds();
            return this._maxY
        }
        GetMaxZ() {
            this._MaybeComputeBounds();
            return this._maxZ
        }
        HasAnyZElevation() {
            return 0 < this.GetMaxZ()
        }
        GetMeshPointAt(b, c) {
            b = Math.floor(b);
            c = Math.floor(c);
            return 0 > b || b >= this._hsize || 0 > c || c >= this._vsize ? null : this._pts[c][b]
        }
        CalculateTransformedMesh(b, c, f) {
            const h = f instanceof e.Rect;
            if (b.GetHSize() !== this.GetHSize() || b.GetVSize() !== this.GetVSize()) throw Error("source mesh wrong size");
            b = b._pts;
            const g = this._pts;
            for (let k = 0, m = g.length; k < m; ++k) {
                const r = b[k],
                    w = g[k];
                for (let p = 0, t = w.length; p <
                    t; ++p) {
                    const u = r[p],
                        q = w[p];
                    h ? q._Interpolate_TexRect(u, c, f) : q._Interpolate_TexQuad(u, c, f)
                }
            }
        }
        Draw(b) {
            const c = this._pts;
            let f = c[0];
            for (let h = 1, g = c.length; h < g; ++h) {
                const k = c[h];
                let m = f[0],
                    r = k[0];
                for (let w = 1, p = k.length; w < p; ++w) {
                    const t = f[w],
                        u = k[w];
                    d.set(m.GetU(), m.GetV(), t.GetU(), t.GetV(), u.GetU(), u.GetV(), r.GetU(), r.GetV());
                    b.Quad3D2(m.GetX(), m.GetY(), m.GetZElevation(), t.GetX(), t.GetY(), t.GetZElevation(), u.GetX(), u.GetY(), u.GetZElevation(), r.GetX(), r.GetY(), r.GetZElevation(), d);
                    m = t;
                    r = u
                }
                f = k
            }
        }
        Outline(b,
            c) {
            c || (c = (g, k, m) => [g, k, m]);
            const f = this._pts;
            let h = f[0];
            for (let g = 1, k = f.length; g < k; ++g) {
                const m = f[g];
                let r = h[0],
                    w = m[0];
                for (let p = 1, t = m.length; p < t; ++p) {
                    const u = h[p],
                        q = m[p],
                        [x, y, B] = c(r.GetX(), r.GetY(), r.GetZElevation()),
                        [F, H, K] = c(u.GetX(), u.GetY(), u.GetZElevation()),
                        [C, A, G] = c(q.GetX(), q.GetY(), q.GetZElevation()),
                        [J, M, R] = c(w.GetX(), w.GetY(), w.GetZElevation());
                    b.Line3D(x, y, B, F, H, K);
                    b.Line3D(x, y, B, C, A, G);
                    b.Line3D(x, y, B, J, M, R);
                    p === t - 1 && b.Line3D(F, H, K, C, A, G);
                    g === k - 1 && b.Line3D(J, M, R, C, A, G);
                    r = u;
                    w = q
                }
                h = m
            }
        }
        InsertPolyMeshVertices(b) {
            b =
                b.pointsArr();
            const c = [],
                f = this.GetHSize() - 1,
                h = this.GetVSize() - 1,
                g = 1 / f,
                k = 1 / h,
                m = f - 1,
                r = h - 1;
            let w = b[0],
                p = b[1],
                t = e.clamp(Math.floor(w * f), 0, m),
                u = e.clamp(Math.floor(p * h), 0, r),
                q = 0,
                x = 0,
                y = 0;
            var B = -1;
            const F = () => {
                w = e.clamp(e.lerp(w, q, y), 0, 1);
                p = e.clamp(e.lerp(p, x, y), 0, 1);
                c.push(w, p)
            };
            for (let H = 0, K = b.length; H < K; H += 2)
                for (w = b[H], p = b[H + 1], c.push(w, p), t = e.clamp(Math.floor(w * f), 0, m), u = e.clamp(Math.floor(p * h), 0, r), B = (H + 2) % K, q = b[B], x = b[B + 1], B = -1;;) {
                    if (1E6 < c.length) throw Error("Too many mesh poly points");
                    const C = t *
                        g,
                        A = u * k,
                        G = (t + 1) * g,
                        J = (u + 1) * k;
                    e.isPointInTriangleInclusive(w, p, C, A, G, A, G, J);
                    if (0 !== B && (y = e.rayIntersectExtended(w, p, q, x, C, A, G, J, -.001), 0 <= y && .99999999 >= y)) {
                        F();
                        B = 0;
                        continue
                    }
                    if (0 < u && 2 !== B && (y = e.rayIntersectExtended(w, p, q, x, C, A, G, A, .001), 0 <= y && .99999999 >= y)) {
                        F();
                        u--;
                        B = 4;
                        continue
                    }
                    if (t < m && 3 !== B && (y = e.rayIntersectExtended(w, p, q, x, G, A, G, J, .001), 0 <= y && .99999999 >= y)) {
                        F();
                        t++;
                        B = 1;
                        continue
                    }
                    if (0 < t && 1 !== B && (y = e.rayIntersectExtended(w, p, q, x, C, A, C, J, .001), 0 <= y && .99999999 >= y)) {
                        F();
                        t--;
                        B = 3;
                        continue
                    }
                    if (u < r && 4 !== B &&
                        (y = e.rayIntersectExtended(w, p, q, x, C, J, G, J, .001), 0 <= y && .99999999 >= y)) {
                        F();
                        u++;
                        B = 2;
                        continue
                    }
                    break
                }
            return e.New(e.CollisionPoly, c)
        }
        TransformCollisionPoly(b, c) {
            b = this._TransformPolyPoints(b);
            this._SimplifyPoly(b);
            c.setPoints(b)
        }
        _TransformPolyPoints(b) {
            const c = [];
            b = b.pointsArr();
            for (let f = 0, h = b.length; f < h; f += 2) {
                const [g, k] = this.TransformPoint(b[f], b[f + 1]);
                c.push(g, k)
            }
            return c
        }
        TransformPoint(b, c) {
            var f = this.GetHSize() - 1,
                h = this.GetVSize() - 1,
                g = 1 / f,
                k = 1 / h;
            f = e.clamp(Math.floor(b * f), 0, f - 1);
            const m = e.clamp(Math.floor(c *
                h), 0, h - 1);
            h = f * g;
            const r = m * k,
                w = (f + 1) * g,
                p = (m + 1) * k,
                t = this.GetMeshPointAt(f, m),
                u = this.GetMeshPointAt(f + 1, m + 1),
                q = e.isPointInTriangleInclusive(b, c, h, r, w, r, w, p);
            g = q ? h + g : h;
            k = q ? r : r + k;
            f = this.GetMeshPointAt(f + (q ? 1 : 0), m + (q ? 0 : 1));
            const [x, y, B] = e.triangleCartesianToBarycentric(b, c, h, r, g, k, w, p);
            return e.triangleBarycentricToCartesian(x, y, B, t.GetX(), t.GetY(), f.GetX(), f.GetY(), u.GetX(), u.GetY())
        }
        _SimplifyPoly(b) {
            const c = [];
            let f = b[0],
                h = b[1],
                g = f - b.at(-2),
                k = h - b.at(-1);
            for (let r = 0, w = b.length; r < w; r += 2) {
                var m = (r + 2) % w;
                const p = b[m];
                m = b[m + 1];
                const t = p - f,
                    u = m - h,
                    q = 1E-7 > Math.abs(u) && 1E-7 > Math.abs(k) && Math.sign(t) === Math.sign(g);
                (!(1E-7 > Math.abs(t) && 1E-7 > Math.abs(g) && Math.sign(u) === Math.sign(k) || q) && 1E-7 < Math.abs(t / g - u / k) || 0 == t && 0 === u) && c.push(f, h);
                f = p;
                h = m;
                g = t;
                k = u
            }
            6 <= c.length && c.length < b.length && e.shallowAssignArray(b, c)
        }
        SaveToJson() {
            return {
                cols: this.GetHSize(),
                rows: this.GetVSize(),
                points: this._pts.map(b => b.map(c => c.SaveToJson()))
            }
        }
        LoadFromJson(b) {
            const c = this.GetHSize(),
                f = this.GetVSize();
            if (b.cols !== c || b.rows !== f) throw Error("mesh data wrong size");
            b = b.points;
            for (let h = 0; h < f; ++h) {
                const g = b[h];
                for (let k = 0; k < c; ++k) this.GetMeshPointAt(k, h).LoadFromJson(g[k])
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]),
        a = new Set(["nearest", "bilinear", "trilinear"]),
        b = new Set(["default", "low", "high"]),
        c = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);

    function f(m, r) {
        let w, p;
        switch (m) {
            case "rgba8":
                m = r.RGBA8;
                p = w = r.RGBA;
                r = r.UNSIGNED_BYTE;
                break;
            case "rgb8":
                m = r.RGB8;
                p = w = r.RGB;
                r = r.UNSIGNED_BYTE;
                break;
            case "rgba4":
                m = r.RGBA4;
                p = w = r.RGBA;
                r = r.UNSIGNED_SHORT_4_4_4_4;
                break;
            case "rgb5_a1":
                m = r.RGB5_A1;
                p = w = r.RGBA;
                r = r.UNSIGNED_SHORT_5_5_5_1;
                break;
            case "rgb565":
                m = r.RGB565;
                p = w = r.RGB;
                r = r.UNSIGNED_SHORT_5_6_5;
                break;
            default:
                throw Error("invalid pixel format");
        }
        return {
            sizedinternalformat: m,
            internalformat: w,
            format: p,
            type: r
        }
    }
    const h = {
            wrapX: "clamp-to-edge",
            wrapY: "clamp-to-edge",
            sampling: "trilinear",
            anisotropy: 0,
            pixelFormat: "rgba8",
            mipMap: !0,
            mipMapQuality: "default",
            premultiplyAlpha: !0,
            isSvg: !1,
            width: -1,
            height: -1
        },
        g = {
            premultiplyAlpha: !0,
            flipY: !1
        },
        k = new Set;
    e.Gfx.WebGLRendererTexture = class {
        constructor(m) {
            this._renderer = m;
            this._texture = null;
            this._height =
                this._width = 0;
            this._isStatic = !0;
            this._wrapY = this._wrapX = "clamp-to-edge";
            this._sampling = "trilinear";
            this._anisotropy = 0;
            this._pixelFormat = "rgba8";
            this._isMipMapped = !1;
            this._mipMapQuality = "default";
            this._refCount = 0
        }
        _CreateStatic(m, r) {
            if (!("undefined" !== typeof HTMLImageElement && m instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && m instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && m instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && m instanceof OffscreenCanvas ||
                    m instanceof ImageData || m instanceof ArrayBuffer) && null !== m) throw Error("invalid texture source");
            r = Object.assign({}, h, r);
            if (this._texture) throw Error("already created texture");
            this._wrapX = r.wrapX;
            this._wrapY = r.wrapY;
            this._sampling = r.sampling;
            this._anisotropy = r.anisotropy;
            this._pixelFormat = r.pixelFormat;
            this._isMipMapped = !!r.mipMap && this._renderer.AreMipmapsEnabled();
            this._mipMapQuality = r.mipMapQuality;
            if (!c.has(this._wrapX) || !c.has(this._wrapY)) throw Error("invalid wrap mode");
            if (!a.has(this._sampling)) throw Error("invalid sampling");
            if (!d.has(this._pixelFormat)) throw Error("invalid pixel format");
            if (!b.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
            this._isStatic = !0;
            if (m instanceof ArrayBuffer || null === m || r.isSvg) {
                if (this._width = r.width, this._height = r.height, m instanceof ArrayBuffer && m.byteLength !== this._width * this._height * 4) throw Error("ArrayBuffer wrong size");
            } else this._width = m.width, this._height = m.height;
            if (0 >= this._width || 0 >= this._height) throw Error("invalid texture data size");
            if (r.isSvg) {
                var w = e.CreateCanvas(this._width,
                    this._height);
                w.getContext("2d").drawImage(m, 0, 0, this._width, this._height);
                m = w
            }
            var p = e.isPOT(this._width) && e.isPOT(this._height);
            w = this._renderer.GetMaxTextureSize();
            if (this._width > w || this._height > w) throw Error("texture data exceeds maximum texture size");
            w = this._renderer.GetContext();
            var t = this._renderer.GetWebGLVersionNumber();
            this._texture = w.createTexture();
            w.bindTexture(w.TEXTURE_2D, this._texture);
            w.pixelStorei(w.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha);
            w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL, !1);
            r = f(this._pixelFormat, w);
            if (this._renderer.SupportsNPOTTextures() || p || !this._IsTiled()) 2 <= t ? (w.texStorage2D(w.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, r.sizedinternalformat, this._width, this._height), m instanceof ArrayBuffer ? w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, this._width, this._height, r.format, r.type, new Uint8Array(m)) : null !== m && w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, r.format, r.type, m)) : m instanceof ArrayBuffer ? w.texImage2D(w.TEXTURE_2D, 0, r.internalformat,
                this._width, this._height, 0, r.format, r.type, new Uint8Array(m)) : null === m ? w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, this._width, this._height, 0, r.format, r.type, null) : w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, r.format, r.type, m);
            else {
                if (null === m) throw Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                m instanceof ArrayBuffer && (m = new ImageData(new Uint8ClampedArray(m), this._width, this._height));
                m instanceof ImageData && (p = e.CreateCanvas(this._width, this._height),
                    p.getContext("2d").putImageData(m, 0, 0), m = p);
                p = e.CreateCanvas(e.nextHighestPowerOfTwo(this._width), e.nextHighestPowerOfTwo(this._height));
                t = p.getContext("2d");
                t.imageSmoothingEnabled = "nearest" !== this._sampling;
                t.drawImage(m, 0, 0, this._width, this._height, 0, 0, p.width, p.height);
                w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, r.format, r.type, p)
            }
            null !== m && this._SetTextureParameters(w);
            w.bindTexture(w.TEXTURE_2D, null);
            this._renderer._ResetLastTexture();
            this._refCount = 1;
            k.add(this)
        }
        _CreateDynamic(m, r, w) {
            w = Object.assign({},
                h, w);
            if (this._texture) throw Error("already created texture");
            this._wrapX = w.wrapX;
            this._wrapY = w.wrapY;
            this._sampling = w.sampling;
            this._pixelFormat = w.pixelFormat;
            this._isMipMapped = !!w.mipMap && this._renderer.AreMipmapsEnabled();
            this._mipMapQuality = w.mipMapQuality;
            if (!c.has(this._wrapX) || !c.has(this._wrapY)) throw Error("invalid wrap mode");
            if (!a.has(this._sampling)) throw Error("invalid sampling");
            if (!d.has(this._pixelFormat)) throw Error("invalid pixel format");
            if (!b.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
            this._isStatic = !1;
            this._width = Math.floor(m);
            this._height = Math.floor(r);
            m = e.isPOT(this._width) && e.isPOT(this._height);
            r = this._renderer.GetMaxTextureSize();
            if (0 >= this._width || 0 >= this._height) throw Error("invalid texture size");
            if (this._width > r || this._height > r) throw Error("texture exceeds maximum texture size");
            if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !m) throw Error("non-power-of-two tiled textures not supported");
            m = this._renderer.GetContext();
            r = this._renderer.GetWebGLVersionNumber();
            this._texture = m.createTexture();
            m.bindTexture(m.TEXTURE_2D, this._texture);
            m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha);
            m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, !1);
            w = f(this._pixelFormat, m);
            m.texImage2D(m.TEXTURE_2D, 0, 2 <= r ? w.sizedinternalformat : w.internalformat, this._width, this._height, 0, w.format, w.type, null);
            this._SetTextureParameters(m);
            m.bindTexture(m.TEXTURE_2D, null);
            this._renderer._ResetLastTexture();
            this._refCount = 1;
            k.add(this)
        }
        _GetMipMapHint(m) {
            if ("default" === this._mipMapQuality) return this._isStatic ?
                m.NICEST : m.FASTEST;
            if ("low" === this._mipMapQuality) return m.FASTEST;
            if ("high" === this._mipMapQuality) return m.NICEST;
            throw Error("invalid mipmap quality");
        }
        _IsTiled() {
            return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY
        }
        _GetTextureWrapMode(m, r) {
            if ("clamp-to-edge" === r) return m.CLAMP_TO_EDGE;
            if ("repeat" === r) return m.REPEAT;
            if ("mirror-repeat" === r) return m.MIRRORED_REPEAT;
            throw Error("invalid wrap mode");
        }
        _SetTextureParameters(m) {
            var r = e.isPOT(this._width) && e.isPOT(this._height);
            m.texParameteri(m.TEXTURE_2D,
                m.TEXTURE_WRAP_S, this._GetTextureWrapMode(m, this._wrapX));
            m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, this._GetTextureWrapMode(m, this._wrapY));
            "nearest" === this._sampling ? (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST), this._isMipMapped = !1) : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.LINEAR), (r || this._renderer.SupportsNPOTTextures()) && this._isMipMapped ? (m.hint(m.GENERATE_MIPMAP_HINT, this._GetMipMapHint(m)), m.generateMipmap(m.TEXTURE_2D),
                r = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat(), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, r ? m.LINEAR_MIPMAP_LINEAR : m.LINEAR_MIPMAP_NEAREST)) : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.LINEAR), this._isMipMapped = !1));
            (r = this._renderer._GetAnisotropicExtension()) && 0 < this._anisotropy && "nearest" !== this._sampling && m.texParameterf(m.TEXTURE_2D, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))
        }
        _Update(m, r) {
            if (!("undefined" !==
                    typeof HTMLImageElement && m instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && m instanceof HTMLVideoElement || "undefined" !== typeof HTMLCanvasElement && m instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && m instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && m instanceof OffscreenCanvas || m instanceof ImageData)) throw Error("invalid texture source");
            if (!this._texture || 0 >= this._refCount) throw Error("texture not created");
            if (this._isStatic) throw Error("cannot update static texture");
            r = Object.assign({}, g, r);
            const w = m.width || m.videoWidth,
                p = m.height || m.videoHeight;
            var t = this._renderer.GetWebGLVersionNumber();
            const u = this._renderer.GetContext();
            u.bindTexture(u.TEXTURE_2D, this._texture);
            u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha);
            u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, !!r.flipY);
            r = f(this._pixelFormat, u);
            t = 2 <= t ? r.sizedinternalformat : r.internalformat;
            try {
                if (this._width === w && this._height === p) {
                    const q = e.isPOT(this._width) && e.isPOT(this._height);
                    u.texSubImage2D(u.TEXTURE_2D,
                        0, 0, 0, r.format, r.type, m);
                    (q || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (u.hint(u.GENERATE_MIPMAP_HINT, this._GetMipMapHint(u)), u.generateMipmap(u.TEXTURE_2D))
                } else {
                    this._width = w;
                    this._height = p;
                    const q = e.isPOT(this._width) && e.isPOT(this._height);
                    if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !q) throw Error("non-power-of-two tiled textures not supported");
                    u.texImage2D(u.TEXTURE_2D, 0, t, r.format, r.type, m);
                    (q || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (u.hint(u.GENERATE_MIPMAP_HINT,
                        this._GetMipMapHint(u)), u.generateMipmap(u.TEXTURE_2D))
                }
            } catch (q) {
                console.error("Error updating WebGL texture: ", q)
            }
            u.bindTexture(u.TEXTURE_2D, null);
            this._renderer._ResetLastTexture()
        }
        _Delete() {
            if (0 < this._refCount) throw Error("texture still has references");
            if (!this._texture) throw Error("already deleted texture");
            k.delete(this);
            this._renderer.GetContext().deleteTexture(this._texture);
            this._texture = null
        }
        IsValid() {
            return !!this._texture
        }
        _GetTexture() {
            return this._texture
        }
        GetRenderer() {
            return this._renderer
        }
        AddReference() {
            this._refCount++
        }
        SubtractReference() {
            if (0 >=
                this._refCount) throw Error("no more references");
            this._refCount--
        }
        GetReferenceCount() {
            return this._refCount
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsStatic() {
            return this._isStatic
        }
        GetEstimatedMemoryUsage() {
            let m = this._width * this._height;
            switch (this._pixelFormat) {
                case "rgba8":
                    m *= 4;
                    break;
                case "rgb8":
                    m *= 3;
                    break;
                case "rgba4":
                case "rgb5_a1":
                case "rgb565":
                    m *= 2
            }
            this._isMipMapped && (m += Math.floor(m / 3));
            return m
        }
        static OnContextLost() {
            k.clear()
        }
        static allTextures() {
            return k.values()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.glMatrix.mat4,
        a = new Set(["nearest", "bilinear", "trilinear"]),
        b = {
            sampling: "trilinear",
            alpha: !0,
            depth: !1,
            isSampled: !0,
            isDefaultSize: !0,
            multisampling: 0
        },
        c = new Set;
    e.Gfx.WebGLRenderTarget = class {
        constructor(f) {
            this._renderer = f;
            this._renderBuffer = this._texture = this._frameBuffer = null;
            this._height = this._width = 0;
            this._isDefaultSize = !0;
            this._sampling = "trilinear";
            this._alpha = !0;
            this._depth = !1;
            this._isSampled = !0;
            this._multisampling = 0;
            this._projectionMatrix = d.create()
        }
        _Create(f,
            h, g) {
            g = Object.assign({}, b, g);
            const k = this._renderer.GetWebGLVersionNumber();
            if (this._texture || this._renderBuffer) throw Error("already created render target");
            this._sampling = g.sampling;
            this._alpha = !!g.alpha;
            this._depth = !!g.depth;
            this._isSampled = !!g.isSampled;
            this._isDefaultSize = !!g.isDefaultSize;
            this._multisampling = g.multisampling;
            if (!a.has(this._sampling)) throw Error("invalid sampling");
            if (0 < this._multisampling && (2 > k || this._isSampled)) throw Error("invalid use of multisampling");
            2 > k && (this._isSampled = !0);
            this._width = f;
            this._height = h;
            if (0 >= this._width || 0 >= this._height) throw Error("invalid render target size");
            this._CalculateProjection();
            f = this._renderer.GetContext();
            this._frameBuffer = f.createFramebuffer();
            f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer);
            this._isSampled ? (this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
                sampling: this._sampling,
                pixelFormat: this._alpha ? "rgba8" : "rgb8",
                mipMap: !1
            }), h = this._texture._GetTexture(), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0,
                f.TEXTURE_2D, h, 0)) : (this._renderBuffer = f.createRenderbuffer(), f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer), h = this._alpha ? f.RGBA8 : f.RGB8, 0 < this._multisampling && ((g = f.getInternalformatParameter(f.RENDERBUFFER, h, f.SAMPLES)) && g[0] ? (g = g[0], this._multisampling > g && (this._multisampling = g)) : this._multisampling = 0), 0 === this._multisampling ? f.renderbufferStorage(f.RENDERBUFFER, h, this._width, this._height) : f.renderbufferStorageMultisample(f.RENDERBUFFER, this._multisampling, h, this._width, this._height), f.framebufferRenderbuffer(f.FRAMEBUFFER,
                f.COLOR_ATTACHMENT0, f.RENDERBUFFER, this._renderBuffer), f.bindRenderbuffer(f.RENDERBUFFER, null));
            h = this._renderer._GetDepthBuffer();
            this._depth && h && f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, h);
            f.bindFramebuffer(f.FRAMEBUFFER, null);
            c.add(this)
        }
        _Resize(f, h) {
            if (this._width !== f || this._height !== h) this._width = f, this._height = h, this._CalculateProjection(), f = this._renderer.GetContext(), f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width,
                this._height)) : (f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer), f.renderbufferStorage(f.RENDERBUFFER, this._alpha ? f.RGBA8 : f.RGB8, this._width, this._height), f.bindRenderbuffer(f.RENDERBUFFER, null)), h = this._renderer._GetDepthBuffer(), this._depth && h && f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, h), f.bindFramebuffer(f.FRAMEBUFFER, null)
        }
        _Delete() {
            if (!this._texture && !this._renderBuffer) throw Error("already deleted render target");
            c.delete(this);
            const f = this._renderer.GetContext();
            f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer);
            this._texture ? (f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, null, 0), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER, null), f.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null);
            f.bindFramebuffer(f.FRAMEBUFFER, null);
            2 <= this._renderer.GetWebGLVersionNumber() && (f.bindFramebuffer(f.READ_FRAMEBUFFER, null),
                f.bindFramebuffer(f.DRAW_FRAMEBUFFER, null));
            f.deleteFramebuffer(this._frameBuffer);
            this._frameBuffer = this._renderer.GetBatchState().currentFramebuffer = null
        }
        _CalculateProjection() {
            this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height)
        }
        _GetFramebuffer() {
            return this._frameBuffer
        }
        GetRenderer() {
            return this._renderer
        }
        GetTexture() {
            return this._texture
        }
        GetProjectionMatrix() {
            return this._projectionMatrix
        }
        IsLinearSampling() {
            return "nearest" !== this._sampling
        }
        HasAlpha() {
            return this._alpha
        }
        IsSampled() {
            return this._isSampled
        }
        HasDepthBuffer() {
            return this._depth
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsDefaultSize() {
            return this._isDefaultSize
        }
        GetMultisampling() {
            return this._multisampling
        }
        GetOptions() {
            const f = {
                sampling: this._sampling,
                alpha: this._alpha,
                isSampled: this._isSampled
            };
            this._isDefaultSize || (f.width = this._width, f.height = this._height);
            return f
        }
        IsCompatibleWithOptions(f) {
            f = Object.assign({}, b, f);
            return "nearest" !== f.sampling !== this.IsLinearSampling() || !!f.alpha !== this.HasAlpha() || !!f.depth !== this.HasDepthBuffer() || 2 <= this._renderer.GetWebGLVersionNumber() && !!f.isSampled !== this.IsSampled() ? !1 : "number" === typeof f.width || "number" === typeof f.height ? !this.IsDefaultSize() && this.GetWidth() === f.width && this.GetHeight() ===
                f.height : this.IsDefaultSize()
        }
        _GetWebGLTexture() {
            return this._texture ? this._texture._GetTexture() : null
        }
        GetEstimatedMemoryUsage() {
            return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
        }
        static async DebugReadPixelsToBlob(f, h) {
            f = await f.ReadBackRenderTargetToImageData(h, !0);
            return await e.ImageDataToBlob(f)
        }
        static OnContextLost() {
            c.clear()
        }
        static allRenderTargets() {
            return c.values()
        }
        static ResizeAll(f, h) {
            for (const g of c) g.IsDefaultSize() && g._Resize(f,
                h)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new Set("aPos aTex aPoints matP matMV samplerFront samplerBack destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness".split(" "));
    e.Gfx.WebGLShaderProgram = class {
        static async Compile(a, b, c, f) {
            const h = a.GetContext(),
                g = h.createShader(h.FRAGMENT_SHADER);
            h.shaderSource(g, b);
            h.compileShader(g);
            b = h.createShader(h.VERTEX_SHADER);
            h.shaderSource(b,
                c);
            h.compileShader(b);
            const k = h.createProgram();
            h.attachShader(k, g);
            h.attachShader(k, b);
            h.bindAttribLocation(k, 0, "aPos");
            h.bindAttribLocation(k, 1, "aTex");
            h.bindAttribLocation(k, 2, "aPoints");
            h.linkProgram(k);
            const m = a._GetParallelShaderCompileExtension();
            m ? await a._WaitForObjectReady(() => h.getProgramParameter(k, m.COMPLETION_STATUS_KHR)) : await e.Wait(5);
            if (!h.getShaderParameter(g, h.COMPILE_STATUS)) throw f = h.getShaderInfoLog(g), h.deleteShader(g), h.deleteShader(b), h.deleteProgram(k), Error("Error compiling fragment shader: " +
                f);
            if (!h.getShaderParameter(b, h.COMPILE_STATUS)) throw f = h.getShaderInfoLog(b), h.deleteShader(g), h.deleteShader(b), h.deleteProgram(k), Error("Error compiling vertex shader: " + f);
            if (!h.getProgramParameter(k, h.LINK_STATUS)) throw f = h.getProgramInfoLog(k), h.deleteShader(g), h.deleteShader(b), h.deleteProgram(k), Error("Error linking shader program: " + f);
            (a = e.FilterUnprintableChars(h.getProgramInfoLog(k) || "").trim()) && !e.IsStringAllWhitespace(a) && console.info(`[WebGL] Shader program '${f}' compilation log: `,
                a);
            h.deleteShader(g);
            h.deleteShader(b);
            return k
        }
        static async Create(a, b, c, f) {
            c = await e.Gfx.WebGLShaderProgram.Compile(a, b.src, c, f);
            return new e.Gfx.WebGLShaderProgram(a, c, b, f)
        }
        constructor(a, b, c, f) {
            const h = a.GetContext();
            var g = a.GetBatchState();
            a.EndBatch();
            h.useProgram(b);
            this._gl = h;
            this._renderer = a;
            this._name = f;
            this._shaderProgram = b;
            this._isDeviceTransform = "<default-device-transform>" === f;
            f = h.getAttribLocation(b, "aPos");
            const k = h.getAttribLocation(b, "aTex");
            this._locAPoints = h.getAttribLocation(b,
                "aPoints"); - 1 !== f && (h.bindBuffer(h.ARRAY_BUFFER, a._vertexBuffer), h.vertexAttribPointer(f, a.GetNumVertexComponents(), h.FLOAT, !1, 0, 0), h.enableVertexAttribArray(f)); - 1 !== k && (h.bindBuffer(h.ARRAY_BUFFER, a._texcoordBuffer), h.vertexAttribPointer(k, 2, h.FLOAT, !1, 0, 0), h.enableVertexAttribArray(k)); - 1 !== this._locAPoints && (h.bindBuffer(h.ARRAY_BUFFER, a._pointBuffer), h.vertexAttribPointer(this._locAPoints, 4, h.FLOAT, !1, 0, 0), h.enableVertexAttribArray(this._locAPoints));
            h.bindBuffer(h.ARRAY_BUFFER, null);
            this._uMatP =
                new e.Gfx.WebGLShaderUniform(this, "matP", "mat4");
            this._uMatMV = new e.Gfx.WebGLShaderUniform(this, "matMV", "mat4");
            this._uColor = new e.Gfx.WebGLShaderUniform(this, "color", "vec4");
            this._uSamplerFront = new e.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler");
            this._uPointTexStart = new e.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2");
            this._uPointTexEnd = new e.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2");
            this._uZElevation = new e.Gfx.WebGLShaderUniform(this, "zElevation", "float");
            this._uTileSize = new e.Gfx.WebGLShaderUniform(this,
                "tileSize", "vec2");
            this._uTileSpacing = new e.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2");
            this._uColor2 = new e.Gfx.WebGLShaderUniform(this, "color2_", "vec4");
            this._uOutlineThickness = new e.Gfx.WebGLShaderUniform(this, "outlineThickness", "float");
            this._uSamplerBack = new e.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler");
            this._uDestStart = new e.Gfx.WebGLShaderUniform(this, "destStart", "vec2");
            this._uDestEnd = new e.Gfx.WebGLShaderUniform(this, "destEnd", "vec2");
            this._uSrcStart = new e.Gfx.WebGLShaderUniform(this,
                "srcStart", "vec2");
            this._uSrcEnd = new e.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2");
            this._uSrcOriginStart = new e.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2");
            this._uSrcOriginEnd = new e.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2");
            this._uPixelSize = new e.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2");
            this._uSeconds = new e.Gfx.WebGLShaderUniform(this, "seconds", "float");
            this._uLayerScale = new e.Gfx.WebGLShaderUniform(this, "layerScale", "float");
            this._uLayerAngle = new e.Gfx.WebGLShaderUniform(this,
                "layerAngle", "float");
            this._uLayoutStart = new e.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2");
            this._uLayoutEnd = new e.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2");
            this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() ||
                this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
            this._extendBoxHorizontal = c.extendBoxHorizontal || 0;
            this._extendBoxVertical = c.extendBoxVertical || 0;
            this._crossSampling = !!c.crossSampling;
            this._mustPreDraw = !!c.mustPreDraw;
            this._preservesOpaqueness = !!c.preservesOpaqueness;
            this._animated = !!c.animated;
            a = c.parameters || [];
            this._uCustomParameters = [];
            this._usesDest = this._uDestStart.IsUsed() || this._uDestEnd.IsUsed();
            this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() ||
                this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();
            this._needsPostDrawOrExtendBox = this._crossSampling || this._usesDest || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical;
            this._hasCurrentMatMV = this._hasCurrentMatP = !1;
            this._uColor.Init4f(1, 1, 1, 1);
            this._uColor2.Init4f(1, 1, 1, 1);
            this._uSamplerFront.Init1i(0);
            this._uSamplerBack.Init1i(1);
            this._uPointTexStart.Init2f(0, 0);
            this._uPointTexEnd.Init2f(1, 1);
            this._uZElevation.Init1f(0);
            this._uTileSize.Init2f(0, 0);
            this._uTileSpacing.Init2f(0,
                0);
            this._uDestStart.Init2f(0, 0);
            this._uDestEnd.Init2f(1, 1);
            this._uSrcStart.Init2f(0, 0);
            this._uSrcEnd.Init2f(0, 0);
            this._uSrcOriginStart.Init2f(0, 0);
            this._uSrcOriginEnd.Init2f(0, 0);
            this._uPixelSize.Init2f(0, 0);
            this._uLayerScale.Init1f(1);
            this._uLayerAngle.Init1f(0);
            this._uSeconds.Init1f(0);
            this._uLayoutStart.Init2f(0, 0);
            this._uLayoutEnd.Init2f(0, 0);
            this._uOutlineThickness.Init1f(1);
            for (const m of a) a = m[2], b = new e.Gfx.WebGLShaderUniform(this, m[0], a), "color" === a ? b.Init3f(0, 0, 0) : b.Init1f(0), this._uCustomParameters.push(b);
            this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(g.currentMatP) : (this.UpdateMatP(g.currentMatP, !0), this.UpdateMatMV(g.currentMV, !0));
            g = g.currentShader;
            h.useProgram(g ? g._shaderProgram : null)
        }
        Release() {
            this._gl.deleteProgram(this._shaderProgram);
            this._shaderProgram = null;
            this._renderer._RemoveShaderProgram(this);
            this._renderer = this._gl = null
        }
        GetName() {
            return this._name
        }
        GetWebGLContext() {
            return this._gl
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        UsesDest() {
            return this._usesDest
        }
        UsesCrossSampling() {
            return this._crossSampling
        }
        MustPreDraw() {
            return this._mustPreDraw
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        ExtendsBox() {
            return 0 !==
                this._extendBoxHorizontal || 0 !== this._extendBoxVertical
        }
        GetBoxExtendHorizontal() {
            return this._extendBoxHorizontal
        }
        GetBoxExtendVertical() {
            return this._extendBoxVertical
        }
        UsesAnySrcRectOrPixelSize() {
            return this._usesAnySrcRectOrPixelSize
        }
        NeedsPostDrawOrExtendsBox() {
            return this._needsPostDrawOrExtendBox
        }
        GetParameterCount() {
            return this._uCustomParameters.length
        }
        GetParameterType(a) {
            return this._uCustomParameters[a].GetType()
        }
        AreCustomParametersAlreadySetInBatch(a) {
            for (let b = 0, c = a.length; b < c; ++b)
                if (!this._uCustomParameters[b].IsSetToCustomInBatch(a[b])) return !1;
            return !0
        }
        SetCustomParametersInBatch(a) {
            for (let b = 0, c = a.length; b < c; ++b) this._uCustomParameters[b].SetBatchValueCustom(a[b])
        }
        AreOptionalUniformsAlreadySetInBatch(a, b, c, f, h, g, k, m, r) {
            return this._uSamplerBack.IsUsed() || this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(h, g) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(a.getLeft(), a.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(a.getRight(), a.getBottom()) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(k) ||
                this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(m) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(b.getLeft(), b.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(b.getRight(), b.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(c.getLeft(), c.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(c.getRight(), c.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(f.getLeft(),
                    f.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(f.getTop(), f.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(r) ? !1 : !0
        }
        SetOptionalUniformsInBatch(a, b, c, f, h, g, k, m, r) {
            this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(h, g), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(a.getLeft(), a.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(a.getRight(), a.getBottom()), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(k),
                this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(m), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(b.getLeft(), b.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(b.getRight(), b.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(c.getLeft(), c.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(c.getRight(), c.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(f.getLeft(), f.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(f.getTop(),
                    f.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(r))
        }
        IsAnimated() {
            return this._animated
        }
        UpdateMatP(a, b) {
            this._hasCurrentMatP && !b || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(a), this._hasCurrentMatP = !0)
        }
        SetMatPStale() {
            this._hasCurrentMatP = !1
        }
        UpdateMatMV(a, b) {
            this._hasCurrentMatMV && !b || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(a), this._hasCurrentMatMV = !0)
        }
        SetMatMVStale() {
            this._hasCurrentMatMV = !1
        }
        _UpdateDeviceTransformUniforms(a) {
            if (!this._isDeviceTransform) throw Error("not device transform shader");
            this._uMatP.UpdateMatrix4fv(a);
            a = this._renderer;
            const b = a.GetWidth() / 2,
                c = a.GetHeight() / 2;
            a = a.CalculateLookAtModelView2(b, c, a.GetDefaultCameraZ() * self.devicePixelRatio, b, c, 0);
            this._uMatMV.UpdateMatrix4fv(a)
        }
        UpdateColor(a) {
            this._uColor.IsUsed() && this._uColor.Update4f(a[0], a[1], a[2], a[3])
        }
        static GetReservedUniformNames() {
            return d
        }
        static GetDefaultVertexShaderSource(a) {
            a = a ? "highmedp" : "mediump";
            return ["#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;",
                `attribute ${a} vec2 aTex;`, `varying ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"
            ].join("\n")
        }
        static GetTextureFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}"
        }
        static GetTilemapFragmentShaderSource() {
            return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}"
        }
        static GetPointVertexShaderSource(a) {
            return e.Gfx.WebGLShaderProgram.GetPointVertexShaderSource_WebGL1()
        }
        static GetPointFragmentShaderSource(a) {
            return e.Gfx.WebGLShaderProgram.GetPointFragmentShaderSource_WebGL1()
        }
        static GetPointVertexShaderSource_WebGL1() {
            return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
        }
        static GetPointFragmentShaderSource_WebGL1() {
            return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;\n}"
        }
        static GetColorFillFragmentShaderSource() {
            return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}"
        }
        static GetLinearGradientFillFragmentShaderSource() {
            return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}"
        }
        static GetSmoothLineFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}"
        }
        static GetHardEllipseFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}"
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}"
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.glMatrix.mat4,
        a = new Map([
            ["float", 1],
            ["percent", 1],
            ["sampler", 1],
            ["vec2", 2],
            ["vec3", 3],
            ["color", 3],
            ["vec4", 4],
            ["mat4", 16]
        ]);
    e.Gfx.WebGLShaderUniform = class {
        constructor(b, c, f) {
            if (!a.has(f)) throw Error("invalid uniform type");
            this._owner = b;
            this._gl = this._owner.GetWebGLContext();
            this._name = c;
            this._type = f;
            this._isColorType = "color" === this._type;
            this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), c);
            this._isUsed = !!this._location;
            b = a.get(f);
            this._lastValue =
                new Float32Array(b);
            this._lastBatchValue = new Float32Array(b)
        }
        Release() {
            this._location = this._gl = this._owner = null
        }
        IsUsed() {
            return this._isUsed
        }
        GetType() {
            return this._type
        }
        IsColorType() {
            return this._isColorType
        }
        Init1f(b) {
            this.IsUsed() && (this._lastValue[0] = b, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, b))
        }
        Init1i(b) {
            this.IsUsed() && (this._lastValue[0] = b, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, b))
        }
        Init2f(b, c) {
            this.IsUsed() && (this._lastValue[0] =
                b, this._lastValue[1] = c, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, b, c))
        }
        Init3f(b, c, f) {
            this.IsUsed() && (this._lastValue[0] = b, this._lastValue[1] = c, this._lastValue[2] = f, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, b, c, f))
        }
        Init4f(b, c, f, h) {
            this.IsUsed() && (this._lastValue[0] = b, this._lastValue[1] = c, this._lastValue[2] = f, this._lastValue[3] = h, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, b, c, f, h))
        }
        Update1f(b) {
            b = Math.fround(b);
            const c = this._lastValue;
            c[0] !== b && (c[0] = b, this._gl.uniform1f(this._location, b))
        }
        Update1i(b) {
            const c = this._lastValue;
            c[0] !== b && (c[0] = b, this._gl.uniform1i(this._location, b))
        }
        Update2f(b, c) {
            b = Math.fround(b);
            c = Math.fround(c);
            const f = this._lastValue;
            if (f[0] !== b || f[1] !== c) f[0] = b, f[1] = c, this._gl.uniform2f(this._location, b, c)
        }
        Update3f(b, c, f) {
            b = Math.fround(b);
            c = Math.fround(c);
            f = Math.fround(f);
            const h = this._lastValue;
            if (h[0] !== b || h[1] !== c || h[2] !== f) h[0] = b, h[1] = c, h[2] = f, this._gl.uniform3f(this._location, b, c,
                f)
        }
        Update4f(b, c, f, h) {
            b = Math.fround(b);
            c = Math.fround(c);
            f = Math.fround(f);
            h = Math.fround(h);
            const g = this._lastValue;
            if (g[0] !== b || g[1] !== c || g[2] !== f || g[3] !== h) g[0] = b, g[1] = c, g[2] = f, g[3] = h, this._gl.uniform4f(this._location, b, c, f, h)
        }
        UpdateMatrix4fv(b) {
            const c = this._lastValue;
            d.exactEquals(c, b) || (e.typedArraySet16(c, b, 0), this._gl.uniformMatrix4fv(this._location, !1, b))
        }
        IsSetToCustomInBatch(b) {
            const c = this._lastBatchValue;
            return this.IsColorType() ? c[0] === Math.fround(b.getR()) && c[1] === Math.fround(b.getG()) &&
                c[2] === Math.fround(b.getB()) : c[0] === Math.fround(b)
        }
        SetBatchValueCustom(b) {
            const c = this._lastBatchValue;
            this.IsColorType() ? (c[0] = b.getR(), c[1] = b.getG(), c[2] = b.getB()) : c[0] = b
        }
        IsSetTo1InBatch(b) {
            return this._lastBatchValue[0] === Math.fround(b)
        }
        IsSetTo2InBatch(b, c) {
            const f = this._lastBatchValue;
            return f[0] === Math.fround(b) && f[1] === Math.fround(c)
        }
        SetBatch1(b) {
            this._lastBatchValue[0] = b
        }
        SetBatch2(b, c) {
            const f = this._lastBatchValue;
            f[0] = b;
            f[1] = c
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.glMatrix,
        a = d.vec4,
        b = d.mat4;
    e.Gfx.BatchState = class {
        constructor(c) {
            this.renderer = c;
            this.currentMV = b.create();
            this.currentMatP = b.create();
            this.currentFramebuffer = null;
            this.currentColor = a.fromValues(1, 1, 1, 1);
            this.currentShader = null;
            this.pointTexCoords = new e.Rect;
            this.clearColor = e.New(e.Color, 0, 0, 0, 0)
        }
    };
    e.Gfx.WebGLBatchJob = class {
        constructor(c) {
            const f = new ArrayBuffer(96);
            this._type = 0;
            this._batchState = c;
            this._gl = c.renderer.GetContext();
            this._indexCount = this._startIndex =
                0;
            this._texParam = null;
            this._mat4param = new Float32Array(f, 0, 16);
            this._colorParam = new Float32Array(f, 64, 4);
            this._srcOriginRect = new Float32Array(f, 80, 4);
            this._shaderParams = []
        }
        InitQuad(c, f) {
            this._type = 1;
            this._startIndex = c;
            this._indexCount = f
        }
        DoQuad() {
            const c = this._gl;
            c.drawElements(c.TRIANGLES, this._indexCount, c.UNSIGNED_SHORT, this._startIndex)
        }
        InitSetTexture(c) {
            this._type = 2;
            this._texParam = c
        }
        DoSetTexture() {
            const c = this._gl,
                f = this._texParam;
            c.bindTexture(c.TEXTURE_2D, f ? f._GetTexture() : null)
        }
        InitSetColor(c) {
            this._type =
                3;
            c.writeToTypedArray(this._colorParam, 0)
        }
        DoSetColor() {
            const c = this._colorParam,
                f = this._batchState;
            a.copy(f.currentColor, c);
            f.currentShader.UpdateColor(c)
        }
        InitSetGradientColor(c) {
            this._type = 21;
            c.writeToTypedArray(this._colorParam, 0)
        }
        DoSetGradientColor() {
            const c = this._colorParam,
                f = this._batchState.currentShader;
            f._uColor2.IsUsed() && f._uColor2.Update4f(c[0], c[1], c[2], c[3])
        }
        InitSetBlend(c, f) {
            this._type = 4;
            this._startIndex = c;
            this._indexCount = f
        }
        DoSetBlend() {
            this._gl.blendFunc(this._startIndex, this._indexCount)
        }
        InitSetViewport(c,
            f, h, g) {
            this._type = 5;
            const k = this._colorParam;
            k[0] = c;
            k[1] = f;
            k[2] = h;
            k[3] = g
        }
        DoSetViewport() {
            const c = this._colorParam;
            this._gl.viewport(c[0], c[1], c[2], c[3])
        }
        InitSetProjection(c) {
            this._type = 6;
            b.copy(this._mat4param, c)
        }
        DoSetProjection() {
            const c = this._batchState,
                f = c.renderer._allShaderPrograms,
                h = c.currentShader,
                g = this._mat4param;
            for (let k = 0, m = f.length; k < m; ++k) {
                const r = f[k];
                r === h ? r.UpdateMatP(g, !0) : r.SetMatPStale()
            }
            b.copy(c.currentMatP, g)
        }
        InitSetModelView(c) {
            this._type = 7;
            b.copy(this._mat4param, c)
        }
        DoSetModelView() {
            const c =
                this._batchState,
                f = c.renderer._allShaderPrograms,
                h = c.currentShader,
                g = this._mat4param;
            for (let k = 0, m = f.length; k < m; ++k) {
                const r = f[k];
                r === h ? r.UpdateMatMV(g, !0) : r.SetMatMVStale()
            }
            b.copy(c.currentMV, g)
        }
        InitSetRenderTarget(c) {
            this._type = 8;
            this._texParam = c
        }
        DoSetRenderTarget() {
            const c = this._gl;
            var f = this._texParam;
            const h = this._batchState;
            f ? (f = f._GetFramebuffer(), h.currentFramebuffer = f, c.bindFramebuffer(c.FRAMEBUFFER, f)) : (h.currentFramebuffer = null, c.bindFramebuffer(c.FRAMEBUFFER, null))
        }
        InitClearSurface(c) {
            this._type =
                9;
            c.writeToTypedArray(this._mat4param, 0)
        }
        InitClearSurface2(c, f, h, g) {
            this._type = 9;
            const k = this._mat4param;
            k[0] = c;
            k[1] = f;
            k[2] = h;
            k[3] = g
        }
        DoClearSurface() {
            const c = this._gl;
            var f = this._mat4param,
                h = this._batchState;
            const g = h.clearColor;
            (h = h.renderer._isScissorViewport && e.isDebug) && c.disable(c.SCISSOR_TEST);
            const k = f[0],
                m = f[1],
                r = f[2];
            f = f[3];
            g.equalsRgba(k, m, r, f) || (c.clearColor(k, m, r, f), g.setRgba(k, m, r, f));
            c.clear(c.COLOR_BUFFER_BIT);
            h && c.enable(c.SCISSOR_TEST)
        }
        InitClearRect(c, f, h, g, k, m, r, w) {
            this._type = 10;
            const p = this._mat4param;
            p[0] = c;
            p[1] = f;
            p[2] = h;
            p[3] = g;
            p[4] = k;
            p[5] = m;
            p[6] = r;
            p[7] = w
        }
        DoClearRectangle() {
            const c = this._gl;
            var f = this._mat4param,
                h = this._batchState;
            const g = h.renderer;
            h = h.clearColor;
            g._isScissorViewport || c.enable(c.SCISSOR_TEST);
            c.scissor(f[0], f[1], f[2], f[3]);
            const k = f[4],
                m = f[5],
                r = f[6];
            f = f[7];
            h.equalsRgba(k, m, r, f) || (c.clearColor(k, m, r, f), h.setRgba(k, m, r, f));
            c.clear(c.COLOR_BUFFER_BIT);
            g._isScissorViewport ? c.scissor(0, 0, g._viewportScissorWidth, g._viewportScissorHeight) : c.disable(c.SCISSOR_TEST)
        }
        InitSetPointTexCoords(c) {
            this._type =
                15;
            c.writeToTypedArray(this._mat4param, 0)
        }
        DoSetPointTextureCoords() {
            const c = this._mat4param;
            this._batchState.pointTexCoords.set(c[0], c[1], c[2], c[3])
        }
        InitPoints(c, f) {
            this._type = 11;
            this._startIndex = c;
            this._indexCount = 1;
            this._mat4param[0] = f
        }
        DoPoints() {
            const c = this._gl,
                f = this._batchState,
                h = f.renderer._spPoints;
            c.useProgram(h._shaderProgram);
            h.UpdateMatP(f.currentMatP, !1);
            h.UpdateMatMV(f.currentMV, !1);
            var g = f.pointTexCoords;
            h._uPointTexStart.IsUsed() && h._uPointTexStart.Update2f(g.getLeft(), g.getTop());
            h._uPointTexEnd.IsUsed() && h._uPointTexEnd.Update2f(g.getRight(), g.getBottom());
            g = this._mat4param[0];
            h._uZElevation.IsUsed() && h._uZElevation.Update1f(g);
            h._uColor.IsUsed() && (g = f.currentColor, h._uColor.Update4f(g[0], g[1], g[2], g[3]));
            c.drawArrays(c.POINTS, this._startIndex / 4, this._indexCount);
            c.useProgram(f.currentShader._shaderProgram)
        }
        InitSetProgram(c) {
            this._type = 12;
            this._texParam = c
        }
        DoSetProgram() {
            var c = this._gl;
            const f = this._batchState,
                h = this._texParam;
            f.currentShader = h;
            c.useProgram(h._shaderProgram);
            h.UpdateMatP(f.currentMatP, !1);
            h.UpdateMatMV(f.currentMV, !1);
            h._uColor.IsUsed() && (c = f.currentColor, h._uColor.Update4f(c[0], c[1], c[2], c[3]))
        }
        InitSetProgramParameters() {
            this._type = 13
        }
        DoSetProgramParameters() {
            const c = this._batchState.currentShader;
            c._hasAnyOptionalUniforms && this._DoSetOptionalUniformProgramParameters(c);
            c._uCustomParameters.length && this._DoUpdateCustomProgramParameters(c)
        }
        _DoSetOptionalUniformProgramParameters(c) {
            const f = this._gl,
                h = this._mat4param,
                g = this._colorParam,
                k = this._srcOriginRect;
            if (c._uSamplerBack.IsUsed()) {
                const m = this._batchState.renderer,
                    r = this._texParam;
                m._lastTexture1 !== r && (f.activeTexture(f.TEXTURE1), f.bindTexture(f.TEXTURE_2D, r ? r._GetTexture() : null), m._lastTexture1 = r, f.activeTexture(f.TEXTURE0))
            }
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(h[0], h[1]);
            c._uDestStart.IsUsed() && c._uDestStart.Update2f(h[2], h[3]);
            c._uDestEnd.IsUsed() && c._uDestEnd.Update2f(h[4], h[5]);
            c._uLayerScale.IsUsed() && c._uLayerScale.Update1f(h[6]);
            c._uLayerAngle.IsUsed() && c._uLayerAngle.Update1f(h[7]);
            c._uSrcStart.IsUsed() && c._uSrcStart.Update2f(h[12], h[13]);
            c._uSrcEnd.IsUsed() && c._uSrcEnd.Update2f(h[14], h[15]);
            c._uSrcOriginStart.IsUsed() && c._uSrcOriginStart.Update2f(k[0], k[1]);
            c._uSrcOriginEnd.IsUsed() && c._uSrcOriginEnd.Update2f(k[2], k[3]);
            c._uLayoutStart.IsUsed() && c._uLayoutStart.Update2f(g[0], g[1]);
            c._uLayoutEnd.IsUsed() && c._uLayoutEnd.Update2f(g[2], g[3]);
            c._uSeconds.IsUsed() && c._uSeconds.Update1f(this._startIndex)
        }
        _DoUpdateCustomProgramParameters(c) {
            c = c._uCustomParameters;
            const f = this._shaderParams;
            for (let h = 0, g = c.length; h < g; ++h) {
                const k = c[h],
                    m = f[h];
                k.IsColorType() ? k.Update3f(m.getR(), m.getG(), m.getB()) : k.Update1f(m)
            }
        }
        InitInvalidateFramebuffer(c) {
            this._type = 14;
            this._texParam = c
        }
        DoInvalidateFramebuffer() {
            const c = this._gl,
                f = this._texParam,
                h = this._batchState.currentFramebuffer;
            f !== h && c.bindFramebuffer(c.FRAMEBUFFER, f);
            c.invalidateFramebuffer(c.FRAMEBUFFER, [c.COLOR_ATTACHMENT0]);
            f !== h && c.bindFramebuffer(c.FRAMEBUFFER, h)
        }
        InitBlitFramebuffer(c, f, h) {
            this._type = 17;
            const g = this._mat4param,
                k = this._batchState.renderer;
            g[0] = c.GetWidth();
            g[1] = c.GetHeight();
            g[2] = f ? f.GetWidth() : k.GetWidth();
            g[3] = f ? f.GetHeight() : k.GetHeight();
            g[4] = c.IsLinearSampling() ? 1 : 0;
            g[5] = "stretch" === h;
            h = this._shaderParams;
            e.clearArray(h);
            h.push(c._GetFramebuffer());
            h.push(f ? f._GetFramebuffer() : null)
        }
        DoBlitFramebuffer() {
            var c = this._mat4param,
                f = this._shaderParams;
            const h = this._gl;
            var g = c[0],
                k = c[1],
                m = c[2];
            const r = c[3],
                w = 0 !== c[4];
            c = 0 !== c[5];
            const p = f[1];
            h.bindFramebuffer(h.READ_FRAMEBUFFER, f[0]);
            h.bindFramebuffer(h.DRAW_FRAMEBUFFER, p);
            c ? h.blitFramebuffer(0,
                0, g, k, 0, 0, m, r, h.COLOR_BUFFER_BIT, w ? h.LINEAR : h.NEAREST) : (f = Math.min(g, m), g = Math.min(k, r), m = Math.max(k - r, 0), k = Math.max(r - k, 0), h.blitFramebuffer(0, m, f, g + m, 0, k, f, g + k, h.COLOR_BUFFER_BIT, h.NEAREST))
        }
        InitStartQuery(c) {
            this._type = 18;
            this._texParam = c
        }
        DoStartQuery() {
            this._texParam.BeginTimeElapsed();
            this._texParam = null
        }
        InitEndQuery(c) {
            this._type = 19;
            this._texParam = c
        }
        DoEndQuery() {
            this._texParam.EndTimeElapsed();
            this._texParam = null
        }
        InitSetEllipseParams(c, f, h) {
            this._type = 20;
            const g = this._mat4param;
            g[0] = c;
            g[1] =
                f;
            g[2] = h
        }
        DoSetEllipseParams() {
            const c = this._batchState.currentShader,
                f = this._mat4param;
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(f[0], f[1]);
            c._uOutlineThickness.IsUsed() && c._uOutlineThickness.Update1f(f[2])
        }
        InitSetTilemapInfo(c, f, h, g, k, m, r) {
            this._type = 16;
            const w = this._mat4param;
            c.writeToTypedArray(w, 0);
            w[4] = 1 / f;
            w[5] = 1 / h;
            w[6] = g / f;
            w[7] = k / h;
            w[8] = m / f;
            w[9] = r / h
        }
        DoSetTilemapInfo() {
            const c = this._batchState.currentShader,
                f = this._mat4param;
            c._uSrcStart.IsUsed() && c._uSrcStart.Update2f(f[0], f[1]);
            c._uPixelSize.IsUsed() &&
                c._uPixelSize.Update2f(f[4], f[5]);
            c._uTileSize.IsUsed() && c._uTileSize.Update2f(f[6], f[7]);
            c._uTileSpacing.IsUsed() && c._uTileSpacing.Update2f(f[8], f[9])
        }
        InitClearDepth() {
            this._type = 22
        }
        DoClearDepth() {
            const c = this._gl;
            c.clear(c.DEPTH_BUFFER_BIT)
        }
        InitSetDepthEnabled(c) {
            this._type = 23;
            this._startIndex = c ? 1 : 0
        }
        DoSetDepthEnabled() {
            const c = this._gl;
            0 === this._startIndex ? (c.disable(c.DEPTH_TEST), c.depthMask(!1)) : (c.enable(c.DEPTH_TEST), c.depthMask(!0))
        }
        InitCoplanarStartStencilPass() {
            this._type = 24
        }
        DoCoplanarStartStencilPass() {
            const c =
                this._gl;
            c.clear(c.STENCIL_BUFFER_BIT);
            c.enable(c.STENCIL_TEST);
            c.stencilFunc(c.ALWAYS, 1, 1);
            c.stencilOp(c.KEEP, c.KEEP, c.REPLACE);
            c.colorMask(!1, !1, !1, !1)
        }
        InitCoplanarStartColorPass() {
            this._type = 25
        }
        DoCoplanarStartColorPass() {
            const c = this._gl;
            c.colorMask(!0, !0, !0, !0);
            c.stencilFunc(c.EQUAL, 1, 1);
            c.stencilOp(c.KEEP, c.KEEP, c.KEEP)
        }
        InitCoplanarRestore() {
            this._type = 26
        }
        DoCoplanarRestore() {
            const c = this._gl;
            c.disable(c.STENCIL_TEST)
        }
        Run() {
            switch (this._type) {
                case 1:
                    this.DoQuad();
                    break;
                case 2:
                    this.DoSetTexture();
                    break;
                case 3:
                    this.DoSetColor();
                    break;
                case 4:
                    this.DoSetBlend();
                    break;
                case 5:
                    this.DoSetViewport();
                    break;
                case 6:
                    this.DoSetProjection();
                    break;
                case 7:
                    this.DoSetModelView();
                    break;
                case 8:
                    this.DoSetRenderTarget();
                    break;
                case 9:
                    this.DoClearSurface();
                    break;
                case 10:
                    this.DoClearRectangle();
                    break;
                case 11:
                    this.DoPoints();
                    break;
                case 12:
                    this.DoSetProgram();
                    break;
                case 13:
                    this.DoSetProgramParameters();
                    break;
                case 14:
                    this.DoInvalidateFramebuffer();
                    break;
                case 15:
                    this.DoSetPointTextureCoords();
                    break;
                case 16:
                    this.DoSetTilemapInfo();
                    break;
                case 17:
                    this.DoBlitFramebuffer();
                    break;
                case 18:
                    this.DoStartQuery();
                    break;
                case 19:
                    this.DoEndQuery();
                    break;
                case 20:
                    this.DoSetEllipseParams();
                    break;
                case 21:
                    this.DoSetGradientColor();
                    break;
                case 22:
                    this.DoClearDepth();
                    break;
                case 23:
                    this.DoSetDepthEnabled();
                    break;
                case 24:
                    this.DoCoplanarStartStencilPass();
                    break;
                case 25:
                    this.DoCoplanarStartColorPass();
                    break;
                case 26:
                    this.DoCoplanarRestore()
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = {
            timeout: 60
        },
        a = new e.Color(0, 0, 0, 1),
        b = new Set(["left", "center", "right"]),
        c = new Set(["top", "center", "bottom"]),
        f = new Set(["word", "character"]),
        h = new Set;
    e.FontManager && e.FontManager.addEventListener("fontload", p => {
        p = p.font.GetName();
        for (const t of h)(t.IsBBCodeEnabled() || e.equalsNoCase(t.GetFontName(), p)) && t._SetTextChanged()
    });

    function g(p, t, u, q, x, y) {
        t ? "Gecko" === e.Platform.BrowserEngine ? p.strokeText(u, q, x, y) : p.strokeText(u, q, x) : "Gecko" === e.Platform.BrowserEngine ? p.fillText(u,
            q, x, y) : p.fillText(u, q, x)
    }

    function k(p, t, u, q, x, y) {
        t ? p.strokeRect(u, q, x, y) : p.fillRect(u, q, x, y)
    }

    function m(p) {
        return 4 / 3 * p
    }
    let r = !1,
        w = !1;
    e.Gfx.RendererText = class {
        constructor(p, t) {
            t = Object.assign({}, d, t);
            this._renderer = p;
            this._fontName = "Arial";
            this._fontSize = 16;
            this._fontSizeScale = 1;
            this._lineHeight = 0;
            this._isItalic = this._isBold = !1;
            this._colorStr = "black";
            this._isBBcodeEnabled = !1;
            this.onloadfont = null;
            this._alreadyLoadedFonts = new Set;
            this._horizontalAlign = "left";
            this._verticalAlign = "top";
            this._text = "";
            this._bbString = null;
            this._wrappedText = e.New(e.WordWrap);
            this._wrapMode = "word";
            this._isUpdating = this._textChanged = !1;
            this._isAsync = !0;
            this._drawMaxCharCount = -1;
            this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0;
            this._zoom = 1;
            this._changed = !1;
            this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = null;
            this._lastCanvasHeight = this._lastCanvasWidth = -1;
            this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = "";
            this._lastTextCanvasLineWidth =
                this._lastTextCanvasOpacity = 1;
            this._measureTextCallback = (u, q) => this._MeasureText(u, q);
            this._texture = null;
            this._textureHeight = this._textureWidth = 0;
            this._rcTex = new e.Rect;
            this._scaleFactor = 1;
            this._needToRecreateTexture = !1;
            this._textureTimeout = new e.IdleTimeout(() => {
                this.ReleaseTexture();
                this._SetTextCanvasSize(8, 8)
            }, t.timeout);
            this.ontextureupdate = null;
            this._wasReleased = !1;
            h.add(this)
        }
        Release() {
            this.onloadfont = null;
            this._alreadyLoadedFonts.clear();
            this._measureTextCallback = this._measureContextTop = this._measureContext =
                this._textContext = this._textCanvas = this._bbString = null;
            this._textureTimeout.Release();
            this.ontextureupdate = null;
            this.ReleaseTexture();
            this._wrappedText.Clear();
            this._renderer = this._wrappedText = null;
            this._wasReleased = !0;
            h.delete(this)
        }
        _SetChanged() {
            this._changed = !0
        }
        _SetTextChanged() {
            this._SetChanged();
            this._wrappedText.Clear();
            this._textChanged = !0
        }
        SetIsAsync(p) {
            this._isAsync = !!p
        }
        IsAsync() {
            return this._isAsync
        }
        SetBBCodeEnabled(p) {
            p = !!p;
            this._isBBcodeEnabled !== p && (p = (this._isBBcodeEnabled = p) ? "alphabetic" :
                "top", this._textContext && (this._textContext.textBaseline = p), this._measureContext && (this._measureContext.textBaseline = p), this._SetTextChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetFontName(p) {
            p || (p = "serif");
            this._fontName !== p && (this._fontName = p, this._SetTextChanged())
        }
        GetFontName() {
            return this._fontName
        }
        SetFontSize(p) {
            .1 > p && (p = .1);
            this._fontSize !== p && (this._fontSize = p, this._SetTextChanged())
        }
        SetFontSizeScale(p) {
            this._fontSizeScale !== p && (this._fontSizeScale = p, this._SetTextChanged())
        }
        SetLineHeight(p) {
            this._lineHeight !==
                p && (this._lineHeight = p, this._SetChanged())
        }
        SetBold(p) {
            p = !!p;
            this._isBold !== p && (this._isBold = p, this._SetTextChanged())
        }
        SetItalic(p) {
            p = !!p;
            this._isItalic !== p && (this._isItalic = p, this._SetTextChanged())
        }
        SetDrawMaxCharacterCount(p) {
            p = Math.floor(p);
            this._drawMaxCharCount !== p && (this._drawMaxCharCount = p, this._SetChanged())
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(p, t) {
            for (let u = p.length - 1; 0 <= u; --u) {
                const q = p[u];
                if (q.tag === t) return q
            }
            return null
        }
        _HasStyleTag(p, t) {
            return !!this._GetStyleTag(p,
                t)
        }
        _GetFontString(p, t) {
            let u = [];
            (this._isBold || this._HasStyleTag(t, "b")) && u.push("bold");
            (this._isItalic || this._HasStyleTag(t, "i")) && u.push("italic");
            var q = this._GetStyleTag(t, "size");
            q = (q ? parseFloat(q.param) : this._fontSize) * this._fontSizeScale;
            p ? u.push(q + "pt") : u.push(q * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt");
            p = this._fontName;
            (t = this._GetStyleTag(t, "font")) && t.param && (p = t.param, this.onloadfont && !this._alreadyLoadedFonts.has(p) && (this.onloadfont(p), this._alreadyLoadedFonts.add(p)));
            p && u.push('"' + p + '"');
            return u.join(" ")
        }
        SetColor(p) {
            p instanceof e.Color && (p = p.getCssRgb());
            this._colorStr !== p && (this._colorStr = p, this._SetChanged())
        }
        SetColorRgb(p, t, u) {
            a.setRgb(p, t, u);
            this.SetColor(a)
        }
        SetHorizontalAlignment(p) {
            if (!b.has(p)) throw Error("invalid horizontal alignment");
            this._horizontalAlign !== p && (this._horizontalAlign = p, this._SetChanged())
        }
        SetVerticalAlignment(p) {
            if (!c.has(p)) throw Error("invalid vertical alignment");
            this._verticalAlign !== p && (this._verticalAlign = p, this._SetChanged())
        }
        SetWordWrapMode(p) {
            if (!f.has(p)) throw Error("invalid word wrap mode");
            this._wrapMode !== p && (this._wrapMode = p, this._SetTextChanged())
        }
        SetText(p) {
            this._text !== p && (this._text = p, this._SetTextChanged())
        }
        SetSize(p, t, u) {
            "undefined" === typeof u && (u = 1);
            if (!(0 >= p || 0 >= p || this._cssWidth === p && this._cssHeight === t && this._zoom === u)) {
                1 === this._zoom !== (1 === u) && (this._needToRecreateTexture = !0);
                var q = this._cssWidth,
                    x = this._zoom;
                this._cssWidth = p;
                this._cssHeight = t;
                this._zoom = u;
                p = self.devicePixelRatio;
                this._width = this._cssWidth * this._zoom * p;
                this._height = this._cssHeight * this._zoom * p;
                p = Math.max(this._width,
                    this._height);
                t = Math.min(this._renderer.GetMaxTextureSize(), 2048);
                u = 1;
                p > t && (u = t / p, this._width = Math.min(this._width * u, t), this._height = Math.min(this._height * u, t));
                this._scaleFactor = u;
                0 < this._textureWidth && 0 < this._textureHeight && this._zoom === x && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight);
                this._cssWidth !== q ? this._SetTextChanged() : this._SetChanged()
            }
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetTextWidth() {
            this._MaybeWrapText();
            return this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight
        }
        GetTexture() {
            this._textureTimeout.Reset();
            this._MaybeUpdate();
            return this._texture
        }
        _MaybeUpdate() {
            this._texture && !this._changed && !this._textChanged || this._isUpdating || 0 >= this._width || 0 >= this._height || (this._changed = !1, this._isUpdating = !0, this._isAsync ? e.Asyncify(() => this._DoUpdate()) : this._DoUpdate())
        }
        _DoUpdate() {
            this._wasReleased || (this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height)),
                this._MaybeWrapText(), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset(), this._isUpdating = !1)
        }
        _SetTextCanvasSize(p, t) {
            this._textCanvas || (this._textCanvas = e.CreateCanvas(16, 16));
            let u = !1;
            if (this._lastCanvasWidth !== p || this._lastCanvasHeight !== t) this._lastCanvasWidth = p, this._lastCanvasHeight = t, this._textCanvas.width = p, this._textCanvas.height = t, u = !0;
            this._textContext || (this._textContext = this._textCanvas.getContext("2d"), u = !0);
            u ? (this._textContext.textBaseline = this._isBBcodeEnabled ?
                "alphabetic" : "top", this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, p, t)
        }
        _MaybeCreateMeasureContext() {
            this._measureContext || (this._measureContext = e.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = e.CreateCanvas(16, 16).getContext("2d"),
                this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline = "top")
        }
        _SetMeasureFontString(p) {
            this._lastMeasureCanvasFont !== p && (this._lastMeasureCanvasFont = p, this._measureContext.font = p, this._measureContextTop.font = p)
        }
        _SupportsFontBoundingBoxMeasurements() {
            if (!r) {
                r = !0;
                this._MaybeCreateMeasureContext();
                const p = this._measureContext.measureText("test");
                w = "number" === typeof p.fontBoundingBoxAscent && "number" === typeof p.fontBoundingBoxDescent
            }
            return w
        }
        _MaybeWrapText() {
            this._textChanged &&
                (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new e.BBString(this._text, {
                    noEscape: !0
                })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._textChanged = !1)
        }
        _MeasureText(p, t) {
            this._SetMeasureFontString(this._GetFontString(!0, t));
            t = this._GetStyleTag(t, "size");
            t = (t ? parseFloat(t.param) : this._fontSize) * this._fontSizeScale;
            const u = this._measureContext.measureText(p);
            let q = 0;
            this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements() && (p = this._measureContextTop.measureText(p), q = u.fontBoundingBoxAscent - p.fontBoundingBoxAscent);
            return {
                width: u.width,
                height: m(t),
                fontBoundingBoxAscent: u.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: u.fontBoundingBoxDescent || 0,
                topToAlphabeticDistance: q
            }
        }
        _SetDrawFontString(p) {
            this._lastTextCanvasFont !== p && (this._lastTextCanvasFont = p, this._textContext.font = p)
        }
        _SetDrawCanvasColor(p) {
            this._lastTextCanvasFillStyle !==
                p && (this._lastTextCanvasFillStyle = p, this._textContext.fillStyle = p, this._textContext.strokeStyle = p)
        }
        _SetDrawCanvasOpacity(p) {
            this._lastTextCanvasOpacity !== p && (this._lastTextCanvasOpacity = p, this._textContext.globalAlpha = p)
        }
        _SetDrawCanvasLineWith(p) {
            this._lastTextCanvasLineWidth !== p && (this._lastTextCanvasLineWidth = p, this._textContext.lineWidth = p)
        }
        _DrawTextToCanvas() {
            this._drawCharCount = 0;
            const p = this._scaleFactor * this._zoom * self.devicePixelRatio,
                t = (4 + this._lineHeight) * p;
            var u = 0;
            const q = this._wrappedText.GetLines();
            if (0 !== q.length) {
                var x = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements(),
                    y = q[0].height * p;
                "center" === this._verticalAlign ? (u = q.reduce((B, F) => B + F.height * p + t, 0) - t, u = Math.max(this._height / 2 - u / 2, 0), x && (y = q[0].topToAlphabeticDistance * p)) : "bottom" === this._verticalAlign && (u = q.reduce((B, F) => B + F.height * p + t, 0) - this._lineHeight * p, x = x ? q.at(-1).fontBoundingBoxDescent * p : 0, u = this._height - u - x - 2);
                for (let B = 0, F = q.length; B < F; ++B) {
                    x = q[B];
                    const H = x.height * p,
                        K = u;
                    if (this._isBBcodeEnabled) {
                        if (u += 0 === B ? y : H,
                            0 < B && u > this._height - 4 * p) break
                    } else if (0 < B && u >= this._height - H) break;
                    0 <= K && this._DrawTextLine(x, u, p);
                    this._isBBcodeEnabled || (u += H);
                    u += t
                }
            }
        }
        _DrawTextLine(p, t, u) {
            let q = 0;
            "center" === this._horizontalAlign ? q = (this._width - p.width * u) / 2 : "right" === this._horizontalAlign && (q = this._width - p.width * u);
            for (const x of p.fragments) this._DrawTextFragment(x, q, t, u, p.height), q += x.width * u
        }
        _DrawTextFragment(p, t, u, q, x) {
            const y = this._textContext,
                B = x / 16;
            x = p.width * q;
            const F = p.height * q,
                H = p.height / 16;
            var K = (4 + this._lineHeight) * q,
                C = p.styles;
            p = p.text;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount) return;
                this._drawCharCount + p.length > this._drawMaxCharCount && (p = p.substr(0, this._drawMaxCharCount - this._drawCharCount), x = this._MeasureText(p, C).width * q);
                this._drawCharCount += p.length
            }
            var A = this._GetStyleTag(C, "background");
            const G = this._HasStyleTag(C, "u"),
                J = this._HasStyleTag(C, "s");
            if ((!e.IsStringAllWhitespace(p) || A || G || J) && !this._HasStyleTag(C, "hide")) {
                var M = this._GetStyleTag(C, "offsetx");
                t += M ? parseFloat(M.param) *
                    q : 0;
                M = this._GetStyleTag(C, "offsety");
                u += M ? parseFloat(M.param) * q : 0;
                A && (this._SetDrawCanvasColor(A.param), y.fillRect(t, u - F, x, F + K));
                K = this._GetStyleTag(C, "color");
                this._SetDrawCanvasColor(K ? K.param : this._colorStr);
                A = this._GetStyleTag(C, "opacity");
                this._SetDrawCanvasOpacity(A ? parseFloat(A.param) / 100 : 1);
                A = (A = this._GetStyleTag(C, "linethickness")) ? parseFloat(A.param) : 1;
                (M = this._HasStyleTag(C, "stroke")) && this._SetDrawCanvasLineWith(.5 * H * A * this._scaleFactor * this._zoom * self.devicePixelRatio);
                this._SetDrawFontString(this._GetFontString(!1,
                    C));
                g(y, M, p, t, u, x);
                !M && (this._SetDrawCanvasLineWith(.5 * H * A * this._scaleFactor * this._zoom * self.devicePixelRatio), C = this._GetStyleTag(C, "outline")) && (this._SetDrawCanvasColor(C.param), g(y, !0, p, t, u, x));
                this._SetDrawCanvasColor(K ? K.param : this._colorStr);
                G && k(y, M, t, u + q * B, x, q * B * A);
                J && (q *= H, y.fillRect(t, u - F / 4 + q / 2 - q * A / 2, x, q * A))
            }
        }
        _UpdateTexture() {
            if (!this._renderer.IsContextLost() && (this._textureWidth = Math.ceil(this._width), this._textureHeight = Math.ceil(this._height), this._rcTex.set(0, 0, this._width / this._textureWidth,
                    this._height / this._textureHeight), this._needToRecreateTexture && (this.ReleaseTexture(), this._needToRecreateTexture = !1), this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
                    mipMap: 1 === this._zoom,
                    mipMapQuality: "high"
                })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this.ontextureupdate)) this.ontextureupdate()
        }
        GetTexRect() {
            return this._rcTex
        }
        ReleaseTexture() {
            this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture),
                this._texture = null)
        }
        static OnContextLost() {
            for (const p of h) p.ReleaseTexture()
        }
        static GetAll() {
            return h.values()
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor(a) {
            this._gl = a.GetContext();
            this._version = a.GetWebGLVersionNumber();
            this._timerExt = a._GetDisjointTimerQueryExtension();
            this._query = null;
            this._hasResult = this._isActive = !1;
            this._result = 0;
            this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
        }
        Release() {
            this._DeleteQueryObject();
            this._timerExt = this._gl = null;
            this._hasResult = !1
        }
        _DeleteQueryObject() {
            this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
                this._query = null)
        }
        BeginTimeElapsed() {
            if (this._isActive) throw Error("query already active");
            1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
            this._isActive = !0
        }
        EndTimeElapsed() {
            if (!this._isActive) throw Error("query not active");
            1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
            this._isActive = !1
        }
        CheckForResult() {
            if (this._query &&
                !this._hasResult && !this._isActive) {
                var a = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
                var b = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
                a && !b && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT), this._result /= 1E9, this._hasResult = !0);
                (a ||
                    b) && this._DeleteQueryObject()
            }
        }
        HasResult() {
            return this._hasResult
        }
        GetResult() {
            if (!this._hasResult) throw Error("no result available");
            return this._result
        }
    }
    e.Gfx.WebGLTimeElapsedQuery = class {
        constructor(a) {
            this._renderer = a;
            this._frameNumber = a.GetFrameNumber();
            this._isActive = !1;
            this._parentQuery = null;
            this._isNested = !1;
            this._realQuery = null;
            this._queries = []
        }
        Release() {
            for (const a of this._queries) a instanceof d && a.Release();
            e.clearArray(this._queries);
            this._renderer = this._realQuery = this._parentQuery = null
        }
        BeginTimeElapsed() {
            if (this._isActive) throw Error("query already active");
            const a = this._renderer._GetTimeQueryStack();
            0 < a.length ? (this._isNested = !0, this._parentQuery = a.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = !1, this._parentQuery = null);
            this._isActive = !0;
            a.push(this);
            this._StartReal()
        }
        EndTimeElapsed() {
            if (!this._isActive) throw Error("query not active");
            if (this._renderer._GetTimeQueryStack().pop() !== this) throw Error("can only end most nested query");
            this._isActive = !1;
            this._EndReal();
            this._parentQuery && (this._parentQuery._StartReal(),
                this._parentQuery = null)
        }
        _StartReal() {
            this._realQuery = e.New(d, this._renderer);
            this._queries.push(this._realQuery);
            this._realQuery.BeginTimeElapsed()
        }
        _EndReal() {
            this._realQuery.EndTimeElapsed();
            this._realQuery = null
        }
        CheckForResult() {
            for (const a of this._queries) a.CheckForResult()
        }
        IsNested() {
            return this._isNested
        }
        HasResult() {
            return this._queries.every(a => a.HasResult())
        }
        GetResult() {
            return this._queries.reduce((a, b) => a + b.GetResult(), 0)
        }
        GetFrameNumber() {
            return this._frameNumber
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Gfx.WebGLQueryResultBuffer = class {
        constructor(d, a = 1E3) {
            this._renderer = d;
            this._maxQueries = a;
            this._buffer = [];
            this._renderer._AddQueryResultBuffer(this)
        }
        Release() {
            this.Clear();
            this._renderer._RemoveQueryResultBuffer(this);
            this._renderer = null
        }
        Clear() {
            for (const d of this._buffer) d.Release();
            e.clearArray(this._buffer)
        }
        AddTimeElapsedQuery() {
            const d = new e.Gfx.WebGLTimeElapsedQuery(this._renderer);
            this._buffer.push(d);
            this._buffer.length > this._maxQueries && this._buffer.shift().Release();
            return d
        }
        CheckForResults(d) {
            for (const a of this._buffer) {
                if (a.GetFrameNumber() >= d) break;
                if (a.IsNested()) break;
                a.CheckForResult()
            }
        }
        GetFrameRangeResultSum(d, a) {
            if (a <= d) return NaN;
            let b = 0;
            for (const c of this._buffer) {
                if (c.GetFrameNumber() >= a) break;
                if (!(c.GetFrameNumber() < d))
                    if (c.HasResult()) b += c.GetResult();
                    else return NaN
            }
            return b
        }
        DeleteAllBeforeFrameNumber(d) {
            for (let a = 0, b = this._buffer.length; a < b; ++a) {
                const c = this._buffer[a];
                if (c.GetFrameNumber() < d) c.Release();
                else {
                    0 < a && this._buffer.splice(0, a);
                    break
                }
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.glMatrix,
        a = d.vec4,
        b = d.mat4,
        c = {
            powerPreference: "default",
            enableGpuProfiling: !0,
            alpha: !1,
            lowLatency: !1,
            depth: !1,
            maxWebGLVersion: 2,
            failIfMajorPerformanceCaveat: !1
        },
        f = new Set(["default", "low-power", "high-performance"]),
        h = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1),
        g = b.create(),
        k = b.create(),
        m = new e.Quad,
        r = new e.Rect;
    let w = null;
    e.isDebug && (self.debug_lose_context = function() {
        w ? w.loseContext() : console.warn("WEBGL_lose_context not supported")
    }, self.debug_restore_context = function() {
        w ? w.restoreContext() :
            console.warn("WEBGL_lose_context not supported")
    });
    const p = new Set;
    let t = -1;

    function u() {
        t = -1;
        for (const q of p) q.checkFunc() && (q.resolve(), p.delete(q));
        0 < p.size && (t = self.requestAnimationFrame(u))
    }
    e.Gfx.WebGLRenderer = class extends e.Gfx.RendererBase {
        constructor(q, x) {
            super();
            x = Object.assign({}, c, x);
            if (!f.has(x.powerPreference)) throw Error("invalid power preference");
            const y = {
                alpha: !!x.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: x.powerPreference,
                failIfMajorPerformanceCaveat: !!x.failIfMajorPerformanceCaveat
            };
            x.lowLatency && (y.desynchronized = !0, y.preserveDrawingBuffer = !0);
            let B = null,
                F = 0;
            2 <= x.maxWebGLVersion && (B = q.getContext("webgl2", y), F = 2);
            B || (B = q.getContext("webgl", y), F = 1);
            if (!B) throw Error("failed to initialise WebGL context");
            this._gl = B;
            this._attribs = B.getContextAttributes();
            x.lowLatency && !this._attribs.desynchronized && console.info("[WebGLRenderer] Low-latency mode specified but is not supported here");
            this._versionString = B.getParameter(B.VERSION);
            this._version = F;
            this._viewport = a.create();
            this._bbProjectionMatrix =
                b.create();
            this._isDepthEnabled = this._usesDepthBuffer = !!x.depth;
            this._depthBuffer = null;
            this._isAutoSizeDepthBuffer = !0;
            this._depthBufferHeight = this._depthBufferWidth = 0;
            this._pointBuffer = this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null;
            this._vertexData = new Float32Array(8E3 * this.GetNumVertexComponents());
            this._indexData = new Uint16Array(12E3);
            this._texcoordData = new Float32Array(16E3);
            this._pointData = new Float32Array(32E3);
            this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
            this._spDeviceTransformTextureFill = this._lastProgram = null;
            this._batch = [];
            this._topOfBatch = this._batchPtr = 0;
            this._currentRenderTarget = null;
            this._lastPointZ = 0;
            this._batchState = e.New(e.Gfx.BatchState, this);
            this._lastColor = e.New(e.Color, 1, 1, 1, 1);
            this._lastTexture1 = this._lastTexture0 = null;
            this._lastDestBlend = this._lastSrcBlend = 0;
            this._isScissorViewport = !1;
            this._viewportScissorHeight = this._viewportScissorWidth = -1;
            this._lastPointTexCoords = new e.Rect;
            this._maxTextureSize = -1;
            this._highpPrecision = this._maxPointSize =
                this._minPointSize = 0;
            this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
            this._extensions = [];
            this._isInitialisingAfterContextRestored = !1;
            this._anisotropicExt = this._parallelShaderCompileExt = null;
            this._maxAnisotropy = 0;
            this._isGpuProfilingEnabled = !!x.enableGpuProfiling;
            this._timerExt = null;
            this._allQueryResultBuffers = new Set;
            this._timeQueryStack = [];
            this.FillIndexBufferData(this._indexData)
        }
        IsWebGL() {
            return !0
        }
        async InitState() {
            super.InitState();
            var q = this._gl,
                x = this.GetNumVertexComponents();
            this._lastColor.setRgba(1,
                1, 1, 1);
            this._lastTexture1 = this._lastTexture0 = null;
            this._pointPtr = this._vertexPtr = 0;
            this._lastVertexPtr = 8E3 * x - 4 * x;
            e.clearArray(this._batch);
            this._topOfBatch = this._batchPtr = 0;
            this._currentRenderTarget = this._lastProgram = null;
            this._lastPointTexCoords.set(0, 0, 1, 1);
            this._lastPointZ = 0;
            x = this._batchState;
            x.currentShader = null;
            x.currentFramebuffer = null;
            a.set(x.currentColor, 1, 1, 1, 1);
            x.clearColor.setRgba(0, 0, 0, 0);
            x.pointTexCoords.set(0, 0, 1, 1);
            q.clearColor(0, 0, 0, 0);
            q.clear(q.COLOR_BUFFER_BIT);
            q.enable(q.BLEND);
            q.blendFunc(q.ONE, q.ONE_MINUS_SRC_ALPHA);
            this._lastSrcBlend = q.ONE;
            this._lastDestBlend = q.ONE_MINUS_SRC_ALPHA;
            this._InitBlendModes(q);
            q.disable(q.CULL_FACE);
            q.disable(q.STENCIL_TEST);
            q.disable(q.DITHER);
            this._usesDepthBuffer ? (q.enable(q.DEPTH_TEST), q.depthMask(!0), q.depthFunc(q.LEQUAL)) : (q.disable(q.DEPTH_TEST), q.depthMask(!1));
            this._isDepthEnabled = this._usesDepthBuffer;
            this._pointBuffer = q.createBuffer();
            q.bindBuffer(q.ARRAY_BUFFER, this._pointBuffer);
            q.bufferData(q.ARRAY_BUFFER, this._pointData.byteLength,
                q.DYNAMIC_DRAW);
            this._vertexBuffer = q.createBuffer();
            q.bindBuffer(q.ARRAY_BUFFER, this._vertexBuffer);
            q.bufferData(q.ARRAY_BUFFER, this._vertexData.byteLength, q.DYNAMIC_DRAW);
            this._texcoordBuffer = q.createBuffer();
            q.bindBuffer(q.ARRAY_BUFFER, this._texcoordBuffer);
            q.bufferData(q.ARRAY_BUFFER, this._texcoordData.byteLength, q.DYNAMIC_DRAW);
            this._indexBuffer = q.createBuffer();
            q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            q.bufferData(q.ELEMENT_ARRAY_BUFFER, this._indexData, q.STATIC_DRAW);
            q.activeTexture(q.TEXTURE0);
            q.bindTexture(q.TEXTURE_2D, null);
            this._maxTextureSize = q.getParameter(q.MAX_TEXTURE_SIZE);
            x = q.getParameter(q.ALIASED_POINT_SIZE_RANGE);
            this._minPointSize = x[0];
            this._maxPointSize = x[1];
            x = q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.HIGH_FLOAT);
            const y = q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.HIGH_FLOAT);
            this._highpPrecision = x && y ? Math.min(x.precision, y.precision) : 0;
            2048 < this._maxPointSize && (this._maxPointSize = 2048);
            this._extensions = q.getSupportedExtensions();
            if (x = q.getExtension("WEBGL_debug_renderer_info")) this._unmaskedVendor =
                q.getParameter(x.UNMASKED_VENDOR_WEBGL), this._unmaskedRenderer = q.getParameter(x.UNMASKED_RENDERER_WEBGL);
            this._parallelShaderCompileExt = q.getExtension("KHR_parallel_shader_compile");
            e.isDebug && (w = q.getExtension("WEBGL_lose_context"));
            if (this._isGpuProfilingEnabled)
                if (1 === this.GetWebGLVersionNumber()) {
                    if ("Chromium" !== e.Platform.BrowserEngine || 81 <= e.Platform.BrowserVersionNumber || "undefined" !== typeof document) this._timerExt = q.getExtension("EXT_disjoint_timer_query")
                } else this._timerExt = q.getExtension("EXT_disjoint_timer_query_webgl2") ||
                    q.getExtension("EXT_disjoint_timer_query");
            this._maxAnisotropy = (this._anisotropicExt = q.getExtension("EXT_texture_filter_anisotropic")) ? q.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            q = e.Gfx.WebGLShaderProgram;
            x = q.GetDefaultVertexShaderSource(!1);
            q = [
                [q.GetTextureFillFragmentShaderSource(), x, "<default>"],
                [q.GetTextureFillFragmentShaderSource(), x, "<default-device-transform>"],
                [q.GetPointFragmentShaderSource(this._version), q.GetPointVertexShaderSource(this._version), "<point>"],
                [q.GetColorFillFragmentShaderSource(), x, "<fill>"],
                [q.GetLinearGradientFillFragmentShaderSource(), x, "<lineargradient>"],
                [q.GetHardEllipseFillFragmentShaderSource(), x, "<hardellipse>"],
                [q.GetHardEllipseOutlineFragmentShaderSource(), x, "<hardellipseoutline>"],
                [q.GetSmoothEllipseFillFragmentShaderSource(), x, "<smoothellipse>"],
                [q.GetSmoothEllipseOutlineFragmentShaderSource(), x, "<smoothellipseoutline>"],
                [q.GetSmoothLineFillFragmentShaderSource(), x, "<smoothline>"],
                [q.GetTilemapFragmentShaderSource(), q.GetDefaultVertexShaderSource(!0),
                    "<tilemap>"
                ]
            ];
            q = await Promise.all(q.map(B => this.CreateShaderProgram({
                src: B[0]
            }, B[1], B[2])));
            this._spTextureFill = q[0];
            this._spDeviceTransformTextureFill = q[1];
            this._spPoints = q[2];
            this._spColorFill = q[3];
            this._spLinearGradientFill = q[4];
            this._spHardEllipseFill = q[5];
            this._spHardEllipseOutline = q[6];
            this._spSmoothEllipseFill = q[7];
            this._spSmoothEllipseOutline = q[8];
            this._spSmoothLineFill = q[9];
            this._spTilemapFill = q[10];
            this.SetTextureFillMode()
        }
        async CreateShaderProgram(q, x, y) {
            q = await e.Gfx.WebGLShaderProgram.Create(this,
                q, x, y);
            this._AddShaderProgram(q);
            return q
        }
        ResetLastProgram() {
            this._lastProgram = null
        }
        SetSize(q, x, y) {
            if (this._width !== q || this._height !== x || y) {
                this.EndBatch();
                y = this._gl;
                var B = this._batchState;
                this._width = q;
                this._height = x;
                q = this.GetScissoredViewportWidth();
                x = this.GetScissoredViewportHeight();
                this._SetViewport(0, 0, q, x);
                this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, q / x);
                this.SetProjectionMatrix(this._bbProjectionMatrix);
                this._spDeviceTransformTextureFill && (y.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()),
                    this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill);
                y.bindTexture(y.TEXTURE_2D, null);
                y.activeTexture(y.TEXTURE1);
                y.bindTexture(y.TEXTURE_2D, null);
                y.activeTexture(y.TEXTURE0);
                this._lastTexture1 = this._lastTexture0 = null;
                this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height);
                this._currentRenderTarget && this._currentRenderTarget._Resize(this._width,
                    this._height);
                y.bindFramebuffer(y.FRAMEBUFFER, null);
                this._currentRenderTarget = null;
                B.currentFramebuffer = null
            }
        }
        _SetDepthBufferSize(q, x) {
            const y = this._gl;
            if (this._depthBuffer) {
                if (this._depthBufferWidth === q && this._depthBufferHeight === x) return;
                y.deleteRenderbuffer(this._depthBuffer)
            }
            this._depthBuffer = y.createRenderbuffer();
            y.bindRenderbuffer(y.RENDERBUFFER, this._depthBuffer);
            y.renderbufferStorage(y.RENDERBUFFER, 2 <= this._version ? y.DEPTH24_STENCIL8 : y.DEPTH_STENCIL, q, x);
            y.bindRenderbuffer(y.RENDERBUFFER,
                null);
            this._depthBufferWidth = q;
            this._depthBufferHeight = x
        }
        SetFixedSizeDepthBuffer(q, x) {
            this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !1, this._SetDepthBufferSize(q, x))
        }
        SetAutoSizeDepthBuffer() {
            this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !0, this._SetDepthBufferSize(this._width, this._height))
        }
        SetViewportScissor(q, x) {
            const y = this._gl;
            if (this._width === q && this._height === x) this._isScissorViewport && (this.EndBatch(), y.disable(y.SCISSOR_TEST), this._isScissorViewport = !1, this._viewportScissorHeight =
                this._viewportScissorWidth = -1, this.SetSize(this._width, this._height, !0));
            else if (this._isScissorViewport || (this.EndBatch(), y.enable(y.SCISSOR_TEST), this._isScissorViewport = !0), this._viewportScissorWidth !== q || this._viewportScissorHeight !== x) this.EndBatch(), y.scissor(0, 0, q, x), this._viewportScissorWidth = q, this._viewportScissorHeight = x, this.SetSize(this._width, this._height, !0)
        }
        RemoveViewportScissor() {
            const q = this._gl;
            this._isScissorViewport && (this.EndBatch(), q.disable(q.SCISSOR_TEST), this._isScissorViewport = !1);
            this._viewportScissorHeight = this._viewportScissorWidth = -1
        }
        GetScissoredViewportWidth() {
            return this._isScissorViewport ? this._viewportScissorWidth : this.GetWidth()
        }
        GetScissoredViewportHeight() {
            return this._isScissorViewport ? this._viewportScissorHeight : this.GetHeight()
        }
        _SetViewport(q, x, y, B) {
            const F = this._viewport;
            if (F[0] !== q || F[1] !== x || F[2] !== y || F[3] !== B) this.PushBatch().InitSetViewport(q, x, y, B), a.set(F, q, x, y, B), this._topOfBatch = 0
        }
        SetProjectionMatrix(q) {
            b.exactEquals(this._matP, q) || (this.PushBatch().InitSetProjection(q),
                b.copy(this._matP, q), this._topOfBatch = 0)
        }
        SetDefaultRenderTargetProjectionState() {
            let q, x;
            var y = this._currentRenderTarget;
            null === y || y.IsDefaultSize() && this._isScissorViewport ? (q = this._bbProjectionMatrix, x = this.GetScissoredViewportWidth(), y = this.GetScissoredViewportHeight()) : (q = y.GetProjectionMatrix(), x = y.GetWidth(), y = y.GetHeight());
            this.SetProjectionMatrix(q);
            this._SetViewport(0, 0, x, y)
        }
        SetModelViewMatrix(q) {
            b.exactEquals(this._matMV, q) || (this.PushBatch().InitSetModelView(q), b.copy(this._matMV, q), this._topOfBatch =
                0)
        }
        GetBatchState() {
            return this._batchState
        }
        PushBatch() {
            const q = this._batch;
            this._batchPtr === q.length && q.push(new e.Gfx.WebGLBatchJob(this._batchState));
            return q[this._batchPtr++]
        }
        EndBatch() {
            0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._topOfBatch = this._pointPtr = this._texPtr = this._vertexPtr = this._batchPtr = 0)
        }
        _WriteBuffers() {
            const q = this._gl;
            0 < this._pointPtr && (q.bindBuffer(q.ARRAY_BUFFER, this._pointBuffer), q.bufferSubData(q.ARRAY_BUFFER, 0, this._pointData.subarray(0,
                this._pointPtr)));
            0 < this._vertexPtr && (q.bindBuffer(q.ARRAY_BUFFER, this._vertexBuffer), q.bufferSubData(q.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), q.bindBuffer(q.ARRAY_BUFFER, this._texcoordBuffer), q.bufferSubData(q.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
        }
        _ExecuteBatch() {
            const q = this._batch;
            for (let x = 0, y = this._batchPtr; x < y; ++x) q[x].Run()
        }
        GetOpacity() {
            return this._lastColor.getA()
        }
        SetColorRgba(q, x, y, B) {
            const F = this._lastColor;
            F.equalsRgba(q, x, y, B) || (F.setRgba(q,
                x, y, B), this.PushBatch().InitSetColor(F), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetOpacity(q) {
            const x = this._lastColor;
            x.getA() !== q && (x.setA(q), this.PushBatch().InitSetColor(x), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetColor(q) {
            const x = this._lastColor;
            x.equals(q) || (x.set(q), this.PushBatch().InitSetColor(x), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        ResetColor() {
            this.SetColorRgba(1, 1, 1, 1)
        }
        GetColor() {
            return this._lastColor
        }
        SetTexture(q) {
            q !== this._lastTexture0 && (this.PushBatch().InitSetTexture(q),
                this._lastTexture0 = q, this._topOfBatch = 0)
        }
        _ResetLastTexture() {
            this._lastTexture0 = null
        }
        SetBlendMode(q) {
            q = this._GetBlendByIndex(q);
            this._SetBlend(q[0], q[1])
        }
        SetNamedBlendMode(q) {
            q = this.GetNamedBlend(q);
            this._SetBlend(q.srcBlend, q.destBlend)
        }
        _SetBlend(q, x) {
            if (q !== this._lastSrcBlend || x !== this._lastDestBlend) this.PushBatch().InitSetBlend(q, x), this._lastSrcBlend = q, this._lastDestBlend = x, this._topOfBatch = 0, this._currentStateGroup = null
        }
        IsPremultipliedAlphaBlend() {
            return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend ===
                this._gl.ONE_MINUS_SRC_ALPHA
        }
        SetAlphaBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetNoPremultiplyAlphaBlend() {
            this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetCopyBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ZERO)
        }
        Rect(q) {
            this.Rect2(q.getLeft(), q.getTop(), q.getRight(), q.getBottom())
        }
        Rect2(q, x, y, B) {
            this.Quad2(q, x, y, x, y, B, q, B)
        }
        _ExtendQuadBatch() {
            let q = this._vertexPtr;
            q >= this._lastVertexPtr && (this.EndBatch(), q = 0);
            1 === this._topOfBatch ? this._batch[this._batchPtr -
                1]._indexCount += 6 : (this.PushBatch().InitQuad(q, 6), this._topOfBatch = 1)
        }
        _WriteQuadToVertexBuffer(q) {
            q.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ);
            this._vertexPtr += 12
        }
        Quad(q) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(q);
            h.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad2(q, x, y, B, F, H, K, C) {
            this._ExtendQuadBatch();
            const A = this._vertexData;
            let G = this._vertexPtr;
            const J = this._baseZ + this._currentZ;
            A[G++] = q;
            A[G++] = x;
            A[G++] = J;
            A[G++] = y;
            A[G++] =
                B;
            A[G++] = J;
            A[G++] = F;
            A[G++] = H;
            A[G++] = J;
            A[G++] = K;
            A[G++] = C;
            A[G++] = J;
            this._vertexPtr = G;
            h.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad3(q, x) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(q);
            x.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad4(q, x) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(q);
            x.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad3D(q, x, y, B, F, H, K, C, A, G, J, M, R) {
            this._ExtendQuadBatch();
            const U = this._vertexData;
            let V = this._vertexPtr;
            const ba = this._baseZ + this._currentZ;
            U[V++] = q;
            U[V++] = x;
            U[V++] = ba + y;
            U[V++] = B;
            U[V++] = F;
            U[V++] = ba + H;
            U[V++] = K;
            U[V++] = C;
            U[V++] = ba + A;
            U[V++] = G;
            U[V++] = J;
            U[V++] = ba + M;
            this._vertexPtr = V;
            R.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad3D2(q, x, y, B, F, H, K, C, A, G, J, M, R) {
            this._ExtendQuadBatch();
            const U = this._vertexData;
            let V = this._vertexPtr;
            const ba = this._baseZ + this._currentZ;
            U[V++] = q;
            U[V++] = x;
            U[V++] = ba + y;
            U[V++] = B;
            U[V++] = F;
            U[V++] = ba + H;
            U[V++] = K;
            U[V++] = C;
            U[V++] = ba +
                A;
            U[V++] = G;
            U[V++] = J;
            U[V++] = ba + M;
            this._vertexPtr = V;
            R.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        FullscreenQuad(q, x) {
            b.copy(g, this._matP);
            b.copy(k, this._matMV);
            this.SetDefaultRenderTargetProjectionState();
            if (this._isScissorViewport) {
                q = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ() * self.devicePixelRatio, 0, 0, 0);
                this.SetModelViewMatrix(q);
                q = this._viewportScissorWidth / 2;
                var y = this._viewportScissorHeight / 2;
                r.set(-q, y, -q + this._viewportScissorWidth, y - this._viewportScissorHeight);
                m.setFromRect(r);
                r.set(0, 0, this._viewportScissorWidth / this._width, this._viewportScissorHeight / this._height);
                this.Quad3(m, r)
            } else {
                const [H, K] = this.GetRenderTargetSize(this._currentRenderTarget);
                y = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ() * self.devicePixelRatio, 0, 0, 0, K);
                this.SetModelViewMatrix(y);
                if ("crop" === q && this._currentRenderTarget && x) {
                    q = this._width / 2;
                    y = this._height / 2;
                    const C = x.GetWidth();
                    x = x.GetHeight();
                    var B = this._currentRenderTarget.GetWidth(),
                        F = this._currentRenderTarget.GetHeight();
                    B = Math.min(B, C);
                    const A = Math.min(F, x),
                        G = Math.max(x - F, 0);
                    F = Math.max(F - x, 0);
                    r.set(-q, y - F, -q + B, y - A - F);
                    m.setFromRect(r);
                    r.set(0, G, B, A + G);
                    r.divide(C, x);
                    this.Quad3(m, r)
                } else q = H / 2, y = K / 2, this.Rect2(-q, y, q, -y)
            }
            this.SetProjectionMatrix(g);
            this.SetModelViewMatrix(k)
        }
        StartRenderingPoints(q) {
            this._lastPointTexCoords.equals(q) || (this._lastPointTexCoords.copy(q), this.PushBatch().InitSetPointTexCoords(q), this._topOfBatch = 0)
        }
        FinishRenderingPoints() {}
        Point(q, x, y, B) {
            7996 <= this._pointPtr && this.EndBatch();
            let F = this._pointPtr;
            var H = this._baseZ + this._currentZ;
            2 === this._topOfBatch && this._lastPointZ === H ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(F, H), this._topOfBatch = 2, this._lastPointZ = H);
            H = this._pointData;
            H[F++] = q;
            H[F++] = x;
            H[F++] = y;
            H[F++] = B;
            this._pointPtr = F
        }
        SetProgram(q) {
            this._lastProgram !== q && (this.PushBatch().InitSetProgram(q), this._lastProgram = q, this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetDeviceTransformTextureFillMode() {
            this.SetProgram(this._spDeviceTransformTextureFill)
        }
        SetGradientColor(q) {
            this.PushBatch().InitSetGradientColor(q);
            this._topOfBatch = 0
        }
        SetEllipseParams(q, x, y = 1) {
            this.PushBatch().InitSetEllipseParams(q, x, y);
            this._topOfBatch = 0
        }
        SetTilemapInfo(q, x, y, B, F, H, K) {
            if (this._lastProgram !== this._spTilemapFill) throw Error("must set tilemap fill mode first");
            this.PushBatch().InitSetTilemapInfo(q, x, y, B, F, H, K);
            this._topOfBatch = 0
        }
        SetProgramParameters(q, x, y, B, F, H, K, C, A, G, J) {
            const M = this._lastProgram;
            var R = M._hasAnyOptionalUniforms;
            const U = !!J.length;
            if (R && !M.AreOptionalUniformsAlreadySetInBatch(x, y, B, F, H, K, C, A, G) || U && !M.AreCustomParametersAlreadySetInBatch(J)) {
                var V =
                    this.PushBatch();
                V.InitSetProgramParameters();
                R && (M.SetOptionalUniformsInBatch(x, y, B, F, H, K, C, A, G), R = V._mat4param, R[0] = H, R[1] = K, x.writeToTypedArray(R, 2), R[6] = C, R[7] = A, y.writeToTypedArray(R, 12), x = V._colorParam, F.writeToTypedArray(x, 0), F = x[1], x[1] = x[3], x[3] = F, B.writeToTypedArray(V._srcOriginRect, 0), V._startIndex = G, M._uSamplerBack.IsUsed() ? V._texParam = q ? q.GetTexture() : null : V._texParam = null);
                U && (M.SetCustomParametersInBatch(J), e.shallowAssignArray(V._shaderParams, J));
                this._topOfBatch = 0
            }
        }
        ClearRgba(q, x,
            y, B) {
            this.PushBatch().InitClearSurface2(q, x, y, B);
            this._topOfBatch = 0
        }
        Clear(q) {
            this.PushBatch().InitClearSurface(q);
            this._topOfBatch = 0
        }
        ClearRect(q, x, y, B) {
            this.ClearRect4(q, x, y, B, 0, 0, 0, 0)
        }
        ClearRect2(q) {
            this.ClearRect4(q.getLeft(), q.getTop(), q.width(), q.height(), 0, 0, 0, 0)
        }
        ClearRect3(q, x) {
            this.ClearRect4(q.getLeft(), q.getTop(), q.width(), q.height(), x.getR(), x.getG(), x.getB(), x.getA())
        }
        ClearRect4(q, x, y, B, F, H, K, C) {
            0 > y || 0 > B || (this.PushBatch().InitClearRect(q, x, y, B, F, H, K, C), this._topOfBatch = 0)
        }
        Start() {}
        Finish() {
            super.Finish();
            this._gl.flush()
        }
        ClearDepth() {
            this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer() && (this.PushBatch().InitClearDepth(), this._topOfBatch = 0)
        }
        SetDepthEnabled(q) {
            q = !!q;
            this._isDepthEnabled !== q && this._usesDepthBuffer && (this._isDepthEnabled = q, this.PushBatch().InitSetDepthEnabled(q), this._topOfBatch = 0)
        }
        _GetDepthBuffer() {
            return this._depthBuffer
        }
        CheckForQueryResults() {
            for (const q of this._allQueryResultBuffers) q.CheckForResults(this._frameNumber)
        }
        IsContextLost() {
            return !this._gl ||
                this._gl.isContextLost() || this._isInitialisingAfterContextRestored
        }
        OnContextLost() {
            super.OnDeviceOrContextLost();
            e.Gfx.WebGLRendererTexture.OnContextLost();
            e.Gfx.WebGLRenderTarget.OnContextLost();
            e.Gfx.RendererText.OnContextLost();
            for (const q of this._allQueryResultBuffers) q.Clear();
            this._extensions = [];
            this._anisotropicExt = this._parallelShaderCompileExt = this._timerExt = null;
            this._maxAnisotropy = 0;
            this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
            this._depthBuffer = this._spDeviceTransformTextureFill =
                this._lastProgram = null;
            for (const q of this._stateGroups.values()) q.OnContextLost()
        }
        async OnContextRestored() {
            this._isInitialisingAfterContextRestored = !0;
            await this.InitState();
            this._isInitialisingAfterContextRestored = !1;
            for (const q of this._stateGroups.values()) q.OnContextRestored(this);
            this.SetSize(this._width, this._height, !0)
        }
        CreateStaticTexture(q, x) {
            if (this.IsContextLost()) throw Error("context lost");
            this.EndBatch();
            const y = e.New(e.Gfx.WebGLRendererTexture, this);
            y._CreateStatic(q, x);
            return y
        }
        CreateStaticTextureAsync(q,
            x) {
            if (this.IsContextLost()) return Promise.reject("context lost");
            x = Object.assign({}, x);
            const y = x.wrapX && "clamp-to-edge" !== x.wrapX || x.wrapY && "clamp-to-edge" !== x.wrapY;
            if (!e.Supports.ImageBitmapOptions || !this.SupportsNPOTTextures() && y) return e.Supports.ImageBitmap ? createImageBitmap(q).then(B => e.Asyncify(() => this.CreateStaticTexture(B, x))) : q instanceof Blob ? e.BlobToImage(q, !0).then(B => this.CreateStaticTextureAsync(B, x)) : "undefined" !== typeof HTMLImageElement && q instanceof HTMLImageElement && "function" ===
                typeof q.decode ? q.decode().then(() => e.Asyncify(() => this.CreateStaticTexture(q, x))) : e.Asyncify(() => this.CreateStaticTexture(q, x));
            x.premultiplyAlpha = !1;
            return createImageBitmap(q, {
                premultiplyAlpha: "premultiply"
            }).then(B => e.Asyncify(() => this.CreateStaticTexture(B, x)))
        }
        CreateDynamicTexture(q, x, y) {
            this.EndBatch();
            const B = e.New(e.Gfx.WebGLRendererTexture, this);
            B._CreateDynamic(q, x, y);
            return B
        }
        UpdateTexture(q, x, y) {
            this.EndBatch();
            x._Update(q, y)
        }
        DeleteTexture(q) {
            q && (q.SubtractReference(), 0 < q.GetReferenceCount() ||
                (this.EndBatch(), q === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), q === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), q._Delete()))
        }
        CreateRenderTarget(q) {
            let x = this._width,
                y = this._height,
                B = !0;
            q && ("number" === typeof q.width && (x = q.width, B = !1), "number" === typeof q.height && (y = q.height, B = !1));
            if (0 >= x || 0 >= y) throw Error("invalid size");
            this.EndBatch();
            const F = e.New(e.Gfx.WebGLRenderTarget, this);
            F._Create(x, y, Object.assign({
                isDefaultSize: B
            }, q));
            this._currentRenderTarget = null;
            this._batchState.currentFramebuffer = null;
            return F
        }
        SetRenderTarget(q) {
            q !== this._currentRenderTarget && (q && q.IsDefaultSize() && q._Resize(this._width, this._height), this.PushBatch().InitSetRenderTarget(q), this._currentRenderTarget = q, this._topOfBatch = 0, this.SetDefaultRenderTargetProjectionState())
        }
        GetRenderTarget() {
            return this._currentRenderTarget
        }
        GetRenderTargetSize(q) {
            return q ? [q.GetWidth(), q.GetHeight()] : [this._width, this._height]
        }
        CopyRenderTarget(q, x = "stretch") {
            2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling() ? (this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(q, x)) : (this.PushBatch().InitBlitFramebuffer(q, this._currentRenderTarget, x), this._topOfBatch = 0)
        }
        DrawRenderTarget(q, x = "stretch") {
            q = q.GetTexture();
            if (!q) throw Error("not a texture-backed render target");
            this.SetTexture(q);
            this.FullscreenQuad(x, q)
        }
        InvalidateRenderTarget(q) {
            2 >
                this._version || (this.PushBatch().InitInvalidateFramebuffer(q._GetFramebuffer()), this._topOfBatch = 0)
        }
        DeleteRenderTarget(q) {
            this.SetRenderTarget(null);
            this.EndBatch();
            const x = q.GetTexture();
            x === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null);
            x === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null);
            q._Delete()
        }
        async ReadBackRenderTargetToImageData(q,
            x, y) {
            this.EndBatch();
            const B = this._currentRenderTarget;
            if (q) {
                var F = q.GetWidth();
                var H = q.GetHeight();
                var K = q._GetFramebuffer()
            } else F = this.GetWidth(), H = this.GetHeight(), K = null;
            let C = q = 0;
            var A = F,
                G = H;
            y && (q = e.clamp(Math.floor(y.getLeft()), 0, F - 1), C = e.clamp(Math.floor(y.getTop()), 0, H - 1), A = y.width(), A = 0 === A ? F - q : e.clamp(Math.floor(A), 0, F - q), G = y.height(), G = 0 === G ? H - C : e.clamp(Math.floor(G), 0, H - C), C = H - (C + G));
            const J = this._gl;
            J.bindFramebuffer(J.FRAMEBUFFER, K);
            H = () => {
                J.bindFramebuffer(J.FRAMEBUFFER, null);
                this._currentRenderTarget =
                    null;
                this._batchState.currentFramebuffer = null;
                this.SetRenderTarget(B)
            };
            if (!x && 2 <= this.GetWebGLVersionNumber()) {
                J.bindFramebuffer(J.READ_FRAMEBUFFER, K);
                K = J.createBuffer();
                y = A * G * 4;
                F = J.PIXEL_PACK_BUFFER;
                J.bindBuffer(F, K);
                J.bufferData(F, y, J.STREAM_READ);
                J.readPixels(q, C, A, G, J.RGBA, J.UNSIGNED_BYTE, 0);
                J.bindFramebuffer(J.READ_FRAMEBUFFER, null);
                J.bindBuffer(F, null);
                H();
                const M = J.fenceSync(J.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this._WaitForObjectReady(() => J.getSyncParameter(M, J.SYNC_STATUS) === J.SIGNALED);
                J.deleteSync(M);
                x = new ImageData(A, G);
                J.bindBuffer(F, K);
                J.getBufferSubData(F, 0, new Uint8Array(x.data.buffer), 0, y);
                J.bindBuffer(F, null);
                J.deleteBuffer(K)
            } else x = new ImageData(A, G), J.readPixels(q, C, A, G, J.RGBA, J.UNSIGNED_BYTE, new Uint8Array(x.data.buffer)), H();
            return x
        }
        CoplanarStartStencilPass() {
            this.SetDepthEnabled(!0);
            this.PushBatch().InitCoplanarStartStencilPass();
            this._topOfBatch = 0
        }
        CoplanarStartColorPass() {
            this.SetDepthEnabled(!1);
            this.PushBatch().InitCoplanarStartColorPass();
            this._topOfBatch = 0
        }
        CoplanarRestoreStandardRendering() {
            this.SetDepthEnabled(!0);
            this.PushBatch().InitCoplanarRestore();
            this._topOfBatch = 0
        }
        StartQuery(q) {
            this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(q), this._topOfBatch = 0)
        }
        EndQuery(q) {
            this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(q), this._topOfBatch = 0)
        }
        _WaitForObjectReady(q) {
            const x = new Promise(y => p.add({
                resolve: y,
                checkFunc: q
            })); - 1 === t && (t = self.requestAnimationFrame(u));
            return x
        }
        IsDesynchronized() {
            return !!this._attribs.desynchronized
        }
        GetEstimatedBackBufferMemoryUsage() {
            return this._width * this._height *
                (this._attribs.alpha ? 4 : 3)
        }
        GetEstimatedRenderBufferMemoryUsage() {
            let q = 0;
            for (const x of e.Gfx.WebGLRenderTarget.allRenderTargets()) x.GetTexture() || (q += x.GetEstimatedMemoryUsage());
            return q
        }
        GetEstimatedTextureMemoryUsage() {
            let q = 0;
            for (const x of e.Gfx.WebGLRendererTexture.allTextures()) q += x.GetEstimatedMemoryUsage();
            return q
        }
        GetEstimatedTotalMemoryUsage() {
            return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
        }
        GetWebGLVersionString() {
            return this._versionString
        }
        GetWebGLVersionNumber() {
            return this._version
        }
        GetDisplayName() {
            return "webgl" +
                this.GetWebGLVersionNumber()
        }
        SupportsNPOTTextures() {
            return 2 <= this.GetWebGLVersionNumber()
        }
        GetMaxTextureSize() {
            return this._maxTextureSize
        }
        GetMinPointSize() {
            return this._minPointSize
        }
        GetMaxPointSize() {
            return this._maxPointSize
        }
        SupportsHighP() {
            return 0 !== this._highpPrecision
        }
        GetHighPPrecision() {
            return this._highpPrecision
        }
        GetUnmaskedVendor() {
            return this._unmaskedVendor
        }
        GetUnmaskedRenderer() {
            return this._unmaskedRenderer
        }
        GetExtensions() {
            return this._extensions
        }
        SupportsGPUProfiling() {
            return !!this._timerExt
        }
        _GetDisjointTimerQueryExtension() {
            return this._timerExt
        }
        _GetParallelShaderCompileExtension() {
            return this._parallelShaderCompileExt
        }
        _GetAnisotropicExtension() {
            return this._anisotropicExt
        }
        _GetMaxAnisotropy() {
            return this._maxAnisotropy
        }
        _AddQueryResultBuffer(q) {
            this._allQueryResultBuffers.add(q)
        }
        _RemoveQueryResultBuffer(q) {
            this._allQueryResultBuffers.delete(q)
        }
        _GetTimeQueryStack() {
            return this._timeQueryStack
        }
        GetContext() {
            return this._gl
        }
        _InitBlendModes(q) {
            this._InitBlendModeData([
                ["normal",
                    q.ONE, q.ONE_MINUS_SRC_ALPHA
                ],
                ["additive", q.ONE, q.ONE],
                ["xor", q.ONE, q.ONE_MINUS_SRC_ALPHA],
                ["copy", q.ONE, q.ZERO],
                ["destination-over", q.ONE_MINUS_DST_ALPHA, q.ONE],
                ["source-in", q.DST_ALPHA, q.ZERO],
                ["destination-in", q.ZERO, q.SRC_ALPHA],
                ["source-out", q.ONE_MINUS_DST_ALPHA, q.ZERO],
                ["destination-out", q.ZERO, q.ONE_MINUS_SRC_ALPHA],
                ["source-atop", q.DST_ALPHA, q.ONE_MINUS_SRC_ALPHA],
                ["destination-atop", q.ONE_MINUS_DST_ALPHA, q.SRC_ALPHA]
            ])
        }
        CreateRendererText() {
            return e.New(e.Gfx.RendererText, this)
        }
        CreateWebGLText() {
            return this.CreateRendererText()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X;
    let a = null;
    const b = new Set;

    function c(k, m) {
        const r = k[0] - m[0];
        return 0 !== r ? r : k[1] - m[1]
    }
    const f = [],
        h = [];
    let g = !1;
    self.IRuntime = class {
        constructor(k, m) {
            a = k;
            Object.defineProperties(this, {
                assets: {
                    value: a.GetAssetManager().GetIAssetManager(),
                    writable: !1
                },
                objects: {
                    value: m,
                    writable: !1
                },
                globalVars: {
                    value: {},
                    writable: !1
                },
                projectName: {
                    value: a.GetProjectName(),
                    writable: !1
                },
                projectVersion: {
                    value: a.GetProjectVersion(),
                    writable: !1
                },
                storage: {
                    value: new self.IStorage(a),
                    writable: !1
                },
                isInWorker: {
                    value: a.IsInWorker(),
                    writable: !1
                }
            });
            a.UserScriptDispatcher().addEventListener("keydown", r => {
                b.has(r.key) ? r.stopPropagation() : b.add(r.key)
            });
            a.UserScriptDispatcher().addEventListener("keyup", r => b.delete(r.key));
            a.Dispatcher().addEventListener("window-blur", () => b.clear());
            a.IsInWorker() && (self.alert = r => {
                g || (g = !0, console.warn("[Construct 3] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."));
                return this.alert(r)
            })
        }
        _InitGlobalVars(k) {
            Object.defineProperties(this.globalVars, k)
        }
        addEventListener(k, m) {
            a.UserScriptDispatcher().addEventListener(k, m)
        }
        removeEventListener(k, m) {
            a.UserScriptDispatcher().removeEventListener(k, m)
        }
        callFunction(k, ...m) {
            d.RequireString(k);
            const r = a.GetEventSheetManager(),
                w = r.GetFunctionBlockByName(k);
            if (!w) throw Error(`cannot find function name '${k}'`);
            if (!w.IsEnabled()) return w.GetDefaultReturnValue();
            if (m.length < w.GetFunctionParameterCount()) throw Error(`not enough function parameters passed for '${k}' (${m.length} passed, ${w.GetFunctionParameterCount()} expected)`);
            const p = w.GetEventBlock();
            k = null;
            var t = r.GetCurrentEvent();
            t && (t = t.GetSolModifiersIncludingParents(), 0 < t.length && (k = t, r.PushCleanSol(t)));
            m = p.RunAsExpressionFunctionCall(p.GetSolModifiersIncludingParents(), w.GetReturnType(), w.GetDefaultReturnValue(), ...m);
            k && r.PopSol(k);
            return m
        }
        setReturnValue(k) {
            const m = a.GetEventStack().GetCurrentExpFuncStackFrame();
            if (!m) throw Error("not in a function which returns a value");
            switch (m.GetFunctionReturnType()) {
                case 1:
                    "number" === typeof k && m.SetFunctionReturnValue(k);
                    break;
                case 2:
                    "string" === typeof k && m.SetFunctionReturnValue(k);
                    break;
                case 3:
                    "number" !== typeof k && "string" !== typeof k || m.SetFunctionReturnValue(k)
            }
        }
        get dt() {
            return a.GetDt()
        }
        get gameTime() {
            return a.GetGameTime()
        }
        get wallTime() {
            return a.GetWallTime()
        }
        random() {
            return a.Random()
        }
        get layout() {
            return a.GetMainRunningLayout().GetILayout()
        }
        getLayout(k) {
            const m = a.GetLayoutManager();
            if ("number" === typeof k || "string" === typeof k) k = m.GetLayout(k);
            else throw new TypeError("expected string or number");
            if (!k) throw Error("invalid layout");
            return k.GetILayout()
        }
        getAllLayouts() {
            return a.GetLayoutManager().GetAllLayouts().map(k => k.GetILayout())
        }
        goToLayout(k) {
            const m = a.GetLayoutManager();
            if ("number" === typeof k || "string" === typeof k) k = m.GetLayout(k);
            else throw new TypeError("expected string or number");
            if (!k) throw Error("invalid layout");
            m.IsPendingChangeMainLayout() || m.ChangeMainLayout(k)
        }
        get keyboard() {
            const k = a._GetCommonScriptInterfaces().keyboard;
            if (!k) throw Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
            return k
        }
        get mouse() {
            const k = a._GetCommonScriptInterfaces().mouse;
            if (!k) throw Error("runtime.mouse used but Mouse object missing - add it to your project first");
            return k
        }
        get touch() {
            const k = a._GetCommonScriptInterfaces().touch;
            if (!k) throw Error("runtime.touch used but Touch object missing - add it to your project first");
            return k
        }
        invokeDownload(k, m) {
            d.RequireString(k);
            d.RequireString(m);
            a.InvokeDownload(k, m)
        }
        getInstanceByUid(k) {
            d.RequireFiniteNumber(k);
            return (k = a.GetInstanceByUID(k)) ? k.GetInterfaceClass() :
                null
        }
        sortZOrder(k, m) {
            d.RequireFunction(m);
            const r = a.GetCurrentLayout();
            for (var w of k) {
                k = a._UnwrapIWorldInstance(w);
                var p = k.GetWorldInfo();
                f.push([p.GetLayer().GetIndex(), p.GetZIndex()]);
                h.push(k)
            }
            if (0 !== f.length) {
                f.sort(c);
                h.sort((t, u) => m(t.GetInterfaceClass(), u.GetInterfaceClass()));
                w = !1;
                for (let t = 0, u = f.length; t < u; ++t) {
                    k = h[t];
                    p = r.GetLayerByIndex(f[t][0]);
                    const q = f[t][1],
                        x = p._GetInstances();
                    x[q] !== k && (x[q] = k, k.GetWorldInfo()._SetLayer(p), p.SetZIndicesChanged(), w = !0)
                }
                w && a.UpdateRender();
                e.clearArray(f);
                e.clearArray(h)
            }
        }
        alert(k) {
            return a.PostComponentMessageToDOMAsync("runtime", "alert", {
                message: k + (a.IsInWorker() ? " [via Web Worker]" : "")
            })
        }
    }
} {
    "use strict";
    const e = self.C3;
    let d = null;
    self.IAssetManager = class {
        constructor(a) {
            d = a;
            Object.defineProperties(this, {
                isWebMOpusSupported: {
                    value: d.IsAudioFormatSupported("audio/webm; codecs=opus"),
                    writable: !1
                }
            })
        }
        fetchText(a) {
            return d.FetchText(a)
        }
        fetchJson(a) {
            return d.FetchJson(a)
        }
        fetchBlob(a) {
            return d.FetchBlob(a)
        }
        fetchArrayBuffer(a) {
            return d.FetchArrayBuffer(a)
        }
        getProjectFileUrl(a) {
            return d.GetProjectFileUrl(a)
        }
        getMediaFileUrl(a) {
            e.IsRelativeURL(a) && (a = a.toLowerCase());
            return d.GetMediaFileUrl(a, d.GetMediaSubfolder())
        }
        get mediaFolder() {
            return d.GetMediaSubfolder()
        }
        async decodeWebMOpus(a,
            b) {
            if (this.isWebMOpusSupported) throw Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
            b = await d.GetRuntime()._WasmDecodeWebMOpus(b);
            b = new Float32Array(b);
            a = a.createBuffer(1, b.length, 48E3);
            a.getChannelData(0).set(b);
            return a
        }
        loadScripts(...a) {
            return d.LoadScripts(...a)
        }
        compileWebAssembly(a) {
            return d.CompileWebAssembly(a)
        }
        loadStyleSheet(a) {
            return d.LoadStyleSheet(a)
        }
    }
} {
    "use strict";
    const e = self.C3X;
    self.IStorage = class {
        constructor(d) {
            this._storage = d._GetProjectStorage()
        }
        getItem(d) {
            e.RequireString(d);
            return this._storage.getItem(d)
        }
        setItem(d, a) {
            e.RequireString(d);
            return this._storage.setItem(d, a)
        }
        removeItem(d) {
            e.RequireString(d);
            return this._storage.removeItem(d)
        }
        clear() {
            return this._storage.clear()
        }
        keys() {
            return this._storage.keys()
        }
    }
} {
    "use strict";
    const e = self.C3X,
        d = new WeakMap;
    self.IObjectClass = class {
        constructor(a) {
            d.set(this, a);
            Object.defineProperties(this, {
                name: {
                    value: a.GetName(),
                    writable: !1
                }
            });
            a.GetRuntime()._MapScriptInterface(this, a)
        }
        addEventListener(a, b) {
            e.RequireString(a);
            e.RequireFunction(b);
            d.get(this).UserScriptDispatcher().addEventListener(a, b)
        }
        removeEventListener(a, b) {
            e.RequireString(a);
            e.RequireFunction(b);
            d.get(this).UserScriptDispatcher().removeEventListener(a, b)
        }
        getAllInstances() {
            return d.get(this).GetInstances().map(a =>
                a.GetInterfaceClass())
        }
        getFirstInstance() {
            const a = d.get(this).GetInstances();
            return 0 < a.length ? a[0].GetInterfaceClass() : null
        }
        getPickedInstances() {
            return d.get(this).GetCurrentSol().GetInstances().map(a => a.GetInterfaceClass())
        }
        getFirstPickedInstance() {
            const a = d.get(this).GetCurrentSol().GetInstances();
            return 0 < a.length ? a[0].GetInterfaceClass() : null
        }* instances() {
            for (const a of d.get(this).GetInstances()) yield a.GetInterfaceClass()
        }* pickedInstances() {
            for (const a of d.get(this).GetCurrentSol().GetInstances()) yield a.GetInterfaceClass()
        }
        setInstanceClass(a) {
            e.RequireFunction(a);
            if (0 < d.get(this).GetInstanceCount()) throw Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
            d.get(this)._SetUserScriptInstanceClass(a)
        }
        createInstance(a, b, c, f) {
            e.RequireNumber(b);
            e.RequireNumber(c);
            if ("number" !== typeof a && "string" !== typeof a) throw new TypeError("invalid layer parameter");
            const h = d.get(this),
                g = h.GetRuntime();
            a = g.GetMainRunningLayout().GetLayer(a);
            if (!a) throw Error("invalid layer");
            b = g.CreateInstance(h, a, b, c, f);
            f && a.SortAndAddInstancesByZIndex(b);
            f = g.GetEventSheetManager();
            f.BlockFlushingInstances(!0);
            b._TriggerOnCreatedOnSelfAndRelated();
            f.BlockFlushingInstances(!1);
            return b.GetInterfaceClass()
        }
    }
} {
    "use strict";
    const e = self.C3X,
        d = new WeakMap;
    self.ILayout = class {
        constructor(a) {
            d.set(this, a);
            const b = [],
                c = a.GetEffectList(),
                f = c.GetAllEffectTypes().length;
            for (let h = 0; h < f; ++h) b.push(new self.IEffectInstance(c, h));
            Object.defineProperties(this, {
                name: {
                    value: a.GetName(),
                    writable: !1
                },
                index: {
                    value: a.GetIndex(),
                    writable: !1
                },
                effects: {
                    value: b,
                    writable: !1
                }
            })
        }
        addEventListener(a, b) {
            e.RequireString(a);
            e.RequireFunction(b);
            d.get(this).UserScriptDispatcher().addEventListener(a, b)
        }
        removeEventListener(a, b) {
            e.RequireString(a);
            e.RequireFunction(b);
            d.get(this).UserScriptDispatcher().removeEventListener(a, b)
        }
        get width() {
            return d.get(this).GetWidth()
        }
        set width(a) {
            d.get(this).SetWidth(a)
        }
        get height() {
            return d.get(this).GetHeight()
        }
        set height(a) {
            d.get(this).SetHeight(a)
        }
        set scale(a) {
            e.RequireFiniteNumber(a);
            d.get(this).SetScale(a)
        }
        get scale() {
            return d.get(this).GetScale()
        }
        set angle(a) {
            e.RequireFiniteNumber(a);
            d.get(this).SetAngle(a)
        }
        get angle() {
            return d.get(this).GetAngle()
        }
        set scrollX(a) {
            e.RequireNumber(a);
            d.get(this).SetScrollX(a)
        }
        get scrollX() {
            return d.get(this).GetScrollX()
        }
        set scrollY(a) {
            e.RequireNumber(a);
            d.get(this).SetScrollY(a)
        }
        get scrollY() {
            return d.get(this).GetScrollY()
        }
        scrollTo(a, b) {
            e.RequireNumber(a);
            e.RequireNumber(b);
            const c = d.get(this);
            c.SetScrollX(a);
            c.SetScrollY(b)
        }
        getLayer(a) {
            const b = d.get(this);
            if ("number" === typeof a || "string" === typeof a) a = b.GetLayer(a);
            else throw new TypeError("expected string or number");
            return a ? a.GetILayer() : null
        }
        getAllLayers() {
            return d.get(this).GetLayers().map(a => a.GetILayer())
        }
        setVanishingPoint(a, b) {
            e.RequireFiniteNumber(a);
            e.RequireFiniteNumber(b);
            d.get(this).SetVanishingPointXY(a,
                b)
        }
        getVanishingPoint() {
            return d.get(this)._GetVanishingPoint()
        }
        set projection(a) {
            e.RequireString(a);
            const b = d.get(this);
            if ("perspective" === a) b.SetPerspectiveProjection();
            else if ("orthographic" === a) b.SetOrthographicProjection();
            else throw Error("invalid projection");
        }
        get projection() {
            return d.get(this).IsOrthographicProjection() ? "orthographic" : "perspective"
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = new WeakMap,
        b = new Map([
            ["normal", 0],
            ["additive", 1],
            ["copy", 3],
            ["destination-over", 4],
            ["source-in", 5],
            ["destination-in", 6],
            ["source-out", 7],
            ["destination-out", 8],
            ["source-atop", 9],
            ["destination-atop", 10]
        ]),
        c = new Map([...b.entries()].map(h => [h[1], h[0]])),
        f = e.New(e.Color);
    self.ILayer = class {
        constructor(h) {
            a.set(this, h);
            const g = [],
                k = h.GetEffectList(),
                m = k.GetAllEffectTypes().length;
            for (let r = 0; r < m; ++r) g.push(new self.IEffectInstance(k, r));
            Object.defineProperties(this, {
                name: {
                    value: h.GetName(),
                    writable: !1
                },
                index: {
                    value: h.GetIndex(),
                    writable: !1
                },
                layout: {
                    value: h.GetLayout().GetILayout(),
                    writable: !1
                },
                effects: {
                    value: g,
                    writable: !1
                }
            })
        }
        static _Unwrap(h) {
            return a.get(h)
        }
        get isVisible() {
            return a.get(this).IsVisible()
        }
        set isVisible(h) {
            a.get(this).SetVisible(h)
        }
        get opacity() {
            return a.get(this).GetOpacity()
        }
        set opacity(h) {
            h = e.clamp(+h, 0, 1);
            isNaN(h) || a.get(this).SetOpacity(h)
        }
        set scale(h) {
            d.RequireFiniteNumber(h);
            a.get(this).SetOwnScale(h)
        }
        get scale() {
            return a.get(this).GetOwnScale()
        }
        set scaleRate(h) {
            d.RequireFiniteNumber(h);
            a.get(this).SetScaleRate(h)
        }
        get scaleRate() {
            return a.get(this).GetScaleRate()
        }
        set angle(h) {
            d.RequireFiniteNumber(h);
            a.get(this).SetAngle(h)
        }
        get angle() {
            return a.get(this).GetOwnAngle()
        }
        set parallaxX(h) {
            d.RequireFiniteNumber(h);
            a.get(this).SetParallaxX(h)
        }
        get parallaxX() {
            return a.get(this).GetParallaxX()
        }
        set parallaxY(h) {
            d.RequireFiniteNumber(h);
            a.get(this).SetParallaxY(h)
        }
        get parallaxY() {
            return a.get(this).GetParallaxY()
        }
        set zElevation(h) {
            d.RequireFiniteNumber(h);
            a.get(this).SetZElevation(h)
        }
        get zElevation() {
            return a.get(this).GetZElevation()
        }
        set isTransparent(h) {
            a.get(this).SetTransparent(h)
        }
        get isTransparent() {
            return a.get(this).IsTransparent()
        }
        set isForceOwnTexture(h) {
            a.get(this).SetForceOwnTexture(h)
        }
        get isForceOwnTexture() {
            return a.get(this).IsForceOwnTexture()
        }
        set blendMode(h) {
            d.RequireString(h);
            h = b.get(h);
            if ("number" !== typeof h) throw Error("invalid blend mode");
            a.get(this).SetBlendMode(h)
        }
        get blendMode() {
            return c.get(a.get(this).GetBlendMode())
        }
        set backgroundColor(h) {
            d.RequireArray(h);
            if (3 > h.length) throw Error("expected 3 elements");
            f.setRgb(h[0], h[1], h[2]);
            h = a.get(this);
            const g = h.GetBackgroundColor();
            g.equalsIgnoringAlpha(f) || (g.copyRgb(f), h.GetRuntime().UpdateRender())
        }
        get backgroundColor() {
            const h = a.get(this).GetBackgroundColor();
            return [h.getR(), h.getG(), h.getB()]
        }
        set scrollX(h) {
            d.RequireNumber(h);
            const g = a.get(this);
            g.SetOwnScrollPositionEnabled(!0);
            g.SetScrollX(h)
        }
        get scrollX() {
            return a.get(this).GetScrollX()
        }
        set scrollY(h) {
            d.RequireNumber(h);
            const g = a.get(this);
            g.SetOwnScrollPositionEnabled(!0);
            g.SetScrollY(h)
        }
        get scrollY() {
            return a.get(this).GetScrollY()
        }
        scrollTo(h, g) {
            d.RequireNumber(h);
            d.RequireNumber(g);
            const k = a.get(this);
            k.SetOwnScrollPositionEnabled(!0);
            k.SetScrollX(h);
            k.SetScrollY(g)
        }
        restoreScrollPosition() {
            a.get(this).SetOwnScrollPositionEnabled(!1)
        }
        getViewport() {
            return a.get(this).GetViewport().toDOMRect()
        }
        cssPxToLayer(h,
            g, k = 0) {
            d.RequireNumber(h);
            d.RequireNumber(g);
            d.RequireNumber(k);
            const m = a.get(this),
                r = m.GetRuntime();
            return m.CanvasCssToLayer(h - r.GetCanvasClientX(), g - r.GetCanvasClientY(), k)
        }
        layerToCssPx(h, g, k = 0) {
            d.RequireNumber(h);
            d.RequireNumber(g);
            d.RequireNumber(k);
            const m = a.get(this),
                r = m.GetRuntime(),
                [w, p] = m.LayerToCanvasCss(h, g, k);
            return [w + r.GetCanvasClientX(), p + r.GetCanvasClientY()]
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = new WeakMap,
        b = new WeakMap;

    function c(h) {
        let g = b.get(h);
        if (g) return g;
        g = e.New(e.Event.Dispatcher);
        b.set(h, g);
        return g
    }
    let f = null;
    self.IInstance = class {
        constructor() {
            a.set(this, f);
            const h = {
                runtime: {
                    value: f.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                objectType: {
                    value: f.GetObjectClass().GetIObjectClass(),
                    writable: !1
                },
                uid: {
                    value: f.GetUID(),
                    writable: !1
                }
            };
            f._GetInstVarsScriptDescriptor(h);
            f._GetBehaviorsScriptDescriptor(h);
            Object.defineProperties(this, h);
            f.GetRuntime()._MapScriptInterface(this,
                f)
        }
        static _Init(h) {
            f = h
        }
        static _GetInitInst() {
            return f
        }
        _Release() {
            const h = b.get(this);
            h && (h.Release(), b.delete(this));
            a.delete(this)
        }
        addEventListener(h, g, k) {
            d.RequireString(h);
            d.RequireFunction(g);
            c(this).addEventListener(h, g, k)
        }
        removeEventListener(h, g, k) {
            d.RequireString(h);
            d.RequireFunction(g);
            c(this).removeEventListener(h, g, k)
        }
        dispatchEvent(h) {
            c(this).dispatchEvent(h)
        }
        destroy() {
            const h = a.get(this);
            h.GetRuntime().DestroyInstance(h)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = self.IInstance,
        b = self.ILayer,
        c = new WeakMap,
        f = new Map([
            ["normal", 0],
            ["additive", 1],
            ["copy", 3],
            ["destination-over", 4],
            ["source-in", 5],
            ["destination-in", 6],
            ["source-out", 7],
            ["destination-out", 8],
            ["source-atop", 9],
            ["destination-atop", 10]
        ]),
        h = new Map([...f.entries()].map(k => [k[1], k[0]])),
        g = e.New(e.Color);
    self.IWorldInstance = class k extends a {
        constructor() {
            super();
            var m = a._GetInitInst();
            c.set(this, m);
            const r = [];
            var w = m.GetWorldInfo();
            if (m = w.GetInstanceEffectList()) {
                w =
                    w.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let p = 0; p < w; ++p) r.push(new self.IEffectInstance(m, p))
            }
            Object.defineProperties(this, {
                effects: {
                    value: r,
                    writable: !1
                }
            })
        }
        get layout() {
            return c.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer() {
            return c.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x() {
            return c.get(this).GetWorldInfo().GetX()
        }
        set x(m) {
            m = +m;
            const r = c.get(this).GetWorldInfo();
            isNaN(m) || r.GetX() === m || (r.SetX(m), r.SetBboxChanged())
        }
        get y() {
            return c.get(this).GetWorldInfo().GetY()
        }
        set y(m) {
            m = +m;
            const r = c.get(this).GetWorldInfo();
            isNaN(m) || r.GetY() === m || (r.SetY(m), r.SetBboxChanged())
        }
        get zElevation() {
            return c.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(m) {
            m = +m;
            const r = c.get(this),
                w = r.GetWorldInfo();
            isNaN(m) || w.GetZElevation() === m || (w.SetZElevation(m), r.GetRuntime().UpdateRender())
        }
        get totalZElevation() {
            return c.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width() {
            return c.get(this).GetWorldInfo().GetWidth()
        }
        set width(m) {
            m = +m;
            const r = c.get(this).GetWorldInfo();
            isNaN(m) ||
                r.GetWidth() === m || (r.SetWidth(m), r.SetBboxChanged())
        }
        get height() {
            return c.get(this).GetWorldInfo().GetHeight()
        }
        set height(m) {
            m = +m;
            const r = c.get(this).GetWorldInfo();
            isNaN(m) || r.GetHeight() === m || (r.SetHeight(m), r.SetBboxChanged())
        }
        get angle() {
            return c.get(this).GetWorldInfo().GetAngle()
        }
        set angle(m) {
            m = e.clampAngle(+m);
            const r = c.get(this).GetWorldInfo();
            isNaN(m) || r.GetAngle() === m || (r.SetAngle(m), r.SetBboxChanged())
        }
        get angleDegrees() {
            return e.toDegrees(this.angle)
        }
        set angleDegrees(m) {
            this.angle = e.toRadians(m)
        }
        getBoundingBox() {
            return c.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad() {
            return c.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        get isVisible() {
            return c.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(m) {
            m = !!m;
            const r = c.get(this),
                w = r.GetWorldInfo();
            w.IsVisible() !== m && (w.SetVisible(m), r.GetRuntime().UpdateRender())
        }
        get opacity() {
            return c.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(m) {
            m = e.clamp(+m, 0, 1);
            const r = c.get(this),
                w = r.GetWorldInfo();
            isNaN(m) || w.GetOpacity() === m || (w.SetOpacity(m), r.GetRuntime().UpdateRender())
        }
        set colorRgb(m) {
            d.RequireArray(m);
            if (3 > m.length) throw Error("expected 3 elements");
            g.setRgb(m[0], m[1], m[2]);
            m = c.get(this);
            const r = m.GetWorldInfo();
            r.GetUnpremultipliedColor().equalsIgnoringAlpha(g) ||
                (r.SetUnpremultipliedColor(g), m.GetRuntime().UpdateRender())
        }
        get colorRgb() {
            const m = c.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [m.getR(), m.getG(), m.getB()]
        }
        set blendMode(m) {
            d.RequireString(m);
            m = f.get(m);
            if ("number" !== typeof m) throw Error("invalid blend mode");
            const r = c.get(this);
            r.GetWorldInfo().SetBlendMode(m);
            r.GetRuntime().UpdateRender()
        }
        get blendMode() {
            return h.get(c.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop() {
            c.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom() {
            c.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(m) {
            d.RequireInstanceOf(m,
                b);
            m = b._Unwrap(m);
            if (!m) throw Error("invalid layer");
            c.get(this).GetWorldInfo().ZOrderMoveToLayer(m)
        }
        moveAdjacentToInstance(m, r) {
            d.RequireInstanceOf(m, k);
            c.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(c.get(m), r)
        }
        get zIndex() {
            return c.get(this).GetWorldInfo().GetZIndex()
        }
        containsPoint(m, r) {
            d.RequireNumber(m);
            d.RequireNumber(r);
            return c.get(this).GetWorldInfo().ContainsPoint(+m, +r)
        }
        testOverlap(m) {
            d.RequireInstanceOf(m, k);
            const r = c.get(this);
            m = c.get(m);
            return r.GetRuntime().GetCollisionEngine().TestOverlap(r,
                m)
        }
        testOverlapSolid() {
            var m = c.get(this);
            return (m = m.GetRuntime().GetCollisionEngine().TestOverlapSolid(m)) ? m.GetInterfaceClass() : null
        }
        getParent() {
            const m = c.get(this).GetParent();
            return m ? m.GetInterfaceClass() : null
        }
        getTopParent() {
            const m = c.get(this).GetTopParent();
            return m ? m.GetInterfaceClass() : null
        }* parents() {
            for (const m of c.get(this).parents()) yield m.GetInterfaceClass()
        }
        getChildCount() {
            return c.get(this).GetChildCount()
        }
        getChildAt(m) {
            return (m = c.get(this).GetChildAt(m)) ? m.GetInterfaceClass() : null
        }* children() {
            for (const m of c.get(this).children()) yield m.GetInterfaceClass()
        }* allChildren() {
            for (const m of c.get(this).allChildren()) yield m.GetInterfaceClass()
        }
        addChild(m,
            r) {
            d.RequireInstanceOf(m, k);
            d.RequireOptionalObject(r);
            r || (r = {});
            const w = c.get(this);
            m = c.get(m);
            w.AddChild(m, r)
        }
        removeChild(m) {
            d.RequireInstanceOf(m, k);
            const r = c.get(this);
            m = c.get(m);
            r.RemoveChild(m)
        }
        removeFromParent() {
            const m = c.get(this);
            m.HasParent() && m.GetParent().RemoveChild(m)
        }
        createMesh(m, r) {
            d.RequireFiniteNumber(m);
            d.RequireFiniteNumber(r);
            c.get(this).GetWorldInfo().CreateMesh(m, r)
        }
        releaseMesh() {
            const m = c.get(this).GetWorldInfo();
            m.ReleaseMesh();
            m.SetBboxChanged()
        }
        setMeshPoint(m, r, w) {
            d.RequireFiniteNumber(m);
            d.RequireFiniteNumber(r);
            d.RequireObject(w);
            const p = c.get(this).GetWorldInfo();
            p.SetMeshPoint(m, r, w) && p.SetBboxChanged()
        }
        getMeshSize() {
            var m = c.get(this).GetWorldInfo();
            if (!m.HasMesh()) return [0, 0];
            m = m.GetSourceMesh();
            return [m.GetHSize(), m.GetVSize()]
        }
    }
} {
    "use strict";
    const e = self.C3X,
        d = new WeakMap;
    self.IDOMInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            d.set(this, self.IInstance._GetInitInst())
        }
        getElement() {
            return d.get(this).GetSdkInstance()._GetElementInDOMMode()
        }
        focus() {
            d.get(this).GetSdkInstance().FocusElement()
        }
        blur() {
            d.get(this).GetSdkInstance().BlurElement()
        }
        setCssStyle(a, b) {
            e.RequireString(a);
            d.get(this).GetSdkInstance().SetElementCSSStyle(a, b)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = new WeakMap,
        b = new WeakMap;

    function c(h) {
        let g = b.get(h);
        if (g) return g;
        g = e.New(e.Event.Dispatcher);
        b.set(h, g);
        return g
    }
    let f = null;
    self.IBehaviorInstance = class {
        constructor() {
            a.set(this, f);
            const h = {
                runtime: {
                    value: f.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                behavior: {
                    value: f.GetBehavior().GetIBehavior(),
                    writable: !1
                }
            };
            Object.defineProperties(this, h)
        }
        static _Init(h) {
            f = h
        }
        static _GetInitInst() {
            return f
        }
        get instance() {
            return a.get(this).GetObjectInstance().GetInterfaceClass()
        }
        _Release() {
            const h =
                b.get(this);
            h && (h.Release(), b.delete(this));
            a.delete(this)
        }
        addEventListener(h, g, k) {
            d.RequireString(h);
            d.RequireFunction(g);
            c(this).addEventListener(h, g, k)
        }
        removeEventListener(h, g, k) {
            d.RequireString(h);
            d.RequireFunction(g);
            c(this).removeEventListener(h, g, k)
        }
        dispatchEvent(h) {
            c(this).dispatchEvent(h)
        }
    }
} {
    "use strict";
    const e = new WeakMap;
    self.IBehavior = class {
        constructor(d) {
            e.set(this, d);
            d = {
                runtime: {
                    value: d.GetRuntime().GetIRuntime(),
                    writable: !1
                }
            };
            Object.defineProperties(this, d)
        }
        getAllInstances() {
            return e.get(this).GetInstances().map(d => d.GetInterfaceClass())
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = new WeakMap;
    self.IEffectInstance = class {
        constructor(b, c) {
            a.set(this, b);
            Object.defineProperties(this, {
                index: {
                    value: c,
                    writable: !1
                }
            })
        }
        get name() {
            return a.get(this).GetAllEffectTypes()[this.index].GetName()
        }
        get isActive() {
            return a.get(this).IsEffectIndexActive(this.index)
        }
        set isActive(b) {
            b = !!b;
            const c = a.get(this);
            c.IsEffectIndexActive(this.index) !== b && (c.SetEffectIndexActive(this.index, b), c.UpdateActiveEffects(), c.GetRuntime().UpdateRender())
        }
        setParameter(b, c) {
            d.RequireFiniteNumber(b);
            b = Math.floor(+b);
            const f = a.get(this);
            var h = f.GetEffectParametersForIndex(this.index);
            if (0 > b || b >= h.length) throw new RangeError("invalid effect parameter index");
            const g = h[b];
            if (g instanceof e.Color) {
                if (!Array.isArray(c) || 3 > c.length) throw new TypeError("expected array with 3 elements");
                b = c[0];
                h = c[1];
                c = c[2];
                if (g.equalsRgb(b, h, c)) return;
                g.setRgb(b, h, c)
            } else {
                if ("number" !== typeof c) throw new TypeError("expected number");
                if (g === c) return;
                h[b] = c
            }
            f.IsEffectIndexActive(this.index) && f.GetRuntime().UpdateRender()
        }
        getParameter(b) {
            d.RequireFiniteNumber(b);
            b = Math.floor(+b);
            const c = a.get(this).GetEffectParametersForIndex(this.index);
            if (0 > b || b >= c.length) throw new RangeError("invalid effect parameter index");
            b = c[b];
            return b instanceof e.Color ? [b.getR(), b.getG(), b.getB()] : b
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new Set(["local", "remote"]),
        a = new Map([
            ["mp4", "video/mp4"],
            ["webm", "video/webm"],
            ["m4a", "audio/mp4"],
            ["mp3", "audio/mpeg"],
            ["js", "application/javascript"],
            ["wasm", "application/wasm"],
            ["svg", "image/svg+xml"],
            ["html", "text/html"]
        ]);

    function b(f) {
        if (!f) return "";
        f = f.split(".");
        if (2 > f.length) return "";
        f = f.at(-1).toLowerCase();
        return a.get(f) || ""
    }

    function c(f) {
        return new Promise((h, g) => {
            const k = document.createElement("script");
            k.onload = h;
            k.onerror = g;
            k.async = !1;
            k.type = "module";
            k.src = f;
            document.head.appendChild(k)
        })
    }
    e.AssetManager = class extends e.DefendedBase {
        constructor(f, h) {
            super();
            var g = h.exportType;
            this._runtime = f;
            this._localUrlBlobs = new Map;
            this._localBlobUrlCache = new Map;
            this._localBlobSWUrls = new Map;
            this._isCordova = "cordova" === g;
            this._isiOSCordova = !!h.isiOSCordova;
            this._isFileProtocol = !!h.isFileProtocol;
            this._swClientId = h.swClientId;
            this._supportedAudioFormats = h.supportedAudioFormats || {};
            this._audioFiles = new Map;
            this._preloadSounds = !1;
            this._iconsSubfolder = this._fontsSubfolder =
                this._mediaSubfolder = "";
            this._defaultLoadPolicy = "html5" === g || "scirra-arcade" === g || "instant-games" === g ? "remote" : "local";
            this._allAssets = [];
            this._assetsByUrl = new Map;
            this._webFonts = [];
            this._loadPromises = [];
            this._hasFinishedInitialLoad = !1;
            this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0;
            this._hasHadErrorLoading = !1;
            this._loadingRateLimiter = e.New(e.RateLimiter, () => this._FireLoadingProgressEvent(), 50);
            this._promiseThrottle = new e.PromiseThrottle(Math.max(e.hardwareConcurrency, 8));
            if (f = h.previewImageBlobs) {
                (g = h.previewProjectFileBlobs) && Object.assign(f, g);
                (g = h.projectData) && (f["data.json"] = g);
                for (const [k, m] of Object.entries(f)) this._localUrlBlobs.set(k.toLowerCase(), m)
            }
            if (h = h.previewProjectFileSWUrls)
                for (const [k, m] of Object.entries(h)) this._localBlobSWUrls.set(k, m);
            this._iAssetManager = new self.IAssetManager(this)
        }
        Release() {
            this._localUrlBlobs.clear();
            for (const f of this._localBlobUrlCache.values()) f.startsWith("blob:") && URL.revokeObjectURL(f);
            this._localBlobUrlCache.clear();
            for (const f of this._allAssets) f.Release();
            e.clearArray(this._allAssets);
            this._assetsByUrl.clear();
            e.clearArray(this._loadPromises);
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        _SetMediaSubfolder(f) {
            this._mediaSubfolder = f
        }
        GetMediaSubfolder() {
            return this._mediaSubfolder
        }
        _SetFontsSubfolder(f) {
            this._fontsSubfolder = f
        }
        GetFontsSubfolder() {
            return this._fontsSubfolder
        }
        _SetIconsSubfolder(f) {
            this._iconsSubfolder = f
        }
        GetIconsSubfolder() {
            return this._iconsSubfolder
        }
        IsFileProtocol() {
            return this._isFileProtocol
        }
        _HasLocalUrlBlob(f) {
            return this._localUrlBlobs.has(f.toLowerCase())
        }
        _GetLocalUrlBlob(f) {
            return this._localUrlBlobs.get(f.toLowerCase()) ||
                null
        }
        GetLocalUrlAsBlobUrl(f) {
            if (!this._HasLocalUrlBlob(f)) return f;
            f = f.toLowerCase();
            var h = this._localBlobUrlCache.get(f);
            h || (h = this._GetLocalUrlBlob(f), h = URL.createObjectURL(h), this._localBlobUrlCache.set(f, h));
            return h
        }
        FetchBlob(f, h) {
            h = h || this._defaultLoadPolicy;
            const g = this._GetLocalUrlBlob(f);
            if (g) return Promise.resolve(g);
            if (e.IsRelativeURL(f)) {
                const k = f.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(k) : "local" === h ? this._promiseThrottle.Add(() => e.FetchBlob(k)) :
                    e.FetchBlob(k)
            }
            return e.FetchBlob(f)
        }
        FetchArrayBuffer(f) {
            const h = this._GetLocalUrlBlob(f);
            if (h) return e.BlobToArrayBuffer(h);
            if (e.IsRelativeURL(f)) {
                const g = f.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(g) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => e.FetchArrayBuffer(g)) : e.FetchArrayBuffer(g)
            }
            return e.FetchArrayBuffer(f)
        }
        FetchText(f) {
            const h = this._GetLocalUrlBlob(f);
            if (h) return e.BlobToString(h);
            if (e.IsRelativeURL(f)) {
                const g =
                    f.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(g) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => e.FetchText(g)) : e.FetchText(g)
            }
            return e.FetchText(f)
        }
        async FetchJson(f) {
            f = await this.FetchText(f);
            return JSON.parse(f)
        }
        _CordovaFetchLocalFileAs(f, h) {
            return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
                filename: f,
                as: h
            })
        }
        CordovaFetchLocalFileAsText(f) {
            return this._CordovaFetchLocalFileAs(f, "text")
        }
        async CordovaFetchLocalFileAsBlob(f) {
            const h =
                await this._CordovaFetchLocalFileAs(f, "buffer");
            f = b(f);
            return new Blob([h], {
                type: f
            })
        }
        async CordovaFetchLocalFileAsBlobURL(f) {
            f = f.toLowerCase();
            var h = this._localBlobUrlCache.get(f);
            if (h) return h;
            h = await this.CordovaFetchLocalFileAsBlob(f);
            h = URL.createObjectURL(h);
            this._localBlobUrlCache.set(f, h);
            return h
        }
        CordovaFetchLocalFileAsArrayBuffer(f) {
            return this._CordovaFetchLocalFileAs(f, "buffer")
        }
        GetMediaFileUrl(f) {
            return this._HasLocalUrlBlob(f) ? this.GetLocalUrlAsBlobUrl(f) : this._mediaSubfolder + f.toLowerCase()
        }
        GetProjectFileUrl(f,
            h = "") {
            if (e.IsAbsoluteURL(f)) {
                if (h) throw Error("cannot specify subfolder with remote URL");
                return Promise.resolve(f)
            }
            return this._HasLocalUrlBlob(f) ? Promise.resolve(this.GetLocalUrlAsBlobUrl(f)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(h + f) : Promise.resolve(h + f.toLowerCase())
        }
        GetProjectFileIframeUrl(f) {
            if (e.IsAbsoluteURL(f)) return Promise.resolve(f);
            var h = f.indexOf("?"),
                g = -1 === h ? "" : f.substr(h);
            h = -1 === h ? f : f.substr(0, h);
            return this._HasLocalUrlBlob(h) ? (f = this._localBlobSWUrls.get(h) ||
                this.GetLocalUrlAsBlobUrl(h), !f.startsWith("blob:") && this._swClientId && (f = new URL(f), g = new URLSearchParams(g), g.set("__c3_client_id", this._swClientId), f.search = g.toString(), f = f.toString()), Promise.resolve(f)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(h) : Promise.resolve(f.toLowerCase())
        }
        LoadProjectFileUrl(f) {
            return this.GetProjectFileUrl(f)
        }
        LoadImage(f) {
            if (f.loadPolicy && !d.has(f.loadPolicy)) throw Error("invalid load policy");
            let h = this._assetsByUrl.get(f.url);
            if (h) return h;
            h = e.New(e.ImageAsset, this, {
                url: f.url,
                size: f.size || 0,
                loadPolicy: f.loadPolicy || this._defaultLoadPolicy
            });
            this._allAssets.push(h);
            this._assetsByUrl.set(h.GetURL(), h);
            this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += h.GetSize(), this._loadPromises.push(h.Load().then(() => this._AddLoadedSize(h.GetSize()))));
            return h
        }
        async WaitForAllToLoad() {
            try {
                await Promise.all(this._loadPromises), this._lastLoadProgress = 1
            } catch (f) {
                console.error("Error loading: ", f), this._hasHadErrorLoading = !0, this._FireLoadingProgressEvent()
            }
        }
        SetInitialLoadFinished() {
            this._hasFinishedInitialLoad = !0
        }
        HasHadErrorLoading() {
            return this._hasHadErrorLoading
        }
        _AddLoadedSize(f) {
            this._assetSizeLoaded += f;
            this._loadingRateLimiter.Call()
        }
        _FireLoadingProgressEvent() {
            const f = e.New(e.Event, "loadingprogress");
            this._lastLoadProgress = e.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1);
            f.progress = this._lastLoadProgress;
            this._runtime.Dispatcher().dispatchEvent(f)
        }
        GetLoadProgress() {
            return this._lastLoadProgress
        }
        _SetWebFonts(f) {
            e.shallowAssignArray(this._webFonts, f);
            this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
        }
        _LoadWebFonts() {
            if ("undefined" ===
                typeof FontFace) return Promise.resolve();
            const f = [];
            for (const [h, g, k] of this._webFonts) this._totalAssetSizeToLoad += k, f.push(this._LoadWebFont(h, g).then(() => this._AddLoadedSize(k)));
            return Promise.all(f)
        }
        async _LoadWebFont(f, h) {
            try {
                const g = await this.GetProjectFileUrl(h, this._fontsSubfolder),
                    k = new FontFace(f, `url('${g}')`);
                this._runtime.IsInWorker() ? self.fonts.add(k) : document.fonts.add(k);
                await k.load()
            } catch (g) {
                console.warn(`[C3 runtime] Failed to load web font '${f}': `, g)
            }
        }
        IsAudioFormatSupported(f) {
            return !!this._supportedAudioFormats[f]
        }
        _SetAudioFiles(f,
            h) {
            this._preloadSounds = !!h;
            for (const [g, k, m] of f) this._audioFiles.set(g, {
                fileName: g,
                formats: k.map(r => ({
                    type: r[0],
                    fileExtension: r[1],
                    fullName: g + r[1],
                    fileSize: r[2]
                })),
                isMusic: m
            })
        }
        GetPreferredAudioFile(f) {
            f = this._audioFiles.get(f.toLowerCase());
            if (!f) return null;
            let h = null;
            for (const g of f.formats)
                if (h || "audio/webm; codecs=opus" !== g.type || (h = g), this.IsAudioFormatSupported(g.type)) return g;
            return h
        }
        GetProjectAudioFileUrl(f) {
            return (f = this.GetPreferredAudioFile(f)) ? {
                url: this.GetMediaFileUrl(f.fullName),
                type: f.type
            } : null
        }
        GetAudioToPreload() {
            if (this._preloadSounds) {
                const f = [];
                for (const h of this._audioFiles.values()) {
                    if (h.isMusic) continue;
                    const g = this.GetPreferredAudioFile(h.fileName);
                    g && f.push({
                        originalUrl: h.fileName,
                        url: this.GetMediaFileUrl(g.fullName),
                        type: g.type,
                        fileSize: g.fileSize
                    })
                }
                return f
            }
            return []
        }
        GetIAssetManager() {
            return this._iAssetManager
        }
        async LoadScripts(...f) {
            const h = await Promise.all(f.map(g => this.GetProjectFileUrl(g)));
            this._runtime.IsInWorker() ? 1 === f.length ? (f = f[0], await self.c3_import((e.IsRelativeURL(f) ?
                "./" : "") + f)) : (f = f.map(g => `import "${e.IsRelativeURL(g)?"./":""}${g}";`).join("\n"), f = URL.createObjectURL(new Blob([f], {
                type: "application/javascript"
            })), await self.c3_import(f)) : await Promise.all(h.map(g => c(g)))
        }
        async CompileWebAssembly(f) {
            if (WebAssembly.compileStreaming) return f = await this.GetProjectFileUrl(f), await WebAssembly.compileStreaming(fetch(f));
            f = await e.FetchArrayBuffer(f);
            return await WebAssembly.compile(f)
        }
        async LoadStyleSheet(f) {
            f = await this.GetProjectFileUrl(f);
            return await this._runtime.PostComponentMessageToDOMAsync("runtime",
                "add-stylesheet", {
                    url: f
                })
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Asset = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._assetManager = d;
            this._runtime = d.GetRuntime();
            this._url = a.url;
            this._size = a.size;
            this._loadPolicy = a.loadPolicy;
            this._blob = null;
            this._isLoaded = !1;
            this._loadPromise = null
        }
        Release() {
            this._blob = this._runtime = this._assetManager = this._loadPromise = null
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        Load() {
            return "local" === this._loadPolicy || this._blob ? (this._isLoaded = !0, Promise.resolve()) : this._loadPromise ?
                this._loadPromise : this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(d => {
                    this._isLoaded = !0;
                    this._loadPromise = null;
                    return this._blob = d
                }).catch(d => console.error("Error loading resource: ", d))
        }
        IsLoaded() {
            return this._isLoaded
        }
        GetBlob() {
            return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new e.PromiseThrottle,
        a = new Set;
    e.ImageAsset = class extends e.Asset {
        constructor(b, c) {
            super(b, c);
            this._webglTexture = this._texturePromise = null;
            this._refCount = 0;
            this._imageHeight = this._imageWidth = -1;
            a.add(this)
        }
        Release() {
            this.ReleaseTexture();
            if (0 !== this._refCount) throw Error("released image asset which still has texture references");
            this._texturePromise = null;
            a.delete(this);
            super.Release()
        }
        static OnWebGLContextLost() {
            for (const b of a) b._texturePromise = null, b._webglTexture =
                null, b._refCount = 0
        }
        LoadStaticTexture(b, c) {
            c = c || {};
            this._refCount++;
            if (this._webglTexture) return Promise.resolve(this._webglTexture);
            if (this._texturePromise) return this._texturePromise;
            c.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();
            return this._texturePromise = this.GetBlob().then(f => d.Add(() => b.CreateStaticTextureAsync(f, c).then(h => {
                this._texturePromise = null;
                if (0 === this._refCount) return b.DeleteTexture(h), null;
                this._webglTexture = h;
                this._imageWidth = h.GetWidth();
                this._imageHeight =
                    h.GetHeight();
                return this._webglTexture
            }))).catch(f => {
                console.error("Failed to load texture: ", f);
                throw f;
            })
        }
        ReleaseTexture() {
            if (0 >= this._refCount) throw Error("texture released too many times");
            this._refCount--;
            0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null)
        }
        GetTexture() {
            return this._webglTexture
        }
        GetWidth() {
            return this._imageWidth
        }
        GetHeight() {
            return this._imageHeight
        }
        async LoadToDrawable() {
            const b = await this.GetBlob();
            return e.Supports.ImageBitmapOptions ? await createImageBitmap(b, {
                premultiplyAlpha: "none"
            }) : e.Supports.ImageBitmap ? await createImageBitmap(b) : await e.BlobToImage(b)
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(a, b) {
        return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
    }
    e.RenderCell = class extends e.DefendedBase {
        constructor(a, b, c) {
            super();
            this._grid = a;
            this._x = b;
            this._y = c;
            this._instances = [];
            this._isSorted = !0;
            this._pendingRemoval = new Set;
            this._isAnyPendingRemoval = !1
        }
        Release() {
            e.clearArray(this._instances);
            this._pendingRemoval.clear();
            this._grid = null
        }
        Reset() {
            e.clearArray(this._instances);
            this._isSorted = !0;
            this._pendingRemoval.clear();
            this._isAnyPendingRemoval = !1
        }
        SetChanged() {
            this._isSorted = !1
        }
        IsEmpty() {
            if (!this._instances.length) return !0;
            if (this._instances.length > this._pendingRemoval.size) return !1;
            this._FlushPending();
            return !0
        }
        Insert(a) {
            this._pendingRemoval.has(a) ? (this._pendingRemoval.delete(a), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(a), this._isSorted = 1 === this._instances.length)
        }
        Remove(a) {
            this._pendingRemoval.add(a);
            this._isAnyPendingRemoval = !0;
            50 <= this._pendingRemoval.size && this._FlushPending()
        }
        _FlushPending() {
            this._isAnyPendingRemoval &&
                (this._instances.length === this._pendingRemoval.size ? this.Reset() : (e.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = !1))
        }
        _EnsureSorted() {
            this._isSorted || (this._instances.sort(d), this._isSorted = !0)
        }
        Dump(a) {
            this._FlushPending();
            this._EnsureSorted();
            this._instances.length && a.push(this._instances)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.RenderGrid = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._cellWidth = d;
            this._cellHeight = a;
            this._cells = e.New(e.PairMap)
        }
        Release() {
            this._cells.Release();
            this._cells = null
        }
        GetCell(d, a, b) {
            let c = this._cells.Get(d, a);
            return c ? c : b ? (c = e.New(e.RenderCell, this, d, a), this._cells.Set(d, a, c), c) : null
        }
        XToCell(d) {
            return Math.floor(d / this._cellWidth)
        }
        YToCell(d) {
            return Math.floor(d / this._cellHeight)
        }
        Update(d, a, b) {
            if (a)
                for (let c = a.getLeft(), f = a.getRight(); c <= f; ++c)
                    for (let h =
                            a.getTop(), g = a.getBottom(); h <= g; ++h) {
                        if (b && b.containsPoint(c, h)) continue;
                        const k = this.GetCell(c, h, !1);
                        k && (k.Remove(d), k.IsEmpty() && this._cells.Delete(c, h))
                    }
            if (b)
                for (let c = b.getLeft(), f = b.getRight(); c <= f; ++c)
                    for (let h = b.getTop(), g = b.getBottom(); h <= g; ++h) a && a.containsPoint(c, h) || this.GetCell(c, h, !0).Insert(d)
        }
        QueryRange(d, a) {
            let b = this.XToCell(d.getLeft());
            const c = this.YToCell(d.getTop()),
                f = this.XToCell(d.getRight());
            for (d = this.YToCell(d.getBottom()); b <= f; ++b)
                for (let h = c; h <= d; ++h) {
                    const g = this.GetCell(b,
                        h, !1);
                    g && g.Dump(a)
                }
        }
        MarkRangeChanged(d) {
            let a = d.getLeft();
            const b = d.getTop(),
                c = d.getRight();
            for (d = d.getBottom(); a <= c; ++a)
                for (let f = b; f <= d; ++f) {
                    const h = this.GetCell(a, f, !1);
                    h && h.SetChanged()
                }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new e.Rect,
        a = new e.Quad,
        b = [],
        c = new e.Rect,
        f = new e.Rect,
        h = self.glMatrix,
        g = h.vec3,
        k = h.vec4,
        m = h.mat4,
        r = m.create(),
        w = g.create(),
        p = k.create(),
        t = g.create(),
        u = g.create(),
        q = g.create(),
        x = e.New(e.Vector2);

    function y(C, A) {
        return C.GetWorldInfo()._GetLastCachedZIndex() - A.GetWorldInfo()._GetLastCachedZIndex()
    }

    function B(C, A) {
        return C.GetWorldInfo().GetZElevation() - A.GetWorldInfo().GetZElevation()
    }
    const F = [],
        H = [],
        K = [];
    e.Layer = class extends e.DefendedBase {
        constructor(C, A, G) {
            super();
            this._layout = C;
            this._runtime = C.GetRuntime();
            this._name = G[0];
            this._index = A;
            this._sid = G[2];
            this._isVisible = !!G[3];
            this._backgroundColor = e.New(e.Color);
            this._backgroundColor.setFromJSON(G[4].map(J => J / 255));
            this._isTransparent = !!G[5];
            this._parallaxX = G[6];
            this._parallaxY = G[7];
            this._color = e.New(e.Color, 1, 1, 1, G[8]);
            this._premultipliedColor = e.New(e.Color);
            this._isForceOwnTexture = G[9];
            this._renderAs3d = G[17];
            this._useCameraDistanceDrawOrder = G[18];
            this._useRenderCells = G[10];
            this._scaleRate = G[11];
            this._blendMode =
                G[12];
            this._curRenderTarget = null;
            this._scale = 1;
            this._zElevation = G[16];
            this._scrollY = this._scrollX = this._angle = 0;
            this._hasOwnScrollPosition = !1;
            this._viewport = e.New(e.Rect);
            this._viewportZ0 = e.New(e.Rect);
            this._viewport3D = e.New(e.Rect);
            this._projectionMatrix = m.create();
            this._isProjectionMatrixChanged = !0;
            this._modelViewMatrix = m.create();
            this._isMVMatrixChanged = !0;
            this._viewFrustum = e.New(e.Gfx.ViewFrustum);
            this._isViewFrustumChanged = !0;
            this._startupInitialInstances = [];
            this._initialInstances = [];
            this._createdGlobalUids = [];
            this._initialUIDsToInstanceData = new Map;
            this._instances = [];
            this._anyInstanceZElevated = this._zIndicesUpToDate = !1;
            this._effectList = e.New(e.EffectList, this, G[15]);
            this._renderGrid = null;
            this._lastRenderList = [];
            this._isRenderListUpToDate = !1;
            this._lastRenderCells = e.New(e.Rect, 0, 0, -1, -1);
            this._curRenderCells = e.New(e.Rect, 0, 0, -1, -1);
            this._iLayer = new self.ILayer(this);
            this._UpdatePremultipliedColor();
            this.UsesRenderCells() && (this._renderGrid = e.New(e.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
            for (const J of G[14]) C = this._runtime.GetObjectClassByIndex(J[1]), this._layout._AddInitialObjectClass(C), C.GetDefaultInstanceData() || (C.SetDefaultInstanceData(J), C._SetDefaultLayerIndex(this._index)), this._initialInstances.push(J), this._initialUIDsToInstanceData.set(J[2], J);
            e.shallowAssignArray(this._startupInitialInstances, this._initialInstances)
        }
        static Create(C, A, G) {
            return e.New(e.Layer, C, A, G)
        }
        Release() {
            this._runtime = this._layout = null
        }
        GetInitialInstanceData(C) {
            return this._initialUIDsToInstanceData.get(C)
        }
        CreateInitialInstances(C) {
            const A =
                this._layout.IsFirstVisit();
            let G = 0;
            const J = this._initialInstances;
            for (let R = 0, U = J.length; R < U; ++R) {
                var M = J[R];
                const V = this._runtime.GetObjectClassByIndex(M[1]);
                let ba = !0;
                if (!V.HasPersistBehavior() || A) M = this._runtime.CreateInstanceFromData(M, this, !0), C.push(M), V.IsGlobal() && (ba = !1, this._createdGlobalUids.push(M.GetUID()));
                ba && (J[G] = J[R], ++G)
            }
            e.truncateArray(J, G);
            this._runtime.FlushPendingInstances();
            this.SetZIndicesChanged()
        }
        _AddInstance(C, A) {
            const G = C.GetWorldInfo();
            if (G.GetLayer() !== this) throw Error("instance added to wrong layer");
            this._instances.push(C);
            0 !== G.GetZElevation() && (this._anyInstanceZElevated = !0);
            A && this.UsesRenderCells() && C.GetWorldInfo().SetBboxChanged();
            this.SetZIndicesChanged()
        }
        _MaybeAddInstance(C) {
            this._instances.includes(C) || (this._instances.push(C), 0 !== C.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged())
        }
        _PrependInstance(C, A) {
            const G = C.GetWorldInfo();
            if (G.GetLayer() !== this) throw Error("instance added to wrong layer");
            this._instances.unshift(C);
            0 !== G.GetZElevation() &&
                (this._anyInstanceZElevated = !0);
            this.SetZIndicesChanged();
            A && this.UsesRenderCells() && C.GetWorldInfo().SetBboxChanged()
        }
        _RemoveInstance(C, A) {
            const G = this._instances.indexOf(C);
            0 > G || (A && this.UsesRenderCells() && C.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(G, 1), this.SetZIndicesChanged(), this._MaybeResetAnyInstanceZElevatedFlag())
        }
        _SetAnyInstanceZElevated() {
            this._anyInstanceZElevated = !0
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
            0 === this._instances.length && (this._anyInstanceZElevated = !1)
        }
        _SortInstancesByLastCachedZIndex(C) {
            if (C) {
                C =
                    new Set;
                for (var A of this._instances) {
                    var G = A.GetWorldInfo()._GetLastCachedZIndex();
                    0 <= G && C.add(G)
                }
                A = -1;
                for (const J of this._instances)
                    if (G = J.GetWorldInfo(), !(0 <= G._GetLastCachedZIndex())) {
                        for (++A; C.has(A);) ++A;
                        G._SetZIndex(A)
                    }
            }
            this._instances.sort(y)
        }
        _Start() {}
        _End() {
            for (const C of this._instances) C.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(C);
            this._runtime.FlushPendingInstances();
            e.clearArray(this._instances);
            this._anyInstanceZElevated = !1;
            this.SetZIndicesChanged()
        }
        RecreateInitialObjects(C,
            A, G, J, M) {
            const R = this._runtime.GetEventSheetManager(),
                U = this._runtime.GetAllObjectClasses(),
                V = C.IsFamily(),
                ba = [];
            for (const qa of this._initialInstances) {
                var ia = qa[0];
                if (A.containsPoint(ia[0], ia[1])) {
                    ia = U[qa[1]];
                    if (ia !== C)
                        if (V) {
                            if (!C.FamilyHasMember(ia)) continue
                        } else continue;
                    ia = this;
                    var ja = this._runtime.GetCurrentLayout();
                    this.GetLayout() !== ja && ((ia = ja.GetLayerByName(this.GetName())) || (ia = ja.GetLayerByIndex(this.GetIndex())));
                    ja = this._runtime.CreateInstanceFromData(qa, ia, !1, void 0, void 0, !1, M);
                    ia.SortAndAddInstancesByZIndex(ja);
                    ia = ja.GetWorldInfo();
                    ia.OffsetXY(G, J);
                    ia.SetBboxChanged();
                    R.BlockFlushingInstances(!0);
                    ja._TriggerOnCreatedOnSelfAndRelated();
                    R.BlockFlushingInstances(!1);
                    ba.push(ja)
                }
            }
            return ba
        }
        GetInstanceCount() {
            return this._instances.length
        }
        GetLayout() {
            return this._layout
        }
        GetName() {
            return this._name
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        GetRuntime() {
            return this._runtime
        }
        GetDevicePixelRatio() {
            return this._runtime.GetDevicePixelRatio()
        }
        GetEffectList() {
            return this._effectList
        }
        UsesRenderCells() {
            return this._useRenderCells &&
                !this._useCameraDistanceDrawOrder
        }
        GetRenderGrid() {
            return this._renderGrid
        }
        SetRenderListStale() {
            this._isRenderListUpToDate = !1
        }
        IsVisible() {
            return this._isVisible
        }
        SetVisible(C) {
            C = !!C;
            this._isVisible !== C && (this._isVisible = C, this._runtime.UpdateRender())
        }
        SetOwnScrollPositionEnabled(C) {
            C = !!C;
            if (this._hasOwnScrollPosition !== C) {
                if (this._hasOwnScrollPosition = C) C = this.GetLayout(), this._scrollX = C.GetScrollX(), this._scrollY = C.GetScrollY();
                this._SetMVMatrixChanged();
                this._runtime.UpdateRender()
            }
        }
        IsOwnScrollPositionEnabled() {
            return this._hasOwnScrollPosition
        }
        SetScrollX(C) {
            var A =
                this.GetLayout();
            const G = A.GetScrollLeftBound();
            A = A.GetScrollRightBound();
            C > A && (C = A);
            C < G && (C = G);
            this._scrollX !== C && (this._scrollX = C, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
        }
        SetScrollY(C) {
            var A = this.GetLayout();
            const G = A.GetScrollTopBound();
            A = A.GetScrollBottomBound();
            C > A && (C = A);
            C < G && (C = G);
            this._scrollY !== C && (this._scrollY = C, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
        }
        GetScrollX() {
            return this.IsOwnScrollPositionEnabled() ?
                this._scrollX : this.GetLayout().GetScrollX()
        }
        GetScrollY() {
            return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY()
        }
        GetViewport() {
            return this._viewport
        }
        GetViewport3D() {
            return this._viewport3D
        }
        _GetVanishingPoint() {
            const C = this.GetLayout();
            return [C.GetVanishingPointX(), C.GetVanishingPointY()]
        }
        GetViewportForZ(C, A) {
            var G = this._viewportZ0;
            if (0 === C) A.copy(G);
            else {
                let U = G.midX(),
                    V = G.midY();
                var J = this.Get2DScaleFactorToZ(C);
                const ba = G.width() / J;
                G = G.height() / J;
                const [ia, ja] = this._GetVanishingPoint();
                if (.5 !== ia || .5 !== ja) {
                    const qa = this.GetCameraZ();
                    var M = this._runtime,
                        R = 100 / qa;
                    J = (ia - .5) * M.GetViewportWidth() / R;
                    M = (ja - .5) * M.GetViewportHeight() / R;
                    R = this.GetAngle();
                    0 !== R && (x.set(J, M), x.rotate(R), J = x.getX(), M = x.getY());
                    C = e.unlerp(qa, 0, C);
                    U += e.lerp(J, 0, C);
                    V += e.lerp(M, 0, C)
                }
                A.set(U - ba / 2, V - G / 2, U + ba / 2, V + G / 2)
            }
        }
        GetOpacity() {
            return this._color.getA()
        }
        SetOpacity(C) {
            C = e.clamp(C, 0, 1);
            this._color.getA() !== C && (this._color.setA(C), this._UpdatePremultipliedColor(), this._runtime.UpdateRender())
        }
        _UpdatePremultipliedColor() {
            this._premultipliedColor.copy(this._color);
            this._premultipliedColor.premultiply()
        }
        GetPremultipliedColor() {
            return this._premultipliedColor
        }
        HasDefaultColor() {
            return this._color.equalsRgba(1, 1, 1, 1)
        }
        GetScaleRate() {
            return this._scaleRate
        }
        SetScaleRate(C) {
            this._scaleRate !== C && (this._scaleRate = C, this._SetMVMatrixChanged(), this._runtime.UpdateRender())
        }
        GetParallaxX() {
            return this._parallaxX
        }
        GetParallaxY() {
            return this._parallaxY
        }
        SetParallax(C, A) {
            if (this._parallaxX !== C || this._parallaxY !== A)
                if (this._parallaxX = C, this._parallaxY = A, this._SetMVMatrixChanged(),
                    this._runtime.UpdateRender(), 1 !== this._parallaxX || 1 !== this._parallaxY)
                    for (const G of this._instances) G.GetObjectClass()._SetAnyInstanceParallaxed(!0)
        }
        SetParallaxX(C) {
            this.SetParallax(C, this.GetParallaxY())
        }
        SetParallaxY(C) {
            this.SetParallax(this.GetParallaxX(), C)
        }
        SetZElevation(C) {
            this._zElevation !== C && (this._zElevation = C, this._runtime.UpdateRender())
        }
        GetZElevation() {
            return this._zElevation
        }
        SetAngle(C) {
            C = e.clampAngle(C);
            this._angle !== C && (this._angle = C, this._SetMVMatrixChanged(), this._runtime.UpdateRender())
        }
        GetAngle() {
            return e.clampAngle(this._layout.GetAngle() +
                this._angle)
        }
        GetOwnAngle() {
            return this._angle
        }
        HasInstances() {
            return 0 < this._instances.length
        }
        _GetInstances() {
            return this._instances
        }
        _GetInstancesInDrawOrder() {
            return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (e.shallowAssignArray(K, this._GetInstances()), K.sort((C, A) => this._SortInstancesByCameraDistance(C, A)), K) : this._GetInstances()
        }
        _SortInstancesByCameraDistance(C, A) {
            var G = this.GetLayout().Get3DCameraPosition(),
                J = G[0],
                M = G[1];
            G = G[2];
            var R = C.GetWorldInfo();
            const U = A.GetWorldInfo();
            A =
                R.GetX() - J;
            C = R.GetY() - M;
            R = R.GetZElevation() - G;
            J = U.GetX() - J;
            M = U.GetY() - M;
            G = U.GetZElevation() - G;
            return J * J + M * M + G * G - (A * A + C * C + R * R)
        }
        GetBackgroundColor() {
            return this._backgroundColor
        }
        IsTransparent() {
            return this._isTransparent
        }
        SetTransparent(C) {
            C = !!C;
            this._isTransparent !== C && (this._isTransparent = C, this._runtime.UpdateRender())
        }
        IsForceOwnTexture() {
            return this._isForceOwnTexture
        }
        SetForceOwnTexture(C) {
            C = !!C;
            this._isForceOwnTexture !== C && (this._isForceOwnTexture = C, this._runtime.UpdateRender())
        }
        RendersIn2DMode() {
            return !this.GetRuntime().Uses3DFeatures() ||
                !this._renderAs3d
        }
        RendersIn3DMode() {
            return !this.RendersIn2DMode()
        }
        Has3DCamera() {
            return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled()
        }
        SetBlendMode(C) {
            this._blendMode !== C && (this._blendMode = C, this._runtime.UpdateRender())
        }
        GetBlendMode() {
            return this._blendMode
        }
        IsTransformCompatibleWith(C) {
            return this === C || this._parallaxX === C._parallaxX && this._parallaxY === C._parallaxY && this._scale === C._scale && this._scaleRate === C._scaleRate && this._angle === C._angle && this.GetScrollX() === C.GetScrollX() && this.GetScrollY() ===
                C.GetScrollY()
        }
        SaveTransform() {
            return {
                parallaxX: this.GetParallaxX(),
                parallaxY: this.GetParallaxY(),
                scale: this.GetOwnScale(),
                scaleRate: this.GetScaleRate(),
                angle: this.GetOwnAngle(),
                hasOwnScroll: this.IsOwnScrollPositionEnabled(),
                scrollX: this.GetScrollX(),
                scrollY: this.GetScrollY()
            }
        }
        RestoreTransform(C) {
            this.SetParallax(C.parallaxX, C.parallaxY);
            this.SetOwnScale(C.scale);
            this.SetScaleRate(C.scaleRate);
            this.SetAngle(C.angle);
            this.SetOwnScrollPositionEnabled(C.hasOwnScroll);
            this.SetScrollX(C.scrollX);
            this.SetScrollY(C.scrollY)
        }
        _RemoveAllInstancesInSet(C) {
            0 !==
                C.size && 0 < e.arrayRemoveAllInSet(this._instances, C) && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged())
        }
        SetZIndicesChanged() {
            this._isRenderListUpToDate = this._zIndicesUpToDate = !1
        }
        _UpdateZIndices() {
            if (!this._zIndicesUpToDate) {
                this._instances.sort(B);
                if (this.UsesRenderCells())
                    for (let C = 0, A = this._instances.length; C < A; ++C) {
                        const G = this._instances[C].GetWorldInfo();
                        G._SetZIndex(C);
                        this._renderGrid.MarkRangeChanged(G.GetRenderCellRange())
                    } else
                        for (let C = 0, A = this._instances.length; C < A; ++C) this._instances[C].GetWorldInfo()._SetZIndex(C);
                this._zIndicesUpToDate = !0
            }
        }
        MoveInstanceAdjacent(C, A, G) {
            var J = C.GetWorldInfo();
            A = A.GetWorldInfo();
            if (J.GetLayer() !== this || A.GetLayer() !== this) throw Error("can't arrange Z order unless both objects on this layer");
            J = J.GetZIndex();
            A = A.GetZIndex();
            if (J === A + (G ? 1 : -1)) return !1;
            e.arrayRemove(this._instances, J);
            J < A && A--;
            G && A++;
            A === this._instances.length ? this._instances.push(C) : this._instances.splice(A, 0, C);
            this.SetZIndicesChanged();
            return !0
        }
        _MergeSortedZArrays(C, A) {
            const G = [];
            let J = 0,
                M = 0,
                R = C.length,
                U = A.length;
            for (; J < R && M < U;) {
                const V = C[J],
                    ba = A[M];
                V.GetWorldInfo()._GetLastCachedZIndex() < ba.GetWorldInfo()._GetLastCachedZIndex() ? (G.push(V), ++J) : (G.push(ba), ++M)
            }
            for (; J < R; ++J) G.push(C[J]);
            for (; M < U; ++M) G.push(A[M]);
            return G
        }
        _MergeAllSortedZArrays_pass(C) {
            const A = [],
                G = C.length;
            for (let J = 0; J < G - 1; J += 2) A.push(this._MergeSortedZArrays(C[J], C[J + 1]));
            1 === G % 2 && A.push(C[G - 1]);
            return A
        }
        _MergeAllSortedZArrays(C) {
            for (; 1 < C.length;) C = this._MergeAllSortedZArrays_pass(C);
            return C[0]
        }
        _GetRenderCellInstancesToDraw() {
            this._UpdateZIndices();
            e.clearArray(b);
            this._renderGrid.QueryRange(this._viewport, b);
            return b.length ? 1 === b.length ? b[0] : this._MergeAllSortedZArrays(b) : []
        }
        _IsOpaque() {
            return !this.UsesOwnTexture() && !this.IsTransparent()
        }
        ShouldDraw() {
            return this.IsVisible() && 0 < this.GetOpacity() && (this.HasInstances() || !this.IsTransparent())
        }
        UsesOwnTexture() {
            return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        _CanFastPathDrawLayer(C) {
            if (0 ===
                C.length) return !0;
            if (2 <= C.length) return !1;
            C = C[0].GetShaderProgram();
            return !C.MustPreDraw() && !C.UsesDest() && !C.UsesCrossSampling() && this.HasDefaultColor()
        }
        Get2DScaleFactorToZ(C) {
            if (this._layout.IsOrthographicProjection()) return 1; {
                const A = this.GetCameraZ();
                return A / (A - C)
            }
        }
        GetCameraZ() {
            return 100 / this.GetNormalScale()
        }
        _SetMVMatrixChanged() {
            this._isViewFrustumChanged = this._isMVMatrixChanged = !0
        }
        _GetModelViewMatrix(C) {
            this._isMVMatrixChanged && (this._CalculateModelViewMatrix(C, this._modelViewMatrix, 0, 0,
                null), this._isMVMatrixChanged = !1);
            return this._modelViewMatrix
        }
        _CalculateModelViewMatrix(C, A, G, J, M) {
            const R = this._runtime;
            var U = this.GetLayout();
            const V = R.GetRenderScale();
            var ba = R.GetParallaxXOrigin(),
                ia = R.GetParallaxYOrigin();
            let ja = (this.GetScrollX() - ba) * this._parallaxX + ba;
            var qa = (this.GetScrollY() - ia) * this._parallaxY + ia;
            this._runtime.IsPixelRoundingEnabled() && (ja = Math.round(ja), qa = Math.round(qa));
            if (this.Has3DCamera()) g.copy(t, U.Get3DCameraPosition()), g.copy(u, U.Get3DCameraLookAt()), g.copy(q,
                U.Get3DCameraUpVector()), U = u[0] - t[0], J = u[1] - t[1], qa = u[2] - t[2], t[0] = (t[0] - ba) * this._parallaxX + ba, t[1] = (t[1] - ia) * this._parallaxY + ia, t[2] *= Math.max(this._parallaxX, this._parallaxY), u[0] = t[0] + U, u[1] = t[1] + J, u[2] = t[2] + qa, g.set(w, V, V, 1), g.multiply(t, t, w), g.multiply(u, u, w);
            else {
                ba = (ja + G) * V;
                ia = (qa + J) * V;
                U = U.IsOrthographicProjection() ? 100 : this.GetCameraZ();
                J = this.GetAngle();
                const [za, Ca] = this._GetVanishingPoint();
                if (.5 !== za || .5 !== Ca) G = 100 / U, qa = (za - .5) * R.GetViewportWidth() * V / G, G = (Ca - .5) * R.GetViewportHeight() *
                    V / G, 0 !== J && (x.set(qa, G), x.rotate(J), qa = x.getX(), G = x.getY()), ba += qa, ia += G;
                g.set(t, ba, ia, U);
                g.set(u, ba, ia, U - 100);
                0 === J ? g.set(q, 0, 1, 0) : g.set(q, Math.sin(J), Math.cos(J), 0)
            }
            C.CalculateLookAtModelView(A, t, u, q, M || R.GetCanvasManager().GetDrawHeight());
            1 !== V && (g.set(w, V, V, 1), m.scale(A, A, w))
        }
        _SetProjectionMatrixChanged() {
            this._isViewFrustumChanged = this._isProjectionMatrixChanged = !0
        }
        _GetProjectionMatrix(C) {
            this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(C), this._isProjectionMatrixChanged = !1);
            return this._projectionMatrix
        }
        _CalculateProjectionMatrix(C) {
            var A = this._runtime.GetCanvasManager();
            const [G, J] = this._GetVanishingPoint();
            if (this._layout.IsOrthographicProjection()) C.CalculateOrthographicMatrix(this._projectionMatrix, A.GetDrawWidth(), A.GetDrawHeight());
            else if (.5 === G && .5 === J) m.copy(this._projectionMatrix, A.GetDefaultProjectionMatrix());
            else {
                const M = A.GetDrawWidth();
                A = A.GetDrawHeight();
                C.CalculatePerspectiveMatrix(this._projectionMatrix, M / A, G, J)
            }
        }
        _SetTransform(C, A = !0, G = 0, J = 0, M = 0) {
            A &&
                C.SetProjectionMatrix(this._GetProjectionMatrix(C));
            0 === G && 0 === J && 0 === M ? A = this._GetModelViewMatrix(C) : (this._CalculateModelViewMatrix(C, r, G, J, M), A = r);
            C.SetModelViewMatrix(A)
        }
        PrepareForDraw(C) {
            this._SetTransform(C);
            C.SetBaseZ(this.GetZElevation())
        }
        Draw(C, A, G) {
            var J = this._runtime.GetCanvasManager();
            const M = this.UsesOwnTexture();
            var R = null;
            let U = null;
            if (this._runtime.IsGPUProfiling())
                if (C.IsWebGL()) {
                    const V = J.GetLayerTimingsBuffer(this);
                    V && (U = V.AddTimeElapsedQuery(), C.StartQuery(U))
                } else C.IsWebGPU() &&
                    C.WriteTimestamp(2 * (this.GetIndex() + 1));
            M ? (R = {
                sampling: this._runtime.GetSampling()
            }, "low" === J.GetCurrentFullscreenScalingQuality() && (R.width = J.GetDrawWidth(), R.height = J.GetDrawHeight()), R = this._runtime.GetAdditionalRenderTarget(R), C.SetRenderTarget(R), this.IsTransparent() ? C.ClearRgba(0, 0, 0, 0) : C.Clear(this._backgroundColor)) : (C.SetRenderTarget(A), this.IsTransparent() || G || C.Clear(this._backgroundColor));
            this._curRenderTarget = R || A;
            this._SetTransform(C);
            C.SetBaseZ(this.GetZElevation());
            C.SetDepthEnabled(this.RendersIn3DMode());
            this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(), J = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated, this.Has3DCamera() ? this._DrawInstances_3DCamera(C) : J ? this._DrawInstances_RenderCells(C) : this._DrawInstances(C, this._GetInstancesInDrawOrder()));
            C.SetBaseZ(0);
            C.SetCurrentZ(0);
            M && (C.SetDepthEnabled(!1), this._DrawLayerOwnTextureToRenderTarget(C, R, A, G));
            U && C.EndQuery(U);
            this._runtime.IsGPUProfiling() && C.IsWebGPU() && C.WriteTimestamp(2 * (this.GetIndex() + 1) + 1);
            this._curRenderTarget =
                null
        }
        _DrawInstances(C, A) {
            const G = this._viewport,
                J = this._curRenderTarget,
                M = this.GetLayout().IsOrthographicProjection(),
                R = this.GetLayout().HasVanishingPointOutsideViewport();
            let U = null;
            for (let V = 0, ba = A.length; V < ba; ++V) {
                const ia = A[V];
                if (ia === U) continue;
                U = ia;
                const ja = ia.GetWorldInfo();
                ja.IsVisible() && ja.IsInViewport(G, R, M) && this._DrawInstanceMaybeWithEffects(ia, ja, C, J)
            }
        }
        _DrawInstances_3DCamera(C) {
            const A = this._curRenderTarget,
                G = this._GetViewFrustum(),
                J = this._GetInstancesInDrawOrder();
            for (let V = 0, ba = J.length; V <
                ba;) {
                var M = J[V],
                    R = M.GetWorldInfo();
                if (!R.IsVisible() || !R.IsInViewport3D(G)) {
                    ++V;
                    continue
                }(!M.RendersToOwnZPlane() || 0 < R.GetDepth()) && H.push(M);
                var U = M.GetWorldInfo().GetTotalZElevation();
                F.push(M);
                let ia = V + 1;
                for (; ia < ba; ++ia) {
                    const ja = J[ia],
                        qa = ja.GetWorldInfo();
                    if (qa.IsVisible() && qa.IsInViewport3D(G)) {
                        if (qa.GetTotalZElevation() !== U) break;
                        ja.RendersToOwnZPlane() ? (0 < qa.GetDepth() && H.push(ja), F.push(ja)) : H.push(ja)
                    }
                }
                if (1 !== F.length || F[0].MustMitigateZFighting()) {
                    this._DrawCoplanarInstances_3DCamera(C,
                        F);
                    for (let ja = 0, qa = H.length; ja < qa; ++ja) M = H[ja], R = M.GetWorldInfo(), R._SetDrawNonBackFacesOnly(!0), this._DrawInstanceMaybeWithEffects(M, R, C, A), R._SetDrawNonBackFacesOnly(!1)
                } else {
                    this._DrawInstanceMaybeWithEffects(M, R, C, A);
                    for (let ja = 0, qa = H.length; ja < qa; ++ja) R = H[ja], R !== M && (U = R.GetWorldInfo(), U.GetLayer()._DrawInstanceMaybeWithEffects(R, U, C, A))
                }
                V = ia;
                e.clearArray(F);
                e.clearArray(H)
            }
        }
        _DrawCoplanarInstances_3DCamera(C, A) {
            const G = this._curRenderTarget;
            C.CoplanarStartStencilPass();
            for (let R = 0, U = A.length; R <
                U; ++R) {
                var J = A[R],
                    M = J.GetWorldInfo();
                M._SetDrawBackFaceOnly(!0);
                this._DrawInstance(J, M, C)
            }
            C.CoplanarStartColorPass();
            for (let R = 0, U = A.length; R < U; ++R) J = A[R], M = J.GetWorldInfo(), this._DrawInstanceMaybeWithEffects(J, M, C, G), M._SetDrawBackFaceOnly(!1);
            C.CoplanarRestoreStandardRendering()
        }
        _DrawInstances_RenderCells(C) {
            var A = this._renderGrid;
            const G = this._curRenderCells,
                J = this._lastRenderCells,
                M = this._viewport;
            G.set(A.XToCell(M.getLeft()), A.YToCell(M.getTop()), A.XToCell(M.getRight()), A.YToCell(M.getBottom()));
            this._isRenderListUpToDate && G.equals(J) ? A = this._lastRenderList : (A = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = !0, J.copy(G));
            this._DrawInstances(C, A);
            A !== this._lastRenderList && e.shallowAssignArray(this._lastRenderList, A)
        }
        _DrawInstanceMaybeWithEffects(C, A, G, J) {
            A.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(C, A, G, J) : this._DrawInstance(C, A, G)
        }
        _DrawInstance(C, A, G) {
            A = A.GetRendererStateGroup();
            G.GetCurrentStateGroup() !== A && A.Apply();
            C.Draw(G)
        }
        _DrawInstanceWithEffectsAndRestore(C,
            A, G, J) {
            this._DrawInstanceWithEffects(C, A, G, J, null) && this._SetTransform(G)
        }
        _DrawInstanceWithEffects(C, A, G, J, M) {
            const R = A.GetInstanceEffectList().GetActiveEffectTypes();
            if (1 === R.length) {
                const U = R[0],
                    V = U.GetShaderProgram();
                if (!V.NeedsPostDrawOrExtendsBox() && A.HasDefaultColor() && !C.MustPreDraw()) return this._DrawInstanceWithEffects_FastPath(C, A, U, V, G), !1
            }
            C = e.RenderEffectChain(G, this._runtime, C, J, R, M);
            G.SetBaseZ(this.GetZElevation());
            return C
        }
        _DrawInstanceWithEffects_FastPath(C, A, G, J, M) {
            M.SetProgram(J);
            M.SetBlendMode(A.GetBlendMode());
            J.IsAnimated() && this._runtime.UpdateRender();
            let R = 0,
                U = 0;
            if (J.UsesAnySrcRectOrPixelSize()) {
                const [V, ba] = C.GetCurrentSurfaceSize();
                R = 1 / V;
                U = 1 / ba;
                (J = C.GetCurrentTexRect()) ? f.copy(J): f.set(0, 0, 0, 0)
            }
            G = A.GetInstanceEffectList().GetEffectParametersForIndex(G.GetIndex());
            M.SetCurrentZ(A.GetZElevation());
            M.SetProgramParameters(null, c, f, f, A.GetBoundingBox(), R, U, this.GetOwnScale(), this.GetAngle(), this._runtime.GetGameTime(), G);
            C.Draw(M)
        }
        _DrawLayerOwnTextureToRenderTarget(C, A,
            G, J) {
            const M = this._effectList.GetActiveEffectTypes(),
                R = this._runtime;
            if (this._CanFastPathDrawLayer(M)) {
                C.SetRenderTarget(G);
                if (1 === M.length) {
                    var U = M[0];
                    G = U.GetShaderProgram();
                    C.SetProgram(G);
                    f.set(0, 0, 1, 1);
                    U = this._effectList.GetEffectParametersForIndex(U.GetIndex());
                    C.SetProgramParameters(null, c, f, f, this._viewport, 1 / R.GetDrawWidth(), 1 / R.GetDrawHeight(), this.GetNormalScale(), this.GetAngle(), R.GetGameTime(), U);
                    G.IsAnimated() && R.UpdateRender()
                } else C.SetTextureFillMode();
                J && 0 === this._blendMode && this.HasDefaultColor() &&
                    0 === M.length ? C.CopyRenderTarget(A) : (C.SetBlendMode(this._blendMode), C.SetColor(this._premultipliedColor), C.DrawRenderTarget(A));
                C.InvalidateRenderTarget(A);
                R.ReleaseAdditionalRenderTarget(A)
            } else e.RenderEffectChain(C, R, this, G, M)
        }
        GetOwnScale() {
            return this._scale
        }
        SetOwnScale(C) {
            this._scale !== C && (this._scale = C, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender())
        }
        GetRenderScale() {
            return this.GetNormalScale() * this._runtime.GetRenderScale()
        }
        GetDisplayScale() {
            return this.GetNormalScale() *
                this._runtime.GetDisplayScale()
        }
        GetNormalScale() {
            return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
        }
        UpdateViewport() {
            var C = this._runtime.GetParallaxXOrigin(),
                A = this._runtime.GetParallaxYOrigin(),
                G = (this.GetScrollX() - C) * this._parallaxX + C,
                J = (this.GetScrollY() - A) * this._parallaxY + A;
            C = this.GetNormalScale();
            A = this._runtime.GetViewportWidth() / C;
            C = this._runtime.GetViewportHeight() / C;
            G -= A / 2;
            let M = J - C / 2;
            this._runtime.IsPixelRoundingEnabled() && (G = Math.round(G), M = Math.round(M));
            J = this._viewportZ0;
            J.set(G, M, G + A, M + C);
            A = this.GetAngle();
            0 !== A && (d.copy(J), d.offset(-J.midX(), -J.midY()), a.setFromRotatedRect(d, A), a.getBoundingBox(d), d.offset(J.midX(), J.midY()), J.copy(d));
            A = this._zElevation;
            this.GetViewportForZ(A, this._viewport);
            this.Has3DCamera() ? this.CalculateViewport3D(A, this._viewport3D) : this._viewport3D.copy(this._viewport)
        }
        CalculateViewport3D(C, A) {
            var G = this._runtime.GetCanvasManager(),
                J = G.GetCssWidth();
            G = G.GetCssHeight();
            const [M, R] = this.CanvasCssToLayer(0, 0, C), [U, V] = this.CanvasCssToLayer(J,
                0, C), [ba, ia] = this.CanvasCssToLayer(J, G, C), [ja, qa] = this.CanvasCssToLayer(0, G, C);
            C = Math.min(M, U, ba, ja);
            J = Math.min(R, V, ia, qa);
            G = Math.max(M, U, ba, ja);
            let za = Math.max(R, V, ia, qa);
            isFinite(C) || (C = -Infinity);
            isFinite(J) || (J = -Infinity);
            isFinite(G) || (G = Infinity);
            isFinite(za) || (za = Infinity);
            A.set(C, J, G, za)
        }
        CanvasCssToLayer(C, A, G = 0) {
            return this._CanvasToLayer(C, A, G, this.GetDisplayScale())
        }
        DrawSurfaceToLayer(C, A, G = 0) {
            return this._CanvasToLayer(C, A, G, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _CanvasToLayer(C,
            A, G, J) {
            var M = this._runtime,
                R = M.GetRenderer();
            const U = this.GetNormalScale(),
                V = M.GetViewportWidth() / U;
            M = M.GetViewportHeight() / U;
            k.set(p, 0, 0, V, M);
            C /= J;
            A = p[3] - A / J;
            J = this._GetProjectionMatrix(R);
            R = this._GetModelViewMatrix(R);
            return e.Gfx.UnprojectScreenToWorldZ(C, A, G, R, J, p, w) ? [w[0], w[1]] : [NaN, NaN]
        }
        CanvasCssToLayer_DefaultTransform(C, A) {
            const G = this._scale,
                J = this._scaleRate,
                M = this._parallaxX,
                R = this._parallaxY,
                U = this._angle;
            this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
            this._angle = 0;
            this._SetMVMatrixChanged();
            C = this.CanvasCssToLayer(C, A);
            this._scale = G;
            this._scaleRate = J;
            this._parallaxX = M;
            this._parallaxY = R;
            this._angle = U;
            this._SetMVMatrixChanged();
            return C
        }
        LayerToCanvasCss(C, A, G = 0) {
            return this._LayerToCanvas(C, A, G, this.GetDisplayScale())
        }
        LayerToDrawSurface(C, A, G = 0) {
            return this._LayerToCanvas(C, A, G, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _LayerToCanvas(C, A, G, J) {
            var M = this._runtime,
                R = M.GetRenderer();
            const U = this.GetNormalScale();
            var V = M.GetViewportWidth() / U;
            M = M.GetViewportHeight() / U;
            k.set(p, 0, 0, V,
                M);
            V = this._GetProjectionMatrix(R);
            R = this._GetModelViewMatrix(R);
            return e.Gfx.Project(C, A, G, R, V, p, w) ? [w[0] * J, (p[3] - w[1]) * J] : [NaN, NaN]
        }
        _GetLayerToDrawSurfaceScale(C, A) {
            C *= this.GetRenderScale() * this.GetDevicePixelRatio();
            0 !== A && (C *= this.Get2DScaleFactorToZ(A));
            return C
        }
        _GetViewFrustum() {
            this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = !1);
            return this._viewFrustum
        }
        _UpdateViewFrustum() {
            var C = this._runtime.GetRenderer();
            const A = this._GetProjectionMatrix(C);
            C = this._GetModelViewMatrix(C);
            this._viewFrustum.CalculatePlanes(C, A)
        }
        _SaveToJson() {
            return {
                s: this.GetOwnScale(),
                a: this.GetOwnAngle(),
                vl: this._viewport.getLeft(),
                vt: this._viewport.getTop(),
                vr: this._viewport.getRight(),
                vb: this._viewport.getBottom(),
                v: this.IsVisible(),
                bc: this._backgroundColor.toJSON(),
                t: this.IsTransparent(),
                sx: this._scrollX,
                sy: this._scrollY,
                hosp: this._hasOwnScrollPosition,
                px: this.GetParallaxX(),
                py: this.GetParallaxY(),
                c: this._color.toJSON(),
                sr: this.GetScaleRate(),
                fx: this._effectList.SaveToJson(),
                cg: this._createdGlobalUids
            }
        }
        _LoadFromJson(C) {
            this._scale =
                C.s;
            this._angle = C.a;
            this._viewport.set(C.vl, C.vt, C.vr, C.vb);
            this._isVisible = !!C.v;
            this._backgroundColor.setFromJSON(C.bc);
            this._isTransparent = !!C.t;
            C.hasOwnProperty("sx") && (this._scrollX = C.sx);
            C.hasOwnProperty("sy") && (this._scrollY = C.sy);
            C.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!C.hosp);
            this._parallaxX = C.px;
            this._parallaxY = C.py;
            this._color.setFromJSON(C.c);
            this._scaleRate = C.sr;
            e.shallowAssignArray(this._createdGlobalUids, C.cg);
            e.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
            const A = new Set(this._createdGlobalUids);
            let G = 0;
            for (let J = 0, M = this._initialInstances.length; J < M; ++J) A.has(this._initialInstances[J][2]) || (this._initialInstances[G] = this._initialInstances[J], ++G);
            e.truncateArray(this._initialInstances, G);
            this._effectList.LoadFromJson(C.fx);
            this._SortInstancesByLastCachedZIndex(!1);
            this.SetZIndicesChanged()
        }
        GetILayer() {
            return this._iLayer
        }
        SortAndAddInstancesByZIndex(C) {
            C.GetWorldInfo();
            if (!this._instances.includes(C))
                if (C.HasChildren()) {
                    var A = [...C.allChildren()];
                    A.push(C);
                    A.sort((J, M) => {
                        J = J.GetWorldInfo().GetSceneGraphZIndex();
                        M = M.GetWorldInfo().GetSceneGraphZIndex();
                        return J - M
                    });
                    for (var G of A)
                        if (G.IsInContainer())
                            for (const J of G.siblings()) A.includes(J) || (C = [...J.allChildren()], C.push(J), C.sort((M, R) => {
                                M = M.GetWorldInfo().GetSceneGraphZIndex();
                                R = R.GetWorldInfo().GetSceneGraphZIndex();
                                return M - R
                            }), C && C.length && A.splice(A.length, 0, ...C));
                    for (const J of A) this._AddInstance(J, !0)
                } else if (this._AddInstance(C, !0), C.IsInContainer())
                for (A of C.siblings())
                    if (G = [...A.allChildren()], G.push(A), G.sort((J, M) => {
                            J = J.GetWorldInfo().GetSceneGraphZIndex();
                            M = M.GetWorldInfo().GetSceneGraphZIndex();
                            return J - M
                        }), G && G.length)
                        for (const J of G) this._AddInstance(J, !0)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3Debugger,
        a = e.New(e.Rect),
        b = e.New(e.Rect),
        c = e.New(e.Rect),
        f = e.New(e.Color),
        h = self.glMatrix.vec3,
        g = [],
        k = [],
        m = [],
        r = [],
        w = [];

    function p(q, x, y, B) {
        return q[0] === Math.fround(x) && q[1] === Math.fround(y) && q[2] === Math.fround(B)
    }
    let t = null;

    function u(q, x) {
        t !== q && (q.PrepareForDraw(x), t = q)
    }
    e.Layout = class extends e.DefendedBase {
        constructor(q, x, y) {
            super();
            this._layoutManager = q;
            this._runtime = q.GetRuntime();
            this._name = y[0];
            this._originalWidth = y[1];
            this._originalHeight = y[2];
            this._width =
                y[1];
            this._height = y[2];
            this._isUnboundedScrolling = !!y[3];
            this._isOrthographicProjection = !!y[4];
            this._vanishingPointX = y[5];
            this._vanishingPointY = y[6];
            this._eventSheetName = y[7];
            this._eventSheet = null;
            this._sid = y[8];
            this._index = x;
            this._scrollY = this._scrollX = 0;
            this._scale = 1;
            this._angle = 0;
            this._initialObjectClasses = new Set;
            this._textureLoadedTypes = new Set;
            this._textureLoadPendingPromises = new Set;
            this._createdInstances = [];
            this._initialNonWorld = [];
            this._is3dCameraEnabled = !1;
            this._cam3dposition = h.create();
            this._cam3dlook = h.create();
            this._cam3dup = h.create();
            this._layers = [];
            this._layersByName = new Map;
            this._layersBySid = new Map;
            this._effectList = e.New(e.EffectList, this, y[11]);
            this._curRenderTarget = null;
            this._persistData = {};
            this._isFirstVisit = !0;
            this._iLayout = new self.ILayout(this);
            this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            for (const B of y[9]) q = e.Layer.Create(this, this._layers.length, B), this._layers.push(q), this._layersByName.set(q.GetName().toLowerCase(), q), this._layersBySid.set(q.GetSID(), q);
            for (const B of y[10]) {
                y = this._runtime.GetObjectClassByIndex(B[1]);
                if (!y) throw Error("missing nonworld object class");
                y.GetDefaultInstanceData() || y.SetDefaultInstanceData(B);
                this._initialNonWorld.push(B);
                this._AddInitialObjectClass(y)
            }
        }
        Release() {
            for (const q of this._layers) q.Release();
            e.clearArray(this._layers);
            this._textureLoadPendingPromises.clear();
            this._runtime = this._layoutManager = this._eventSheet = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetIndex() {
            return this._index
        }
        GetEffectList() {
            return this._effectList
        }
        GetMinLayerScale() {
            let q =
                this._layers[0].GetNormalScale();
            for (let x = 1, y = this._layers.length; x < y; ++x) {
                const B = this._layers[x];
                if (0 !== B.GetParallaxX() || 0 !== B.GetParallaxY()) q = Math.min(q, B.GetNormalScale())
            }
            return q
        }
        _GetScrollBoundMarginHorizontal() {
            return .5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale()
        }
        _GetScrollBoundMarginVertical() {
            return .5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale()
        }
        GetScrollLeftBound() {
            return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginHorizontal()
        }
        GetScrollRightBound() {
            return this.IsUnboundedScrolling() ?
                Infinity : this.GetWidth() - this._GetScrollBoundMarginHorizontal()
        }
        GetScrollTopBound() {
            return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginVertical()
        }
        GetScrollBottomBound() {
            return this.IsUnboundedScrolling() ? Infinity : this.GetHeight() - this._GetScrollBoundMarginVertical()
        }
        SetScrollX(q) {
            const x = this.GetScrollLeftBound(),
                y = this.GetScrollRightBound();
            q > y && (q = y);
            q < x && (q = x);
            this._scrollX !== q && (this._scrollX = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetScrollX() {
            return this._scrollX
        }
        SetScrollY(q) {
            const x =
                this.GetScrollTopBound(),
                y = this.GetScrollBottomBound();
            q > y && (q = y);
            q < x && (q = x);
            this._scrollY !== q && (this._scrollY = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetScrollY() {
            return this._scrollY
        }
        IsUnboundedScrolling() {
            return this._isUnboundedScrolling
        }
        BoundScrolling() {
            this.SetScrollX(this.GetScrollX());
            this.SetScrollY(this.GetScrollY());
            for (const q of this._layers) q.IsOwnScrollPositionEnabled() && (q.SetScrollX(q.GetScrollX()), q.SetScrollY(q.GetScrollY()))
        }
        SetVanishingPointXY(q, x) {
            if (this._vanishingPointX !==
                q || this._vanishingPointY !== x) this._vanishingPointX = q, this._vanishingPointY = x, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetVanishingPointX() {
            return this.IsOrthographicProjection() ? .5 : this._vanishingPointX
        }
        GetVanishingPointY() {
            return this.IsOrthographicProjection() ? .5 : this._vanishingPointY
        }
        HasVanishingPointOutsideViewport() {
            const q = this.GetVanishingPointX(),
                x = this.GetVanishingPointY();
            return 0 > q || 1 < q || 0 > x || 1 < x
        }
        SetPerspectiveProjection() {
            this._isOrthographicProjection &&
                (this._isOrthographicProjection = !1, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        SetOrthographicProjection() {
            this._isOrthographicProjection || (this._isOrthographicProjection = !0, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        IsOrthographicProjection() {
            return this._isOrthographicProjection
        }
        IsPerspectiveProjection() {
            return !this.IsOrthographicProjection()
        }
        Set3DCameraEnabled(q) {
            q = !!q;
            this._is3dCameraEnabled !==
                q && (this._is3dCameraEnabled = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        Is3DCameraEnabled() {
            return this._is3dCameraEnabled
        }
        Set3DCameraOrientation(q, x, y, B, F, H, K, C, A) {
            p(this._cam3dposition, q, x, y) && p(this._cam3dlook, B, F, H) && p(this._cam3dup, K, C, A) || (h.set(this._cam3dposition, q, x, y), h.set(this._cam3dlook, B, F, H), h.set(this._cam3dup, K, C, A), this.Set3DCameraChanged())
        }
        Set3DCameraChanged() {
            this._SetAllLayersMVChanged();
            this._runtime.UpdateRender()
        }
        Get3DCameraPosition() {
            return this._cam3dposition
        }
        Get3DCameraLookAt() {
            return this._cam3dlook
        }
        Get3DCameraUpVector() {
            return this._cam3dup
        }
        GetScale() {
            return this._scale
        }
        SetScale(q) {
            this._scale !==
                q && (this._scale = q, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender())
        }
        SetAngle(q) {
            q = e.clampAngle(q);
            this._angle !== q && (this._angle = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetAngle() {
            return this._angle
        }
        GetWidth() {
            return this._width
        }
        SetWidth(q) {
            !isFinite(q) || 1 > q || (this._width = q)
        }
        GetHeight() {
            return this._height
        }
        SetHeight(q) {
            !isFinite(q) || 1 > q || (this._height = q)
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetLayers() {
            return this._layers
        }
        GetLayerCount() {
            return this._layers.length
        }
        GetLayer(q) {
            return "number" ===
                typeof q ? this.GetLayerByIndex(q) : this.GetLayerByName(q.toString())
        }
        GetLayerByIndex(q) {
            q = e.clamp(Math.floor(q), 0, this._layers.length - 1);
            return this._layers[q]
        }
        GetLayerByName(q) {
            return this._layersByName.get(q.toLowerCase()) || null
        }
        GetLayerBySID(q) {
            return this._layersBySid.get(q) || null
        }
        _SetAllLayersProjectionChanged() {
            for (const q of this._layers) q._SetProjectionMatrixChanged()
        }
        _SetAllLayersMVChanged() {
            for (const q of this._layers) q._SetMVMatrixChanged()
        }
        SaveTransform() {
            return {
                scrollX: this.GetScrollX(),
                scrollY: this.GetScrollY(),
                scale: this.GetScale(),
                angle: this.GetAngle(),
                vpX: this.GetVanishingPointX(),
                vpY: this.GetVanishingPointY()
            }
        }
        RestoreTransform(q) {
            this.SetScrollX(q.scrollX);
            this.SetScrollY(q.scrollY);
            this.SetScale(q.scale);
            this.SetAngle(q.angle);
            this.SetVanishingPointXY(q.vpX, q.vpY)
        }
        HasOpaqueBottomLayer() {
            for (const q of this._layers)
                if (q.ShouldDraw()) return q._IsOpaque();
            return !1
        }
        GetLayoutBackgroundColor() {
            for (const q of this._layers)
                if (q.ShouldDraw() && q._IsOpaque()) return f.copyRgb(q.GetBackgroundColor()),
                    f.setA(1), f;
            f.setRgba(0, 0, 0, 0);
            return f
        }
        IsFirstVisit() {
            return this._isFirstVisit
        }
        _GetInitialObjectClasses() {
            return [...this._initialObjectClasses]
        }
        _AddInitialObjectClass(q) {
            if (q.IsInContainer())
                for (const x of q.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(x);
            else this._initialObjectClasses.add(q)
        }
        _GetTextureLoadedObjectTypes() {
            return [...this._textureLoadedTypes]
        }
        _Load(q, x) {
            if (q === this || !x) return Promise.resolve();
            q && (e.CopySet(this._textureLoadedTypes, q._textureLoadedTypes), q._textureLoadedTypes.clear());
            q = [];
            for (const y of this._initialObjectClasses) this._textureLoadedTypes.has(y) || (q.push(y.LoadTextures(x)), this._textureLoadedTypes.add(y));
            return Promise.all(q)
        }
        async MaybeLoadTexturesFor(q) {
            if (q.IsFamily()) throw Error("cannot load textures for family");
            var x = this._runtime.GetRenderer();
            !x || x.IsContextLost() || this._textureLoadedTypes.has(q) || (this._textureLoadedTypes.add(q), x = q.LoadTextures(x), this._AddPendingTextureLoadPromise(x), await x, q.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender())
        }
        _AddPendingTextureLoadPromise(q) {
            this._textureLoadPendingPromises.add(q);
            q.then(() => this._textureLoadPendingPromises.delete(q)).catch(() => this._textureLoadPendingPromises.delete(q))
        }
        WaitForPendingTextureLoadsToComplete() {
            return Promise.all([...this._textureLoadPendingPromises])
        }
        MaybeUnloadTexturesFor(q) {
            if (q.IsFamily() || 0 < q.GetInstanceCount()) throw Error("cannot unload textures");
            const x = this._runtime.GetRenderer();
            x && this._textureLoadedTypes.has(q) && (this._textureLoadedTypes.delete(q), q.ReleaseTextures(x))
        }
        _Unload(q, x) {
            if (q !== this && x)
                for (const y of this._textureLoadedTypes) y.IsGlobal() ||
                    q._initialObjectClasses.has(y) || (y.ReleaseTextures(), this._textureLoadedTypes.delete(y))
        }
        _OnWebGLContextLost() {
            this._textureLoadedTypes.clear()
        }
        async _StartRunning(q) {
            const x = this._runtime,
                y = this._layoutManager,
                B = x.GetEventSheetManager();
            this._eventSheetName && (this._eventSheet = B.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes());
            y._SetMainRunningLayout(this);
            this._width = this._originalWidth;
            this._height = this._originalHeight;
            this._scrollX = x.GetOriginalViewportWidth() /
                2;
            this._scrollY = x.GetOriginalViewportHeight() / 2;
            this.BoundScrolling();
            this._MoveGlobalObjectsToThisLayout(q);
            this._runtime.SetUsingCreatePromises(!0);
            this._CreateInitialInstances();
            this._isFirstVisit || this._CreatePersistedInstances();
            this._CreateAndLinkContainerInstances(this._createdInstances);
            this._CreateInitialNonWorldInstances();
            y.ClearPendingChangeLayout();
            x.FlushPendingInstances();
            this._runtime.SetUsingCreatePromises(!1);
            const F = this._runtime.GetCreatePromises();
            await Promise.all(F);
            e.clearArray(F);
            if (!x.IsLoadingState()) {
                for (const H of this._createdInstances) H.SetupInitialSceneGraphConnections();
                for (const H of this._createdInstances) H._TriggerOnCreated()
            }
            e.clearArray(this._createdInstances);
            await Promise.all([...this._initialObjectClasses].map(H => H.PreloadTexturesWithInstances(this._runtime.GetRenderer())));
            q && (x.Dispatcher().dispatchEvent(new e.Event("beforefirstlayoutstart")), await x.DispatchUserScriptEventAsyncWait(new e.Event("beforeprojectstart")));
            await this.DispatchUserScriptEventAsyncWait(new e.Event("beforelayoutstart"));
            x.IsLoadingState() || await x.TriggerAsync(e.Plugins.System.Cnds.OnLayoutStart, null, null);
            await this.DispatchUserScriptEventAsyncWait(new e.Event("afterlayoutstart"));
            q && (x.Dispatcher().dispatchEvent(new e.Event("afterfirstlayoutstart")), await x.DispatchUserScriptEventAsyncWait(new e.Event("afterprojectstart")));
            B._RunQueuedTriggers(y);
            await this.WaitForPendingTextureLoadsToComplete();
            this._SetAllLayersProjectionChanged();
            this._SetAllLayersMVChanged();
            this._isFirstVisit = !1
        }
        _MoveGlobalObjectsToThisLayout(q) {
            for (const y of this._runtime.GetAllObjectClasses())
                if (!y.IsFamily() &&
                    y.IsWorldType())
                    for (const B of y.GetInstances()) {
                        const F = B.GetWorldInfo();
                        var x = F.GetLayer();
                        x = e.clamp(x.GetIndex(), 0, this._layers.length - 1);
                        x = this._layers[x];
                        F._SetLayer(x);
                        x._MaybeAddInstance(B)
                    }
            if (!q)
                for (const y of this._layers) y._SortInstancesByLastCachedZIndex(!1)
        }
        _CreateInitialInstances() {
            for (const q of this._layers) q.CreateInitialInstances(this._createdInstances), q.UpdateViewport(), q._Start()
        }
        _CreatePersistedInstances() {
            let q = !1;
            for (const [y, B] of Object.entries(this._persistData)) {
                const F =
                    this._runtime.GetObjectClassBySID(parseInt(y, 10));
                if (F && !F.IsFamily() && F.HasPersistBehavior()) {
                    for (const H of B) {
                        var x = null;
                        if (F.IsWorldType() && (x = this.GetLayerBySID(H.w.l), !x)) continue;
                        x = this._runtime.CreateInstanceFromData(F, x, !1, 0, 0, !0);
                        x.LoadFromJson(H);
                        q = !0;
                        this._createdInstances.push(x)
                    }
                    e.clearArray(B)
                }
            }
            for (const y of this._layers) y._SortInstancesByLastCachedZIndex(!0), y.SetZIndicesChanged();
            q && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap())
        }
        _CreateAndLinkContainerInstances(q) {
            for (const y of q) {
                if (!y.IsInContainer()) continue;
                const B = y.GetWorldInfo(),
                    F = y.GetIID();
                for (const H of y.GetObjectClass().GetContainer().objectTypes())
                    if (H !== y.GetObjectClass()) {
                        var x = H.GetInstances();
                        x.length > F ? y._AddSibling(x[F]) : (x = B ? this._runtime.CreateInstanceFromData(H, B.GetLayer(), !0, B.GetX(), B.GetY(), !0) : this._runtime.CreateInstanceFromData(H, null, !0, 0, 0, !0), this._runtime.FlushPendingInstances(), H._UpdateIIDs(), y._AddSibling(x), q.push(x))
                    }
            }
        }
        _CreateInitialNonWorldInstances() {
            for (const q of this._initialNonWorld) this._runtime.GetObjectClassByIndex(q[1]).IsInContainer() ||
                this._runtime.CreateInstanceFromData(q, null, !0)
        }
        _CreateGlobalNonWorlds() {
            const q = [],
                x = this._initialNonWorld;
            let y = 0;
            for (let B = 0, F = x.length; B < F; ++B) {
                const H = x[B],
                    K = this._runtime.GetObjectClassByIndex(H[1]);
                K.IsGlobal() ? K.IsInContainer() && K.GetContainer().HasAnyWorldType() || q.push(this._runtime.CreateInstanceFromData(H, null, !0)) : (x[y] = H, ++y)
            }
            e.truncateArray(x, y);
            this._runtime.FlushPendingInstances();
            this._CreateAndLinkContainerInstances(q)
        }
        RecreateInitialObjects(q, x, y, B, F, H) {
            if (y) return y.RecreateInitialObjects(q,
                x, B, F, H);
            y = [];
            for (const K of this._layers) y.push(K.RecreateInitialObjects(q, x, B, F, H));
            return y.flat()
        }
        async _StopRunning() {
            const q = this._layoutManager;
            this._runtime.IsLoadingState() || await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnLayoutEnd, null, null);
            q.SetIsEndingLayout(!0);
            this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
            this._isFirstVisit || this._SavePersistData();
            for (const x of this._layers) x._End();
            for (const x of this._runtime.GetAllObjectClasses())
                if (!(x.IsGlobal() || x.IsWorldType() ||
                        x.GetPlugin().IsSingleGlobal() || x.IsFamily())) {
                    for (const y of x.GetInstances()) this._runtime.DestroyInstance(y);
                    this._runtime.FlushPendingInstances()
                }
            q.SetIsEndingLayout(!1);
            q.GetMainRunningLayout() === this && q._SetMainRunningLayout(null)
        }
        _SaveInstanceToPersist(q) {
            const x = q.GetObjectClass().GetSID().toString();
            this._persistData.hasOwnProperty(x) || (this._persistData[x] = []);
            this._persistData[x].push(q.SaveToJson())
        }
        _SavePersistData() {
            for (const q of this._layers) {
                q._UpdateZIndices();
                for (const x of q._GetInstances()) {
                    const y =
                        x.GetObjectClass();
                    !y.IsGlobal() && y.HasPersistBehavior() && this._SaveInstanceToPersist(x)
                }
            }
        }
        ResetPersistData() {
            this._persistData = {};
            this._isFirstVisit = !0
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        UsesOwnTexture() {
            return "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() || this._runtime.UsesAnyBackgroundBlending() || "low-latency" === this._runtime.GetCompositingMode() || this._effectList.HasAnyActiveEffect() || this._runtime.GetRenderer().IsWebGL() && this._runtime.Uses3DFeatures()
        }
        _CanFastPathDrawLayout(q) {
            return 0 ===
                q.length ? !0 : 2 <= q.length ? !1 : !q[0].GetShaderProgram().MustPreDraw()
        }
        Draw(q) {
            var x = this._runtime.GetCanvasManager();
            const y = this.UsesOwnTexture();
            var B = null;
            y ? ("low-latency" !== this._runtime.GetCompositingMode() && (q.SetRenderTarget(null), q.ClearRgba(0, 0, 0, 0)), B = {
                    sampling: this._runtime.GetSampling(),
                    isSampled: q.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect()
                }, "low" === x.GetCurrentFullscreenScalingQuality() && (B.width = x.GetDrawWidth(), B.height = x.GetDrawHeight()),
                B = this._runtime.GetAdditionalRenderTarget(B), q.SetRenderTarget(B)) : q.SetRenderTarget(null);
            q.Clear(this.GetLayoutBackgroundColor());
            this._runtime.Uses3DFeatures() && q.ClearDepth();
            this._curRenderTarget = B;
            for (var F of this._layers) F.UpdateViewport(), F.ShouldDraw() && g.push(F);
            for (let H = 0, K = g.length; H < K;) {
                x = g[H];
                if (x.Has3DCamera() && !x.UsesOwnTexture()) {
                    k.push(x);
                    for (F = H + 1; F < K; ++F) {
                        const C = g[F];
                        if (C.Has3DCamera() && !C.UsesOwnTexture()) k.push(g[F]);
                        else break
                    }
                    if (2 <= k.length) {
                        this._Draw3DLayers(q, B, k);
                        H +=
                            k.length;
                        e.clearArray(k);
                        continue
                    }
                    e.clearArray(k)
                }
                x.Draw(q, B, 0 === H);
                ++H
            }
            e.clearArray(g);
            y && (q.SetDepthEnabled(!1), this._DrawLayoutOwnTextureToRenderTarget(q, B));
            this._curRenderTarget = null
        }
        _DrawLayoutOwnTextureToRenderTarget(q, x) {
            const y = this._effectList.GetActiveEffectTypes(),
                B = this._runtime;
            if (this._CanFastPathDrawLayout(y)) {
                q.SetRenderTarget(null);
                if (1 === y.length) {
                    var F = y[0];
                    const H = F.GetShaderProgram();
                    q.SetProgram(H);
                    b.set(0, 0, 1, 1);
                    c.set(0, 0, B.GetViewportWidth(), B.GetViewportHeight());
                    F = this._effectList.GetEffectParametersForIndex(F.GetIndex());
                    q.SetProgramParameters(null, a, b, b, c, 1 / B.GetDrawWidth(), 1 / B.GetDrawHeight(), this.GetScale(), this.GetAngle(), B.GetGameTime(), F);
                    H.IsAnimated() && B.UpdateRender()
                } else q.SetTextureFillMode();
                0 === y.length ? q.CopyRenderTarget(x) : (q.SetAlphaBlend(), q.ResetColor(), q.DrawRenderTarget(x));
                q.InvalidateRenderTarget(x);
                B.ReleaseAdditionalRenderTarget(x)
            } else e.RenderEffectChain(q, B, this, null, y)
        }
        _Draw3DLayers(q, x, y) {
            var B = this._runtime.GetCanvasManager();
            q.SetDepthEnabled(!0);
            for (var F of y) F._UpdateZIndices(),
                e.appendArray(m, F._GetInstancesInDrawOrder());
            y = y[0];
            F = null;
            if (this._runtime.IsGPUProfiling())
                if (q.IsWebGL()) {
                    if (B = B.GetLayerTimingsBuffer(y)) F = B.AddTimeElapsedQuery(), q.StartQuery(F)
                } else q.IsWebGPU() && q.WriteTimestamp(2 * (y.GetIndex() + 1));
            for (let G = 0, J = m.length; G < J;) {
                var H = m[G],
                    K = H.GetWorldInfo(),
                    C = K.GetLayer();
                if (K.IsVisible() && K.IsInViewport3D(C._GetViewFrustum())) {
                    (!H.RendersToOwnZPlane() || 0 < K.GetDepth()) && w.push(H);
                    var A = H.GetWorldInfo().GetTotalZElevation();
                    r.push(H);
                    for (B = G + 1; B < J; ++B) {
                        const M =
                            m[B],
                            R = M.GetWorldInfo();
                        if (R.IsVisible() && R.IsInViewport3D(R.GetLayer()._GetViewFrustum())) {
                            if (R.GetTotalZElevation() !== A) break;
                            M.RendersToOwnZPlane() ? (0 < R.GetDepth() && w.push(M), r.push(M)) : w.push(M)
                        }
                    }
                    if (1 !== r.length || r[0].MustMitigateZFighting()) {
                        this._Draw3DLayersCoplanarInstances(q, x, r);
                        for (let M = 0, R = w.length; M < R; ++M) H = w[M], K = H.GetWorldInfo(), C = K.GetLayer(), K._SetDrawNonBackFacesOnly(!0), u(C, q), C._DrawInstanceMaybeWithEffects(H, K, q, x), K._SetDrawNonBackFacesOnly(!1)
                    } else {
                        u(C, q);
                        C._DrawInstanceMaybeWithEffects(H,
                            K, q, x);
                        for (let M = 0, R = w.length; M < R; ++M) K = w[M], K !== H && (C = K.GetWorldInfo(), A = C.GetLayer(), u(A, q), A._DrawInstanceMaybeWithEffects(K, C, q, x))
                    }
                    G = B;
                    e.clearArray(r);
                    e.clearArray(w)
                } else ++G
            }
            F && q.EndQuery(F);
            this._runtime.IsGPUProfiling() && q.IsWebGPU() && q.WriteTimestamp(2 * (y.GetIndex() + 1) + 1);
            e.clearArray(m);
            t = null
        }
        _Draw3DLayersCoplanarInstances(q, x, y) {
            q.CoplanarStartStencilPass();
            for (let K = 0, C = y.length; K < C; ++K) {
                var B = y[K],
                    F = B.GetWorldInfo(),
                    H = F.GetLayer();
                F._SetDrawBackFaceOnly(!0);
                u(H, q);
                H._DrawInstance(B,
                    F, q)
            }
            q.CoplanarStartColorPass();
            for (let K = 0, C = y.length; K < C; ++K) B = y[K], F = B.GetWorldInfo(), H = F.GetLayer(), u(H, q), H._DrawInstanceMaybeWithEffects(B, F, q, x), F._SetDrawBackFaceOnly(!1);
            q.CoplanarRestoreStandardRendering()
        }
        _SaveToJson() {
            const q = {
                sx: this.GetScrollX(),
                sy: this.GetScrollY(),
                s: this.GetScale(),
                a: this.GetAngle(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                ortho: this.IsOrthographicProjection(),
                vpX: this.GetVanishingPointX(),
                vpY: this.GetVanishingPointY(),
                fv: this._isFirstVisit,
                persist: this._persistData,
                fx: this._effectList.SaveToJson(),
                layers: {}
            };
            for (const x of this._layers) q.layers[x.GetSID().toString()] = x._SaveToJson();
            return q
        }
        _LoadFromJson(q) {
            this._scrollX = q.sx;
            this._scrollY = q.sy;
            this._scale = q.s;
            this._angle = q.a;
            this._width = q.w;
            this._height = q.h;
            this._isOrthographicProjection = !!q.ortho;
            q.hasOwnProperty("vpX") && (this._vanishingPointX = q.vpX);
            q.hasOwnProperty("vpY") && (this._vanishingPointY = q.vpY);
            this._isFirstVisit = !!q.fv;
            this._persistData = q.persist;
            this._effectList.LoadFromJson(q.fx);
            for (const [x, y] of Object.entries(q.layers)) q =
                parseInt(x, 10), (q = this.GetLayerBySID(q)) && q._LoadFromJson(y);
            this._SetAllLayersProjectionChanged();
            this._SetAllLayersMVChanged()
        }
        GetILayout() {
            return this._iLayout
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(q) {
            q.layout = this.GetILayout();
            var x = this._runtime;
            (x = x.IsDebug() && !x.GetEventSheetManager().IsInEventEngine()) && d.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(q);
            x && d.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(q) {
            q.layout = this.GetILayout();
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(q)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.LayoutManager = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._runtime = d;
            this._allLayouts = [];
            this._layoutsByName = new Map;
            this._layoutsBySid = new Map;
            this._mainRunningLayout = null;
            this._runningSubLayouts = [];
            this._firstLayout = null;
            this._isEndingLayout = 0;
            this._pendingChangeLayout = null
        }
        Release() {
            this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null;
            e.clearArray(this._allLayouts);
            this._layoutsByName.clear();
            this._layoutsBySid.clear();
            e.clearArray(this._runningSubLayouts)
        }
        Create(d) {
            d = e.New(e.Layout, this, this._allLayouts.length, d);
            this._allLayouts.push(d);
            this._layoutsByName.set(d.GetName().toLowerCase(), d);
            this._layoutsBySid.set(d.GetSID(), d)
        }
        GetRuntime() {
            return this._runtime
        }
        SetFirstLayout(d) {
            this._firstLayout = d
        }
        GetFirstLayout() {
            if (this._firstLayout) return this._firstLayout;
            if (this._allLayouts.length) return this._allLayouts[0];
            throw Error("no first layout");
        }
        GetLayoutByName(d) {
            return this._layoutsByName.get(d.toLowerCase()) ||
                null
        }
        GetLayoutBySID(d) {
            return this._layoutsBySid.get(d) || null
        }
        GetLayoutByIndex(d) {
            d = e.clamp(Math.floor(d), 0, this._allLayouts.length - 1);
            return this._allLayouts[d]
        }
        GetLayout(d) {
            return "number" === typeof d ? this.GetLayoutByIndex(d) : this.GetLayoutByName(d.toString())
        }
        GetAllLayouts() {
            return this._allLayouts
        }
        _SetMainRunningLayout(d) {
            this._mainRunningLayout = d
        }
        GetMainRunningLayout() {
            return this._mainRunningLayout
        }
        _AddRunningSubLayout(d) {
            if (this._runningSubLayouts.includes(d)) throw Error("layout already running");
            this._runningSubLayouts.push(d)
        }
        _RemoveRunningSubLayout(d) {
            d = this._runningSubLayouts.indexOf(d);
            if (-1 === d) throw Error("layout not running");
            this._runningSubLayouts.splice(d, 1)
        }* runningLayouts() {
            this._mainRunningLayout && (yield this._mainRunningLayout);
            this._runningSubLayouts.length && (yield* this._runningSubLayouts)
        }
        IsLayoutRunning(d) {
            return this._mainRunningLayout === d || this._runningSubLayouts.includes(d)
        }
        SetIsEndingLayout(d) {
            if (d) this._isEndingLayout++;
            else {
                if (0 >= this._isEndingLayout) throw Error("already unset");
                this._isEndingLayout--
            }
        }
        IsEndingLayout() {
            return 0 < this._isEndingLayout
        }
        ChangeMainLayout(d) {
            this._pendingChangeLayout = d
        }
        ClearPendingChangeLayout() {
            this._pendingChangeLayout = null
        }
        IsPendingChangeMainLayout() {
            return !!this._pendingChangeLayout
        }
        GetPendingChangeMainLayout() {
            return this._pendingChangeLayout
        }
        SetAllLayerProjectionChanged() {
            const d = this.GetMainRunningLayout();
            d && d._SetAllLayersProjectionChanged()
        }
        SetAllLayerMVChanged() {
            const d = this.GetMainRunningLayout();
            d && d._SetAllLayersMVChanged()
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor() {
            this.runtime = this.renderer = null;
            this.surfaceHeight = this.surfaceWidth = this.drawHeight = this.drawWidth = 0;
            this.layoutRect = new e.Rect;
            this.rcTexBounce = new e.Rect;
            this.rcTexDest = new e.Rect;
            this.rcTexOrigin = new e.Rect;
            this.screenRect = new e.Rect;
            this.clearRect = new e.Rect;
            this.srcRect = new e.Rect;
            this.fxTex = [null, null];
            this.fxIndex = 0;
            this.otherFxIndex = 1;
            this.layerAngle = this.layerScale = this.boxExtendVertical = this.boxExtendHorizontal = 0;
            this.renderTarget = this.wi =
                this.inst = this.layer = this.layout = null;
            this.didChangeTransform = this.postDraw = this.preDraw = !1;
            this.opts = null
        }
        Clear() {
            this.opts = this.renderTarget = this.wi = this.inst = this.layer = this.layout = this.runtime = this.renderer = null
        }
        ShouldPreDraw(u) {
            u = u.GetShaderProgram();
            if (u.MustPreDraw()) return !0;
            if (this.inst) return u.UsesDest() && (0 !== this.wi.GetAngle() || 0 > this.wi.GetWidth() || 0 > this.wi.GetHeight()) || 0 !== this.boxExtendHorizontal || 0 !== this.boxExtendVertical || !this.wi.HasDefaultColor() || this.inst.MustPreDraw();
            if (this.layer) return !this.layer.HasDefaultColor()
        }
        ShouldPostDraw(u) {
            u =
                u.GetShaderProgram();
            return u.UsesDest() || u.UsesCrossSampling() || this.layout && "low" === this.runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality()
        }
        GetEffectRenderTarget(u) {
            if (0 !== u && 1 !== u) throw Error("invalid effect target");
            const q = this.fxTex;
            if (!q[u]) {
                var x = this.runtime;
                const y = x.GetCanvasManager();
                x = {
                    sampling: x.GetSampling()
                };
                "low" === y.GetCurrentFullscreenScalingQuality() && (x.width = y.GetDrawWidth(), x.height = y.GetDrawHeight());
                q[u] = y.GetAdditionalRenderTarget(x)
            }
            return q[u]
        }
        ReleaseEffectRenderTargets() {
            const u =
                this.fxTex,
                q = this.runtime.GetCanvasManager();
            u[0] && (q.ReleaseAdditionalRenderTarget(u[0]), u[0] = null);
            u[1] && (q.ReleaseAdditionalRenderTarget(u[1]), u[1] = null)
        }
    }
    const a = [];
    let b = 0;

    function c() {
        b === a.length && a.push(new d);
        return a[b++]
    }

    function f(u) {
        u.ReleaseEffectRenderTargets();
        u.Clear();
        b--
    }
    const h = new e.Quad;
    let g = !1;
    async function k(u, q, x) {
        q = await e.Gfx.WebGLRenderTarget.DebugReadPixelsToBlob(q, x);
        q = URL.createObjectURL(q);
        console.log("[FX] " + u + " " + (x ? "" : " [to display]") + ": ", q)
    }
    e.RenderEffectChain =
        function(u, q, x, y, B, F) {
            const H = c();
            H.renderer = u;
            H.runtime = q;
            if (x instanceof e.Instance) H.inst = x, H.wi = H.inst.GetWorldInfo();
            else if (x instanceof e.Layer) H.layer = x;
            else if (x instanceof e.Layout) H.layout = x;
            else throw Error("invalid effects object");
            x = q.GetCanvasManager();
            H.renderTarget = y;
            H.drawWidth = x.GetDrawWidth();
            H.drawHeight = x.GetDrawHeight();
            H.surfaceWidth = H.drawWidth;
            H.surfaceHeight = H.drawHeight;
            H.fxIndex = 0;
            H.otherFxIndex = 1;
            H.boxExtendHorizontal = 0;
            H.boxExtendVertical = 0;
            H.screenRect.set(0, 0, H.drawWidth,
                H.drawHeight);
            H.clearRect.set(0, 0, H.drawWidth, H.drawHeight);
            H.didChangeTransform = !1;
            H.opts = F;
            H.inst ? (y = H.wi, H.layerScale = y.GetLayer().GetRenderScale(), H.layerAngle = y.GetLayer().GetAngle(), H.layoutRect.copy(y.GetBoundingBox())) : H.layer ? (y = H.layer, H.layerScale = y.GetRenderScale(), H.layerAngle = y.GetAngle(), H.layoutRect.copy(y.GetViewport())) : (y = H.layout, H.layerScale = y.GetScale(), H.layerAngle = y.GetAngle(), H.layoutRect.set(0, 0, H.drawWidth, H.drawHeight));
            H.inst ? m(H, B) : (H.rcTexBounce.set(0, 0, H.drawWidth /
                H.surfaceWidth, H.drawHeight / H.surfaceHeight), H.rcTexDest.copy(H.rcTexBounce), H.rcTexOrigin.copy(H.rcTexBounce), H.rcTexBounce.swapTopBottom(), H.rcTexDest.swapTopBottom(), H.rcTexOrigin.swapTopBottom());
            u.SetAlphaBlend();
            u.ResetColor();
            u.SetBaseZ(0);
            u.SetCurrentZ(0);
            H.preDraw = H.ShouldPreDraw(B[0]);
            H.preDraw && r(H);
            u.ResetColor();
            y = B.length - 1;
            H.postDraw = H.ShouldPostDraw(B[y]);
            for (let K = 0, C = B.length; K < C; ++K) F = B[K], x = F.GetShaderProgram(), u.SetProgram(x), x.IsAnimated() && q.UpdateRender(), 0 !== K || H.preDraw ?
                (u.SetCopyBlend(), p(H, F, K === y && !H.postDraw, K)) : w(H, F), 0 === H.fxIndex ? (H.fxIndex = 1, H.otherFxIndex = 0) : (H.fxIndex = 0, H.otherFxIndex = 1);
            H.postDraw && t(H, B);
            u = H.didChangeTransform;
            f(H);
            g = !1;
            return u
        };

    function m(u, q) {
        for (let G = 0, J = q.length; G < J; ++G) {
            var x = q[G].GetShaderProgram();
            u.boxExtendHorizontal += x.GetBoxExtendHorizontal();
            u.boxExtendVertical += x.GetBoxExtendVertical()
        }
        var y = u.wi;
        q = y.GetLayer();
        var B = q.GetAngle();
        x = y.GetBoundingBox();
        var F = y.GetTotalZElevation();
        y = y.GetDepth();
        let [H, K] = q.LayerToDrawSurface(x.getLeft(),
            x.getTop(), F), [C, A] = q.LayerToDrawSurface(x.getRight(), x.getBottom(), F);
        if (0 !== B || 0 < y) {
            const [G, J] = q.LayerToDrawSurface(x.getRight(), x.getTop(), F), [M, R] = q.LayerToDrawSurface(x.getLeft(), x.getBottom(), F);
            if (0 < y) {
                B = F + y;
                const [U, V] = q.LayerToDrawSurface(x.getLeft(), x.getTop(), B), [ba, ia] = q.LayerToDrawSurface(x.getRight(), x.getTop(), B), [ja, qa] = q.LayerToDrawSurface(x.getRight(), x.getBottom(), B), [za, Ca] = q.LayerToDrawSurface(x.getLeft(), x.getBottom(), B);
                q = Math.min(H, C, G, M, U, ba, ja, za);
                C = Math.max(H, C, G, M, U, ba,
                    ja, za);
                H = q;
                q = Math.min(K, A, J, R, V, ia, qa, Ca);
                A = Math.max(K, A, J, R, V, ia, qa, Ca);
                K = q
            } else q = Math.min(H, C, G, M), C = Math.max(H, C, G, M), H = q, q = Math.min(K, A, J, R), A = Math.max(K, A, J, R), K = q
        }
        q = u.screenRect;
        x = u.rcTexOrigin;
        B = u.rcTexDest;
        F = u.clearRect;
        y = u.rcTexBounce;
        q.set(H, K, C, A);
        q.shuntY(u.drawHeight);
        x.copy(q);
        x.divide(u.surfaceWidth, u.surfaceHeight);
        x.swapTopBottom();
        q.inflate(u.boxExtendHorizontal, u.boxExtendVertical);
        B.copy(q);
        B.divide(u.surfaceWidth, u.surfaceHeight);
        B.swapTopBottom();
        F.copy(q);
        F.roundOuter();
        F.inflate(u.boxExtendHorizontal +
            1, u.boxExtendVertical + 1);
        q.clamp(0, 0, u.drawWidth, u.drawHeight);
        F.clamp(0, 0, u.drawWidth, u.drawHeight);
        y.copy(q);
        y.divide(u.surfaceWidth, u.surfaceHeight);
        y.swapTopBottom()
    }

    function r(u) {
        const q = u.renderer;
        q.SetTextureFillMode();
        const x = u.GetEffectRenderTarget(u.fxIndex);
        q.SetRenderTarget(x);
        var y = u.opts;
        y && y.preTransform && y.preTransform();
        q.ClearRect2(u.clearRect);
        u.inst ? (q.SetColor(u.wi.GetPremultipliedColor()), q.SetCurrentZ(u.wi.GetTotalZElevation()), u.inst.Draw(q), q.SetCurrentZ(0)) : (y = (u.layer ||
            u.layout).GetRenderTarget(), u.layer ? q.SetColor(u.layer.GetPremultipliedColor()) : q.ResetColor(), q.DrawRenderTarget(y), q.InvalidateRenderTarget(y), u.runtime.GetCanvasManager().ReleaseAdditionalRenderTarget(y));
        u.rcTexDest.clampFlipped(0, 1, 1, 0);
        u.fxIndex = 1;
        u.otherFxIndex = 0;
        g && k("Pre-draw", q, x)
    }

    function w(u, q) {
        const x = u.renderer,
            y = u.runtime,
            B = u.GetEffectRenderTarget(u.fxIndex);
        x.SetRenderTarget(B);
        var F = u.opts;
        F && F.preTransform && F.preTransform();
        x.ClearRect2(u.clearRect);
        if (u.inst) {
            const [H, K] = u.inst.GetCurrentSurfaceSize();
            (F = u.inst.GetCurrentTexRect()) ? u.srcRect.copy(F): u.srcRect.set(0, 0, 0, 0);
            q = u.wi.GetInstanceEffectList().GetEffectParametersForIndex(q.GetIndex());
            x.SetProgramParameters(u.renderTarget, u.rcTexDest, u.srcRect, u.srcRect, u.layoutRect, 1 / H, 1 / K, u.layerScale, u.layerAngle, y.GetGameTime(), q);
            x.SetCurrentZ(u.wi.GetTotalZElevation());
            u.inst.Draw(x);
            x.SetCurrentZ(0);
            u.rcTexDest.clampFlipped(0, 1, 1, 0);
            u.screenRect.shuntY(u.drawHeight)
        } else q = (u.layer || u.layout).GetEffectList().GetEffectParametersForIndex(q.GetIndex()),
            x.SetProgramParameters(u.renderTarget, u.rcTexDest, u.rcTexBounce, u.rcTexOrigin, u.layoutRect, 1 / u.drawWidth, 1 / u.drawHeight, u.layerScale, u.layerAngle, y.GetGameTime(), q), u = (u.layer || u.layout).GetRenderTarget(), g && k("Layer target", x, u), x.DrawRenderTarget(u), x.InvalidateRenderTarget(u), y.GetCanvasManager().ReleaseAdditionalRenderTarget(u);
        g && k("First bounce", x, B)
    }

    function p(u, q, x, y) {
        const B = u.renderer,
            F = u.runtime;
        0 === y && u.preDraw && u.inst && u.screenRect.shuntY(u.drawHeight);
        x ? (u.inst ? B.SetBlendMode(u.wi.GetBlendMode()) :
            u.layer && B.SetBlendMode(u.layer.GetBlendMode()), x = u.renderTarget, B.SetRenderTarget(x)) : (x = u.GetEffectRenderTarget(u.fxIndex), B.SetRenderTarget(x), B.ClearRect2(u.clearRect));
        q = u.inst ? u.wi.GetInstanceEffectList().GetEffectParametersForIndex(q.GetIndex()) : (u.layer || u.layout).GetEffectList().GetEffectParametersForIndex(q.GetIndex());
        B.SetProgramParameters(u.renderTarget, u.rcTexDest, u.rcTexBounce, u.rcTexOrigin, u.layoutRect, 1 / u.surfaceWidth, 1 / u.surfaceHeight, u.layerScale, u.layerAngle, F.GetGameTime(), q);
        q = u.GetEffectRenderTarget(u.otherFxIndex);
        B.SetTexture(q.GetTexture());
        F.GetCanvasManager().SetDeviceTransform(B);
        u.didChangeTransform = !0;
        h.setFromRect(u.screenRect);
        B.Quad3(h, u.rcTexBounce);
        u.inst || B.InvalidateRenderTarget(q);
        g && k("Bounce " + y, B, x)
    }

    function t(u, q) {
        q = u.renderer;
        if (u.layout) q.SetTextureFillMode(), q.SetRenderTarget(u.renderTarget), u = u.GetEffectRenderTarget(u.otherFxIndex), q.CopyRenderTarget(u), q.InvalidateRenderTarget(u);
        else {
            var x = u.runtime.GetCanvasManager();
            "low" === x.GetCurrentFullscreenScalingQuality() ?
                (q.SetTextureFillMode(), x.SetDeviceTransform(q, x.GetDrawWidth(), x.GetDrawHeight()), u.didChangeTransform = !0) : q.SetDeviceTransformTextureFillMode();
            u.inst ? q.SetBlendMode(u.wi.GetBlendMode()) : u.layer && q.SetBlendMode(u.layer.GetBlendMode());
            q.SetRenderTarget(u.renderTarget);
            x = u.GetEffectRenderTarget(u.otherFxIndex);
            q.SetTexture(x.GetTexture());
            h.setFromRect(u.screenRect);
            q.Quad3(h, u.rcTexBounce);
            u.inst || q.InvalidateRenderTarget(x);
            g && k("Post-draw", q, u.renderTarget)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = /<(.+?)>/g;
    e.TimelineManager = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a;
            this._timelineDataManager = e.New(e.TimelineDataManager);
            this._pluginInstance = null;
            this._timelines = [];
            this._timelinesByName = new Map;
            this._objectClassToTimelineMap = new Map;
            this._timelinesCreatedByTemplate = new Map;
            this._scheduledTimelines = [];
            this._playingTimelines = [];
            this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners = !1;
            this._tickFunc = () => this._OnTick();
            this._tick2Func = () => this._OnTick2();
            this._beforeLayoutChange = () => this._OnBeforeChangeLayout();
            this._layoutChange = () => this._OnAfterChangeLayout();
            this._instanceDestroy = b => this._OnInstanceDestroy(b.instance);
            this._afterLoad = b => this._OnAfterLoad();
            this._destroyedWhileLoadingState = []
        }
        Release() {
            this.RemoveRuntimeListeners();
            this._afterLoad = this._instanceDestroy = this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null;
            for (const a of this._timelines) a.Stop(), a.Release();
            e.clearArray(this._timelines);
            this._timelines = null;
            this._timelineDataManager.Release();
            this._timelineDataManager = null;
            e.clearArray(this._scheduledTimelines);
            this._scheduledTimelines = null;
            e.clearArray(this._playingTimelines);
            this._playingTimelines = null;
            this._timelinesByName.clear();
            this._timelinesByName = null;
            this._objectClassToTimelineMap.clear();
            this._objectClassToTimelineMap = null;
            this._timelinesCreatedByTemplate.clear();
            this._timelinesCreatedByTemplate = null;
            e.clearArray(this._destroyedWhileLoadingState);
            this._runtime = this._destroyedWhileLoadingState =
                null
        }
        AddRuntimeListeners() {
            const a = this._runtime.Dispatcher();
            a.addEventListener("pretick", this._tickFunc);
            a.addEventListener("tick2", this._tick2Func);
            a.addEventListener("beforelayoutchange", this._beforeLayoutChange);
            a.addEventListener("layoutchange", this._layoutChange);
            a.addEventListener("instancedestroy", this._instanceDestroy);
            a.addEventListener("afterload", this._afterLoad)
        }
        RemoveRuntimeListeners() {
            const a = this._runtime.Dispatcher();
            a.removeEventListener("pretick", this._tickFunc);
            a.removeEventListener("tick2",
                this._tick2Func);
            a.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
            a.removeEventListener("layoutchange", this._layoutChange);
            a.removeEventListener("instancedestroy", this._instanceDestroy);
            a.removeEventListener("afterload", this._afterLoad)
        }
        Create(a) {
            this._timelineDataManager.Add(a);
            a = e.TimelineState.CreateInitial(a, this);
            this.Add(a);
            this.SetTimelineObjectClassesToMap(a);
            this._timelinesCreatedByTemplate.set(a.GetName(), 0)
        }
        CreateFromTemplate(a) {
            var b = this.GetTimelineDataManager();
            a =
                a.GetTemplateName();
            b = b.Get(a);
            b = e.TimelineState.CreateFromTemplate(`${a}:${this._timelinesCreatedByTemplate.get(a)}`, b, this);
            this._IncreaseTemplateTimelinesCount(a);
            this.Add(b);
            return b
        }
        _IncreaseTemplateTimelinesCount(a) {
            this._timelinesCreatedByTemplate.set(a, this._timelinesCreatedByTemplate.get(a) + 1)
        }
        _SetCreatedTemplateTimelinesCount() {
            for (const a of this._timelines) {
                if (a.IsTemplate()) continue;
                const b = a.GetTemplateName();
                this._IncreaseTemplateTimelinesCount(b)
            }
        }
        _ClearCreatedTemplateTimelinesCount() {
            for (const a of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(a,
                0)
        }
        Add(a) {
            this._timelines.push(a);
            this._timelinesByName.set(a.GetName().toLowerCase(), a)
        }
        Remove(a) {
            a.IsTemplate() || (e.arrayFindRemove(this._timelines, a), e.arrayFindRemove(this._scheduledTimelines, a), e.arrayFindRemove(this._playingTimelines, a), this._timelinesByName.delete(a.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(a), a.IsReleased() || a.Release())
        }
        Trigger(a) {
            this._runtime.Trigger(a, this._pluginInstance, null)
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimelineDataManager() {
            return this._timelineDataManager
        }
        SetPluginInstance(a) {
            this._pluginInstance =
                a
        }
        GetPluginInstance() {
            return this._pluginInstance
        }* GetTimelines() {
            for (const a of this._timelines) yield a
        }
        SetTimelineObjectClassToMap(a, b) {
            this._objectClassToTimelineMap.has(a) || this._objectClassToTimelineMap.set(a, new Set);
            this._objectClassToTimelineMap.get(a).add(b)
        }
        SetTimelineObjectClassesToMap(a) {
            for (const b of a.GetObjectClasses()) this.SetTimelineObjectClassToMap(b, a)
        }
        RemoveTimelineFromObjectClassMap(a) {
            for (const [b, c] of this._objectClassToTimelineMap.entries()) c.has(a) && (c.delete(a), 0 === c.size &&
                this._objectClassToTimelineMap.delete(b))
        }
        GetTimelinesForObjectClass(a) {
            if (this._objectClassToTimelineMap.has(a)) return this._objectClassToTimelineMap.get(a)
        }
        GetTimelineOfTemplateForInstances(a, b) {
            if (b)
                for (const c of this._timelines)
                    if (b.every(f => c.HasTrackInstance(f.instance, f.trackId)) && c.GetName().includes(a.GetName())) return c
        }
        GetTimelineByName(a) {
            return this._timelinesByName.get(a.toLowerCase()) || null
        }
        GetScheduledOrPlayingTimelineByName(a) {
            for (const b of this._scheduledTimelines)
                if (b.GetName() ===
                    a) return b;
            for (const b of this._playingTimelines)
                if (b.GetName() === a) return b;
            return null
        }* GetTimelinesByName(a) {
            if (d.test(a)) {
                d.lastIndex = 0;
                let c;
                var b = new Set;
                do
                    if (c = d.exec(a)) {
                        const f = c[1].split(",");
                        for (const h of f) b.add(h)
                    }
                while (c);
                for (const f of b.values())(a = this.GetTimelineByName(f)) && (yield a);
                b.clear()
            } else(b = this.GetTimelineByName(a)) && (yield b)
        }* GetTimelinesByTags(a) {
            for (const b of this._timelines) b.HasTags(a) && (yield b)
        }
        AddScheduledTimeline(a) {
            this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a);
            this._MaybeEnableRuntimeListeners()
        }
        RemovePlayingTimeline(a) {
            e.arrayFindRemove(this._playingTimelines, a);
            this._MaybeDisableRuntimeListeners()
        }
        ScheduleTimeline(a) {
            this._playingTimelines.includes(a) ? (a.SetPlaying(!0), a.SetScheduled(!1), a.SetMarkedForRemoval(!1)) : (a.SetPlaying(!1), a.SetScheduled(!0), a.SetMarkedForRemoval(!1), this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a));
            this._MaybeEnableRuntimeListeners()
        }
        DeScheduleTimeline(a) {
            a.SetPlaying(!1);
            a.SetScheduled(!1);
            a.ResolvePlayPromise();
            e.arrayFindRemove(this._scheduledTimelines, a);
            this._MaybeDisableRuntimeListeners()
        }
        CompleteTimeline(a) {
            a.SetPlaying(!1);
            a.SetScheduled(!1);
            a.SetMarkedForRemoval(!0)
        }
        CompleteTimelineAndResolve(a) {
            this.CompleteTimeline(a);
            a.ResolvePlayPromise()
        }
        _OnTick() {
            if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
                var a = !1;
                for (this._isTickingTimelines = !0; this._scheduledTimelines.length;) {
                    var b = this._scheduledTimelines.pop();
                    b.SetInitialState();
                    this._playingTimelines.push(b)
                }
                b =
                    this._runtime.GetDt();
                var c = this._runtime.GetTimeScale();
                for (const f of this._playingTimelines) {
                    if (f.IsMarkedForRemoval()) continue;
                    const h = f.Tick(b, c);
                    !a && h && (a = !0)
                }
                this._isTickingTimelines = !1;
                a && this.GetRuntime().UpdateRender()
            }
        }
        _OnTick2() {
            if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
                var a;
                for (const b of this._playingTimelines) b.IsMarkedForRemoval() && (a || (a = new Set), this._MaybeExecuteTimelineFinishTriggers(b), a.add(b));
                a && e.arrayRemoveAllInSet(this._playingTimelines,
                    a);
                this._MaybeDisableRuntimeListeners()
            }
        }
        _MaybeExecuteTimelineFinishTriggers(a) {
            a.IsReleased() || a.HasValidTracks() && a.IsComplete() && a.InitialStateSet() && a.FinishTriggers()
        }
        _MaybeEnableRuntimeListeners() {
            this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
        }
        _MaybeDisableRuntimeListeners() {
            this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
        }
        _OnBeforeChangeLayout() {
            for (this._changingLayout = !0; this._scheduledTimelines.length;) this.DeScheduleTimeline(this._scheduledTimelines.pop());
            const a = new Set;
            for (const b of this._playingTimelines) b._OnBeforeChangeLayout() && a.add(b);
            e.arrayRemoveAllInSet(this._playingTimelines, a);
            this._MaybeDisableRuntimeListeners();
            for (const b of this._timelines) b.CleanCaches()
        }
        _OnAfterChangeLayout() {
            this._changingLayout = !1
        }
        _OnInstanceDestroy(a) {
            var b = a.GetObjectClass();
            if (b = this.GetTimelinesForObjectClass(b))
                if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(a);
                else
                    for (const c of b) c.IsTemplate() || (c.IsReleased() ? this.Remove(c) : c.HasValidTracks() ||
                        (this._MaybeExecuteTimelineFinishTriggers(c), this.Remove(c)))
        }
        _OnAfterLoad() {
            for (const a of this._destroyedWhileLoadingState) this._OnInstanceDestroy(a);
            e.clearArray(this._destroyedWhileLoadingState)
        }
        _SaveToJson() {
            return {
                timelinesJson: this._SaveTimelinesToJson(),
                scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
                playingTimelinesJson: this._SavePlayingTimelinesToJson(),
                hasRuntimeListeners: this._hasRuntimeListeners,
                changingLayout: this._changingLayout,
                isTickingTimelines: this._isTickingTimelines
            }
        }
        _LoadFromJson(a) {
            a &&
                (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(a.timelinesJson), this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson), this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson), this._hasRuntimeListeners = !a.hasRuntimeListeners, this._changingLayout = !!a.changingLayout, this._isTickingTimelines = !!a.isTickingTimelines, this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners())
        }
        _SaveTimelinesToJson() {
            return this._timelines.map(a =>
                a._SaveToJson())
        }
        _LoadTimelinesFromJson(a) {
            for (const b of a) {
                a = this.GetTimelineByName(b.name);
                if (!a) {
                    a = this._GetTemplateNameFromJson(b);
                    if (!a) continue;
                    a = this.GetTimelineByName(a);
                    a = this.CreateFromTemplate(a)
                }
                a._LoadFromJson(b);
                a.HasTracks() || this.Remove(a)
            }
        }
        _GetTemplateNameFromJson(a) {
            return (a = a.name.split(":")) && 2 === a.length ? a[0] : null
        }
        _SaveScheduledTimelinesToJson() {
            return this._SaveTimelines(this._scheduledTimelines)
        }
        _LoadScheduledTimelinesFromJson(a) {
            this._LoadTimelines(a, this._scheduledTimelines)
        }
        _SavePlayingTimelinesToJson() {
            return this._SaveTimelines(this._playingTimelines)
        }
        _LoadPlayingTimelinesFromJson(a) {
            this._LoadTimelines(a,
                this._playingTimelines)
        }
        _IsTimelineInJson(a, b) {
            for (const c of b)
                if (c === a.GetName()) return !0;
            return !1
        }
        _SaveTimelines(a) {
            return a.map(b => b.GetName())
        }
        _LoadTimelines(a, b) {
            var c = new Set;
            for (const f of b) this._IsTimelineInJson(f, a) || c.add(f);
            e.arrayRemoveAllInSet(b, c);
            c = f => h => h.GetName() === f;
            for (const f of a)(a = this.GetTimelineByName(f)) && (b.find(c(f)) || b.push(a))
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TimelineState = class extends e.DefendedBase {
        constructor(d, a, b) {
            super();
            this._runtime = b.GetRuntime();
            this._timelineManager = b;
            this._timelineDataItem = a;
            this._name = d;
            this._tracks = [];
            for (const c of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(e.TrackState.Create(this, c));
            this._playResolve = this._playPromise = null;
            this._playheadTime = e.New(e.KahanSum);
            this._playheadTime.Set(0);
            this._playbackRate = 1;
            this._pingPongState = 0;
            this._currentRepeatCount = 1;
            this._initialStateSet =
                this._isScheduled = this._isPlaying = !1;
            this._complete = !0;
            this._markedForRemoval = this._released = !1;
            this._completedTick = -1;
            this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1;
            this._lastDelta = NaN;
            this._tags = [""];
            this._stringTags = "";
            this._tagsChanged = !1
        }
        static CreateInitial(d, a) {
            var b = a.GetTimelineDataManager();
            const c = b.GetNameId();
            b = b.Get(d[c]);
            d = e.New(e.TimelineState, d[c], b, a);
            d.SetIsTemplate(!0);
            return d
        }
        static CreateFromTemplate(d, a, b) {
            return e.New(e.TimelineState, d, a, b)
        }
        static get WORLD_INSTANCE_BOX_CHANGE() {
            return 1
        }
        static get LAYOUT_RENDER_CHANGE() {
            return e.nextHighestPowerOfTwo(1)
        }
        Release() {
            if (!this.IsReleased()) {
                this._timelineManager.DeScheduleTimeline(this);
                this._timelineManager.CompleteTimelineAndResolve(this);
                for (const d of this._tracks) d.Release();
                e.clearArray(this._tracks);
                this._tracks = null;
                this._playheadTime.Release();
                this._timelineDataItem = this._timelineManager = this._runtime = this._playheadTime = null;
                this._released = !0;
                this._playResolve = this._playPromise = null
            }
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetTracks() {
            return this._tracks
        }
        GetSimilarPropertyTracks(d, a, b) {
            const c = [];
            for (const f of this._tracks) {
                if (d !==
                    f.GetInstance()) continue;
                const h = f.GetPropertyTrack(b);
                h && a.constructor === h.GetSourceAdapter().constructor && c.push(h)
            }
            return c
        }
        HasTracks() {
            return !!this._tracks.length
        }
        GetTrackById(d) {
            for (const a of this._tracks)
                if (e.equalsNoCase(a.GetId(), d)) return a;
            return null
        }
        GetTrackByName(d) {
            for (const a of this._tracks)
                if (!a.IsInstanceTrack() && e.equalsNoCase(a.GetName(), d)) return a;
            return null
        }
        SetName(d) {
            this._name = d
        }
        GetName() {
            return this._name
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        GetTemplateName() {
            return this._timelineDataItem.GetName()
        }
        GetTotalTime() {
            return this._timelineDataItem.GetTotalTime()
        }
        SetTotalTime(d) {
            this._timelineDataItem.SetTotalTime(d)
        }
        GetStep() {
            return this._timelineDataItem.GetStep()
        }
        SetStep(d) {
            this._timelineDataItem.SetStep(d)
        }
        GetInterpolationMode() {
            return this._timelineDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(d) {
            this._timelineDataItem.SetInterpolationMode(d)
        }
        GetResultMode() {
            return this._timelineDataItem.GetResultMode()
        }
        SetResultMode(d) {
            this._timelineDataItem.GetResultMode(d)
        }
        SetEase(d) {
            for (const a of this.GetTracks()) a.SetEase(d)
        }
        GetLoop() {
            return this._timelineDataItem.GetLoop()
        }
        SetLoop(d) {
            return this._timelineDataItem.SetLoop(d)
        }
        GetPingPong() {
            return this._timelineDataItem.GetPingPong()
        }
        SetPingPong(d) {
            return this._timelineDataItem.SetPingPong(d)
        }
        GetRepeatCount() {
            return this._timelineDataItem.GetRepeatCount()
        }
        SetPlaybackRate(d) {
            return this._playbackRate =
                d
        }
        GetPlaybackRate() {
            return this._playbackRate
        }
        IsForwardPlayBack() {
            return this.IsPlaying() ? 0 < this._playbackRate : !0
        }
        GetPlayPromise() {
            return this._playPromise ? this._playPromise : this._playPromise = new Promise(d => {
                this._playResolve = d
            })
        }
        ResolvePlayPromise() {
            this._playPromise && (this._playResolve(), this._playResolve = this._playPromise = null)
        }
        SetTags(d) {
            this._tags = e.TimelineState._GetTagArray(d);
            this._tagsChanged = !0
        }
        GetTags() {
            return this._tags
        }
        GetStringTags() {
            this._tagsChanged && (this._stringTags = this._tags.join(" "));
            this._tagsChanged = !1;
            return this._stringTags
        }
        HasTags(d) {
            return this._tags && this._tags.length ? (d = e.TimelineState._GetTagArray(d)) && d.length ? d.every(e.TimelineState._HasTag, this) : !1 : !1
        }
        OnStarted() {
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(this);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStarted);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByName);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByTags);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineStarted);
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            this._finishedTriggers || (this._finishedTriggers = !0, e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
                e.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        SetPlaying(d) {
            this._isPlaying = d
        }
        IsCompletedTick() {
            return this._completedTick === this._runtime.GetTickCount()
        }
        IsPlaying(d = !1) {
            return this.IsCompletedTick() || this.IsScheduled() && !d ? !0 : this._isPlaying
        }
        _IsPlaying() {
            return this.IsPlaying(!0)
        }
        IsPaused() {
            return this._IsPaused()
        }
        _IsPaused() {
            return this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
        }
        SetScheduled(d) {
            this._isScheduled = d
        }
        IsScheduled() {
            return this._isScheduled
        }
        SetComplete(d) {
            this._complete =
                d;
            d = this.GetTime();
            if (0 >= d || d >= this.GetTotalTime()) this._complete = !0
        }
        IsComplete() {
            return this._complete
        }
        IsReleased() {
            return this._released
        }
        SetMarkedForRemoval(d) {
            this._markedForRemoval = d
        }
        IsMarkedForRemoval() {
            return this._markedForRemoval
        }
        SetImplicitPause(d) {
            this._implicitPause = d
        }
        IsImplicitPause() {
            return this._implicitPause
        }
        SetIsTemplate(d) {
            this._isTemplate = !!d
        }
        IsTemplate() {
            return this._isTemplate
        }
        InitialStateSet() {
            return this._initialStateSet
        }
        GetTime() {
            return this._playheadTime.Get()
        }
        SetTime(d) {
            const a =
                this.GetTime();
            this._SetTime(d);
            this.SetComplete(!1);
            this.IsComplete() || this.SetImplicitPause(!0);
            if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime();
            this._Interpolate(d, !1, !0, !0, a) && this.GetRuntime().UpdateRender();
            this._OnSetTime()
        }
        _SetTime(d) {
            0 > d ? this._playheadTime.Set(0) :
                d >= this.GetTotalTime() ? this._playheadTime.Set(this.GetTotalTime()) : this._playheadTime.Set(d)
        }
        _OnSetTime() {
            e.Plugins.Timeline && this.constructor === e.TimelineState && (e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByTags), e.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        _CanResume() {
            if (!this.GetLoop())
                if (this.GetPingPong() &&
                    1 === this._pingPongState)
                    if (this.IsForwardPlayBack()) {
                        if (this.GetTime() >= this.GetTotalTime()) return !1
                    } else {
                        if (0 >= this.GetTime()) return !1
                    }
            else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime()) return !1
                } else if (0 >= this.GetTime()) return !1;
            return !0
        }
        Resume() {
            this.IsReleased() || this._CanResume() && this.Play(!0)
        }
        Play(d = !1) {
            return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() ||
                !this.IsComplete() && !d && !this.IsImplicitPause() ? !1 : this._ScheduleStoppedTimeline()
        }
        _SchedulePlayingTimeline() {
            this.SetImplicitPause(!1);
            this._timelineManager.RemovePlayingTimeline(this);
            this._timelineManager.ScheduleTimeline(this);
            this.GetPlayPromise();
            return !0
        }
        _ScheduleStoppedTimeline() {
            this.SetImplicitPause(!1);
            this._timelineManager.ScheduleTimeline(this);
            this.GetPlayPromise();
            return !0
        }
        Stop(d = !1) {
            this.IsReleased() || (this.SetComplete(d), this._timelineManager.CompleteTimeline(this), this.IsComplete() &&
                this.ResolvePlayPromise())
        }
        Reset(d = !0, a = !1) {
            if (!this.IsReleased()) {
                if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
                if (!this.IsComplete()) {
                    this.Stop(!0);
                    this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                    var b = this.GetTime();
                    a = a ? this._InterpolateBeforeChangeLayout(b) : this._Interpolate(b, !1, !1, !0);
                    d && this._OnSetTime();
                    a && d && this.GetRuntime().UpdateRender()
                }
            }
        }
        ResetBeforeChangeLayout() {
            this.Reset(!1, !0)
        }
        _InterpolateBeforeChangeLayout(d) {
            this._Interpolate(d, !1, !1, !0, NaN, !1, !0)
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            if (this.HasValidGlobalTracks()) return !1;
            this._timelineManager.CompleteTimeline(this);
            this.ResetBeforeChangeLayout();
            return !0
        }
        SetInitialStateFromSetTime() {
            this.SetInitialState(!0)
        }
        SetInitialState(d) {
            if (!this.IsMarkedForRemoval())
                if (d) {
                    this._firstTick = this._initialStateSet = !0;
                    for (const a of this._tracks) a.SetInitialState()
                } else if (this.SetPlaying(!0), this.SetScheduled(!1), this.OnStarted(), this.IsComplete()) {
                this._completedTick = -1;
                this._pingPongState = 0;
                this._currentRepeatCount = 1;
                this._finishedTriggers = this._complete = !1;
                this._firstTick = this._initialStateSet = !0;
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                for (const a of this._tracks) a.SetInitialState()
            } else {
                this._firstTick = !0;
                for (const a of this._tracks) a.SetResumeState()
            }
        }
        Tick(d, a) {
            if (0 !== d || 0 !== this._lastDelta) {
                this._lastDelta = d;
                var b = this.GetTime();
                this._SetTime(b + d * a * this._playbackRate);
                var c;
                this.GetLoop() || this.GetPingPong() ? this.GetLoop() &&
                    !this.GetPingPong() ? c = this._LoopCompleteCheck() : !this.GetLoop() && this.GetPingPong() ? c = this._PingPongCompleteCheck() : this.GetLoop() && this.GetPingPong() && (c = this._LoopPingPongCompleteCheck()) : c = this._SimpleCompleteCheck();
                if (c) {
                    for (const f of this._tracks) f.SetEndState();
                    this.Stop(!0);
                    this.OnCompleted();
                    return !0
                }
                return this._Interpolate(this.GetTime(), !0, !1, !1, b, !0)
            }
        }
        _Interpolate(d, a = !1, b = !1, c = !1, f = NaN, h = !1, g = !1) {
            let k = !1;
            for (var m of this._tracks) m.BeforeInterpolate();
            for (const r of this._tracks) {
                m =
                    d;
                if ("number" === typeof f) {
                    const w = this.GetTime() - r.GetStartOffset(),
                        p = f - r.GetStartOffset();
                    0 > w && 0 < p && (m = r.GetStartOffset(), this._SetTime(m))
                }
                m = r.Interpolate(m, a, b, c, this._firstTick, g);
                !k && m && (k = !0)
            }
            for (const r of this._tracks) r.AfterInterpolate();
            this._firstTick && h && (this._firstTick = !1);
            return k
        }
        _SimpleCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime())
                    if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(0);
                    else return this._SetTime(this.GetTotalTime()), !0
            } else if (0 >= this.GetTime())
                if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(this.GetTotalTime());
                else return this._SetTime(0), !0;
            return !1
        }
        _LoopCompleteCheck() {
            this.IsForwardPlayBack() ? this.GetTime() >= this.GetTotalTime() && this._SetTime(0) : 0 >= this.GetTime() && this._SetTime(this.GetTotalTime());
            return !1
        }
        _PingPongCompleteCheck() {
            if (this.IsForwardPlayBack()) {
                if (this.GetTime() >= this.GetTotalTime())
                    if (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(-1 * this.GetPlaybackRate()),
                        1 === this._pingPongState)
                        if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._pingPongState = 0;
                        else return !0;
                else 0 === this._pingPongState && (this._pingPongState = 1)
            } else if (0 >= this.GetTime())
                if (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState)
                    if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._pingPongState = 0;
                    else return !0;
            else 0 === this._pingPongState && (this._pingPongState = 1);
            return !1
        }
        _LoopPingPongCompleteCheck() {
            this.IsForwardPlayBack() ?
                this.GetTime() >= this.GetTotalTime() && (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(-1 * this.GetPlaybackRate())) : 0 >= this.GetTime() && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()));
            return !1
        }
        AddTrack() {
            var d = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
            d = e.TrackState.Create(this, d);
            this._tracks.push(d);
            return d
        }
        CleanCaches() {
            for (const d of this._tracks) d.CleanCaches()
        }
        ClearTrackInstances() {
            for (const d of this._tracks) d.ClearInstance()
        }
        SetTrackInstance(d,
            a) {
            if (a)
                for (const b of this._tracks)
                    if (b.IsInstanceTrack()) {
                        if (d) {
                            if (b.GetId() !== d) continue
                        } else if (b.HasInstance()) continue;
                        b.SetInstance(a);
                        this._timelineManager.SetTimelineObjectClassToMap(a.GetObjectClass(), this);
                        break
                    }
        }
        HasTrackInstance(d, a) {
            for (const b of this._tracks)
                if (b.IsInstanceTrack())
                    if (a) {
                        if (a === b.GetId() && d === b.GetInstance()) return !0
                    } else if (d === b.GetInstance()) return !0;
            return !1
        }
        HasValidTracks() {
            return this._tracks.some(d => d.IsInstanceTrack() ? d.CanInstanceBeValid() : !0)
        }
        HasValidGlobalTracks() {
            return this._tracks.some(d =>
                d.IsInstanceTrack() ? d.CanInstanceBeValid() ? (d = d.GetObjectClass()) ? d.IsGlobal() : !1 : !1 : !1)
        }
        GetPropertyTrack(d) {
            for (const a of this.GetTracks())
                for (const b of a.GetPropertyTracks())
                    if (b.GetPropertyName() === d) return b
        }
        GetTrackFromInstance(d) {
            for (const a of this._tracks)
                if (d === a.GetInstance()) return a;
            return null
        }
        GetKeyframeWithTags(d) {
            d = d ? d.split(" ") : [];
            d = [...(new Set(d.map(a => a.toLowerCase().trim()))).values()];
            for (const a of this.GetTracks())
                for (const b of a.GetKeyframeDataItems())
                    if (d.every(c => b.HasTag(c))) return b
        }
        GetObjectClasses() {
            const d = [];
            for (const a of this.GetTracks()) d.push(a.GetObjectClass());
            return d.filter(a => a)
        }
        _SaveToJson() {
            return {
                tracksJson: this._SaveTracksToJson(),
                name: this._name,
                playheadTime: this.GetTime(),
                playbackRate: this._playbackRate,
                pingPongState: this._pingPongState,
                currentRepeatCount: this._currentRepeatCount,
                isPlaying: this._isPlaying,
                isScheduled: this._isScheduled,
                initialStateSet: this._initialStateSet,
                finishedTriggers: this._finishedTriggers,
                complete: this._complete,
                released: this._released,
                markedForRemoval: this._markedForRemoval,
                completedTick: this._completedTick,
                implicitPause: this._implicitPause,
                isTemplate: this._isTemplate,
                tags: this._tags.join(" "),
                stringTags: this._stringTags,
                tagsChanged: this._tagsChanged,
                firstTick: this._firstTick
            }
        }
        _LoadFromJson(d) {
            d && (this._LoadTracksFromJson(d.tracksJson), this._name = d.name, this._playheadTime.Set(d.playheadTime), this._playbackRate = d.playbackRate, this._pingPongState = d.pingPongState, this._currentRepeatCount = d.currentRepeatCount, this._isPlaying = !!d.isPlaying, this._isScheduled = !!d.isScheduled,
                this._initialStateSet = !!d.initialStateSet, this._finishedTriggers = d.hasOwnProperty("finishedTriggers") ? !!d.finishedTriggers : !1, this._complete = !!d.complete, this._released = !!d.released, this._markedForRemoval = !!d.markedForRemoval, this._completedTick = d.completedTick, this._implicitPause = !!d.implicitPause, this._isTemplate = !!d.isTemplate, this._tags = d.tags.split(" "), this._stringTags = d.stringTags, this._tagsChanged = !!d.tagsChanged, this._firstTick = !!d.firstTick)
        }
        _SaveTracksToJson() {
            return this._tracks.map(d =>
                d._SaveToJson())
        }
        _LoadTracksFromJson(d) {
            d.forEach((a, b) => {
                this._tracks[b]._LoadFromJson(a)
            });
            this._tracks.filter(a => a.CanInstanceBeValid())
        }
        static _HasTag(d) {
            const a = this.GetTags();
            return "" === d ? 1 === a.length && "" === a[0] : a.includes(d)
        }
        static _GetTagArray(d) {
            if (e.IsArray(d)) return d.slice(0);
            if (e.IsString(d)) return d.split(" ")
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TrackState = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._timeline = d;
            this._trackDataItem = a;
            this._trackData = a.GetTrackData();
            this._objectClassIndex = this._instanceUid = NaN;
            this._worldInfo = this._instance = null;
            this._isNested = 0 < a.GetStartOffset();
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this._lastKeyframeDataItem = null;
            this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();
            this._propertyTracks = [];
            for (const b of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(e.PropertyTrackState.Create(this,
                b))
        }
        static Create(d, a) {
            return e.New(e.TrackState, d, a)
        }
        Release() {
            this._keyframeDataItems = null;
            for (const d of this._propertyTracks) d.Release();
            e.clearArray(this._propertyTracks);
            this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
        }
        CleanCaches() {
            for (const d of this._propertyTracks) d.CleanCaches();
            this._worldInfo = this._instance = null
        }
        GetTimeline() {
            return this._timeline
        }
        GetRuntime() {
            return this._timeline.GetRuntime()
        }
        GetKeyframeDataItems() {
            return this._keyframeDataItems ?
                this._keyframeDataItems : this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
        }
        GetPropertyTracks() {
            return this._propertyTracks
        }
        GetPropertyTrack(d) {
            for (const a of this._propertyTracks)
                if (a.GetPropertyName() === d) return a
        }
        MaybeGetInstance() {
            this._instance || this.GetInstance()
        }
        IsInstanceValid() {
            return this._instance ? !this._instance.IsDestroyed() : !1
        }
        CanInstanceBeValid() {
            if (!this.IsInstanceTrack()) return !1;
            var d = this.GetInstanceUID();
            return (d = this.GetRuntime().GetInstanceByUID(d)) ?
                !d.IsDestroyed() : !1
        }
        GetObjectClass() {
            if (this.IsInstanceTrack()) {
                var d = this.GetObjectClassIndex();
                if (-1 !== d) return this.GetRuntime().GetObjectClassByIndex(d)
            }
        }
        ClearInstance() {
            this._instance = null;
            this._instanceUid = -1;
            this._worldInfo = null;
            this._objectClassIndex = -1
        }
        HasInstance() {
            return !!this._instance
        }
        GetInstance() {
            if (this._instance && this.IsInstanceValid()) return this._instance;
            const d = this.GetInstanceUID();
            return this._instance = this.GetRuntime().GetInstanceByUID(d)
        }
        SetInstance(d) {
            if (this._instance !==
                d) {
                this.CleanCaches();
                this._instance = d;
                this._objectClassIndex = d.GetObjectClass().GetIndex();
                this._instanceUid = d.GetUID();
                this._worldInfo = d.GetWorldInfo();
                for (const h of this.propertyTrackItems()) {
                    const g = h.sourceAdapter;
                    switch (h.propertyTrack.GetSourceAdapterId()) {
                        case "instance-variable":
                            g.GetEditorIndex();
                            var a = d.GetObjectClass(),
                                b = a.GetInstanceVariableIndexByName(h.name),
                                c = a.GetInstanceVariableName(b);
                            a = a.GetInstanceVariableType(b);
                            c === h.name && a === h.type && g.UpdateInstanceVariableIndex(b);
                            break;
                        case "behavior":
                            var f = h.behaviorType;
                            b = this.GetObjectClass();
                            c = d.GetObjectClass();
                            a = g.GetBehaviorType(c);
                            f && a && (f = f.GetName(), b.GetBehaviorIndexByName(f), c.GetBehaviorIndexByName(f), g.GetEditorIndex(), g.UpdateBehaviorTypeSid(a.GetSID()))
                    }
                }
            }
        }* propertyTrackItems() {
            for (const b of this._propertyTracks) {
                var d = b.GetSourceAdapter(),
                    a = this.GetObjectClass();
                const c = {
                    propertyTrack: b,
                    sourceAdapter: d
                };
                switch (b.GetSourceAdapterId()) {
                    case "world-instance":
                        c.property = b.GetPropertyName();
                        break;
                    case "instance-variable":
                        d =
                            d.GetEditorIndex();
                        c.name = a.GetInstanceVariableName(d);
                        c.type = a.GetInstanceVariableType(d);
                        break;
                    case "effect":
                        a = a.GetEffectList();
                        d = d.GetEffectType(a);
                        c.effectType = d;
                        break;
                    case "behavior":
                        d = d.GetBehaviorType(a);
                        c.behaviorType = d;
                        break;
                    case "plugin":
                        c.plugin = a.GetPlugin()
                }
                yield c
            }
        }
        GetWorldInfo() {
            if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo;
            const d = this.GetInstance();
            d && (this._worldInfo = d.GetWorldInfo());
            return this._worldInfo
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetInstanceUID() {
            return this._instanceUid ?
                this._instanceUid : this._trackDataItem.GetInstanceUID()
        }
        SetInstanceUID(d) {
            this._trackDataItem.SetInstanceUID(d)
        }
        GetInterpolationMode() {
            return this._trackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(d) {
            this._trackDataItem.SetInterpolationMode(d)
        }
        GetResultMode() {
            return this._trackDataItem.GetResultMode()
        }
        GetId() {
            return this._trackDataItem.GetId()
        }
        GetStartOffset() {
            return this._trackDataItem.GetStartOffset()
        }
        GetLocalTotalTime() {
            return this._trackDataItem.GetLocalTotalTime()
        }
        SetLocalTotalTime(d) {
            this._trackDataItem.SetLocalTotalTime(d)
        }
        SetResultMode(d) {
            this._trackDataItem.SetResultMode(d)
        }
        SetEase(d) {
            for (const a of this.GetKeyframeDataItems()) a.SetEase(d);
            for (const a of this.GetPropertyTracks()) a.SetEase(d)
        }
        GetEnable() {
            return this._trackDataItem.GetEnable()
        }
        SetEnable(d) {
            this._trackDataItem.SetEnable(d)
        }
        GetObjectClassIndex() {
            return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
        }
        SetObjectClassIndex(d) {
            this._trackDataItem.SetObjectClassIndex(d)
        }
        SetOriginalWidth(d) {
            this._trackDataItem.SetOriginalWidth(d)
        }
        GetOriginalWidth() {
            const d = this.GetInstance();
            return d && d.GetSdkInstance().IsOriginalSizeKnown() ? d.GetSdkInstance().GetOriginalWidth() :
                this._trackDataItem.GetOriginalWidth()
        }
        SetOriginalHeight(d) {
            this._trackDataItem.SetOriginalHeight(d)
        }
        GetOriginalHeight() {
            const d = this.GetInstance();
            return d && d.GetSdkInstance().IsOriginalSizeKnown() ? d.GetSdkInstance().GetOriginalHeight() : this._trackDataItem.GetOriginalHeight()
        }
        GetType() {
            return this._trackDataItem.GetType()
        }
        GetName() {
            return this._trackDataItem.GetName()
        }
        IsInstanceTrack() {
            return 0 === this.GetType()
        }
        IsValueTrack() {
            return 1 === this.GetType()
        }
        SetInitialState() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() ||
                !this.IsInstanceTrack()) {
                for (var d of this._propertyTracks) d.SetInitialState();
                d = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
                this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(d);
                this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
                this.Interpolate(d)
            }
        }
        SetResumeState() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
                this._timeline.IsForwardPlayBack();
                var d = this._timeline.GetTime() - this.GetStartOffset();
                this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(d);
                for (const a of this._propertyTracks) a.SetResumeState()
            }
        }
        SetEndState() {
            if (!(this.GetTimeline().IsComplete() || (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack() || this._isNested))) {
                const d = this._timeline.GetTime(),
                    a = this.GetStartOffset() + this.GetLocalTotalTime();
                d >= a ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0) : 0 >= d && this.Interpolate(0, !0, !1, !0)
            }
        }
        BeforeInterpolate() {
            for (const d of this._propertyTracks) d.BeforeInterpolate()
        }
        Interpolate(d, a = !1, b = !1, c = !1, f = !1, h = !1) {
            this.MaybeGetInstance();
            if (!this.IsInstanceValid() && this.IsInstanceTrack() || h && this.IsInstanceTrack() && this.GetObjectClass().IsGlobal()) return !1;
            d -= this.GetStartOffset();
            if (0 > d) return !1;
            this.MaybeSetInitialStateOfNestedTrack(d, a);
            this.MaybeTriggerKeyframeReachedConditions(d, a, f);
            f = h = !1;
            for (const g of this._propertyTracks) {
                const k = g.Interpolate(d, b, !1, c);
                h || 0 === (k & e.TimelineState.WORLD_INSTANCE_BOX_CHANGE) || (h = !0);
                f || 0 === (k & e.TimelineState.LAYOUT_RENDER_CHANGE) || (f = !0)
            }
            this.MaybeSetEndStateOfNestedTrack(d, a);
            h && (d = this.GetWorldInfo()) &&
                d.SetBboxChanged();
            return f
        }
        AfterInterpolate() {
            for (const d of this._propertyTracks) d.AfterInterpolate()
        }
        MaybeSetInitialStateOfNestedTrack(d, a) {
            if (a && this._isNested && !this._initialStateOfNestedSet) {
                if (this.GetTimeline().IsForwardPlayBack()) {
                    if (0 > d) return;
                    for (const b of this._propertyTracks) b.Interpolate(0, !1, !1, !0)
                } else {
                    if (d > this.GetLocalTotalTime()) return;
                    for (const b of this._propertyTracks) b.Interpolate(this.GetLocalTotalTime(), !1, !1, !0)
                }
                for (const b of this._propertyTracks) b.SetInitialState();
                this._initialStateOfNestedSet = !0
            }
        }
        MaybeSetEndStateOfNestedTrack(d, a) {
            if (a && this._isNested && !this._endStateOfNestedSet)
                if (this.GetTimeline().IsForwardPlayBack()) {
                    if (d >= this.GetLocalTotalTime()) {
                        for (const b of this._propertyTracks) b.Interpolate(this.GetLocalTotalTime(), !1, !1, !0);
                        this._endStateOfNestedSet = !0
                    }
                } else if (0 >= d) {
                for (const b of this._propertyTracks) b.Interpolate(0, !1, !1, !0);
                this._endStateOfNestedSet = !0
            }
        }
        MaybeTriggerKeyframeReachedConditions(d, a, b) {
            if (!b && a) return d = this.GetLastKeyFrameBeforeTime(d), d !== this._lastKeyframeDataItem &&
                this.OnKeyframeReached(d), this._lastKeyframeDataItem = d
        }
        GetLastKeyFrameBeforeTime(d) {
            const a = this.GetTimeline();
            let b = this._trackData.GetKeyFrameDataItemAtTime(d, this._trackDataItem);
            return b ? b : a.IsForwardPlayBack() ? this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(d, this._trackDataItem) : this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(d, this._trackDataItem)
        }
        OnKeyframeReached(d) {
            if (e.Plugins.Timeline && this.GetTimeline().constructor === e.TimelineState) {
                var a = this.GetTimeline();
                e.Plugins.Timeline.Cnds.SetTriggerTimeline(a);
                e.Plugins.Timeline.Cnds.SetTriggerKeyframe(d);
                d = a.GetTimelineManager();
                d.Trigger(e.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
                d.Trigger(e.Plugins.Timeline.Cnds.OnKeyframeReached);
                e.Plugins.Timeline.Cnds.SetTriggerTimeline(null);
                e.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)
            }
        }
        AddKeyframe() {
            return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
        }
        AddPropertyTrack() {
            var d = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
            d = e.PropertyTrackState.Create(this, d);
            this._propertyTracks.push(d);
            return d
        }
        DeleteKeyframes(d) {
            this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(d)
        }
        DeletePropertyKeyframes(d) {
            for (const a of this._propertyTracks) a.DeletePropertyKeyframes(d)
        }
        SaveState() {
            for (const d of this._propertyTracks) d.SaveState()
        }
        CompareInitialStateWithCurrent() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack())
                for (const d of this._propertyTracks) d.CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
                var d = !1;
                for (const a of this._propertyTracks) {
                    const b = a.CompareSaveStateWithCurrent();
                    !d && b && (d = !0)
                }
                d && (d = this.AddKeyframe(), d.SetTime(this.GetTimeline().GetTime()), d.SetEase("noease"), d.SetEnable(!0), d.SetTags(""))
            }
        }
        _SaveToJson() {
            var d = this.GetInstance();
            d = d ? d.GetUID() : this.GetInstanceUID();
            return {
                propertyTracksJson: this._SavePropertyTracksToJson(),
                lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
                initialStateOfNestedSet: this._initialStateOfNestedSet,
                endStateOfNestedSet: this._endStateOfNestedSet,
                instanceUid: d
            }
        }
        _LoadFromJson(d) {
            d && (this._LoadPropertyTracksFromJson(d.propertyTracksJson), this._LoadLastKeyframeDataItemFromJson(d.lastKeyframeDataItemJson), this._LoadInstanceFromJson(d.instanceUid), this._initialStateOfNestedSet = !1, d.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = d.initialStateOfNestedSet), this._endStateOfNestedSet = !1, d.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = d.endStateOfNestedSet))
        }
        _SaveLastKeyframeDataItemToJson() {
            return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
        }
        _SavePropertyTracksToJson() {
            return this._propertyTracks.map(d =>
                d._SaveToJson())
        }
        _LoadPropertyTracksFromJson(d) {
            d.forEach((a, b) => {
                this._propertyTracks[b]._LoadFromJson(a)
            })
        }
        _LoadInstanceFromJson(d) {
            if (e.IsFiniteNumber(d) && (d = this.GetRuntime().GetInstanceByUID(d))) {
                var a = this.GetTimeline();
                a.ClearTrackInstances();
                a.SetTrackInstance(this._trackDataItem.GetId(), d)
            }
        }
        _LoadLastKeyframeDataItemFromJson(d) {
            this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PropertyTrackState = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._track = d;
            this._propertyTrackDataItem = a;
            this._propertyTrackData = a.GetPropertyTrackData();
            this._sourceAdapter = this.GetSourceAdapter();
            this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
        }
        static Create(d, a) {
            return e.New(e.PropertyTrackState, d, a)
        }
        Release() {
            this._track = null;
            this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter =
                null);
            this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
        }
        GetTrack() {
            return this._track
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetTimeline() {
            return this._track.GetTimeline()
        }
        GetRuntime() {
            return this._track.GetRuntime()
        }
        GetInstance() {
            return this._track.GetInstance()
        }
        GetSourceAdapter() {
            if (this._sourceAdapter) return this._sourceAdapter;
            let d;
            switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
                case "behavior":
                    d =
                        new e.PropertyTrackState.BehaviorSourceAdapter(this);
                    break;
                case "effect":
                    d = new e.PropertyTrackState.EffectSourceAdapter(this);
                    break;
                case "instance-variable":
                    d = new e.PropertyTrackState.InstanceVariableSourceAdapter(this);
                    break;
                case "plugin":
                    d = new e.PropertyTrackState.PluginSourceAdapter(this);
                    break;
                case "world-instance":
                    d = new e.PropertyTrackState.WorldInstanceSourceAdapter(this);
                    break;
                case "value":
                    d = new e.PropertyTrackState.ValueSourceAdapter(this)
            }
            return this._sourceAdapter = d
        }
        GetSourceAdapterId() {
            return this._propertyTrackDataItem.GetSourceAdapterId()
        }
        SetSourceAdapterId(d) {
            this._propertyTrackDataItem.SetSourceAdapterId(d)
        }
        GetSourceAdapterArgs() {
            return this._propertyTrackDataItem.GetSourceAdapterArguments()
        }
        SetSourceAdapterArgs(d) {
            this._propertyTrackDataItem.SetSourceAdapterArguments(d)
        }
        GetSourceAdapterValue() {
            return this.GetSourceAdapter().GetValue()
        }
        GetPropertyName() {
            return this._propertyTrackDataItem.GetProperty()
        }
        SetPropertyName(d) {
            this._propertyTrackDataItem.SetProperty(d)
        }
        GetPropertyType() {
            return this._propertyTrackDataItem.GetType()
        }
        SetPropertyType(d) {
            this._propertyTrackDataItem.SetType(d)
        }
        GetPropertyKeyframeType() {
            return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
        }
        GetMin() {
            return this._propertyTrackDataItem.GetMin()
        }
        SetMin(d) {
            this._propertyTrackDataItem.SetMin(d)
        }
        GetMax() {
            return this._propertyTrackDataItem.GetMax()
        }
        SetMax(d) {
            this._propertyTrackDataItem.SetMax(d)
        }
        GetEnable() {
            return this._propertyTrackDataItem.GetEnable()
        }
        SetEnable(d) {
            this._propertyTrackDataItem.SetEnable(d)
        }
        GetInterpolationMode() {
            return this._propertyTrackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(d) {
            this._propertyTrackDataItem.SetInterpolationMode(d)
        }
        GetResultMode() {
            return this._propertyTrackDataItem.GetResultMode()
        }
        SetResultMode(d) {
            this._propertyTrackDataItem.SetResultMode(d)
        }
        SetEase(d) {
            for (const a of this.GetPropertyKeyframeDataItems()) a.SetEase(d)
        }
        GetPropertyKeyframeDataItems() {
            return this._propertyKeyframeDataItems ?
                this._propertyKeyframeDataItems : this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
        }* GetPropertyKeyframeValues() {
            for (const d of this.GetPropertyKeyframeDataItems()) yield d.GetValueWithResultMode()
        }
        CleanCaches() {
            this.GetSourceAdapter().CleanCaches()
        }
        GetCurrentState() {
            return this.GetSourceAdapter().GetCurrentState()
        }
        SetInitialState() {
            this.GetSourceAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetSourceAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this.GetSourceAdapter().BeforeInterpolate()
        }
        Interpolate(d,
            a = !1, b = !1, c = !1) {
            var f = this._propertyTrackDataItem;
            let h = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(d, f);
            h ? f = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(d, f) : (h = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(d, f), f = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(d, f));
            return this.GetSourceAdapter().Interpolate(d, h, f, a, b, c)
        }
        AfterInterpolate() {
            this.GetSourceAdapter().AfterInterpolate()
        }
        static GetStartPropertyKeyframeForTime(d,
            a) {
            const b = a.GetPropertyTrackDataItem();
            a = a._propertyTrackData;
            let c = a.GetPropertyKeyFrameDataItemAtTime(d, b);
            c || (c = a.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(d, b));
            return c
        }
        static GetEndPropertyKeyframeForTime(d, a) {
            const b = a.GetPropertyTrackDataItem();
            a = a._propertyTrackData;
            return a.GetPropertyKeyFrameDataItemAtTime(d, b) ? a.GetFirstPropertyKeyFrameDataItemHigherThan(d, b) : a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(d, b)
        }
        AddPropertyKeyframe() {
            return this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem()
        }
        DeletePropertyKeyframes(d) {
            this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(d)
        }
        SaveState() {
            this.GetSourceAdapter().SaveState()
        }
        CompareInitialStateWithCurrent() {
            if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
                const d =
                    this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem),
                    a = this.GetSourceAdapter().GetCurrentState();
                d.SetAbsoluteValue(a)
            }
        }
        CompareSaveStateWithCurrent() {
            const d = this.GetSourceAdapter().CompareSaveStateWithCurrent();
            d && this.AddPropertyKeyframeAtCurrentTime();
            this.GetSourceAdapter().ClearSaveState();
            return d
        }
        AddPropertyKeyframeAtCurrentTime() {
            const d = this.GetTimeline().GetTime(),
                a = this.GetSourceAdapter(),
                b = e.PropertyTrackState.GetStartPropertyKeyframeForTime(d, this),
                c =
                this.AddPropertyKeyframe();
            c.SetType(b.GetType());
            c.SetTime(d);
            c.SetEase(b.GetEase());
            c.SetEnable(!0);
            c.SetValue(a.GetValueAtTime());
            c.SetAbsoluteValue(a.GetCurrentState())
        }
        _SaveToJson() {
            return {
                sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(d) {
            d && this.GetSourceAdapter()._LoadFromJson(d.sourceAdapterJson)
        }
    }
} {
    "use strict";
    const e = self.C3.PropertyTrackState;
    e.PropertySourceAdapter = class {
        constructor(d) {
            this._propertyTrack = d;
            this._propertyAdapter = null
        }
        Release() {
            this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null);
            this._propertyTrack = null
        }
        GetPropertyTrack() {
            return this._propertyTrack
        }
        CleanCaches() {
            this._propertyAdapter && this._propertyAdapter.CleanCaches()
        }
        GetPropertyAdapter() {
            return this._propertyAdapter ? this._propertyAdapter : this._propertyAdapter = this._CreatePropertyAdapter()
        }
        GetEditorIndex() {}
        GetIndex() {
            return this.GetEditorIndex()
        }
        GetTarget() {}
        SetInitialState() {
            this.GetPropertyAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetPropertyAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this.GetPropertyAdapter().BeforeChangeProperty()
        }
        Interpolate(d,
            a, b, c, f, h) {
            const g = e.PropertySourceAdapter.GetInterpolateFunc(this._propertyTrack)(d, a, b, this._propertyTrack);
            return f ? g : this.GetPropertyAdapter().ChangeProperty(d, g, a, b, c, h)
        }
        AfterInterpolate() {
            this.GetPropertyAdapter().AfterChangeProperty()
        }
        SaveState() {
            this.GetPropertyAdapter().SetSaveState()
        }
        ClearSaveState() {
            this.GetPropertyAdapter().ClearSaveState()
        }
        GetCurrentState() {
            return this.GetPropertyAdapter().GetCurrentState()
        }
        CompareInitialStateWithCurrent() {
            return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
        }
        GetValueAtTime() {
            return e.PropertySourceAdapter.GetValueAtTime(this._propertyTrack)
        }
        _CreatePropertyAdapter() {
            const d =
                this._propertyTrack.GetPropertyType();
            switch (this._propertyTrack.GetPropertyKeyframeType()) {
                case "combo":
                case "boolean":
                case "text":
                case "string":
                    return new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
                case "numeric":
                case "number":
                case "angle":
                    return "combo" === d ? new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
                case "color":
                case "offsetColor":
                    return new e.PropertyInterpolationAdapter.ColorInterpolationAdapter(this)
            }
        }
        _SaveToJson() {
            return {
                propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(d) {
            d &&
                this.GetPropertyAdapter()._LoadFromJson(d.propertyAdapterJson)
        }
        static GetValueAtTime(d) {
            const a = d.GetTrack().GetTimeline().GetTime(),
                b = e.GetStartPropertyKeyframeForTime(a, d),
                c = e.GetEndPropertyKeyframeForTime(a, d);
            return e.PropertySourceAdapter.GetInterpolateFunc(d)(a, b, c, d)
        }
        static GetValue(d, a, b) {
            let c = d.GetResultMode();
            "combo" === d.GetPropertyType() && (c = "absolute");
            switch (c) {
                case "relative":
                    return a + b;
                case "absolute":
                    return b
            }
        }
        static GetInterpolateFunc(d) {
            switch (d.GetPropertyKeyframeType()) {
                case "numeric":
                    return e.NumericTypeAdapter.Interpolate;
                case "angle":
                    return e.AngleTypeAdapter.Interpolate;
                case "boolean":
                    return e.BooleanTypeAdapter.Interpolate;
                case "color":
                    return e.ColorTypeAdapter.Interpolate;
                case "text":
                    return e.TextTypeAdapter.Interpolate
            }
        }
        static GetWillChangeFunc(d) {
            switch (d.GetPropertyKeyframeType()) {
                case "numeric":
                    return e.NumericTypeAdapter.WillChange;
                case "angle":
                    return e.AngleTypeAdapter.WillChange;
                case "boolean":
                    return e.BooleanTypeAdapter.WillChange;
                case "color":
                    return e.ColorTypeAdapter.WillChange;
                case "text":
                    return e.TextTypeAdapter.WillChange
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a)
        }
    }
    e.PropertyTrackState.WorldInstanceSourceAdapter = d
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a);
            this._updatedIndex = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetIndex() {
            return this._updatedIndex ? this._updatedIndex : super.GetIndex()
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance()
        }
        UpdateInstanceVariableIndex(a) {
            this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._updatedIndex =
                a)
        }
        Interpolate(a, b, c, f, h, g) {
            if (this.GetPropertyAdapter().CanChange(b.GetValue())) return super.Interpolate(a, b, c, f, h, g)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                index: this._updatedIndex
            })
        }
        _LoadFromJson(a) {
            a && (super._LoadFromJson(a), this._updatedIndex = a.index)
        }
    }
    e.PropertyTrackState.InstanceVariableSourceAdapter = d
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a);
            this._sid = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            var a = this._propertyTrack.GetPropertyTrackDataItem(),
                b = this._propertyTrack.GetTrack();
            a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0];
            b = b.GetInstance();
            a = b.GetBehaviorIndexBySID(a);
            return b.GetBehaviorInstances()[a].GetSdkInstance()
        }
        GetBehaviorType(a) {
            const b =
                this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
            return a.GetBehaviorTypeByName(b)
        }
        UpdateBehaviorTypeSid(a) {
            this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._sid = a)
        }
        Interpolate(a, b, c, f, h, g) {
            const k = this._propertyTrack.GetTrack().GetInstance();
            if (this.GetBehaviorType(k.GetObjectClass())) return super.Interpolate(a, b, c, f, h, g)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                sid: this._sid
            })
        }
        _LoadFromJson(a) {
            a && (super._LoadFromJson(a),
                this._sid = a.sid)
        }
    }
    e.PropertyTrackState.BehaviorSourceAdapter = d
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
            var b = a.GetEffectList();
            b = this.GetEffectType(b).GetIndex();
            return a.IsEffectIndexActive(b) ? a.GetEffectParametersForIndex(b) : null
        }
        GetEffectType(a) {
            const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
            return a.GetEffectTypeByName(b)
        }
        Interpolate(a, b, c, f, h, g) {
            if (this._IsEffectActive()) return super.Interpolate(a, b, c, f, h, g)
        }
        _IsEffectActive() {
            const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
            var b = a.GetEffectList();
            if (b = this.GetEffectType(b)) return b = b.GetIndex(), a.IsEffectIndexActive(b)
        }
    }
    e.PropertyTrackState.EffectSourceAdapter = d
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
        }
        Interpolate(a, b, c, f, h, g) {
            var k = this._propertyTrack.GetTrack();
            const m = k.GetObjectClass().GetPlugin();
            k = k.GetInstance().GetObjectClass().GetPlugin();
            if (m === k) return super.Interpolate(a, b, c, f, h, g)
        }
    }
    e.PropertyTrackState.PluginSourceAdapter =
        d
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(a) {
            super(a);
            this._value = 0;
            this._init = !1
        }
        SetInitialState() {
            const a = this._propertyTrack.GetPropertyTrackData();
            let b = this._propertyTrack.GetPropertyTrackDataItem();
            b = a.GetFirstPropertyKeyframeDataItem(b);
            this._value = b.GetValueWithResultMode()
        }
        SetResumeState() {}
        GetValue() {
            this._init || this._propertyTrack.Interpolate(0);
            return this._value
        }
        Interpolate(a, b, c, f, h, g) {
            f = e.PropertyTrackState.NumericTypeAdapter.Interpolate;
            this._value =
                f(a, b, c, this._propertyTrack);
            this._init = !0
        }
        SaveState() {}
        ClearSaveState() {}
        GetCurrentState() {
            return this._value
        }
        CompareInitialStateWithCurrent() {
            return !1
        }
        CompareSaveStateWithCurrent() {
            return !1
        }
        _SaveToJson() {
            return {
                value: this._value,
                init: this._init
            }
        }
        _LoadFromJson(a) {
            a && (this._value = a.value, this._init = a.hasOwnProperty("init") ? a.init : !0)
        }
    }
    e.PropertyTrackState.ValueSourceAdapter = d
}
"use strict";
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(e) {
        this._sourceAdapter = e;
        this._propertyTrack = e.GetPropertyTrack();
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
        this._property = this._propertyTrack.GetPropertyName();
        this._firstAbsoluteUpdate = !1;
        this._target = this._saveState = null
    }
    Release() {
        this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
    }
    CleanCaches() {
        this._target = this._saveState = this._worldInfo = null
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    GetWorldInfo() {
        return this._worldInfo ?
            this._worldInfo : this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    }
    SetFirstAbsoluteUpdate(e) {
        this._firstAbsoluteUpdate = !!e
    }
    GetFirstAbsoluteUpdate() {
        return this._firstAbsoluteUpdate
    }
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState() {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState() {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(e) {
        return typeof this._Getter() === typeof e
    }
    BeforeChangeProperty() {}
    ChangeProperty(e, d,
        a, b, c) {}
    AfterChangeProperty() {}
    _FirstKeyframeGetter() {
        return this._PickTimelinePlaybackMode(() => {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(e)
        }, () => {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)
        }).GetAbsoluteValue()
    }
    _CurrentKeyframeGetter() {
        const e = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset();
        return this._PickTimelinePlaybackMode(() => {
            const d = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, d)
        }, () => {
            const d = this._propertyTrack.GetPropertyTrackDataItem(),
                a = this._propertyTrack.GetPropertyTrackData(),
                b = a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, d);
            return b ? b : a.GetLastPropertyKeyframeDataItem(d)
        }).GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(e, d) {
        return this._propertyTrack.GetTimeline().IsForwardPlayBack() ?
            e() : d()
    }
    _PickResultMode(e, d) {
        return "relative" === this._propertyTrack.GetResultMode() ? e() : d()
    }
    _PickFirstAbsoluteUpdate(e, d) {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1), e()) : d()
    }
    _GetAbsoluteInitialValue(e) {}
    _GetIndex() {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget() {
        return this._target ? this._target : this._target = this._sourceAdapter.GetTarget()
    }
    _PickSource(e, d, a, b, c) {
        switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
                return e();
            case "effect":
                return d();
            case "instance-variable":
                return a();
            case "plugin":
                return b();
            case "world-instance":
                return c()
        }
    }
    _SaveToJson() {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(e) {
        e && (this._firstAbsoluteUpdate = e.firstAbsoluteUpdate, this._saveState = e.saveState)
    }
    _GetPropertyKeyframeStubs(e, d = !1) {
        const a = [];
        for (const b of e) {
            e = b.GetTrack().GetStartOffset();
            for (const c of b.GetPropertyKeyframeDataItems()) d && 0 === c.GetTime() ? a.push({
                time: e + c.GetTime(),
                value: c.GetAbsoluteValue()
            }) : d || a.push({
                time: e + c.GetTime(),
                value: c.GetAbsoluteValue()
            })
        }
        return a.sort((b,
            c) => b.time - c.time)
    }
    _GetLastPropertyKeyframeStub(e, d, a) {
        return this._GetPropertyKeyframeStubLowerThanPlayhead(d, a)
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(e, d) {
        for (let a = d.length - 1; 0 <= a; a--)
            if (d[a].time <= e) return d[a];
        return null
    }
}; {
    "use strict";
    const e = self.C3,
        d = new Map,
        a = [0, 0, 0];
    class b extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(c) {
            super(c)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            const c = this._propertyTrack.GetSourceAdapterId(),
                f = this._GetTarget(),
                h = this._GetIndex();
            switch (c) {
                case "behavior":
                    return this._ToColorArray(f.GetPropertyValueByIndex(h));
                case "effect":
                    return this._ToColorArray(f[h]);
                case "plugin":
                    return this._ToColorArray(f.GetPropertyValueByIndex(h));
                case "world-instance":
                    return this._ToColorArray(this._Getter())
            }
        }
        CompareInitialStateWithCurrent() {
            const c =
                this._FirstKeyframeGetter();
            return !this._CompareColors(c, this._Getter())
        }
        CompareSaveStateWithCurrent() {
            return e.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
        }
        _CompareColors(c, f) {
            return c.equalsIgnoringAlpha(f)
        }
        _FirstKeyframeGetter() {
            const c = super._FirstKeyframeGetter();
            return this._GetColorFromArray(c)
        }
        _CurrentKeyframeGetter() {
            const c = super._CurrentKeyframeGetter();
            return this._GetColorFromArray(c)
        }
        _GetAbsoluteInitialValue(c) {}
        _ToColorArray(c) {
            return e.IsInstanceOf(c,
                e.Color) ? c.toArray().slice(0, 3) : c.slice(0, 3)
        }
        _GetColorFromArray(c) {
            return e.IsInstanceOf(c, e.Color) ? c : new e.Color(c[0], c[1], c[2], 1)
        }
        CanChange(c) {
            return !0
        }
        BeforeChangeProperty() {
            var c = this._propertyTrack.GetInstance();
            d.has(c) || d.set(c, new Map);
            c = d.get(c);
            const f = this._propertyTrack.GetSourceAdapterId();
            c.has(f) || c.set(f, new Map);
            c = c.get(f);
            c.has(this._property) || c.set(this._property, {
                used: !1,
                color: new e.Color(0, 0, 0, 1)
            })
        }
        _GetTmpColor(c, f, h) {
            c = d.get(c).get(f).get(h);
            c.used = !0;
            return c.color
        }
        ChangeProperty(c,
            f, h, g, k) {
            k = this._propertyTrack.GetTimeline();
            g = this._propertyTrack.GetTrack();
            c = this._propertyTrack.GetInstance();
            var m = this._propertyTrack.GetSourceAdapter();
            h = this._propertyTrack.GetSourceAdapterId();
            m = k.GetSimilarPropertyTracks(c, m, this._property);
            if (1 < m.length) {
                if (m = this._GetPropertyKeyframeStubs(m, !0), k = this._GetLastPropertyKeyframeStub(k, k.GetTime(), m))
                    if (g = g.GetStartOffset(), m = k.time - g, 0 === m) this._GetTmpColor(c, h, this._property).addRgb(f[0], f[1], f[2]);
                    else {
                        if (0 > m) return;
                        k = f[0];
                        g = f[1];
                        f = f[2];
                        m = this._propertyTrack.Interpolate(m, !1, !0);
                        k = e.Color.DiffChannel(k, m[0]);
                        g = e.Color.DiffChannel(g, m[1]);
                        f = e.Color.DiffChannel(f, m[2]);
                        this._GetTmpColor(c, h, this._property).addRgb(k, g, f)
                    }
            } else this._Setter(f[0], f[1], f[2]);
            return e.TimelineState.LAYOUT_RENDER_CHANGE
        }
        AfterChangeProperty() {
            const c = this._propertyTrack.GetInstance();
            if (d.has(c)) {
                var f = d.get(c),
                    h = this._propertyTrack.GetSourceAdapterId();
                if (f.has(h)) {
                    var g = f.get(h);
                    if (g.has(this._property)) {
                        var k = g.get(this._property),
                            m = k.color;
                        k.used && this._Setter(m.getR(),
                            m.getG(), m.getB());
                        0 === g.size && f.delete(h);
                        0 === f.size && d.delete(c)
                    }
                }
            }
        }
        _Getter() {
            const c = this._propertyTrack.GetSourceAdapterId(),
                f = this._GetTarget(),
                h = this._GetIndex();
            switch (c) {
                case "behavior":
                    return this._GetColorFromArray(f.GetPropertyValueByIndex(h));
                case "effect":
                    return f[h].clone();
                case "plugin":
                    return this._GetColorFromArray(f.GetPropertyValueByIndex(h));
                case "world-instance":
                    return this.GetWorldInfo().GetUnpremultipliedColor().clone()
            }
        }
        _Setter(c, f, h) {
            const g = this._propertyTrack.GetSourceAdapterId(),
                k = this._GetTarget(),
                m = this._GetIndex();
            switch (g) {
                case "behavior":
                    a[0] = c;
                    a[1] = f;
                    a[2] = h;
                    k.SetPropertyValueByIndex(m, a);
                    break;
                case "effect":
                    k[m].setRgb(c, f, h);
                    break;
                case "plugin":
                    a[0] = c;
                    a[1] = f;
                    a[2] = h;
                    k.SetPropertyValueByIndex(m, a);
                    break;
                case "world-instance":
                    this.GetWorldInfo().SetUnpremultipliedColorRGB(c, f, h)
            }
        }
        _SaveToJson() {}
        _LoadFromJson(c) {}
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = b
} {
    "use strict";
    const e = self.C3;
    class d extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(a) {
            super(a)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            return this._FirstKeyframeGetter() !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return e.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
        }
        ChangeProperty(a, b, c, f, h) {
            c = e.PropertyTrackState.PropertySourceAdapter.GetWillChangeFunc(this._propertyTrack);
            var g = this._propertyTrack;
            const k = g.GetTrack();
            f = g.GetSourceAdapterId();
            h = g.GetTimeline();
            var m = k.GetInstance();
            g = g.GetSourceAdapter();
            m = h.GetSimilarPropertyTracks(m, g, this._property);
            1 < m.length && (m = this._GetPropertyKeyframeStubs(m), a += k.GetStartOffset(), a = this._GetLastPropertyKeyframeStub(h, a, m)) && (b = a.value);
            if (c(this._GetIndex(), this._GetTarget(), b, f)) switch (this._Setter(b), f) {
                case "plugin":
                    return e.TimelineState.LAYOUT_RENDER_CHANGE
            }
        }
        _Getter() {
            const a = this._propertyTrack.GetSourceAdapterId(),
                b = this._GetTarget(),
                c = this._GetIndex();
            switch (a) {
                case "behavior":
                    return b.GetPropertyValueByIndex(c);
                case "effect":
                    return b[c];
                case "instance-variable":
                    return b.GetInstanceVariableValue(c);
                case "plugin":
                    return b.GetPropertyValueByIndex(c)
            }
        }
        _Setter(a) {
            const b = this._propertyTrack.GetSourceAdapterId(),
                c = this._GetTarget(),
                f = this._GetIndex();
            switch (b) {
                case "behavior":
                    c.SetPropertyValueByIndex(f, a);
                    break;
                case "effect":
                    c[f] = a;
                    break;
                case "instance-variable":
                    c.SetInstanceVariableValue(f, a);
                    break;
                case "plugin":
                    c.SetPropertyValueByIndex(f,
                        a)
            }
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = d
} {
    "use strict";
    const e = self.C3,
        d = new Map,
        a = (c, f, h, g, k) => d.set(c, {
            setter: f,
            absolute_setter: h,
            getter: g,
            round: k
        });
    a("offsetX", (c, f) => c.OffsetX(f), (c, f) => c.SetX(f), c => c.GetX(), !0);
    a("offsetY", (c, f) => c.OffsetY(f), (c, f) => c.SetY(f), c => c.GetY(), !0);
    a("offsetWidth", (c, f) => c.OffsetWidth(f), (c, f) => c.SetWidth(f), c => c.GetWidth(), !0);
    a("offsetHeight", (c, f) => c.OffsetHeight(f), (c, f) => c.SetHeight(f), c => c.GetHeight(), !0);
    a("offsetAngle", (c, f) => c.OffsetAngle(f), (c, f) => c.SetAngle(f), c => c.GetAngle(), !1);
    a("offsetOpacity",
        (c, f, h, g) => {
            h = c.GetOpacity() + f;
            0 === g._clampAccumulator ? (1 < h ? g._clampAccumulator += h - 1 : 0 > h && (g._clampAccumulator += h), c.OffsetOpacity(f)) : (c = c.GetOpacity() + f, 0 < f && 0 < g._clampAccumulator ? 1 < c && (g._clampAccumulator += c - 1) : 0 < f && 0 > g._clampAccumulator ? (g._clampAccumulator += f, 0 < g._clampAccumulator && (g._clampAccumulator = 0)) : 0 > f && 0 < g._clampAccumulator ? (g._clampAccumulator += f, 0 > g._clampAccumulator && (g._clampAccumulator = 0)) : 0 > f && 0 > g._clampAccumulator && 0 > c && (g._clampAccumulator += c))
        }, (c, f) => {
            c.SetOpacity(f)
        }, c => c.GetOpacity(), !1);
    a("offsetOriginX", (c, f) => c.OffsetOriginX(f), (c, f) => c.SetOriginX(f), c => c.GetOriginX(), !1);
    a("offsetOriginY", (c, f) => c.OffsetOriginY(f), (c, f) => c.SetOriginY(f), c => c.GetOriginY(), !1);
    a("offsetZElevation", (c, f) => c.OffsetZElevation(f), (c, f) => c.SetZElevation(f), c => c.GetZElevation(), !0);
    a("offsetScaleX", (c, f, h, g) => {
        g = 0 > c.GetWidth() ? -1 : 1;
        c.GetTransformWithParentWidth();
        c.OffsetWidth(h.GetOriginalWidth() * g * f)
    }, (c, f, h) => {
        c.SetWidth(h.GetOriginalWidth() * f)
    }, (c, f) => {
        const h = 0 > c.GetWidth() ? -1 : 1;
        if (c.GetTransformWithParentWidth()) {
            var g =
                c.GetParent(),
                k = f.GetTimeline().GetTrackFromInstance(g.GetInstance());
            k ? g = g.GetWidth() / k.GetOriginalWidth() : (k = g.GetInstance().GetSdkInstance(), g = k.IsOriginalSizeKnown() ? g.GetWidth() / k.GetOriginalWidth() : 1);
            return c.GetWidth() * h / (f.GetOriginalWidth() * g)
        }
        return c.GetWidth() * h / f.GetOriginalWidth()
    }, !1);
    a("offsetScaleY", (c, f, h, g) => {
        g = 0 > c.GetHeight() ? -1 : 1;
        c.GetTransformWithParentHeight();
        c.OffsetHeight(h.GetOriginalHeight() * g * f)
    }, (c, f, h) => {
        c.SetHeight(h.GetOriginalHeight() * f)
    }, (c, f) => {
        const h = 0 > c.GetHeight() ?
            -1 : 1;
        if (c.GetTransformWithParentHeight()) {
            var g = c.GetParent(),
                k = f.GetTimeline().GetTrackFromInstance(g.GetInstance());
            k ? g = g.GetHeight() / k.GetOriginalHeight() : (k = g.GetInstance().GetSdkInstance(), g = k.IsOriginalSizeKnown() ? g.GetHeight() / k.GetOriginalHeight() : 1);
            return c.GetHeight() * h / (f.GetOriginalHeight() * g)
        }
        return c.GetHeight() * h / f.GetOriginalHeight()
    }, !1);
    class b extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(c) {
            super(c);
            this._clampAccumulator = this._lastValue = 0;
            this._instance_absolute_setter =
                this._instance_setter = this._instance_getter = null;
            this._round = !1;
            e.IsInstanceOf(this._propertyTrack.GetTimeline(), e.Tween) ? this._typeAdapter = new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
            c = this._propertyTrack.GetPropertyName();
            "world-instance" === this._propertyTrack.GetSourceAdapterId() && (c = d.get(c), this._instance_getter = c.getter, this._instance_setter =
                c.setter, this._instance_absolute_setter = c.absolute_setter, this._round = c.round)
        }
        Release() {
            this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null;
            super.Release()
        }
        GetLastValue() {
            return this._lastValue
        }
        SetLastValue(c) {
            this._lastValue = c
        }
        SetInitialState() {
            const c = this._typeAdapter.SetInitialState();
            "number" === typeof c && (this._lastValue = c);
            this._clampAccumulator = 0
        }
        SetResumeState() {
            const c = this._typeAdapter.SetResumeState();
            "number" === typeof c && (this._lastValue =
                c)
        }
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            return this._FirstKeyframeGetter() !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return e.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
        }
        BeforeChangeProperty() {
            this._typeAdapter.BeforeChangeProperty()
        }
        ChangeProperty(c, f, h, g, k, m, r) {
            return this._typeAdapter.ChangeProperty(c, f, h, g, k, m, r)
        }
        AfterChangeProperty() {
            this._typeAdapter.AfterChangeProperty()
        }
        _Getter() {
            const c = this._GetTarget(),
                f = this._GetIndex(),
                h = this._propertyTrack.GetTrack(),
                g = this.GetWorldInfo();
            return this._PickSource(() => c.GetPropertyValueByIndex(f), () => c[f], () => c.GetInstanceVariableValue(f), () => c.GetPropertyValueByIndex(f), () => this._instance_getter(g, h))
        }
        _Setter(c, f, h) {
            const g = this._GetTarget(),
                k = this._GetIndex(),
                m = this._propertyTrack.GetTrack(),
                r = this.GetWorldInfo();
            this._PickSource(() => g.OffsetPropertyValueByIndex(k, c), () => g[k] += c, () => g.SetInstanceVariableOffset(k, c), () => g.OffsetPropertyValueByIndex(k, c), () => this._instance_setter(r,
                c, m, this))
        }
        _SetterAbsolute(c, f, h) {
            const g = this._GetTarget(),
                k = this._GetIndex(),
                m = this._propertyTrack.GetTrack(),
                r = this.GetWorldInfo();
            this._PickSource(() => g.SetPropertyValueByIndex(k, c), () => g[k] = c, () => g.SetInstanceVariableValue(k, c), () => g.SetPropertyValueByIndex(k, c), () => this._instance_absolute_setter(r, c, m))
        }
        _MaybeEnsureValue(c, f, h, g, k, m) {
            this._typeAdapter._MaybeEnsureValue(c, f, h, g, k, m)
        }
        _AddDelta(c, f, h) {
            var g = (c.toString().split(".")[1] || "").length;
            c = this._Getter();
            g = 0 === g ? this._round ? Math.round(c) :
                c : e.toFixed(c, g);
            this._Setter(g - c, f, h)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                v: this._lastValue,
                a: this._clampAccumulator
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._lastValue = c.v, this._clampAccumulator = c.a)
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = b
} {
    "use strict";
    const e = self.C3,
        d = new Map;
    class a {
        constructor(b) {
            this._numericInterpolationAdapter = b
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const b = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack();
            return b._PickResultMode(() => b._PickTimelinePlaybackMode(() => 0, () => e.PropertyTrackState.PropertySourceAdapter.GetValueAtTime(c)), () => {})
        }
        SetResumeState() {}
        BeforeChangeProperty() {
            const b = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack(),
                f = c.GetPropertyName();
            b._PickResultMode(() => {}, () => {
                var h = c.GetInstance();
                d.has(h) || d.set(h, new Map);
                h = d.get(h);
                const g = c.GetSourceAdapterId();
                h.has(g) || h.set(g, new Map);
                h = h.get(g);
                h.has(f) || h.set(f, {
                    used: !1,
                    value: 0
                })
            })
        }
        _GetTmpAbsoluteValueObject(b, c, f) {
            b = d.get(b).get(c).get(f);
            b.used = !0;
            return b
        }
        ChangeProperty(b, c, f, h, g, k) {
            const m = this._numericInterpolationAdapter,
                r = this._numericInterpolationAdapter.GetPropertyTrack(),
                w = r.GetPropertyName();
            m._PickResultMode(() => {
                const p = m.GetLastValue();
                m._Setter(c -
                    p, f, h);
                k && this._MaybeEnsureValue(b, f, h, g, p, c);
                m.SetLastValue(c)
            }, () => {
                var p = r.GetTimeline(),
                    t = r.GetTrack();
                const u = r.GetInstance();
                var q = r.GetSourceAdapter();
                const x = r.GetSourceAdapterId();
                q = p.GetSimilarPropertyTracks(u, q, w);
                if (1 < q.length) {
                    if (q = m._GetPropertyKeyframeStubs(q, !0), p = m._GetLastPropertyKeyframeStub(p, p.GetTime(), q)) t = t.GetStartOffset(), t = p.time - t, 0 === t ? this._GetTmpAbsoluteValueObject(u, x, w).value += c : 0 > t || (t = r.Interpolate(t, !1, !0), this._GetTmpAbsoluteValueObject(u, x, w).value += c - t)
                } else m._SetterAbsolute(c)
            });
            return m._PickSource(() => {}, () => e.TimelineState.LAYOUT_RENDER_CHANGE, () => {}, () => e.TimelineState.LAYOUT_RENDER_CHANGE, () => e.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        AfterChangeProperty() {
            const b = this._numericInterpolationAdapter,
                c = this._numericInterpolationAdapter.GetPropertyTrack(),
                f = c.GetPropertyName();
            b._PickResultMode(() => {}, () => {
                const h = c.GetInstance();
                if (d.has(h)) {
                    var g = d.get(h),
                        k = c.GetSourceAdapterId();
                    if (g.has(k)) {
                        var m = g.get(k);
                        if (m.has(f)) {
                            var r = m.get(f),
                                w = r.value;
                            r.used && b._SetterAbsolute(w);
                            m.delete(f);
                            0 === m.size && g.delete(k);
                            0 === g.size && d.delete(h)
                        }
                    }
                }
            })
        }
        _MaybeEnsureValue(b, c, f, h, g, k) {
            const m = this._numericInterpolationAdapter;
            h || (c && b === c.GetTime() ? m._AddDelta(c.GetValueWithResultMode(), c, f) : f && b === f.GetTime() ? m._AddDelta(f.GetValueWithResultMode(), c, f) : 0 === k - g && m._AddDelta(c.GetValueWithResultMode(), c, f))
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = a
} {
    "use strict";
    const e = self.C3;
    new Map;
    class d {
        constructor(a) {
            this._numericInterpolationAdapter = a
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const a = this._numericInterpolationAdapter;
            a.SetFirstAbsoluteUpdate(!0);
            return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
        }
        SetResumeState() {
            const a = this._numericInterpolationAdapter;
            if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter()) return a.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
        }
        BeforeChangeProperty() {}
        ChangeProperty(a,
            b, c, f, h, g) {
            const k = this._numericInterpolationAdapter,
                m = k.GetLastValue();
            k._PickResultMode(() => {
                k._Setter(b - m, c, f);
                g && this._MaybeEnsureValue(a, c, f, h, m, b)
            }, () => {
                k._PickFirstAbsoluteUpdate(() => {
                    k._Setter(m, c, f)
                }, () => {
                    k._Setter(b - m, c, f);
                    g && this._MaybeEnsureValue(a, c, f, h, m, b)
                })
            });
            k.SetLastValue(b);
            return k._PickSource(() => {}, () => e.TimelineState.LAYOUT_RENDER_CHANGE, () => {}, () => e.TimelineState.LAYOUT_RENDER_CHANGE, () => e.TimelineState.LAYOUT_RENDER_CHANGE)
        }
        AfterChangeProperty() {}
        _GetAbsoluteInitialValue(a) {
            return a -
                this._numericInterpolationAdapter.GetCurrentState()
        }
        _MaybeEnsureValue(a, b, c, f, h, g) {
            const k = this._numericInterpolationAdapter;
            f ? b && a === b.GetTime() ? k._AddDelta(b.GetValueWithResultMode(), b, c) : c && a === c.GetTime() ? k._AddDelta(c.GetValueWithResultMode(), b, c) : c || k._AddDelta(b.GetValueWithResultMode(), b, c) : b && a === b.GetTime() ? k._AddDelta(b.GetValueWithResultMode(), b, c) : c && a === c.GetTime() ? k._AddDelta(c.GetValueWithResultMode(), b, c) : 0 === g - h && k._AddDelta(b.GetValueWithResultMode(), b, c)
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween =
        d
} {
    "use strict";
    const e = self.C3,
        d = self.Ease;
    e.PropertyTrackState.NumericTypeAdapter = class {
        constructor() {}
        static WillChange(a, b, c, f) {
            let h;
            switch (f) {
                case "behavior":
                    h = b.GetPropertyValueByIndex(a);
                    break;
                case "effect":
                    h = b[a];
                    break;
                case "instance-variable":
                    h = b.GetInstanceVariableValue(a);
                    break;
                case "plugin":
                    h = b.GetPropertyValueByIndex(a)
            }
            return h === c ? !1 : !0
        }
        static Interpolate(a, b, c, f) {
            if (!c) return c = f.GetPropertyTrackDataItem(), c = f.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(c), c.GetValueWithResultMode();
            var h =
                f.GetInterpolationMode();
            "default" === h && (h = "continuous");
            "combo" === f.GetPropertyType() && (h = "discrete");
            if ("discrete" === h) return b.GetValueWithResultMode();
            if ("continuous" === h || "step" === h) {
                "step" === h && (h = f.GetTimeline().GetStep(), 0 !== h && (h = 1 / h, a = Math.floor(a * h) / h));
                var g = b.GetTime();
                const k = c.GetTime();
                h = b.GetValueWithResultMode();
                const m = c.GetValueWithResultMode();
                if (h === m) return h;
                a = e.normalize(a, g, k);
                const r = b.GetEase();
                b = b.GetAddOn("cubic-bezier");
                c = c.GetAddOn("cubic-bezier");
                b && b.GetStartEnable() &&
                    c && c.GetEndEnable() ? (g = k - g, g = d.GetRuntimeEase(r)(g * a, 0, 1, g), g = d.GetRuntimeEase("cubicbezier")(g, h, h + b.GetStartAnchor(), m + c.GetEndAnchor(), m)) : g = d.GetRuntimeEase(r)((k - g) * a, h, m - h, k - g);
                return "integer" === f.GetPropertyType() ? Math.floor(g) : g
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PropertyTrackState.AngleTypeAdapter = class {
        constructor() {}
        static WillChange(d, a, b, c) {
            let f;
            switch (c) {
                case "behavior":
                    f = a.GetPropertyValueByIndex(d);
                    break;
                case "effect":
                    f = a[d];
                    break;
                case "instance-variable":
                    f = a.GetInstanceVariableValue(d);
                    break;
                case "plugin":
                    f = a.GetPropertyValueByIndex(d)
            }
            return f === b ? !1 : !0
        }
        static Interpolate(d, a, b, c) {
            if (!b) return a = c.GetPropertyTrackDataItem(), a = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a), a.GetValueWithResultMode();
            var f =
                c.GetInterpolationMode();
            "default" === f && (f = "continuous");
            "combo" === c.GetPropertyType() && (f = "discrete");
            if ("discrete" === f) return a.GetValueWithResultMode();
            if ("continuous" === f || "step" === f) {
                "step" === f && (c = c.GetTimeline().GetStep(), 0 !== c && (c = 1 / c, d = Math.floor(d * c) / c));
                const h = a.GetTime(),
                    g = b.GetTime();
                c = a.GetValueWithResultMode();
                b = b.GetValueWithResultMode();
                if (f = a.GetAddOn("angle")) {
                    const k = f.GetRevolutions();
                    if (c === b && 0 === k) return c;
                    d = e.normalize(d, h, g);
                    a = self.Ease.GetRuntimeEase(a.GetEase())(d, 0, 1,
                        1);
                    switch (f.GetDirection()) {
                        case "closest":
                            return e.angleLerp(c, b, a, k);
                        case "clockwise":
                            return e.angleLerpClockwise(c, b, a, k);
                        case "anti-clockwise":
                            return e.angleLerpAntiClockwise(c, b, a, k)
                    }
                } else {
                    if (c === b) return c;
                    d = e.normalize(d, h, g);
                    a = self.Ease.GetRuntimeEase(a.GetEase());
                    return e.angleLerp(c, b, a(d, 0, 1, 1))
                }
            }
        }
    }
}
"use strict";
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(e, d, a, b) {
        let c;
        switch (b) {
            case "behavior":
                c = d.GetPropertyValueByIndex(e);
                break;
            case "effect":
                c = d[e];
                break;
            case "instance-variable":
                c = d.GetInstanceVariableValue(e);
                break;
            case "plugin":
                c = d.GetPropertyValueByIndex(e)
        }
        return !!c === !!a ? !1 : !0
    }
    static Interpolate(e, d, a, b) {
        return a ? d.GetValueWithResultMode() ? 1 : 0 : (e = b.GetPropertyTrackDataItem(), e = b.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode() ?
            1 : 0)
    }
}; {
    "use strict";
    const e = self.C3,
        d = [0, 0, 0],
        a = [0, 0, 0],
        b = [0, 0, 0];
    e.PropertyTrackState.ColorTypeAdapter = class {
        constructor() {}
        static WillChange(c, f, h, g) {
            let k;
            switch (g) {
                case "behavior":
                    k = f.GetPropertyValueByIndex(c);
                    break;
                case "effect":
                    k = f[c];
                    break;
                case "instance-variable":
                    k = f.GetInstanceVariableValue(c);
                    break;
                case "plugin":
                    k = f.GetPropertyValueByIndex(c)
            }
            Array.isArray(h) ? (d[0] = h[0], d[1] = h[1], d[2] = h[2]) : (b.parseCommaSeparatedRgb(h), d[0] = Math.floor(255 * b.getR()), d[1] = Math.floor(255 * b.getG()), d[2] = Math.floor(255 * b.getB()));
            Array.isArray(k) ? (a[0] = k[0], a[1] = k[1], a[2] = k[2]) : (b.parseCommaSeparatedRgb(k), a[0] = Math.floor(255 * b.getR()), a[1] = Math.floor(255 * b.getG()), a[2] = Math.floor(255 * b.getB()));
            return d[0] !== a[0] || d[1] !== a[1] || d[2] !== a[2] ? !0 : !1
        }
        static Interpolate(c, f, h, g) {
            if (!h) {
                var k = g.GetPropertyTrackDataItem();
                k = g.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(k);
                g = k.GetValueWithResultMode();
                d[0] = g[0];
                d[1] = g[1];
                d[2] = g[2];
                return d
            }
            k = g.GetInterpolationMode();
            "default" === k && (k = "continuous");
            if ("discrete" === k) return g =
                f.GetValueWithResultMode(), d[0] = g[0], d[1] = g[1], d[2] = g[2], d;
            if ("continuous" === k || "step" === k) {
                "step" === k && (g = g.GetTimeline().GetStep(), 0 !== g && (g = 1 / g, c = Math.floor(c * g) / g));
                g = f.GetTime();
                k = h.GetTime();
                var m = f.GetValueWithResultMode(),
                    r = h.GetValueWithResultMode();
                c = e.normalize(c, g, k);
                var w = f.GetEase();
                f = m[0];
                h = m[1];
                m = m[2];
                const p = r[0],
                    t = r[1];
                r = r[2];
                w = self.Ease.GetRuntimeEase(w);
                g = k - g;
                k = g * c;
                d[0] = f === p ? f : w(k, f, p - f, g);
                d[1] = h === t ? h : w(k, h, t - h, g);
                d[2] = m === r ? m : w(k, m, r - m, g);
                return d
            }
        }
    }
}
"use strict";
self.C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(e, d, a, b) {
        let c;
        switch (b) {
            case "behavior":
                c = d.GetPropertyValueByIndex(e);
                break;
            case "effect":
                c = d[e];
                break;
            case "instance-variable":
                c = d.GetInstanceVariableValue(e);
                break;
            case "plugin":
                c = d.GetPropertyValueByIndex(e)
        }
        return c === a ? !1 : !0
    }
    static Interpolate(e, d, a, b) {
        return a ? d.GetValueWithResultMode() : (e = b.GetPropertyTrackDataItem(), e = b.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode())
    }
}; {
    "use strict";
    const e = self.C3;
    e.TimelineDataManager = class {
        constructor() {
            this._timelineDataItems = new Map
        }
        Release() {
            for (const d of this._timelineDataItems.values()) d.Release();
            this._timelineDataItems.clear();
            this._timelineDataItems = null
        }
        Add(d) {
            d = new e.TimelineDataItem(d);
            const a = d.GetName();
            this._timelineDataItems.set(a, d)
        }
        Get(d) {
            return this._timelineDataItems.get(d)
        }
        GetNameId() {
            return 0
        }
        static _CreateDataItems(d, a, b, c) {
            if (a)
                for (const f of a) e.TimelineDataManager._CreateDataItem("create", f, d, b, c)
        }
        static _LoadDataItemsFromJson(d,
            a, b, c) {
            d.length ? a.forEach((f, h) => {
                d[h]._LoadFromJson(f)
            }) : a.forEach(f => {
                e.TimelineDataManager._CreateDataItem("load", f, d, b, c)
            })
        }
        static _CreateDataItem(d, a, b, c, f) {
            let h;
            if ("function" === typeof c) switch (d) {
                case "load":
                    h = new c(null, f);
                    break;
                case "create":
                    h = new c(a, f)
            } else if ("object" === typeof c) switch (c = c.map.get(a[c.prop]), d) {
                case "load":
                    h = new c(null, f);
                    break;
                case "create":
                    h = new c(a, f)
            }
            switch (d) {
                case "load":
                    h._LoadFromJson(a);
                    b.push(h);
                    break;
                case "create":
                    if ("function" === typeof h.GetEnable && !h.GetEnable()) return h.Release();
                    b.push(h)
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TimelineDataItem = class {
        constructor(d) {
            this._name = "";
            this._totalTime = NaN;
            this._step = 0;
            this._resultMode = this._interpolationMode = "default";
            this._pingPong = this._loop = !1;
            this._repeatCount = 1;
            this._trackData = null;
            d && (this._name = d[0], this._totalTime = d[1], this._step = d[2], this._interpolationMode = d[3], this._resultMode = d[4], this._loop = !!d[6], this._pingPong = !!d[7], this._repeatCount = d[8], this._trackData = new e.TrackData(d[5], this))
        }
        Release() {
            this._trackData.Release();
            this._trackData =
                null
        }
        GetTrackData() {
            this._trackData || (this._trackData = new e.TrackData(null, this));
            return this._trackData
        }
        GetName() {
            return this._name
        }
        SetName(d) {
            this._name = d
        }
        GetTotalTime() {
            return this._totalTime
        }
        SetTotalTime(d) {
            this._totalTime = d
        }
        GetStep() {
            return this._step
        }
        SetStep(d) {
            this._step = d
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(d) {
            this._interpolationMode = d
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(d) {
            this._resultMode = d
        }
        GetLoop() {
            return this._loop
        }
        SetLoop(d) {
            this._loop =
                d
        }
        GetPingPong() {
            return this._pingPong
        }
        SetPingPong(d) {
            this._pingPong = d
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        _SaveToJson() {
            return {
                trackDataJson: this._trackData._SaveToJson(),
                name: this._name,
                totalTime: this._totalTime,
                step: this._step,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                loop: this._loop,
                pingPong: this._pingPong,
                repeatCount: this._repeatCount
            }
        }
        _LoadFromJson(d) {
            d && (this.GetTrackData()._LoadFromJson(d.trackDataJson), this._name = d.name, this._totalTime = d.totalTime, this._step =
                d.step, this._interpolationMode = d.interpolationMode, this._resultMode = d.resultMode, this._loop = d.loop, this._pingPong = d.pingPong, this._repeatCount = d.repeatCount)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor(a, b) {
            this._trackData = b;
            this._additionalInstanceData = this._instanceData = null;
            this._objectClassIndex = this._instanceUid = NaN;
            this._resultMode = this._interpolationMode = "default";
            this._enabled = !1;
            this._propertyTrackData = this._keyframeData = null;
            this._id = "";
            this._nestedData = null;
            this._startOffset = 0;
            this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();
            this._type = 0;
            this._name = "";
            a && (a[0] && (this._instanceData = a[0], this._instanceUid = a[0][2],
                this._objectClassIndex = a[0][1]), this._interpolationMode = a[1], this._resultMode = a[2], this._enabled = !!a[3], a[6] && (this._id = a[6]), a[7] && (this._nestedData = a[7], this._startOffset = a[7][0], this._localTotalTime = a[7][1]), a[8] && (this._additionalInstanceData = a[8]), a[8] && (this._additionalInstanceData = a[8]), a[9] && (this._type = a[9]), a[10] && (this._name = a[10]), this._keyframeData = new e.KeyframeData(a[4], this), this._propertyTrackData = new e.PropertyTrackData(a[5], this))
        }
        Release() {
            this._trackData = this._instanceData = null;
            this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null);
            this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null);
            this._nestedData = null
        }
        GetTrackData() {
            return this._trackData
        }
        GetKeyframeData() {
            this._keyframeData || (this._keyframeData = new e.KeyframeData(null, this));
            return this._keyframeData
        }
        GetPropertyTrackData() {
            this._propertyTrackData || (this._propertyTrackData = new e.PropertyTrackData(null, this));
            return this._propertyTrackData
        }
        GetInstanceData() {
            return this._instanceData
        }
        GetObjectClassIndex() {
            return this._objectClassIndex
        }
        SetObjectClassIndex(a) {
            this._objectClassIndex =
                a
        }
        GetInstanceUID() {
            return this._instanceUid
        }
        SetInstanceUID(a) {
            this._instanceUid = a
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(a) {
            this._interpolationMode = a
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(a) {
            this._resultMode = a
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(a) {
            this._enabled = !!a
        }
        GetId() {
            return this._id
        }
        GetStartOffset() {
            return this._startOffset
        }
        GetLocalTotalTime() {
            return this._localTotalTime
        }
        SetLocalTotalTime(a) {
            this._localTotalTime = a
        }
        GetOriginalWidth() {
            return this._additionalInstanceData[0]
        }
        SetOriginalWidth(a) {
            this._additionalInstanceData ||
                (this._additionalInstanceData = []);
            this._additionalInstanceData[0] = a
        }
        GetOriginalHeight() {
            this._additionalInstanceData || (this._additionalInstanceData = []);
            return this._additionalInstanceData[1]
        }
        SetOriginalHeight(a) {
            this._additionalInstanceData || (this._additionalInstanceData = []);
            this._additionalInstanceData[1] = a
        }
        GetType() {
            return this._type
        }
        GetName() {
            return this._name
        }
        _SaveToJson() {
            return {
                keyframeDataJson: this._keyframeData._SaveToJson(),
                propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
                instanceData: this._instanceData,
                additionalInstanceData: this._additionalInstanceData,
                instanceUid: this._instanceUid,
                objectClassIndex: this._objectClassIndex,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled,
                id: this._id,
                nestedData: this._nestedData,
                type: this._type,
                name: this._name
            }
        }
        _LoadFromJson(a) {
            a && (this._instanceData = a.instanceData, this._instanceUid = a.instanceUid, this._objectClassIndex = a.objectClassIndex, this._interpolationMode = a.interpolationMode, this._resultMode = a.resultMode, this._enabled =
                a.enabled, this._id = a.id, this._type = a.type ? a.type : 0, this._type = a.name ? a.name : "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), a.nestedData && (this._nestedData = a.nestedData, this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), a.additionalInstanceData && (this._additionalInstanceData = a.additionalInstanceData), this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson), this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson))
        }
    }
    e.TrackData = class {
        constructor(a,
            b) {
            this._timelineDataItem = b;
            this._trackDataItems = [];
            this._keyframeTimeMap = new Map;
            e.TimelineDataManager._CreateDataItems(this._trackDataItems, a, d, this)
        }
        Release() {
            this._timelineDataItem = null;
            for (const a of this._trackDataItems) a.Release();
            e.clearArray(this._trackDataItems);
            this._trackDataItems = null;
            this._keyframeTimeMap.clear();
            this._keyframeTimeMap = null
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        AddEmptyTrackDataItem() {
            const a = new d(null, this);
            this._trackDataItems.push(a);
            return a
        }
        GetFirstKeyframeDataItem(a) {
            return a.GetKeyframeData().GetKeyframeDataItemArray()[0]
        }
        GetLastKeyframeDataItem(a) {
            return a.GetKeyframeData().GetKeyframeDataItemArray().at(-1)
        }
        GetKeyFrameDataItemAtTime(a,
            b) {
            const c = this._keyframeTimeMap.get(b);
            if (c && c.has(a)) return c.get(a);
            for (const f of b.GetKeyframeData().keyframeDataItems())
                if (f.GetTime() === a) return c || this._keyframeTimeMap.set(b, new Map), this._keyframeTimeMap.get(b).set(a, f), f
        }
        GetFirstKeyFrameDataItemHigherThan(a, b) {
            for (const c of b.GetKeyframeData().keyframeDataItems())
                if (c.GetTime() > a) return c
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(a, b) {
            for (const c of b.GetKeyframeData().keyframeDataItems())
                if (c.GetTime() >= a) return c
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(a,
            b) {
            for (const c of b.GetKeyframeData().keyframeDataItemsReverse())
                if (c.GetTime() <= a) return c
        }* trackDataItems() {
            for (const a of this._trackDataItems) yield a
        }
        _SaveToJson() {
            return {
                trackDataItemsJson: this._trackDataItems.map(a => a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && e.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, a.trackDataItemsJson, d, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor(a, b) {
            this._propertyTrackData = b;
            this._sourceAdapterId = "";
            this._type = this._property = this._sourceAdapterArguments = null;
            this._max = this._min = NaN;
            this._resultMode = this._interpolationMode = "default";
            this._enabled = !1;
            this._propertyKeyframeData = null;
            a && (this._sourceAdapterId = a[0][0], this._sourceAdapterArguments = a[0].slice(1), this._property = a[1], this._type = a[2], this._min = a[3], this._max = a[4], this._interpolationMode = a[5], this._resultMode = a[6], this._enabled = !!a[7],
                this._propertyKeyframeData = new e.PropertyKeyframeData(a[8], this))
        }
        Release() {
            this._propertyKeyframeData.Release();
            this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetPropertyKeyframeData() {
            this._propertyKeyframeData || (this._propertyKeyframeData = new e.PropertyKeyframeData(null, this));
            return this._propertyKeyframeData
        }
        GetSourceAdapterId() {
            return this._sourceAdapterId
        }
        SetSourceAdapterId(a) {
            this._sourceAdapterId =
                a
        }
        GetSourceAdapterArguments() {
            return this._sourceAdapterArguments
        }
        SetSourceAdapterArguments(a) {
            this._sourceAdapterArguments = a
        }
        GetProperty() {
            return this._property
        }
        SetProperty(a) {
            this._property = a
        }
        GetType() {
            return this._type
        }
        SetType(a) {
            this._type = a
        }
        GetMin() {
            return this._min
        }
        SetMin(a) {
            this._min = a
        }
        GetMax() {
            return this._max
        }
        SetMax(a) {
            this._max = a
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(a) {
            this._interpolationMode = a
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(a) {
            this._resultMode =
                a
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(a) {
            this._enabled = !!a
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
                sourceAdapterId: this._sourceAdapterId,
                sourceAdapterArguments: this._sourceAdapterArguments,
                property: this._property,
                type: this._type,
                min: this._min,
                max: this._max,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled
            }
        }
        _LoadFromJson(a) {
            a && (this._sourceAdapterId = a.sourceAdapterId, this._sourceAdapterArguments = a.sourceAdapterArguments,
                this._property = a.property, this._type = a.type, this._min = a.min, this._max = a.max, this._interpolationMode = a.interpolationMode, this._resultMode = a.resultMode, this._enabled = a.enabled, this.GetPropertyKeyframeData()._LoadFromJson(a.propertyKeyframeDataJson))
        }
    }
    e.PropertyTrackData = class {
        constructor(a, b) {
            this._trackDataItem = b;
            this._propertyTrackDataItems = [];
            this._propertyKeyframeTimeMap = new Map;
            e.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, a, d, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const a of this._propertyTrackDataItems) a.Release();
            e.clearArray(this._propertyTrackDataItems);
            this._propertyTrackDataItems = null;
            this._propertyKeyframeTimeMap.clear();
            this._propertyKeyframeTimeMap = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        AddEmptyPropertyTrackDataItem() {
            const a = new d(null, this);
            this._propertyTrackDataItems.push(a);
            return a
        }
        GetFirstPropertyKeyframeDataItem(a) {
            return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
        }
        GetLastPropertyKeyframeDataItem(a) {
            return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1)
        }
        GetPropertyKeyFrameDataItemAtTime(a,
            b) {
            const c = this._propertyKeyframeTimeMap.get(b);
            if (c && c.has(a)) return c.get(a);
            const f = b.GetPropertyKeyframeData();
            for (const h of f.propertyKeyframeDataItems())
                if (h.GetTime() === a) return c || this._propertyKeyframeTimeMap.set(b, new Map), this._propertyKeyframeTimeMap.get(b).set(a, h), h
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(a, b) {
            b = b.GetPropertyKeyframeData();
            for (const c of b.propertyKeyframeDataItems())
                if (c.GetTime() > a) return c
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b) {
            b = b.GetPropertyKeyframeData();
            for (const c of b.propertyKeyframeDataItems())
                if (c.GetTime() >= a) return c
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b) {
            b = b.GetPropertyKeyframeData();
            for (const c of b.propertyKeyframeDataItemsReverse())
                if (c.GetTime() <= a) return c
        }* propertyTrackDataItems() {
            for (const a of this._propertyTrackDataItems) yield a
        }
        _SaveToJson() {
            return {
                propertyTrackDataItemsJson: this._propertyTrackDataItems.map(a => a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && e.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems,
                a.propertyTrackDataItemsJson, d, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor(a, b) {
            this._keyframeData = b;
            this._time = -1;
            this._ease = "noease";
            this._enable = !1;
            this._lowerTags = this._tags = null;
            a && (this._time = a[0], this._ease = a[1], this._enable = !!a[2], this._tags = (a = a[3]) ? a.split(" ") : [], this._lowerTags = new Set(this._tags.map(c => c.toLowerCase())))
        }
        Release() {
            this._keyframeData = null;
            e.clearArray(this._tags);
            this._tags = null;
            this._lowerTags.clear();
            this._lowerTags = null
        }
        GetKeyframeData() {
            return this._keyframeData
        }
        GetTime() {
            return this._time
        }
        SetTime(a) {
            this._time = a
        }
        GetEase() {
            return this._ease
        }
        SetEase(a) {
            this._ease =
                a
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(a) {
            this._enable = !!a
        }
        GetTags() {
            return this._tags
        }
        SetTags(a) {
            this._tags = a ? a.split(" ") : [];
            this._lowerTags = new Set(this._tags.map(b => b.toLowerCase()))
        }
        GetLowerTags() {
            return this._lowerTags
        }
        HasTag(a) {
            return this._lowerTags.has(a.toLowerCase())
        }
        _SaveToJson() {
            return {
                time: this._time,
                ease: this._ease,
                enable: this._enable,
                tags: this._tags
            }
        }
        _LoadFromJson(a) {
            a && (this._time = a.time, this._ease = a.ease, this._enable = a.enable, this._tags = a.tags, this._lowerTags = new Set(this._tags.map(b =>
                b.toLowerCase())))
        }
    }
    e.KeyframeData = class {
        constructor(a, b) {
            this._trackDataItem = b;
            this._keyframeDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._keyframeDataItems, a, d, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const a of this._keyframeDataItems) a.Release();
            e.clearArray(this._keyframeDataItems);
            this._keyframeDataItems = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetKeyframeDataItemCount() {
            return this._keyframeDataItems.length
        }
        GetKeyframeDataItemArray() {
            return this._keyframeDataItems
        }
        AddEmptyKeyframeDataItem() {
            const a =
                new d(null, this);
            this._keyframeDataItems.push(a);
            return a
        }
        DeleteKeyframeDataItems(a) {
            for (const b of this._keyframeDataItems) {
                if (!a(b)) continue;
                const c = this._keyframeDataItems.indexOf(b); - 1 !== c && (b.Release(), this._keyframeDataItems.splice(c, 1))
            }
            this.SortKeyframeDataItems()
        }
        SortKeyframeDataItems() {
            this._keyframeDataItems.sort((a, b) => a.GetTime() - b.GetTime())
        }
        GetKeyframeDataItemIndex(a) {
            return this._keyframeDataItems.indexOf(a)
        }
        GetKeyframeDataItemFromIndex(a) {
            return this._keyframeDataItems[a]
        }* keyframeDataItems() {
            for (const a of this._keyframeDataItems) yield a
        }* keyframeDataItemsReverse() {
            for (let a =
                    this._keyframeDataItems.length - 1; 0 <= a; a--) yield this._keyframeDataItems[a]
        }
        _SaveToJson() {
            return {
                keyframeDataItemsJson: this._keyframeDataItems.map(a => a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && e.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, a.keyframeDataItemsJson, d, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor(a, b) {
            this._propertyKeyframeData = b;
            this._aValue = this._value = null;
            this._type = "";
            this._time = NaN;
            this._ease = "noease";
            this._enable = !1;
            this._addonData = null;
            a && (this._value = a[0][0], this._aValue = a[0][1], this._type = a[0][2], this._time = a[1], this._ease = a[2], this._enable = !!a[3], this._addonData = null, a[4] && (this._addonData = new e.AddonData(a[4], this)))
        }
        Release() {
            this._propertyKeyframeData = null;
            this._addonData && (this._addonData.Release(), this._addonData = null)
        }
        GetAddonData() {
            return this._addonData
        }
        GetValue() {
            return this._value
        }
        SetValue(a) {
            "color" ===
            this._type && e.IsFiniteNumber(a) ? (this._value[0] = e.GetRValue(a), this._value[1] = e.GetGValue(a), this._value[2] = e.GetBValue(a)) : this._value = a
        }
        GetAbsoluteValue() {
            return this._aValue
        }
        SetAbsoluteValue(a) {
            "color" === this._type && e.IsFiniteNumber(a) ? (this._aValue[0] = e.GetRValue(a), this._aValue[1] = e.GetGValue(a), this._aValue[2] = e.GetBValue(a)) : this._aValue = a
        }
        GetValueWithResultMode() {
            const a = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
            if ("relative" === a) return this.GetValue();
            if ("absolute" ===
                a) return this.GetAbsoluteValue()
        }
        GetType() {
            return this._type
        }
        SetType(a) {
            this._type = a
        }
        GetTime() {
            return this._time
        }
        SetTime(a) {
            this._time = a
        }
        GetEase() {
            return this._ease
        }
        SetEase(a) {
            this._ease = a
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(a) {
            this._enable = !!a
        }
        GetAddOn(a) {
            if (this.GetAddonData())
                for (const b of this.GetAddonData().addonDataItems())
                    if (b.GetId() === a) return b
        }
        _SaveToJson() {
            const a = this._addonData;
            return {
                addonDataJson: a ? a._SaveToJson() : a,
                value: this._value,
                aValue: this._aValue,
                type: this._type,
                time: this._time,
                ease: this._ease,
                enable: this._enable
            }
        }
        _LoadFromJson(a) {
            a && (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson), this._value = a.value, this._aValue = a.aValue, this._type = a.type, this._time = a.time, this._ease = a.ease, this._enable = a.enable)
        }
    }
    e.PropertyKeyframeData = class {
        constructor(a, b) {
            this._propertyTrackDataItem = b;
            this._propertyKeyframeDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, a, d, this)
        }
        Release() {
            this._propertyTrackDataItem = null;
            for (const a of this._propertyKeyframeDataItems) a.Release();
            e.clearArray(this._propertyKeyframeDataItems);
            this._propertyKeyframeDataItems = null
        }
        AddEmptyPropertyKeyframeDataItem() {
            const a = new d(null, this);
            this._propertyKeyframeDataItems.push(a);
            return a
        }
        DeletePropertyKeyframeDataItems(a) {
            for (const b of this._propertyKeyframeDataItems) {
                if (!a(b)) continue;
                const c = this._propertyKeyframeDataItems.indexOf(b); - 1 !== c && (b.Release(), this._propertyKeyframeDataItems.splice(c, 1))
            }
            this.SortPropertyKeyFrameDataItems()
        }
        SortPropertyKeyFrameDataItems() {
            this._propertyKeyframeDataItems.sort((a,
                b) => a.GetTime() - b.GetTime())
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyKeyframeDataItemCount() {
            return this._propertyKeyframeDataItems.length
        }
        GetPropertyKeyframeDataItemArray() {
            return this._propertyKeyframeDataItems
        }* propertyKeyframeDataItems() {
            for (const a of this._propertyKeyframeDataItems) yield a
        }* propertyKeyframeDataItemsReverse() {
            for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--) yield this._propertyKeyframeDataItems[a]
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(a =>
                    a._SaveToJson())
            }
        }
        _LoadFromJson(a) {
            a && e.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, a.propertyKeyframeDataItemsJson, d, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor(c, f) {
            this._addonData = f;
            this._id = c[0];
            this._data = c[1]
        }
        Release() {
            this._data = this._addonData = null
        }
        GetAddonData() {
            return this._addonData
        }
        GetId() {
            return this._id
        }
        _SaveToJson() {
            return {
                id: this._id,
                data: this._data
            }
        }
        _LoadFromJson(c) {
            c && (this._id = c.id, this._data = c.data)
        }
    }
    class a extends d {
        constructor(c, f) {
            super(c, f);
            this._startAnchor = this._data[0];
            this._startEnable = !!this._data[1];
            this._endAnchor = this._data[2];
            this._endEnable = !!this._data[3]
        }
        Release() {
            super.Release()
        }
        GetStartAnchor() {
            return this._startAnchor
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndAnchor() {
            return this._endAnchor
        }
        GetEndEnable() {
            return this._endEnable
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                startAnchor: this._startAnchor,
                startEnable: !!this._startEnable,
                endAnchor: this._endAnchor,
                endEnable: !!this._endEnable
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._startAnchor = c.startAnchor, this._startEnable = !!c.startEnable, this._endAnchor = c.endAnchor, this._endEnable = !!c.endEnable)
        }
    }
    class b extends d {
        constructor(c, f) {
            super(c, f);
            this._direction = this._data[0];
            this._revolutions = this._data[1]
        }
        Release() {
            super.Release()
        }
        GetDirection() {
            return this._direction
        }
        GetRevolutions() {
            return this._revolutions
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                direction: this._direction,
                revolutions: this._revolutions
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._direction = c.direction, this._revolutions = c.revolutions)
        }
    }
    e.AddonData = class {
        constructor(c, f) {
            this._propertyKeyframeDataItem = f;
            this._addonDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._addonDataItems, c, {
                prop: 0,
                map: new Map([
                    ["cubic-bezier", a],
                    ["angle", b]
                ])
            }, this)
        }
        Release() {
            this._propertyKeyframeDataItem = null;
            for (const c of this._addonDataItems) c.Release();
            e.clearArray(this._addonDataItems);
            this._addonDataItems = null
        }
        GetPropertyKeyframeDataItem() {
            return this._propertyKeyframeDataItem
        }* addonDataItems() {
            for (const c of this._addonDataItems) yield c
        }
        _SaveToJson() {
            return {
                addonDataItemsJson: this._addonDataItems.map(c => c._SaveToJson())
            }
        }
        _LoadFromJson(c) {
            c && e.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, c.addonDataItemsJson, {
                prop: "id",
                map: new Map([
                    ["cubic-bezier", a],
                    ["angle", b]
                ])
            }, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    let d = 0;
    e.Tween = class extends e.TimelineState {
        constructor(a, b) {
            super(`tween-${d++}`, a, b);
            this._id = "";
            this._destroyInstanceOnComplete = !1;
            this._initialValueMode = "start-value";
            this._on_started_callbacks = this._on_completed_callbacks = null
        }
        GetInstance() {
            var a = this.GetTracks();
            if (a && a.length && (a = a[0])) {
                var b = a.GetInstance();
                return a.IsInstanceValid() ? b : null
            }
        }
        AddStartedCallback(a) {
            this._on_started_callbacks || (this._on_started_callbacks = []);
            this._on_started_callbacks.push(a)
        }
        AddCompletedCallback(a) {
            this._on_completed_callbacks ||
                (this._on_completed_callbacks = []);
            this._on_completed_callbacks.push(a)
        }
        RemoveStartedCallback(a) {
            this._on_started_callbacks && (a = this._on_started_callbacks.indexOf(a), -1 !== a && this._on_started_callbacks.splice(a, 1))
        }
        RemoveCompletedCallback(a) {
            this._on_completed_callbacks && (a = this._on_completed_callbacks.indexOf(a), -1 !== a && this._on_completed_callbacks.splice(a, 1))
        }
        SetStartValue(a, b) {
            for (const f of this._tracks)
                for (const h of f._propertyTracks) {
                    if (h.GetPropertyName() !== b) continue;
                    var c = h.GetPropertyTrackData();
                    const g = h.GetPropertyTrackDataItem();
                    c = c.GetFirstPropertyKeyframeDataItem(g);
                    c.SetValue(a);
                    c.SetAbsoluteValue(a)
                }
        }
        _GetPropertyTrackState(a) {
            for (const b of this._tracks)
                for (const c of b._propertyTracks)
                    if (c.GetPropertyName() === a) return c
        }
        BeforeSetEndValues(a) {
            for (const f of a) a = this._GetPropertyTrackState(f), this.SetStartValue(a.GetCurrentState(), f);
            if (this.IsForwardPlayBack()) {
                var b = this.GetTotalTime() - this.GetTime();
                this.SetTotalTime(b);
                for (var c of this._tracks) c.SetLocalTotalTime(b);
                this._SetTime(0)
            } else {
                c =
                    this.GetTime();
                this.SetTotalTime(c);
                for (b of this._tracks) b.SetLocalTotalTime(c);
                this._SetTime(c)
            }
            this.SetInitialStateFromSetTime()
        }
        SetEndValue(a, b) {
            var c = this._GetPropertyTrackState(b);
            b = c.GetPropertyTrackData();
            c = c.GetPropertyTrackDataItem();
            b = b.GetLastPropertyKeyframeDataItem(c);
            b.SetTime(this.GetTotalTime());
            b.SetValue(a);
            b.SetAbsoluteValue(a)
        }
        SetId(a) {
            this._id = a
        }
        GetId() {
            return this._id
        }
        SetInitialValueMode(a) {
            this._initialValueMode = a
        }
        GetInitialValueMode() {
            return this._initialValueMode
        }
        SetDestroyInstanceOnComplete(a) {
            this._destroyInstanceOnComplete =
                a
        }
        GetDestroyInstanceOnComplete() {
            return this._destroyInstanceOnComplete
        }
        OnStarted() {
            if (this._on_started_callbacks)
                for (const a of this._on_started_callbacks) a(this);
            if (!this.IsComplete())
                for (const a of this._tracks) a.CompareSaveStateWithCurrent()
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            if (!this._finishedTriggers && (this._finishedTriggers = !0, this._on_completed_callbacks))
                for (const a of this._on_completed_callbacks) a(this)
        }
        SetTime(a) {
            this._DeleteIntermediateKeyframes();
            super.SetTime(a)
        }
        SetInitialState(a) {
            if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode())
                for (const b of this._tracks) b.CompareInitialStateWithCurrent();
            super.SetInitialState(a)
        }
        Stop(a = !1) {
            super.Stop(a);
            if (!this.IsComplete())
                for (const b of this._tracks) b.SaveState()
        }
        Reset(a = !0, b = !1) {
            this._DeleteIntermediateKeyframes();
            super.Reset(a, b)
        }
        _DeleteIntermediateKeyframes() {
            for (const a of this._tracks) {
                const b = c => {
                    c = c.GetTime();
                    const f = this.GetTotalTime();
                    return 0 !== c && c !== f
                };
                a.DeleteKeyframes(b);
                a.DeletePropertyKeyframes(b)
            }
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            const a = this.GetInstance();
            if (a && a.GetObjectClass().IsGlobal()) return !1;
            this._timelineManager.CompleteTimeline(this);
            this.ResetBeforeChangeLayout();
            return !0
        }
        MaybeTriggerKeyframeReachedConditions() {}
        Tick(a, b) {
            a = this.GetInstance();
            a = this.GetRuntime().GetDt(a);
            super.Tick(a, 1)
        }
        _SaveToJson() {
            const a = super._SaveToJson(),
                b = this.GetTimelineDataItem();
            return Object.assign(a, {
                tweenDataItemJson: b._SaveToJson(),
                id: this._id,
                destroyInstanceOnComplete: this._destroyInstanceOnComplete,
                initialValueMode: this._initialValueMode
            })
        }
        _LoadFromJson(a) {
            a && (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson), super._LoadFromJson(a), this._id = a.id, this._destroyInstanceOnComplete = a.destroyInstanceOnComplete, this._initialValueMode = a.initialValueMode)
        }
        static IsPlaying(a) {
            return a.IsPlaying()
        }
        static IsPaused(a) {
            return a.IsPaused()
        }
        static Build(a) {
            var b = a.runtime.GetTimelineManager(),
                c = new e.TimelineDataItem;
            if (a.json) {
                c._LoadFromJson(a.json.tweenDataItemJson);
                var f = new e.Tween(c, b);
                f._LoadFromJson(a.json);
                return f
            }
            b = new e.Tween(c, b);
            e.IsArray(a.propertyTracksConfig) || (a.propertyTracksConfig = [a.propertyTracksConfig]);
            b.SetId(a.id);
            b.SetTags(a.tags);
            b.SetInitialValueMode(a.initialValueMode);
            b.SetDestroyInstanceOnComplete(a.releaseOnComplete);
            b.SetLoop(a.loop);
            b.SetPingPong(a.pingPong);
            b.SetTotalTime(a.time);
            b.SetStep(0);
            b.SetInterpolationMode("default");
            b.SetResultMode(a.propertyTracksConfig[0].resultMode);
            c = b.AddTrack();
            c.SetInstanceUID(a.instance.GetUID());
            c.SetInterpolationMode("default");
            c.SetResultMode(a.propertyTracksConfig[0].resultMode);
            c.SetEnable(!0);
            c.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex());
            var h = a.instance.GetSdkInstance(),
                g = h.IsOriginalSizeKnown() ? h.GetOriginalWidth() : a.instance.GetWorldInfo().GetWidth();
            h = h.IsOriginalSizeKnown() ? h.GetOriginalHeight() : a.instance.GetWorldInfo().GetHeight();
            c.SetOriginalWidth(g);
            c.SetOriginalHeight(h);
            g = c.AddKeyframe();
            g.SetTime(0);
            g.SetEase("noease");
            g.SetEnable(!0);
            g.SetTags("");
            g = c.AddKeyframe();
            g.SetTime(a.time);
            g.SetEase("noease");
            g.SetEnable(!0);
            g.SetTags("");
            for (f of a.propertyTracksConfig) g =
                c.AddPropertyTrack(), g.SetSourceAdapterId(f.sourceId), g.SetSourceAdapterArgs(f.sourceArgs), g.SetPropertyName(f.property), g.SetPropertyType(f.type), g.SetMin(NaN), g.SetMax(NaN), g.SetInterpolationMode("default"), g.SetResultMode(f.resultMode), g.SetEnable(!0), h = g.AddPropertyKeyframe(), h.SetType(f.valueType), h.SetTime(0), h.SetEase(f.ease), h.SetEnable(!0), h.SetValue(f.startValue), h.SetAbsoluteValue(f.startValue), g = g.AddPropertyKeyframe(), g.SetType(f.valueType), g.SetTime(a.time), g.SetEase(f.ease), g.SetEnable(!0),
                g.SetValue(f.endValue), g.SetAbsoluteValue(f.endValue);
            return b
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.Ease;
    e.Transition = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._name = a[0];
            this._transitionKeyframes = [];
            for (const b of a[1]) a = e.TransitionKeyframe.Create(this, b), this._transitionKeyframes.push(a);
            this._precalculatedSamples = new Map;
            this._transitionKeyframeCache = new Map;
            this._PreCalcSamples();
            d.AddCustomEase(this._name, (b, c, f, h) => this.Interpolate(b, c, f, h))
        }
        static Create(a) {
            return e.New(e.Transition, a)
        }
        Release() {
            for (const a of this._transitionKeyframes) a.Release();
            e.clearArray(this._transitionKeyframes);
            this._transitionKeyframes = null;
            this._precalculatedSamples.clear();
            this._precalculatedSamples = null;
            this._transitionKeyframeCache.clear();
            this._transitionKeyframeCache = null
        }
        GetTransitionKeyFrameAt(a) {
            const b = this._transitionKeyframeCache.get(a);
            if (b) return b;
            for (const c of this._transitionKeyframes)
                if (c.GetValueX() === a) return this._transitionKeyframeCache.set(a, c), c
        }
        GetFirstTransitionKeyFrameHigherThan(a) {
            for (const b of this._transitionKeyframes)
                if (b.GetValueX() >
                    a) return b
        }
        GetFirstTransitionKeyFrameHigherOrEqualThan(a) {
            for (const b of this._transitionKeyframes)
                if (b.GetValueX() >= a) return b
        }
        GetFirstTransitionKeyFrameLowerOrEqualThan(a) {
            for (let b = this._transitionKeyframes.length - 1; 0 <= b; b--) {
                const c = this._transitionKeyframes[b];
                if (c.GetValueX() <= a) return c
            }
        }
        Interpolate(a, b, c, f) {
            var h = a / f;
            (a = this.GetTransitionKeyFrameAt(h)) ? f = this.GetFirstTransitionKeyFrameHigherThan(h): (a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(h), f = this.GetFirstTransitionKeyFrameHigherOrEqualThan(h));
            var g = f.GetValueX() - a.GetValueX();
            h = e.mapToRange(h, a.GetValueX(), f.GetValueX(), 0, g);
            g = a.GetValueX();
            const k = a.GetValueY(),
                m = a.GetValueX() + a.GetStartAnchorX(),
                r = a.GetValueY() + a.GetStartAnchorY(),
                w = f.GetValueX() + f.GetEndAnchorX(),
                p = f.GetValueY() + f.GetEndAnchorY(),
                t = f.GetValueX();
            f = f.GetValueY();
            f = d.GetRuntimeEase("spline")(h, g, k, m, r, w, p, t, f, this._precalculatedSamples.get(a));
            f += a.GetValueY();
            return (1 - f) * b + f * (b + c)
        }
        _PreCalcSamples() {
            this._precalculatedSamples.clear();
            for (let c = 0; c < this._transitionKeyframes.length -
                1; c++) {
                var a = this._transitionKeyframes[c];
                if (!a.GetStartEnable()) continue;
                var b = this._transitionKeyframes[c + 1];
                const f = a.GetValueX(),
                    h = a.GetValueX() + a.GetStartAnchorX(),
                    g = b.GetValueX() + b.GetEndAnchorX();
                b = b.GetValueX();
                this._precalculatedSamples.set(a, d.GetBezierSamples(f, h, g, b))
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TransitionKeyframe = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._transition = d;
            this._valueX = a[0];
            this._valueY = a[1];
            this._startAnchorX = a[2];
            this._startAnchorY = a[3];
            this._endAnchorX = a[4];
            this._endAnchorY = a[5];
            this._startEnable = a[6];
            this._endEnable = a[7]
        }
        Release() {
            this._transition = null
        }
        static Create(d, a) {
            return e.New(e.TransitionKeyframe, d, a)
        }
        GetValueX() {
            return this._valueX
        }
        GetValueY() {
            return this._valueY
        }
        GetStartAnchorX() {
            return this._startAnchorX
        }
        GetStartAnchorY() {
            return this._startAnchorY
        }
        GetEndAnchorX() {
            return this._endAnchorX
        }
        GetEndAnchorY() {
            return this._endAnchorY
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndEnable() {
            return this._endEnable
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TransitionManager = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._runtime = d;
            this._transitions = []
        }
        Release() {
            for (const d of this._transitions) d.Release();
            e.clearArray(this._transitions);
            this._transitions = null
        }
        Create(d) {
            this._transitions.push(e.Transition.Create(d))
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SolStack = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._objectClass = d;
            this._stack = [];
            this._stack.push(e.New(e.Sol, this));
            this._index = 0;
            this._current = this._stack[0]
        }
        Release() {
            for (const d of this._stack) d.Release();
            e.clearArray(this._stack);
            this._objectClass = this._current = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetCurrentSol() {
            return this._current
        }
        Clear() {
            this.GetCurrentSol().Clear()
        }
        PushClean() {
            var d = this._stack,
                a = ++this._index;
            a === d.length ? (a = e.New(e.Sol,
                this), d.push(a), this._current = a) : (d = d[a], d.Reset(), this._current = d)
        }
        PushCopy() {
            const d = this._stack,
                a = ++this._index;
            a === d.length && d.push(e.New(e.Sol, this));
            const b = d[a];
            b.Copy(d[a - 1]);
            this._current = b
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
        RemoveInstances(d) {
            const a = this._stack;
            for (let b = 0, c = a.length; b < c; ++b) a[b].RemoveInstances(d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Sol = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._stack = d;
            this._objectClass = this._stack.GetObjectClass();
            this._eventStack = this._objectClass.GetRuntime().GetEventStack();
            this._selectAll = !0;
            this._instances = [];
            this._elseInstances = []
        }
        Release() {
            this.ClearArrays();
            this._eventStack = this._objectClass = this._stack = null
        }
        ClearArrays() {
            e.clearArray(this._instances);
            e.clearArray(this._elseInstances)
        }
        GetObjectClass() {
            return this._objectClass
        }
        IsSelectAll() {
            return this._selectAll
        }
        HasAnyInstances() {
            return this._selectAll ?
                !!this._objectClass.GetInstanceCount() : !!this._instances.length
        }
        GetInstances() {
            return this._selectAll ? this._objectClass.GetInstances() : this._instances
        }
        HasAnyElseInstances() {
            return !!this._elseInstances.length
        }
        GetElseInstances() {
            return this._elseInstances
        }
        GetExpressionInstances() {
            const d = this.GetInstances();
            return d.length ? d : this._elseInstances
        }
        Reset() {
            this._selectAll = !0;
            e.clearArray(this._elseInstances)
        }
        Clear() {
            this._selectAll = !0
        }
        Copy(d) {
            d.IsSelectAll() ? this.Reset() : (this._selectAll = !1, e.shallowAssignArray(this._instances,
                d._instances), e.clearArray(this._elseInstances))
        }
        _PushInstance(d) {
            this._instances.push(d)
        }
        _PushElseInstance(d) {
            this._elseInstances.push(d)
        }
        _SetSelectAll(d) {
            this._selectAll = !!d
        }
        _GetOwnInstances() {
            return this._instances
        }
        _GetOwnElseInstances() {
            return this._elseInstances
        }
        SetSinglePicked(d) {
            this._selectAll = !1;
            e.clearArray(this._instances);
            this._instances.push(d)
        }
        SetArrayPicked(d) {
            this._selectAll = !1;
            e.shallowAssignArray(this._instances, d)
        }
        SetSetPicked(d) {
            this._selectAll = !1;
            e.clearArray(this._instances);
            for (const a of d) this._instances.push(a)
        }
        AddElseInstances(d, a) {
            for (const b of a) d.has(b) || this._elseInstances.push(b)
        }
        TransferElseInstancesToOwn(d) {
            for (const a of d) this._instances.push(a);
            e.arrayRemoveAllInSet(this._elseInstances, d)
        }
        PickOne(d) {
            d && (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock() ? (this.IsSelectAll() && (e.clearArray(this._instances), e.shallowAssignArray(this._elseInstances, d.GetObjectClass().GetInstances()), this._selectAll = !1), d = this._elseInstances.indexOf(d), -1 !==
                d && (this._instances.push(this._elseInstances[d]), this._elseInstances.splice(d, 1))) : this.SetSinglePicked(d))
        }
        RemoveInstances(d) {
            e.arrayRemoveAllInSet(this._instances, d);
            e.arrayRemoveAllInSet(this._elseInstances, d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EventStack = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._eventSheetManager = d;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._stack.push(e.New(e.EventStackFrame, this, null));
            this._index = 0;
            this._expFuncStack = []
        }
        Release() {
            for (const d of this._stack) d.Release();
            e.clearArray(this._stack);
            e.clearArray(this._expFuncStack);
            this._runtime = this._eventSheetManager = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrentStackFrame() {
            return this._stack[this._index]
        }
        Push(d) {
            var a =
                this._stack;
            const b = ++this._index;
            if (b === a.length) return d = e.New(e.EventStackFrame, this, d), a.push(d), d;
            a = a[b];
            a.Reset(d);
            return a
        }
        Pop() {
            --this._index
        }
        PushExpFunc(d) {
            this._expFuncStack.push(d)
        }
        PopExpFunc() {
            this._expFuncStack.pop()
        }
        GetCurrentExpFuncStackFrame() {
            const d = this._expFuncStack;
            return 0 === d.length ? null : d.at(-1)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EventStackFrame = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._stack = d;
            this._runtime = this._stack.GetRuntime();
            this._currentEvent = a;
            this._actIndex = this._cndIndex = 0;
            this._elseBranchRan = this._lastEventTrue = !1;
            this._expressionObjectClass = null;
            this._functionReturnValue = this._functionReturnType = 0
        }
        Release() {
            this.Reset(null);
            this._runtime = this._stack = null
        }
        Reset(d) {
            this._currentEvent = d;
            this._actIndex = this._cndIndex = 0;
            this._elseBranchRan = this._lastEventTrue = !1
        }
        _Restore(d,
            a) {
            this._currentEvent = d;
            this._cndIndex = 0;
            this._actIndex = a
        }
        ResetQuick() {
            this._actIndex = this._cndIndex = 0
        }
        GetCurrentEvent() {
            return this._currentEvent
        }
        SetCurrentEvent(d) {
            this._currentEvent = d
        }
        GetConditionIndex() {
            return this._cndIndex
        }
        SetConditionIndex(d) {
            this._cndIndex = d
        }
        GetActionIndex() {
            return this._actIndex
        }
        SetActionIndex(d) {
            this._actIndex = d
        }
        SetLastEventTrue(d) {
            this._lastEventTrue = !!d
        }
        GetLastEventTrue() {
            return this._lastEventTrue
        }
        SetElseBranchRan(d) {
            this._elseBranchRan = !!d
        }
        GetElseBranchRan() {
            return this._elseBranchRan
        }
        SetExpressionObjectClass(d) {
            this._expressionObjectClass =
                d
        }
        GetExpressionObjectClass() {
            return this._expressionObjectClass
        }
        InitCallFunctionExpression(d, a) {
            this._functionReturnType = d;
            this._functionReturnValue = a
        }
        GetFunctionReturnType() {
            return this._functionReturnType
        }
        SetFunctionReturnValue(d) {
            this._functionReturnValue = d
        }
        GetFunctionReturnValue() {
            return this._functionReturnValue
        }
        IsSolModifierAfterCnds() {
            const d = this._currentEvent;
            return d.IsSolWriterAfterCnds() ? !0 : this._cndIndex < d.GetConditionCount() - 1 ? !!d.GetSolModifiers().length : !1
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.LocalVarStack = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._eventSheetManager = d;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._index = -1;
            this._current = null;
            this._initialValues = []
        }
        Release() {
            e.clearArray(this._stack);
            this._runtime = this._eventSheetManager = null
        }
        _SetInitialValues(d) {
            this._initialValues = d;
            d = this._initialValues.slice(0);
            this._stack.push(d);
            this._index = 0;
            this._current = d
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrent() {
            return this._current
        }
        Push() {
            const d =
                ++this._index,
                a = this._stack;
            d === a.length ? a.push(this._initialValues.slice(0)) : e.shallowAssignArray(a[d], this._initialValues);
            this._current = a[d]
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.LoopStack = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._eventSheetManager = d;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._index = -1
        }
        Release() {
            e.clearArray(this._stack);
            this._runtime = this._eventSheetManager = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        IsInLoop() {
            return 0 <= this._index
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            ++this._index;
            if (this._index === this._stack.length) {
                var d =
                    e.New(e.Loop, this);
                this._stack.push(d);
                return d
            }
            d = this._stack[this._index];
            d.Reset();
            return d
        }
        Pop() {
            --this._index
        }
        FindByName(d) {
            const a = this._stack;
            for (let b = this._index; 0 <= b; --b) {
                const c = a[b];
                if (c.GetName() === d) return c
            }
            return null
        }
        _GetStack() {
            return this._stack.slice(0, this._index + 1)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Loop = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._loopStack = d;
            this._name = "";
            this._index = 0;
            this._isStopped = !1;
            this._end = NaN
        }
        Reset() {
            this._name = "";
            this._index = 0;
            this._isStopped = !1;
            this._end = NaN
        }
        SetName(d) {
            this._name = d
        }
        GetName() {
            return this._name
        }
        SetIndex(d) {
            this._index = d
        }
        GetIndex() {
            return this._index
        }
        Stop() {
            this._isStopped = !0
        }
        IsStopped() {
            return this._isStopped
        }
        SetEnd(d) {
            this._end = d
        }
        GetEnd() {
            return this._end
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ArrayStack = class extends e.DefendedBase {
        constructor() {
            super();
            this._stack = [];
            this._index = -1
        }
        Release() {
            e.clearArray(this._stack)
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            ++this._index;
            if (this._index === this._stack.length) {
                const d = [];
                this._stack.push(d);
                return d
            }
            return this._stack[this._index]
        }
        Pop() {
            --this._index
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(b, c) {
        return b.GetIndex() - c.GetIndex()
    }

    function a(b, c) {
        for (let f = 0, h = b.length; f < h; ++f)
            if (b[f] !== c[f]) return !1;
        return !0
    }
    e.EventSheetManager = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b;
            this._allSheets = [];
            this._sheetsByName = new Map;
            this._allGroups = [];
            this._groupsByName = new Map;
            this._blocksBySid = new Map;
            this._cndsBySid = new Map;
            this._actsBySid = new Map;
            this._allUniqueSolModifiers = new Map;
            this._eventVarsBySid = new Map;
            this._nextLocalVarIndex =
                0;
            this._allGlobalVars = [];
            this._allLocalVars = [];
            this._localVarInitialValues = [];
            this._functionBlocksByName = new Map;
            this._eventStack = e.New(e.EventStack, this);
            this._localVarStack = e.New(e.LocalVarStack, this);
            this._loopStack = e.New(e.LoopStack, this);
            this._triggersToPostInit = [];
            this._queuedTriggers = [];
            this._queuedDebugTriggers = [];
            this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0;
            this._scheduledWaits = [];
            this._asyncActionPromises = [];
            self.c3_callFunction = (c, f) => this._InvokeFunctionFromJS(c,
                f)
        }
        Release() {
            this.ClearAllScheduledWaits();
            this._eventStack.Release();
            this._eventStack = null;
            this._localVarStack.Release();
            this._localVarStack = null;
            e.clearArray(this._queuedTriggers);
            e.clearArray(this._queuedDebugTriggers);
            this._runtime = null;
            e.clearArray(this._allSheets);
            this._sheetsByName.clear()
        }
        Create(b) {
            b = e.New(e.EventSheet, this, b);
            this._allSheets.push(b);
            this._sheetsByName.set(b.GetName().toLowerCase(), b)
        }
        _AddTriggerToPostInit(b) {
            this._triggersToPostInit.push(b)
        }
        _PostInit() {
            for (const b of this._functionBlocksByName.values()) b._PostInit(!1);
            for (const b of this._allSheets) b._PostInit();
            for (const b of this._allSheets) b._UpdateDeepIncludes();
            for (const b of this._triggersToPostInit) b._PostInit(!1);
            e.clearArray(this._triggersToPostInit);
            this._localVarStack._SetInitialValues(this._localVarInitialValues)
        }
        GetRuntime() {
            return this._runtime
        }
        GetEventSheetByName(b) {
            return this._sheetsByName.get(b.toLowerCase()) || null
        }
        _RegisterGroup(b) {
            this._allGroups.push(b);
            this._groupsByName.set(b.GetGroupName(), b)
        }
        _RegisterEventBlock(b) {
            this._blocksBySid.set(b.GetSID(),
                b)
        }
        _RegisterCondition(b) {
            this._cndsBySid.set(b.GetSID(), b)
        }
        _RegisterAction(b) {
            this._actsBySid.set(b.GetSID(), b)
        }
        _RegisterFunctionBlock(b) {
            this._functionBlocksByName.set(b.GetFunctionName().toLowerCase(), b)
        }
        _RegisterEventVariable(b) {
            this._eventVarsBySid.set(b.GetSID(), b);
            b.IsGlobal() ? this._allGlobalVars.push(b) : this._allLocalVars.push(b)
        }
        _DeduplicateSolModifierList(b) {
            2 <= b.length && b.sort(d);
            let c = this._allUniqueSolModifiers.get(b.length);
            c || (c = [], this._allUniqueSolModifiers.set(b.length, c));
            for (let f =
                    0, h = c.length; f < h; ++f) {
                const g = c[f];
                if (a(b, g)) return g
            }
            c.push(b);
            return b
        }
        _GetNextLocalVarIndex(b) {
            this._localVarInitialValues.push(b.GetInitialValue());
            return this._nextLocalVarIndex++
        }
        GetEventStack() {
            return this._eventStack
        }
        GetCurrentEventStackFrame() {
            return this.GetEventStack().GetCurrentStackFrame()
        }
        GetCurrentEvent() {
            return this.GetCurrentEventStackFrame().GetCurrentEvent()
        }
        GetCurrentCondition() {
            const b = this.GetCurrentEventStackFrame();
            return b.GetCurrentEvent().GetConditionAt(b.GetConditionIndex())
        }
        GetCurrentAction() {
            const b =
                this.GetCurrentEventStackFrame();
            return b.GetCurrentEvent().GetActionAt(b.GetActionIndex())
        }
        GetLocalVarStack() {
            return this._localVarStack
        }
        GetLoopStack() {
            return this._loopStack
        }
        GetAllLocalVariablesInScope(b) {
            const c = [];
            for (b = b.GetScopeParent(); b;) e.appendArray(c, b._GetAllLocalVariablesInScope()), b = b.GetScopeParent();
            return c
        }
        _GetLocalVariablesScriptInterface(b) {
            const c = {};
            for (const f of this.GetAllLocalVariablesInScope(b)) c[f.GetJsPropName()] = f._GetScriptInterfaceDescriptor();
            return Object.create(Object.prototype,
                c)
        }
        GetEventVariableBySID(b) {
            return this._eventVarsBySid.get(b) || null
        }
        GetEventBlockBySID(b) {
            return this._blocksBySid.get(b) || null
        }
        GetConditionBySID(b) {
            return this._cndsBySid.get(b) || null
        }
        GetActionBySID(b) {
            return this._actsBySid.get(b) || null
        }
        GetFunctionBlockByName(b) {
            return this._functionBlocksByName.get(b.toLowerCase()) || null
        }
        GetAllGlobalVariables() {
            return this._allGlobalVars
        }
        GetAllLocalVariables() {
            return this._allLocalVars
        }
        ResetAllGlobalsToInitialValue() {
            for (const b of this._allGlobalVars) b.ResetToInitialValue()
        }
        GetEventGroupByName(b) {
            return this._groupsByName.get(b.toLowerCase()) ||
                null
        }
        GetEventGroupBySID(b) {
            return (b = this._blocksBySid.get(b)) && b.IsGroup() ? b : null
        }
        GetAllGroups() {
            return this._allGroups
        }
        ResetAllGroupsInitialActivation() {
            for (const b of this._allGroups) b.ResetInitialActivation()
        }
        _ResetAllHasRunFlags() {
            for (const b of this._allSheets) b._ResetHasRunFlag()
        }
        RunEvents(b) {
            this._ResetAllHasRunFlags();
            this._runningEventsDepth++;
            for (const c of b.runningLayouts())
                if (b = c.GetEventSheet()) this._runtime.PushCurrentLayout(c), b.Run(), this._runtime.PopCurrentLayout();
            this._runningEventsDepth--
        }
        async DebugRunEvents(b) {
            this._ResetAllHasRunFlags();
            this._runningEventsDepth++;
            for (const c of this._DebugRunEventsGen(b)) await this._runtime.DebugBreak(c);
            this._runningEventsDepth--
        }* _DebugRunEventsGen(b) {
            for (const c of b.runningLayouts())
                if (b = c.GetEventSheet()) this._runtime.PushCurrentLayout(c), yield* b.DebugRun(), this._runtime.PopCurrentLayout()
        }
        _Trigger(b, c, f, h) {
            let g = !1;
            if (!b.GetMainRunningLayout()) return this.QueueTrigger(c, f, h);
            this._executingTriggerDepth++;
            for (const k of b.runningLayouts())
                if (b = k.GetEventSheet()) {
                    this._runtime.PushCurrentLayout(k);
                    for (const m of b.deepIncludes()) {
                        const r = m._Trigger(c, f, h);
                        g = g || r
                    }
                    b = b._Trigger(c, f, h);
                    g = g || b;
                    this._runtime.PopCurrentLayout()
                }
            this._executingTriggerDepth--;
            return g
        }* _DebugTrigger(b, c, f, h) {
            let g = !1;
            if (!b.GetMainRunningLayout()) return this.QueueTrigger(c, f, h);
            this._executingTriggerDepth++;
            for (const k of b.runningLayouts())
                if (b = k.GetEventSheet()) {
                    this._runtime.PushCurrentLayout(k);
                    for (const m of b.deepIncludes()) {
                        const r = yield* m._DebugTrigger(c, f, h);
                        g = g || r
                    }
                    b = yield* b._DebugTrigger(c, f, h);
                    g = g || b;
                    this._runtime.PopCurrentLayout()
                }
            this._executingTriggerDepth--;
            return g
        }
        QueueTrigger(b, c, f) {
            this._queuedTriggers.push([b, c, f]);
            return !1
        }
        QueueDebugTrigger(b, c, f) {
            let h = null;
            const g = new Promise(k => h = k);
            this._queuedDebugTriggers.push([b, c, f, h]);
            return g
        }* _RunQueuedDebugTriggersGen() {
            if (this._runtime.HitBreakpoint()) throw Error("should not be in breakpoint");
            const b = this._runtime.GetLayoutManager();
            for (; this._queuedDebugTriggers.length;) {
                const [c, f, h, g] = this._queuedDebugTriggers.shift(), k = yield* this._DebugTrigger(b, c, f, h);
                g(k)
            }
        }
        async RunQueuedDebugTriggersAsync() {
            for (const b of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(b)
        }
        _FastTrigger(b,
            c, f, h) {
            let g = !1;
            var k = b.GetMainRunningLayout();
            if (b = k.GetEventSheet()) {
                this._executingTriggerDepth++;
                this._runtime.PushCurrentLayout(k);
                k = b.deepIncludes();
                for (let m = 0, r = k.length; m < r; ++m) {
                    const w = k[m]._FastTrigger(c, f, h);
                    g = g || w
                }
                c = b._FastTrigger(c, f, h);
                g = g || c;
                this._runtime.PopCurrentLayout();
                this._executingTriggerDepth--;
                return g
            }
        }* _DebugFastTrigger(b, c, f, h) {
            let g = !1;
            var k = b.GetMainRunningLayout();
            if (b = k.GetEventSheet()) {
                this._executingTriggerDepth++;
                this._runtime.PushCurrentLayout(k);
                k = b.deepIncludes();
                for (let m = 0, r = k.length; m < r; ++m) {
                    const w = yield* k[m]._DebugFastTrigger(c, f, h);
                    g = g || w
                }
                c = yield* b._DebugFastTrigger(c, f, h);
                g = g || c;
                this._runtime.PopCurrentLayout();
                this._executingTriggerDepth--;
                return g
            }
        }
        GetTriggerDepth() {
            return this._executingTriggerDepth
        }
        IsInTrigger() {
            return 0 < this.GetTriggerDepth()
        }
        _IncTriggerDepth() {
            return ++this._executingTriggerDepth
        }
        _DecTriggerDepth() {
            --this._executingTriggerDepth
        }
        IsRunningEvents() {
            return 0 < this._runningEventsDepth
        }
        IsInEventEngine() {
            return this.IsRunningEvents() ||
                this.IsInTrigger()
        }
        _RunQueuedTriggers(b) {
            for (const [c, f, h] of this._queuedTriggers) this._Trigger(b, c, f, h);
            e.clearArray(this._queuedTriggers)
        }
        BlockFlushingInstances(b) {
            b ? this._blockFlushingDepth++ : this._blockFlushingDepth--
        }
        IsFlushingBlocked() {
            return 0 < this._blockFlushingDepth
        }
        ClearSol(b) {
            for (let c = 0, f = b.length; c < f; ++c) b[c].GetSolStack().Clear()
        }
        PushCleanSol(b) {
            for (let c = 0, f = b.length; c < f; ++c) b[c].GetSolStack().PushClean()
        }
        PushCopySol(b) {
            for (let c = 0, f = b.length; c < f; ++c) b[c].GetSolStack().PushCopy()
        }
        PopSol(b) {
            for (let c =
                    0, f = b.length; c < f; ++c) b[c].GetSolStack().Pop()
        }
        AddScheduledWait() {
            const b = e.New(e.ScheduledWait, this);
            this._scheduledWaits.push(b);
            return b
        }
        scheduledWaits() {
            return this._scheduledWaits
        }
        RunScheduledWaits() {
            if (this._scheduledWaits.length) {
                var b = this.GetCurrentEventStackFrame(),
                    c = !1;
                this._runningEventsDepth++;
                for (let f = 0, h = this._scheduledWaits.length; f < h; ++f) {
                    const g = this._scheduledWaits[f];
                    g._ShouldRun() && g._Run(b);
                    g.ShouldRelease() && (c = !0)
                }
                c && this._FilterScheduledWaitsToRelease();
                this._runningEventsDepth--
            }
        }
        async DebugRunScheduledWaits() {
            if (this._scheduledWaits.length) {
                var b =
                    this.GetCurrentEventStackFrame(),
                    c = !1;
                this._runningEventsDepth++;
                for (let f = 0, h = this._scheduledWaits.length; f < h; ++f) {
                    const g = this._scheduledWaits[f];
                    g._ShouldRun() && await g._DebugRun(b);
                    g.ShouldRelease() && (c = !0)
                }
                c && this._FilterScheduledWaitsToRelease();
                this._runningEventsDepth--
            }
        }
        _FilterScheduledWaitsToRelease() {
            const b = e.arrayFilterOut(this._scheduledWaits, c => c.ShouldRelease());
            for (const c of b) c.Release()
        }
        ClearAllScheduledWaits() {
            for (const b of this._scheduledWaits) b.Release();
            e.clearArray(this._scheduledWaits)
        }
        RemoveInstancesFromScheduledWaits(b) {
            for (const c of this._scheduledWaits) c.RemoveInstances(b)
        }
        AddAsyncActionPromise(b) {
            this._asyncActionPromises.push(b)
        }
        ClearAsyncActionPromises() {
            e.clearArray(this._asyncActionPromises)
        }
        GetPromiseForAllAsyncActions() {
            const b =
                Promise.all(this._asyncActionPromises);
            this._asyncActionPromises = [];
            return b
        }
        _SaveToJson() {
            return {
                groups: this._SaveGroupsToJson(),
                cnds: this._SaveCndsToJson(),
                acts: this._SaveActsToJson(),
                vars: this._SaveVarsToJson(),
                waits: this._SaveScheduledWaitsToJson()
            }
        }
        _LoadFromJson(b) {
            this._LoadGroupsFromJson(b.groups);
            this._LoadCndsFromJson(b.cnds);
            this._LoadActsFromJson(b.acts);
            this._LoadVarsFromJson(b.vars);
            this._LoadScheduledWaitsFromJson(b.waits)
        }
        _SaveGroupsToJson() {
            const b = {};
            for (const c of this.GetAllGroups()) b[c.GetSID().toString()] =
                c.IsGroupActive();
            return b
        }
        _LoadGroupsFromJson(b) {
            for (const [c, f] of Object.entries(b)) b = parseInt(c, 10), (b = this.GetEventGroupBySID(b)) && b.SetGroupActive(f)
        }
        _SaveCndsToJson() {
            const b = {};
            for (const [c, f] of this._cndsBySid) {
                const h = f._SaveToJson();
                h && (b[c.toString()] = h)
            }
            return b
        }
        _LoadCndsFromJson(b) {
            const c = new Map;
            for (const [f, h] of Object.entries(b)) c.set(parseInt(f, 10), h);
            for (const [f, h] of this._cndsBySid) h._LoadFromJson(c.get(f) || null)
        }
        _SaveActsToJson() {
            const b = {};
            for (const [c, f] of this._actsBySid) {
                const h =
                    f._SaveToJson();
                h && (b[c.toString()] = h)
            }
            return b
        }
        _LoadActsFromJson(b) {
            const c = new Map;
            for (const [f, h] of Object.entries(b)) c.set(parseInt(f, 10), h);
            for (const [f, h] of this._actsBySid) h._LoadFromJson(c.get(f) || null)
        }
        _SaveVarsToJson() {
            const b = {};
            for (const [c, f] of this._eventVarsBySid) f.IsConstant() || !f.IsGlobal() && !f.IsStatic() || (b[c.toString()] = f.GetValue());
            return b
        }
        _LoadVarsFromJson(b) {
            for (const [c, f] of Object.entries(b)) b = parseInt(c, 10), (b = this.GetEventVariableBySID(b)) && b.SetValue(f)
        }
        _SaveScheduledWaitsToJson() {
            return this._scheduledWaits.filter(b =>
                !b.IsPromise()).map(b => b._SaveToJson())
        }
        _LoadScheduledWaitsFromJson(b) {
            this.ClearAllScheduledWaits();
            for (const c of b)(b = e.ScheduledWait._CreateFromJson(this, c)) && this._scheduledWaits.push(b)
        }
        _GetPerfRecords() {
            return [...this._runtime.GetLayoutManager().runningLayouts()].map(b => b.GetEventSheet()).filter(b => b).map(b => b._GetPerfRecord())
        }
        FindFirstFunctionBlockParent(b) {
            for (; b;)
                if (b = b.GetScopeParent(), b instanceof e.FunctionBlock) return b;
            return null
        }
        _InvokeFunctionFromJS(b, c) {
            Array.isArray(c) || (c = []);
            b = this.GetFunctionBlockByName(b.toLowerCase());
            if (!b) return null;
            if (!b.IsEnabled()) return b.GetDefaultReturnValue();
            var f = b.GetFunctionParameters();
            if (c.length < f.length) {
                c = c.slice(0);
                do c.push(f[c.length].GetInitialValue()); while (c.length < f.length)
            }
            f = b.GetEventBlock();
            return f.RunAsExpressionFunctionCall(f.GetSolModifiersIncludingParents(), b.GetReturnType(), b.GetDefaultReturnValue(), ...c)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EventSheet = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._eventSheetManager = d;
            this._runtime = d.GetRuntime();
            this._name = a[0];
            this._events = [];
            this._triggers = new Map;
            this._fastTriggers = new Map;
            this._eventsByDisplayNumber = new Map;
            this._hasRun = !1;
            this._shallowIncludes = [];
            this._deepIncludes = [];
            this._alreadyIncludedSheets = new Set;
            for (const b of a[1]) this._CreateEvent(b, null, this._events);
            this._perfRecord = this._runtime.IsDebug() ? {
                type: "sheet",
                name: this._name,
                totalTimeCounter: 0,
                children: []
            } : null
        }
        Release() {
            this._runtime = this._eventSheetManager = null
        }
        _CreateEvent(d, a, b) {
            switch (d[0]) {
                case 0:
                case 3:
                    this._CreateEventBlock(d, a, b);
                    break;
                case 1:
                    this._CreateEventVariable(d, a, b);
                    break;
                case 2:
                    this._CreateInclude(d, a, b);
                    break;
                case 4:
                    this._CreateFunctionBlock(d, a);
                    break;
                case 5:
                    this._CreateScriptBlock(d, a, b);
                    break;
                default:
                    throw Error("invalid event type");
            }
        }
        _CreateEventBlock(d, a, b) {
            d = e.EventBlock.Create(this, a, d);
            if (d.IsOrBlock()) {
                b.push(d);
                b = d.GetConditions();
                for (let c = 0, f = b.length; c <
                    f; ++c) b[c].IsTrigger() && this._InitTrigger(d, c)
            } else d.IsTrigger() ? this._InitTrigger(d, 0) : b.push(d)
        }
        _CreateFunctionBlock(d, a) {
            d = e.FunctionBlock.Create(this, a, d);
            this._eventSheetManager._RegisterFunctionBlock(d)
        }
        _CreateEventVariable(d, a, b) {
            d = e.EventVariable.Create(this, a, d);
            b.push(d)
        }
        _CreateInclude(d, a, b) {
            d = e.EventInclude.Create(this, a, d);
            b.push(d)
        }
        _CreateScriptBlock(d, a, b) {
            d = e.EventScript.Create(this, a, d);
            b.push(d)
        }
        _InitTrigger(d, a) {
            d.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(d);
            var b =
                d.GetConditionAt(a),
                c = b._GetFunc(),
                f = b.GetObjectClass();
            if (b.IsFastTrigger()) {
                var h = this._fastTriggers.get(f);
                h || (h = new Map, this._fastTriggers.set(f, h));
                b = b.GetFastTriggerValue().toLowerCase();
                f = h.get(c);
                f || (f = new Map, h.set(c, f));
                c = f.get(b);
                c || (c = [], f.set(b, c));
                c.push([d, a])
            } else h = this._triggers.get(f), h || (h = {
                    methodMap: new Map,
                    behaviors: new Map
                }, this._triggers.set(f, h)), (f = b.GetBehaviorType()) ? (b = h.behaviors.get(f), b || (b = new Map, h.behaviors.set(f, b))) : b = h.methodMap, h = b.get(c), h || (h = [], b.set(c, h)),
                h.push([d, a])
        }
        _PostInit() {
            const d = this._events;
            for (let a = 0, b = d.length; a < b; ++a) {
                const c = a < b - 1 && d[a + 1] instanceof e.EventBlock && d[a + 1].IsElseBlock();
                d[a]._PostInit(c)
            }
        }
        _AddShallowInclude(d) {
            this._shallowIncludes.push(d)
        }
        _UpdateDeepIncludes() {
            e.clearArray(this._deepIncludes);
            this._AddDeepIncludes(this);
            this._alreadyIncludedSheets.clear()
        }
        _AddDeepIncludes(d) {
            const a = d._deepIncludes,
                b = d._alreadyIncludedSheets;
            for (const c of this._shallowIncludes) {
                const f = c.GetIncludeSheet();
                c.IsActive() && d !== f && !b.has(f) &&
                    (b.add(f), f._AddDeepIncludes(d), a.push(f))
            }
        }
        deepIncludes() {
            return this._deepIncludes
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        _RegisterEventByDisplayNumber(d, a) {
            this._eventsByDisplayNumber.set(a, d)
        }
        _GetEventByDisplayNumber(d) {
            return this._eventsByDisplayNumber.get(d) || null
        }
        _ResetHasRunFlag() {
            this._hasRun = !1
        }
        Run() {
            if (!this._hasRun) {
                var d = this._runtime,
                    a = d.IsCPUProfiling(),
                    b = a ? performance.now() : 0;
                this._hasRun = !0;
                var c = this.GetEventSheetManager(),
                    f = c.GetCurrentEventStackFrame();
                for (const h of this._events) h.Run(f), c.ClearSol(h.GetSolModifiers()), c.ClearAsyncActionPromises(), d.FlushPendingInstances();
                f.Reset(null);
                a && (this._perfRecord.totalTimeCounter += performance.now() - b)
            }
        }* DebugRun() {
            if (!this._hasRun) {
                this._hasRun = !0;
                var d = this._runtime,
                    a = this.GetEventSheetManager(),
                    b = a.GetCurrentEventStackFrame();
                for (const c of this._events) yield* c.DebugRun(b), a.ClearSol(c.GetSolModifiers()), a.ClearAsyncActionPromises(), d.FlushPendingInstances();
                b.Reset(null)
            }
        }
        _Trigger(d,
            a, b) {
            if (a) {
                const c = a.GetObjectClass();
                this._TriggerForClass(d, a, c, b);
                for (const f of c.GetFamilies()) this._TriggerForClass(d, a, f, b)
            } else return this._TriggerForClass(d, a, null, null)
        }
        _TriggerForClass(d, a, b, c) {
            b = this._triggers.get(b);
            if (!b) return !1;
            c = c ? b.behaviors.get(c) : b.methodMap;
            if (!c) return !1;
            c = c.get(d);
            if (!c) return !1;
            d = !1;
            for (const [f, h] of c) c = this._ExecuteTrigger(a, f, h), d = d || c;
            return d
        }* _DebugTrigger(d, a, b) {
            if (a) {
                const c = a.GetObjectClass();
                yield* this._DebugTriggerForClass(d, a, c, b);
                for (const f of c.GetFamilies()) yield* this._DebugTriggerForClass(d,
                    a, f, b)
            } else return yield* this._DebugTriggerForClass(d, a, null, null)
        }* _DebugTriggerForClass(d, a, b, c) {
            b = this._triggers.get(b);
            if (!b) return !1;
            c = c ? b.behaviors.get(c) : b.methodMap;
            if (!c) return !1;
            c = c.get(d);
            if (!c) return !1;
            d = !1;
            for (const [f, h] of c) c = f.DebugCanRunFast() ? this._ExecuteTrigger(a, f, h) : yield* this._DebugExecuteTrigger(a, f, h), d = d || c;
            return d
        }
        _FastTrigger(d, a, b) {
            a = a.GetObjectClass();
            a = this._fastTriggers.get(a);
            if (!a) return !1;
            d = a.get(d);
            if (!d) return !1;
            b = d.get(b);
            if (!b) return !1;
            d = !1;
            for (let c = 0, f = b.length; c <
                f; ++c) a = b[c], a = this._ExecuteTrigger(null, a[0], a[1]), d = d || a;
            return d
        }* _DebugFastTrigger(d, a, b) {
            a = a.GetObjectClass();
            a = this._fastTriggers.get(a);
            if (!a) return !1;
            d = a.get(d);
            if (!d) return !1;
            b = d.get(b);
            if (!b) return !1;
            d = !1;
            for (let f = 0, h = b.length; f < h; ++f) {
                var c = b[f];
                a = c[0];
                c = c[1];
                a = a.DebugCanRunFast() ? this._ExecuteTrigger(null, a, c) : yield* this._DebugExecuteTrigger(null, a, c);
                d = d || a
            }
            return d
        }
        _ExecuteTrigger(d, a, b) {
            const c = this._runtime,
                f = this._eventSheetManager,
                h = f.GetCurrentEvent(),
                g = f.GetEventStack(),
                k = f.GetTriggerDepth();
            let m = !1;
            h && f.PushCleanSol(h.GetSolModifiersIncludingParents());
            f.PushCleanSol(a.GetSolModifiersIncludingParents());
            const r = 1 < k;
            r && f.GetLocalVarStack().Push();
            const w = g.Push(a);
            d && (a.GetConditions()[b].GetObjectClass().GetCurrentSol().SetSinglePicked(d), d.IsInContainer() && d.SetSiblingsSinglePicked());
            d = !0;
            if (a.GetParent()) {
                const p = a.GetTriggerParents();
                for (let t = 0, u = p.length; t < u; ++t)
                    if (!p[t].RunPreTrigger(w)) {
                        d = !1;
                        break
                    }
            }
            d && (c.IncrementExecCount(), a.IsOrBlock() ? a.RunOrBlockTrigger(w, b) : a.Run(w), m =
                w.GetLastEventTrue());
            g.Pop();
            r && f.GetLocalVarStack().Pop();
            f.PopSol(a.GetSolModifiersIncludingParents());
            h && f.PopSol(h.GetSolModifiersIncludingParents());
            h || 1 !== k || (f.ClearAsyncActionPromises(), f.IsFlushingBlocked() || c.FlushPendingInstances());
            return m
        }* _DebugExecuteTrigger(d, a, b) {
            const c = this._runtime,
                f = this._eventSheetManager,
                h = f.GetCurrentEvent(),
                g = f.GetEventStack(),
                k = f.GetTriggerDepth();
            let m = !1;
            h && f.PushCleanSol(h.GetSolModifiersIncludingParents());
            f.PushCleanSol(a.GetSolModifiersIncludingParents());
            const r = 1 < k;
            r && f.GetLocalVarStack().Push();
            const w = g.Push(a);
            d && (a.GetConditions()[b].GetObjectClass().GetCurrentSol().SetSinglePicked(d), d.IsInContainer() && d.SetSiblingsSinglePicked());
            d = !0;
            if (a.GetParent()) {
                const p = a.GetTriggerParents();
                for (let t = 0, u = p.length; t < u; ++t)
                    if (!(yield* p[t].DebugRunPreTrigger(w))) {
                        d = !1;
                        break
                    }
            }
            d && (c.IncrementExecCount(), a.IsOrBlock() ? yield* a.DebugRunOrBlockTrigger(w, b): yield* a.DebugRun(w), m = w.GetLastEventTrue());
            g.Pop();
            r && f.GetLocalVarStack().Pop();
            f.PopSol(a.GetSolModifiersIncludingParents());
            h && f.PopSol(h.GetSolModifiersIncludingParents());
            h || 1 !== k || (f.ClearAsyncActionPromises(), f.IsFlushingBlocked() || c.FlushPendingInstances());
            return m
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [];

    function a(c, f) {
        return !0
    }

    function* b(c, f) {
        return !0
    }
    e.EventBlock = class extends e.DefendedBase {
        constructor(c, f, h) {
            super();
            this._eventSheet = c;
            this._runtime = c.GetRuntime();
            this._parent = f;
            this._scopeParent = null;
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._solModifiers = [];
            this._solModifiersIncludingParents = [];
            this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1;
            this._isOrBlock = !!h[2];
            this._isElseBlock = !1;
            this._triggerParents = null;
            this._conditions = [];
            this._actions = [];
            this._subEvents = [];
            this._RunActions = a;
            this._DebugRunActions = b;
            this._isInitiallyActive = this._isGroup = !1;
            this._groupName = "";
            this._isGroupActive = !1;
            this._perfRecord = this._containedIncludes = null;
            this._sid = h[4];
            this._displayNumber = h[5];
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: h[3][0],
                isBreakable: h[3][1],
                canRunAllConditionsFast: !1,
                canRunAllActionsFast: !1,
                canRunAllSubEventsFast: !1,
                canRunSelfFast: !1
            } : null;
            this.GetEventSheetManager()._RegisterEventBlock(this);
            3 === h[0] && this._InitGroup(h[1]);
            c = 0;
            for (var g of h[6]) f = e.Condition.Create(this, g, c++), this._conditions.push(f), this._AddSolModifier(f.GetObjectClass());
            c = 0;
            for (const k of h[7]) g = e.Action.Create(this, k, c++), this._actions.push(g);
            if (9 === h.length) {
                h = h[8];
                for (const k of h) this._eventSheet._CreateEvent(k, this, this._subEvents)
            }
            this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() &&
                this._conditions[0]._GetFunc() === e.Plugins.System.Cnds.Else);
            0 === this._conditions.length && (this._conditions = d);
            0 === this._actions.length && (this._actions = d);
            0 === this._subEvents.length && (this._subEvents = d)
        }
        static Create(c, f, h) {
            return e.New(e.EventBlock, c, f, h)
        }
        _InitGroup(c) {
            this._isGroup = !0;
            this._isGroupActive = this._isInitiallyActive = !!c[0];
            this._groupName = c[1].toLowerCase();
            this._containedIncludes = [];
            this.GetEventSheetManager()._RegisterGroup(this);
            this._runtime.IsDebug() && (this._perfRecord = {
                type: "group",
                name: c[1],
                totalTimeCounter: 0,
                children: []
            })
        }
        _AddContainedInclude(c) {
            this._containedIncludes.push(c)
        }
        _AddContainerSolModifierToList(c, f) {
            for (const h of c.GetContainer().objectTypes()) f.includes(h) || f.push(h)
        }
        _AddSolModifierToList(c, f) {
            if (c)
                if (f.includes(c) || f.push(c), c.IsFamily())
                    for (const h of c.GetFamilyMembers()) h.IsInContainer() && this._AddContainerSolModifierToList(h, f);
                else c.IsInContainer() && this._AddContainerSolModifierToList(c, f)
        }
        _AddSolModifier(c) {
            this._AddSolModifierToList(c, this._solModifiers)
        }
        _AddParentSolModifier(c) {
            this._AddSolModifierToList(c,
                this._solModifiersIncludingParents)
        }
        SetAllSolModifiers() {
            this._solModifiers = this._runtime.GetAllObjectClasses()
        }
        _PostInit(c) {
            this._hasElseBlock = !!c;
            this._IdentifyTopLevelGroup();
            this._IdentifyTriggerParents();
            for (const h of this._conditions) h._PostInit();
            if (0 < this._actions.length) {
                c = !1;
                for (var f of this._actions) f._PostInit(), f.HasReturnType() && (c = !0);
                c ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions =
                    this._DebugRunActions_Fast)
            }
            f = this._subEvents;
            for (let h = 0, g = f.length; h < g; ++h) c = h < g - 1 && f[h + 1] instanceof e.EventBlock && f[h + 1].IsElseBlock(), f[h]._PostInit(c);
            this._debugData && this._UpdateCanRunFast();
            this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
        _GetPerfRecordParent() {
            let c = this.GetParent();
            for (; c;) {
                if (c.IsGroup()) return c;
                c = c.GetParent()
            }
            return this._eventSheet
        }
        _UpdateCanRunFast() {
            const c = this._debugData;
            c.canRunAllConditionsFast =
                this._conditions.every(f => f.DebugCanRunFast());
            c.canRunAllActionsFast = this._actions.every(f => f.DebugCanRunFast());
            c.canRunAllSubEventsFast = this._subEvents.every(f => f.DebugCanRunFast());
            c.canRunSelfFast = c.canRunAllConditionsFast && c.canRunAllActionsFast && c.canRunAllSubEventsFast
        }
        _UpdateCanRunFastRecursive() {
            let c = this;
            do c._UpdateCanRunFast(), c = c.GetParent(); while (c)
        }
        _IdentifyTopLevelGroup() {
            if (this.IsGroup()) {
                var c = this.GetParent();
                for (this._isTopLevelGroup = !0; c;) {
                    if (!c.IsGroup()) {
                        this._isTopLevelGroup = !1;
                        break
                    }
                    c = c.GetParent()
                }
            }
        }
        _IdentifySolModifiersIncludingParents() {
            var c = this._runtime.GetAllObjectClasses();
            if (this._solModifiers === c) this._solModifiersIncludingParents = c;
            else {
                this._solModifiersIncludingParents = e.cloneArray(this._solModifiers);
                for (c = this.GetParent(); c;) {
                    for (var f of c._solModifiers) this._AddParentSolModifier(f);
                    c = c.GetParent()
                }
                f = this.GetEventSheetManager();
                this._solModifiers = f._DeduplicateSolModifierList(this._solModifiers);
                this._solModifiersIncludingParents = f._DeduplicateSolModifierList(this._solModifiersIncludingParents)
            }
        }
        _IdentifyTriggerParents() {
            if (this.HasAnyTriggeredCondition()) {
                this._triggerParents = [];
                for (var c = this.GetParent(); c;) this._triggerParents.push(c), c = c.GetParent();
                this._triggerParents.reverse()
            }
        }
        SetSolWriterAfterCnds() {
            this._isSolWriterAfterCnds = !0;
            this._parent && this._parent.SetSolWriterAfterCnds()
        }
        IsSolWriterAfterCnds() {
            return this._isSolWriterAfterCnds
        }
        GetSolModifiers() {
            return this._solModifiers
        }
        GetSolModifiersIncludingParents() {
            this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0, this._IdentifySolModifiersIncludingParents());
            return this._solModifiersIncludingParents
        }
        HasSolModifier(c) {
            return this._solModifiers.includes(c)
        }
        GetTriggerParents() {
            return this._triggerParents
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetEventSheetManager() {
            return this._eventSheet.GetEventSheetManager()
        }
        GetRuntime() {
            return this._runtime
        }
        GetParent() {
            return this._parent
        }
        _SetScopeParent(c) {
            this._scopeParent =
                c
        }
        GetScopeParent() {
            return this._scopeParent || this._parent
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(c) {
            this._debugData.isBreakpoint = !!c;
            this._UpdateCanRunFastRecursive()
        }
        IsGroup() {
            return this._isGroup
        }
        IsTopLevelGroup() {
            return this._isTopLevelGroup
        }
        IsElseBlock() {
            return this._isElseBlock
        }
        HasElseBlock() {
            return this._hasElseBlock
        }
        GetGroupName() {
            return this._groupName
        }
        IsGroupActive() {
            return this._isGroupActive
        }
        ResetInitialActivation() {
            this.SetGroupActive(this._isInitiallyActive)
        }
        SetGroupActive(c) {
            c = !!c;
            if (!this._isGroup) throw Error("not a group");
            if (this._isGroupActive !== c) {
                this._isGroupActive = c;
                for (const f of this._containedIncludes) f.UpdateActive();
                this._containedIncludes.length && (c = this._runtime.GetCurrentLayout().GetEventSheet()) && c._UpdateDeepIncludes()
            }
        }
        GetSID() {
            return this._sid
        }
        IsOrBlock() {
            return this._isOrBlock
        }
        IsTrigger() {
            return this._conditions.length && this._conditions[0].IsTrigger()
        }
        IsForFunctionBlock() {
            return this._scopeParent && this._scopeParent instanceof e.FunctionBlock
        }
        HasAnyTriggeredCondition() {
            return this.IsForFunctionBlock() ||
                this._conditions.some(c => c.IsTrigger())
        }
        GetConditions() {
            return this._conditions
        }
        GetConditionCount() {
            return this._conditions.length
        }
        GetConditionAt(c) {
            c = Math.floor(c);
            if (0 > c || c >= this._conditions.length) throw new RangeError("invalid condition index");
            return this._conditions[c]
        }
        GetConditionByDebugIndex(c) {
            return this.GetConditionAt(c)
        }
        IsFirstConditionOfType(c) {
            let f = c.GetIndex();
            if (0 === f) return !0;
            for (--f; 0 <= f; --f)
                if (this._conditions[f].GetObjectClass() === c.GetObjectClass()) return !1;
            return !0
        }
        GetActions() {
            return this._actions
        }
        GetActionCount() {
            return this._actions.length
        }
        GetActionAt(c) {
            c =
                Math.floor(c);
            if (0 > c || c >= this._actions.length) throw new RangeError("invalid action index");
            return this._actions[c]
        }
        GetActionByDebugIndex(c) {
            c = Math.floor(c);
            const f = this._actions.find(h => h.GetDebugIndex() === c);
            if (!f) throw new RangeError("invalid action debug index");
            return f
        }
        _HasActionIndex(c) {
            c = Math.floor(c);
            return 0 <= c && c < this._actions.length
        }
        GetSubEvents() {
            return this._subEvents
        }
        _GetAllLocalVariablesInScope() {
            return this._subEvents.filter(c => c instanceof e.EventVariable)
        }
        RunPreTrigger(c) {
            c.SetCurrentEvent(this);
            let f = !1;
            const h = this._conditions;
            for (let g = 0, k = h.length; g < k; ++g) {
                const m = h[g];
                c.SetConditionIndex(g);
                if (m.IsLooping()) throw Error("trigger cannot be used as sub-event to a loop");
                if (m.Run()) f = !0;
                else if (!this._isOrBlock) return !1
            }
            return this._isOrBlock ? f : !0
        }
        RunOrBlockTrigger(c, f) {
            c.SetCurrentEvent(this);
            this._conditions[f].Run() && (this._RunActions(c, 0) && this._RunSubEvents(c), c.SetLastEventTrue(!0))
        }* DebugRunPreTrigger(c) {
            c.SetCurrentEvent(this);
            let f = !1;
            const h = this._conditions;
            for (let g = 0, k = h.length; g <
                k; ++g) {
                const m = h[g];
                c.SetConditionIndex(g);
                if (m.IsLooping()) throw Error("trigger cannot be used as sub-event to a loop");
                if (m.DebugCanRunFast() ? m.Run() : yield* m.DebugRun()) f = !0;
                else if (!this._isOrBlock) return !1
            }
            return this._isOrBlock ? f : !0
        }* DebugRunOrBlockTrigger(c, f) {
            c.SetCurrentEvent(this);
            f = this._conditions[f];
            if (f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun())(this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() :
                yield* this._DebugRunSubEvents()), c.SetLastEventTrue(!0)
        }
        Run(c) {
            c.SetCurrentEvent(this);
            this._isElseBlock || c.SetElseBranchRan(!1);
            this._isOrBlock ? this._RunOrBlock(c) : this._RunAndBlock(c)
        }* DebugRun(c) {
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            c.SetCurrentEvent(this);
            this._isElseBlock || c.SetElseBranchRan(!1);
            this._isOrBlock ? yield* this._DebugRunOrBlock(c): yield* this._DebugRunAndBlock(c)
        }
        _RunOrBlock(c) {
            const f = this._conditions;
            let h = 0 === f.length;
            for (let k = 0, m = f.length; k < m; ++k) {
                var g =
                    f[k];
                g.IsTrigger() || (c.SetConditionIndex(k), g = g.Run(), h = h || g)
            }
            c.SetLastEventTrue(h);
            h && (this._RunActions(c, 0) && this._RunSubEvents(c), this._hasElseBlock && c.SetElseBranchRan(!0))
        }* _DebugRunOrBlock(c) {
            const f = this._conditions;
            let h = 0 === f.length;
            for (let k = 0, m = f.length; k < m; ++k) {
                var g = f[k];
                g.IsTrigger() || (c.SetConditionIndex(k), g = g.DebugCanRunFast() ? g.Run() : yield* g.DebugRun(), h = h || g)
            }
            c.SetLastEventTrue(h);
            h && ((this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ?
                this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && c.SetElseBranchRan(!0))
        }
        _RunAndBlock(c) {
            const f = this._conditions;
            for (let h = 0, g = f.length; h < g; ++h) {
                const k = f[h];
                c.SetConditionIndex(h);
                if (!k.Run()) {
                    c.SetLastEventTrue(!1);
                    return
                }
            }
            c.SetLastEventTrue(!0);
            this._RunActions(c, 0) && this._RunSubEvents(c);
            c.GetLastEventTrue() && this._hasElseBlock && c.SetElseBranchRan(!0)
        }* _DebugRunAndBlock(c) {
            const f = this._conditions;
            for (let h = 0, g = f.length; h < g; ++h) {
                const k = f[h];
                c.SetConditionIndex(h);
                if (k.DebugCanRunFast() ?
                    !k.Run() : !(yield* k.DebugRun())) {
                    c.SetLastEventTrue(!1);
                    return
                }
            }
            c.SetLastEventTrue(!0);
            (this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents());
            c.GetLastEventTrue() && this._hasElseBlock && c.SetElseBranchRan(!0)
        }
        _RunActions_Fast(c, f) {
            const h = this._actions;
            for (let g = f, k = h.length; g < k; ++g) f = h[g], c.SetActionIndex(g), f.Run();
            return !0
        }* _DebugRunActions_Fast(c, f) {
            const h = this._actions;
            for (let g =
                    f, k = h.length; g < k; ++g) f = h[g], c.SetActionIndex(g), f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun();
            return !0
        }
        _RunActions_ReturnValue(c, f) {
            const h = this.GetEventSheetManager(),
                g = this._actions;
            for (let k = f, m = g.length; k < m; ++k) {
                f = g[k];
                c.SetActionIndex(k);
                const r = f.Run();
                if (f.CanBailOut() && !0 === r) return !1;
                f.IsAsync() && r instanceof Promise && h.AddAsyncActionPromise(r)
            }
            return !0
        }* _DebugRunActions_ReturnValue(c, f) {
            const h = this.GetEventSheetManager(),
                g = this._actions;
            for (let k = f, m = g.length; k < m; ++k) {
                f = g[k];
                c.SetActionIndex(k);
                let r;
                r = f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun();
                if (f.CanBailOut() && !0 === r) return !1;
                f.IsAsync() && r instanceof Promise && h.AddAsyncActionPromise(r)
            }
            return !0
        }
        _ResumeActionsAndSubEvents(c) {
            this._RunActions(c, c.GetActionIndex()) && this._RunSubEvents()
        }* _DebugResumeActionsAndSubEvents(c) {
            if (yield* this._DebugRunActions(c, c.GetActionIndex())) yield* this._DebugRunSubEvents()
        }
        _RunSubEvents() {
            if (this._subEvents.length) {
                var c = this.IsGroup() && this._runtime.IsCPUProfiling(),
                    f = c ? performance.now() : 0,
                    h = this._eventStack,
                    g = h.Push(this);
                this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(g) : this._RunSubEvents_Fast(g);
                h.Pop();
                c && (this._perfRecord.totalTimeCounter += performance.now() - f)
            }
        }
        _RunSubEvents_SolWriterAfterCnds(c) {
            const f = this._isGroup,
                h = this._isTopLevelGroup,
                g = this.GetEventSheetManager(),
                k = this._subEvents;
            for (let m = 0, r = k.length, w = r - 1; m < r; ++m) {
                const p = k[m],
                    t = p.GetSolModifiers(),
                    u = !h || !f && m < w;
                u && g.PushCopySol(t);
                p.Run(c);
                u ? g.PopSol(t) : g.ClearSol(t)
            }
        }
        _RunSubEvents_Fast(c) {
            const f = this._subEvents;
            for (let h =
                    0, g = f.length; h < g; ++h) f[h].Run(c)
        }* _DebugRunSubEvents() {
            if (this._subEvents.length) {
                var c = this._eventStack,
                    f = c.Push(this);
                this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(f): yield* this._DebugRunSubEvents_Fast(f);
                c.Pop()
            }
        }* _DebugRunSubEvents_SolWriterAfterCnds(c) {
            const f = this._isGroup,
                h = this._isTopLevelGroup,
                g = this.GetEventSheetManager(),
                k = this._subEvents;
            for (let m = 0, r = k.length, w = r - 1; m < r; ++m) {
                const p = k[m],
                    t = p.GetSolModifiers(),
                    u = !h || !f && m < w;
                u && g.PushCopySol(t);
                yield* p.DebugRun(c);
                u ? g.PopSol(t) : g.ClearSol(t)
            }
        }* _DebugRunSubEvents_Fast(c) {
            const f = this._subEvents;
            for (let h = 0, g = f.length; h < g; ++h) yield* f[h].DebugRun(c)
        }
        Retrigger(c, f) {
            this._runtime.IncrementExecCount();
            f.ResetQuick();
            const h = this._conditions;
            if (!this.IsOrBlock())
                for (let g = c.GetConditionIndex() + 1, k = h.length; g < k; ++g)
                    if (c = h[g], f.SetConditionIndex(g), !c.Run()) return !1;
            this._RunActions(f, 0) && this._RunSubEvents(f);
            return !0
        }* DebugRetrigger(c, f) {
            this._runtime.IncrementExecCount();
            f.ResetQuick();
            const h = this._conditions;
            if (!this.IsOrBlock())
                for (let g =
                        c.GetConditionIndex() + 1, k = h.length; g < k; ++g)
                    if (c = h[g], f.SetConditionIndex(g), c.DebugCanRunFast() ? !c.Run() : !(yield* c.DebugRun())) return !1;
            (this.DebugCanRunActionsFast() ? this._RunActions(f, 0) : yield* this._DebugRunActions(f, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents());
            return !0
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
        }
        DebugCanRunActionsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
        }
        DebugCanRunSubEventsFast() {
            return !this._runtime.DebugBreakNext() &&
                this._debugData.canRunAllSubEventsFast
        }
        _CheckParentsOKToRun(c) {
            if (this.GetParent()) {
                const f = this.GetTriggerParents();
                for (let h = 0, g = f.length; h < g; ++h)
                    if (!f[h].RunPreTrigger(c)) return !1
            }
            return !0
        }* _DebugCheckParentsOKToRun(c) {
            if (this.GetParent()) {
                const f = this.GetTriggerParents();
                for (let h = 0, g = f.length; h < g; ++h)
                    if (!(yield* f[h].DebugRunPreTrigger(c))) return !1
            }
            return !0
        }
        _EvaluateFunctionCallParameters(c, f, h) {
            0 < f.length ? h ? (f = f.map(g => g.Get(0)), c.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(f)) :
                this._scopeParent.EvaluateFunctionParameters(f) : h && c.GetLocalVarStack().Push()
        }
        RunAsFunctionCall(c, f) {
            let h, g;
            const k = 0 < c.length;
            var m = this._runtime;
            const r = this._eventStack,
                w = m.GetEventSheetManager(),
                p = 1 < w._IncTriggerDepth();
            this._EvaluateFunctionCallParameters(w, f, p);
            k && w.PushCleanSol(c);
            f = r.Push(this);
            this._CheckParentsOKToRun(f) && (m.IncrementExecCount(), f.SetCurrentEvent(this), (m = this._scopeParent.IsAsync()) && ([g, h] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(f), m && this._scopeParent.MaybeFinishAsyncFunctionCall(g));
            r.Pop();
            p && w.GetLocalVarStack().Pop();
            k && w.PopSol(c);
            w._DecTriggerDepth();
            return h
        }* DebugRunAsFunctionCall(c, f) {
            let h, g;
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            const k = 0 < c.length;
            var m = this._runtime;
            const r = this._eventStack,
                w = m.GetEventSheetManager(),
                p = 1 < w._IncTriggerDepth();
            this._EvaluateFunctionCallParameters(w, f, p);
            k && w.PushCleanSol(c);
            f = r.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(f)) m.IncrementExecCount(), f.SetCurrentEvent(this), (m = this._scopeParent.IsAsync()) &&
                ([g, h] = this._scopeParent.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(f), m && this._scopeParent.MaybeFinishAsyncFunctionCall(g);
            r.Pop();
            p && w.GetLocalVarStack().Pop();
            k && w.PopSol(c);
            w._DecTriggerDepth();
            return h
        }
        RunAsMappedFunctionCall(c) {
            const f = this.GetSolModifiersIncludingParents(),
                h = 0 < f.length,
                g = this._runtime,
                k = this._eventStack,
                m = g.GetEventSheetManager(),
                r = 1 < m._IncTriggerDepth();
            r && m.GetLocalVarStack().Push();
            this._scopeParent.SetFunctionParameters(c);
            h && m.PushCleanSol(f);
            c = k.Push(this);
            this._CheckParentsOKToRun(c) && (g.IncrementExecCount(), c.SetCurrentEvent(this), this._RunAndBlock(c));
            k.Pop();
            r && m.GetLocalVarStack().Pop();
            h && m.PopSol(f);
            m._DecTriggerDepth()
        }* DebugRunAsMappedFunctionCall(c) {
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            const f = this.GetSolModifiersIncludingParents(),
                h = 0 < f.length,
                g = this._runtime,
                k = this._eventStack,
                m = g.GetEventSheetManager(),
                r = 1 < m._IncTriggerDepth();
            r && m.GetLocalVarStack().Push();
            this._scopeParent.SetFunctionParameters(c);
            h &&
                m.PushCleanSol(f);
            c = k.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(c)) g.IncrementExecCount(), c.SetCurrentEvent(this), yield* this._DebugRunAndBlock(c);
            k.Pop();
            r && m.GetLocalVarStack().Pop();
            h && m.PopSol(f);
            m._DecTriggerDepth()
        }
        RunAsExpressionFunctionCall(c, f, h, ...g) {
            let k, m;
            const r = 0 < c.length,
                w = this._runtime,
                p = this._eventStack,
                t = w.GetEventSheetManager(),
                u = 1 < t._IncTriggerDepth();
            u && t.GetLocalVarStack().Push();
            0 < g.length && this._scopeParent.SetFunctionParameters(g);
            r && t.PushCleanSol(c);
            g = p.Push(this);
            g.InitCallFunctionExpression(f, h);
            p.PushExpFunc(g);
            w.SetDebuggingEnabled(!1);
            this._CheckParentsOKToRun(g) && (w.IncrementExecCount(), g.SetCurrentEvent(this), (f = this._scopeParent.IsAsync()) && ([m, k] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(g), f && this._scopeParent.MaybeFinishAsyncFunctionCall(m));
            w.SetDebuggingEnabled(!0);
            p.Pop();
            p.PopExpFunc();
            u && t.GetLocalVarStack().Pop();
            r && t.PopSol(c);
            t._DecTriggerDepth();
            return k || g.GetFunctionReturnValue()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [];
    let a = !1;
    e.EventScript = class extends e.DefendedBase {
        constructor(b, c, f) {
            super();
            const h = b.GetRuntime(),
                g = b.GetEventSheetManager();
            this._eventSheet = b;
            this._eventSheetManager = g;
            this._runtime = b.GetRuntime();
            this._parent = c;
            this._func = h.GetObjectReference(f[1]);
            this._displayNumber = f[2];
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
            this._debugData = h.IsDebug() ? {
                isBreakpoint: f[3][0],
                isBreakable: f[3][1]
            } : null
        }
        static Create(b, c, f) {
            return e.New(e.EventScript,
                b, c, f)
        }
        _PostInit() {
            const b = this._func,
                c = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
            this._func = b.bind(null, this._runtime.GetIRuntime(), c)
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(b) {
            this._debugData.isBreakpoint = !!b
        }
        IsElseBlock() {
            return !1
        }
        GetSolModifiers() {
            return d
        }
        GetSolModifiersIncludingParents() {
            return this._parent ? this._parent.GetSolModifiersIncludingParents() : d
        }
        Run(b) {
            b.SetCurrentEvent(this);
            this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
        }
        async _RunUserScript() {
            try {
                await this._func()
            } catch (b) {
                console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", b), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                    a || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), a = !0)
            }
        }* DebugRun(b) {
            b.SetCurrentEvent(this);
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            this.Run(b)
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
        }
        static HadUserScriptException() {
            return a
        }
        static SetHadUserScriptException() {
            a = !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.FunctionBlock = class extends e.DefendedBase {
        constructor(d, a, b) {
            super();
            this._eventSheet = d;
            this._runtime = d.GetRuntime();
            this._parent = a;
            const c = b[1];
            this._functionName = c[0];
            this._returnType = c[1];
            this._functionParameters = c[2].map(f => e.EventVariable.Create(d, this, f));
            this._isEnabled = c[3];
            this._innerLocalVariables = [];
            this._isAsync = c[4];
            this._nextAsyncId = 0;
            this._currentAsyncId = -1;
            this._asyncMap = new Map;
            this._eventBlock = e.EventBlock.Create(d, a, b);
            this._eventBlock._SetScopeParent(this)
        }
        static Create(d,
            a, b) {
            return e.New(e.FunctionBlock, d, a, b)
        }
        _PostInit() {
            for (const d of this._functionParameters) d._PostInit();
            this._eventBlock._PostInit(!1)
        }
        _GetAllLocalVariablesInScope() {
            return this._functionParameters
        }
        GetFunctionParameters() {
            return this._functionParameters
        }
        GetFunctionParameterCount() {
            return this._functionParameters.length
        }
        _RegisterLocalVariable(d) {
            this._innerLocalVariables.push(d)
        }
        _GetAllInnerLocalVariables() {
            return this._innerLocalVariables
        }
        EvaluateFunctionParameters(d) {
            const a = this._functionParameters;
            for (let b = 0, c = a.length; b < c; ++b) a[b].SetValue(d[b].Get(0))
        }
        SetFunctionParameters(d) {
            const a = this._functionParameters;
            for (let b = 0, c = a.length; b < c; ++b) a[b].SetValue(d[b])
        }
        CaptureFunctionParameters() {
            return this._functionParameters.map(d => d.GetValue())
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetFunctionName() {
            return this._functionName
        }
        GetReturnType() {
            return this._returnType
        }
        IsEnabled() {
            return this._isEnabled
        }
        GetDefaultReturnValue() {
            switch (this._returnType) {
                case 0:
                    return null;
                case 2:
                    return "";
                default:
                    return 0
            }
        }
        GetEventBlock() {
            return this._eventBlock
        }
        IsAsync() {
            return this._isAsync
        }
        StartAsyncFunctionCall() {
            const d = this._nextAsyncId++;
            this._currentAsyncId = d;
            let a;
            const b = new Promise(c => a = c);
            this._asyncMap.set(d, {
                resolve: a,
                pauseCount: 0
            });
            return [d, b]
        }
        MaybeFinishAsyncFunctionCall(d) {
            const a = this._asyncMap.get(d);
            0 === a.pauseCount && (a.resolve(), this._asyncMap.delete(d));
            this._currentAsyncId = -1
        }
        PauseCurrentAsyncFunction() {
            this._asyncMap.get(this._currentAsyncId).pauseCount++;
            return this._currentAsyncId
        }
        ResumeAsyncFunction(d) {
            this._currentAsyncId =
                d;
            this._asyncMap.get(d).pauseCount--
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [];
    e.EventVariable = class extends e.DefendedBase {
        constructor(a, b, c) {
            super();
            const f = a.GetEventSheetManager();
            this._eventSheet = a;
            this._eventSheetManager = f;
            this._runtime = a.GetRuntime();
            this._parent = b;
            this._localVarStack = f.GetLocalVarStack();
            this._name = c[1];
            this._type = c[2];
            this._initialValue = c[3];
            this._isStatic = !!c[4];
            this._isConstant = !!c[5];
            this._isFunctionParameter = b instanceof e.FunctionBlock;
            this._sid = c[6];
            this._jsPropName = this._runtime.GetJsPropName(c[8]);
            this._scriptSetter =
                h => this.SetValue(h);
            this._scriptGetter = () => this.GetValue();
            this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;
            this._value = this._initialValue;
            this._localIndex = -1;
            this.IsBoolean() && (this._value = this._value ? 1 : 0);
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = f._GetNextLocalVarIndex(this));
            f._RegisterEventVariable(this)
        }
        static Create(a, b, c) {
            return e.New(e.EventVariable, a, b, c)
        }
        _PostInit() {
            if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
                const a =
                    this._eventSheetManager.FindFirstFunctionBlockParent(this);
                a && a._RegisterLocalVariable(this)
            }
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this.GetParent()
        }
        IsGlobal() {
            return !this.GetParent()
        }
        IsLocal() {
            return !this.IsGlobal()
        }
        IsFunctionParameter() {
            return this._isFunctionParameter
        }
        IsStatic() {
            return this._isStatic
        }
        IsConstant() {
            return this._isConstant
        }
        IsNumber() {
            return 0 === this._type
        }
        IsString() {
            return 1 === this._type
        }
        IsBoolean() {
            return 2 ===
                this._type
        }
        IsElseBlock() {
            return !1
        }
        GetSID() {
            return this._sid
        }
        GetInitialValue() {
            return this._initialValue
        }
        GetSolModifiers() {
            return d
        }
        Run(a) {
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
        }
        DebugCanRunFast() {
            return !0
        }* DebugRun(a) {
            this.Run(a)
        }
        SetValue(a) {
            this.IsNumber() ? "number" !== typeof a && (a = parseFloat(a)) : this.IsString() ? "string" !== typeof a && (a = a.toString()) : this.IsBoolean() && (a = a ? 1 : 0);
            this._hasSingleValue ? this._value = a : this._localVarStack.GetCurrent()[this._localIndex] =
                a
        }
        GetValue() {
            return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
        }
        GetTypedValue() {
            let a = this.GetValue();
            this.IsBoolean() && (a = !!a);
            return a
        }
        ResetToInitialValue() {
            this._value = this._initialValue
        }
        _GetScriptInterfaceDescriptor() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._scriptGetter,
                set: this._scriptSetter
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [];
    e.EventInclude = class extends e.DefendedBase {
        constructor(a, b, c) {
            super();
            const f = a.GetEventSheetManager();
            this._eventSheet = a;
            this._eventSheetManager = f;
            this._runtime = a.GetRuntime();
            this._parent = b;
            this._includeSheet = null;
            this._includeSheetName = c[1];
            this._isActive = !0
        }
        static Create(a, b, c) {
            return e.New(e.EventInclude, a, b, c)
        }
        _PostInit() {
            this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);
            this._eventSheet._AddShallowInclude(this);
            let a =
                this.GetParent();
            for (; a;) a instanceof e.EventBlock && a.IsGroup() && a._AddContainedInclude(this), a = a.GetParent();
            this.UpdateActive();
            this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
        }
        GetParent() {
            return this._parent
        }
        GetSolModifiers() {
            return d
        }
        GetIncludeSheet() {
            return this._includeSheet
        }
        Run(a) {
            a = !!this.GetParent();
            const b = this._runtime.GetAllObjectClasses();
            a && this._eventSheetManager.PushCleanSol(b);
            this._includeSheet.Run();
            a && this._eventSheetManager.PopSol(b)
        }* DebugRun(a) {
            a = !!this.GetParent();
            const b = this._runtime.GetAllObjectClasses();
            a && this._eventSheetManager.PushCleanSol(b);
            yield* this._includeSheet.DebugRun();
            a && this._eventSheetManager.PopSol(b)
        }
        DebugCanRunFast() {
            return !1
        }
        IsActive() {
            return this._isActive
        }
        UpdateActive() {
            let a = this.GetParent();
            for (; a;) {
                if (a instanceof e.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
                    this._isActive = !1;
                    return
                }
                a = a.GetParent()
            }
            this._isActive = !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ExpNode = class extends e.DefendedBase {
        constructor(k) {
            super();
            this._owner = k;
            this._runtime = k.GetRuntime()
        }
        _PostInit() {}
        static CreateNode(k, m) {
            return e.New([h, c, f, g, d, a][m[0]], k, m)
        }
    };
    class d extends e.ExpNode {
        constructor(k, m) {
            super(k);
            this._systemPlugin = this._runtime.GetSystemPlugin();
            this._func = this._runtime.GetObjectReference(m[1]);
            this._func !== e.Plugins.System.Exps.random && this._func !== e.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance()
        }
        GetBoundMethod() {
            return this._systemPlugin._GetBoundACEMethod(this._func,
                this._systemPlugin)
        }
    }
    class a extends e.ExpNode {
        constructor(k, m) {
            super(k);
            this._functionBlock = null;
            this._functionName = m[1];
            this._owner.SetVariesPerInstance()
        }
        _PostInit() {
            const k = this._runtime.GetEventSheetManager();
            this._functionBlock = k.GetFunctionBlockByName(this._functionName);
            this._functionName = null;
            const m = this._owner.GetEventBlock(),
                r = this._functionBlock.GetEventBlock();
            this._combinedSolModifiers = [...new Set([...m.GetSolModifiersIncludingParents(), ...r.GetSolModifiersIncludingParents()])];
            this._combinedSolModifiers =
                k._DeduplicateSolModifierList(this._combinedSolModifiers)
        }
        GetBoundMethod() {
            const k = this._functionBlock;
            if (k.IsEnabled()) {
                const m = k.GetEventBlock();
                return e.EventBlock.prototype.RunAsExpressionFunctionCall.bind(m, this._combinedSolModifiers, k.GetReturnType(), k.GetDefaultReturnValue())
            } {
                const m = k.GetDefaultReturnValue();
                return () => m
            }
        }
    }

    function b(k, m) {
        if (k >= m) return k % m;
        0 > k && (k <= -m && (k %= m), 0 > k && (k += m));
        return k
    }
    class c extends e.ExpNode {
        constructor(k, m) {
            super(k);
            this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
            this._func = this._runtime.GetObjectReference(m[2]);
            this._returnsString = !!m[3];
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._owner._MaybeVaryFor(this._objectClass)
        }
        GetBoundMethod() {
            return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
        }
        ExpObject(...k) {
            const m = this._objectClass,
                r = m.GetCurrentSol().GetExpressionInstances();
            var w = r.length;
            if (0 === w) return this._returnsString ? "" : 0;
            w = b(this._owner.GetSolIndex(),
                w);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m);
            return this._func.apply(r[w].GetSdkInstance(), k)
        }
        ExpObject_InstExpr(k, ...m) {
            const r = this._objectClass,
                w = r.GetInstances(),
                p = w.length;
            if (0 === p) return this._returnsString ? "" : 0;
            k = b(k, p);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(r);
            return this._func.apply(w[k].GetSdkInstance(), m)
        }
    }
    class f extends e.ExpNode {
        constructor(k, m) {
            super(k);
            this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
            this._varIndex = m[3];
            this._returnsString = !!m[2];
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpInstVar() {
            const k = this._objectClass.GetCurrentSol().GetExpressionInstances();
            var m = k.length;
            if (0 === m) return this._returnsString ? "" : 0;
            m = b(this._owner.GetSolIndex(), m);
            return k[m]._GetInstanceVariableValueUnchecked(this._varIndex)
        }
        ExpInstVar_Family() {
            var k = this._objectClass,
                m = k.GetCurrentSol().GetExpressionInstances(),
                r = m.length;
            if (0 === r) return this._returnsString ? "" : 0;
            r = b(this._owner.GetSolIndex(), r);
            m = m[r];
            k = m.GetObjectClass().GetFamilyInstanceVariableOffset(k.GetFamilyIndex());
            return m._GetInstanceVariableValueUnchecked(this._varIndex + k)
        }
        ExpInstVar_InstExpr(k) {
            const m = this._objectClass;
            var r = m.GetInstances();
            const w = r.length;
            if (0 === w) return this._returnsString ? "" : 0;
            k = b(k, w);
            r = r[k];
            k = 0;
            m.IsFamily() && (k = r.GetObjectClass().GetFamilyInstanceVariableOffset(m.GetFamilyIndex()));
            return r._GetInstanceVariableValueUnchecked(this._varIndex + k)
        }
    }
    class h extends e.ExpNode {
        constructor(k, m) {
            super(k);
            this._objectClass = this._runtime.GetObjectClassByIndex(m[1]);
            this._behaviorType = this._objectClass.GetBehaviorTypeByName(m[2]);
            this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(m[2]);
            this._func = this._runtime.GetObjectReference(m[3]);
            this._returnsString = !!m[4];
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpBehavior(...k) {
            const m = this._objectClass;
            var r = m.GetCurrentSol().GetExpressionInstances(),
                w = r.length;
            if (0 === w) return this._returnsString ? "" : 0;
            w = b(this._owner.GetSolIndex(), w);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m);
            r = r[w];
            w = 0;
            m.IsFamily() && (w = r.GetObjectClass().GetFamilyBehaviorOffset(m.GetFamilyIndex()));
            return this._func.apply(r.GetBehaviorInstances()[this._behaviorIndex + w].GetSdkInstance(), k)
        }
        ExpBehavior_InstExpr(k, ...m) {
            const r = this._objectClass;
            var w = r.GetInstances();
            const p = w.length;
            if (0 === p) return this._returnsString ? "" : 0;
            k = b(k, p);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(r);
            w = w[k];
            k = 0;
            r.IsFamily() && (k = w.GetObjectClass().GetFamilyBehaviorOffset(r.GetFamilyIndex()));
            return this._func.apply(w.GetBehaviorInstances()[this._behaviorIndex +
                k].GetSdkInstance(), m)
        }
    }
    class g extends e.ExpNode {
        constructor(k, m) {
            super(k);
            this._eventVar = null;
            this._eventVarSid = m[1]
        }
        _PostInit() {
            this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetVar() {
            return this._eventVar
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Parameter = class extends e.DefendedBase {
        constructor(y, B, F) {
            super();
            this._owner = y;
            this._index = F;
            this._type = B;
            this.Get = null;
            this._isConstant = this._variesPerInstance = !1
        }
        static Create(y, B, F) {
            const H = B[0];
            return e.New([a, b, r, f, g, c, k, a, f, f, w, p, r, u, b, m, h, t, q, x][H], y, H, F, B)
        }
        _PostInit() {}
        SetVariesPerInstance() {
            this._variesPerInstance = !0
        }
        _MaybeVaryFor(y) {
            this._variesPerInstance || !y || y.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
        }
        VariesPerInstance() {
            return this._variesPerInstance
        }
        GetIndex() {
            return this._index
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        GetEventBlock() {
            return this._owner.GetEventBlock()
        }
        IsConstant() {
            return this._isConstant
        }
    };

    function d(y) {
        y = self.C3_ExpressionFuncs[y];
        if (!y) throw Error("invalid expression number");
        return y
    }
    class a extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._solIndex = 0;
            y = H[1];
            this._expressionNumber = y[0];
            this._numberedNodes = [];
            this._expressionFunc = null;
            for (let K = 1, C = y.length; K < C; ++K) this._numberedNodes.push(e.ExpNode.CreateNode(this, y[K]));
            this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = d(this._expressionNumber), this._isConstant = !0)
        }
        _GetNode(y) {
            if (0 > y || y >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
            return this._numberedNodes[y]
        }
        _PostInit() {
            for (var y of this._numberedNodes) y._PostInit();
            y = d(this._expressionNumber);
            this._expressionFunc = this._numberedNodes.length ? y(this) : y
        }
        GetSolIndex() {
            return this._solIndex
        }
        GetExpression(y) {
            this._solIndex = y;
            return this._expressionFunc()
        }
    }
    class b extends a {
        constructor(y, B, F, H) {
            super(y, B, F, H);
            this.Get = this.GetStringExpression;
            14 === B && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof e.Action && this.GetEventBlock().SetSolWriterAfterCnds())
        }
        GetStringExpression(y) {
            this._solIndex =
                y;
            y = this._expressionFunc();
            return "string" === typeof y ? y : ""
        }
        _GetFastTriggerValue() {
            return d(this._expressionNumber)()
        }
    }
    class c extends a {
        constructor(y, B, F, H) {
            super(y, B, F, H);
            this.Get = this.GetLayer;
            this._isConstant = !1
        }
        GetLayer(y) {
            this._solIndex = y;
            y = this._expressionFunc();
            return this.GetRuntime().GetCurrentLayout().GetLayer(y)
        }
    }
    class f extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._combo = H[1];
            this.Get = this.GetCombo;
            this._isConstant = !0
        }
        GetCombo() {
            return this._combo
        }
    }
    class h extends e.Parameter {
        constructor(y,
            B, F, H) {
            super(y, B, F);
            this._bool = H[1];
            this.Get = this.GetBoolean;
            this._isConstant = !0
        }
        GetBoolean() {
            return this._bool
        }
    }
    class g extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._objectClass = this.GetRuntime().GetObjectClassByIndex(H[1]);
            this.Get = this.GetObjectClass;
            y = this.GetEventBlock();
            y._AddSolModifier(this._objectClass);
            this._owner instanceof e.Action ? y.SetSolWriterAfterCnds() : y.GetParent() && y.GetParent().SetSolWriterAfterCnds();
            this._isConstant = !0
        }
        GetObjectClass() {
            return this._objectClass
        }
    }
    class k extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(H[1]);
            this.Get = this.GetLayout;
            this._isConstant = !0
        }
        GetLayout() {
            return this._layout
        }
    }
    class m extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(H[1]);
            this.Get = this.GetTimeline;
            this._isConstant = !0
        }
        GetTimeline() {
            return this._timeline
        }
    }
    class r extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._fileInfo =
                H[1];
            this.Get = this.GetFile;
            this._isConstant = !0
        }
        GetFile() {
            return this._fileInfo
        }
    }
    class w extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._instVarIndex = H[1];
            (y = this._owner.GetObjectClass()) && y.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = !0)
        }
        GetInstanceVariable() {
            return this._instVarIndex
        }
        GetFamilyInstanceVariable(y) {
            y = y || 0;
            const B = this._owner.GetObjectClass();
            var F = B.GetCurrentSol();
            const H = F.GetInstances();
            if (H.length) y = H[y % H.length].GetObjectClass();
            else if (F.HasAnyElseInstances()) F = F.GetElseInstances(), y = F[y % F.length].GetObjectClass();
            else if (0 < B.GetInstanceCount()) F = B.GetInstances(), y = F[y % F.length].GetObjectClass();
            else return 0;
            return this._instVarIndex + y.GetFamilyInstanceVariableOffset(B.GetFamilyIndex())
        }
    }
    class p extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._eventVarSid = H[1];
            this._eventVar = null;
            this.Get = this.GetEventVariable;
            this._isConstant = !0
        }
        _PostInit() {
            this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetEventVariable() {
            return this._eventVar
        }
    }
    class t extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._functionBlockName = H[1];
            this._functionBlock = null;
            this.Get = this.GetFunction;
            this._isConstant = !0
        }
        _PostInit() {
            this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);
            this._functionBlockName = null
        }
        GetFunction() {
            return this._functionBlock
        }
    }
    class u extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._subParams = [];
            this._variadicRet = [];
            this._isConstant = !0;
            for (let K = 1, C = H.length; K <
                C; ++K) y = e.Parameter.Create(this._owner, H[K], 0), this._subParams.push(y), this._variadicRet.push(0), y.IsConstant() || (this._isConstant = !1);
            this.Get = this.GetVariadic
        }
        _PostInit() {
            for (const y of this._subParams) y._PostInit()
        }
        GetVariadic() {
            const y = this._subParams,
                B = this._variadicRet;
            for (let F = 0, H = y.length; F < H; ++F) B[F] = y[F].Get(0);
            return B
        }
    }
    class q extends e.Parameter {
        constructor(y, B, F, H) {
            super(y, B, F);
            this._easeIndex = H[1];
            this.Get = this.GetEase;
            this._isConstant = !0
        }
        GetEase() {
            return this._easeIndex
        }
    }
    class x extends e.Parameter {
        constructor(y,
            B, F, H) {
            super(y, B, F);
            this._brushIndex = H[1];
            this.Get = this.GetTilemapBrush;
            this._isConstant = !0
        }
        GetTilemapBrush() {
            return this._brushIndex
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(c, f) {
        for (let h = 0, g = c.length; h < g; ++h) f[h] = c[h].Get(0)
    }
    const a = [],
        b = function() {};
    e.Condition = class extends e.DefendedBase {
        constructor(c, f, h) {
            super();
            this._eventBlock = c;
            this._runtime = c.GetRuntime();
            this._index = h;
            this._func = this._runtime.GetObjectReference(f[1]);
            this._isTrigger = 0 < f[3];
            this._isFastTrigger = 2 === f[3];
            this._isLooping = !!f[4];
            this._isInverted = !!f[5];
            this._isStatic = !!f[6];
            this._sid = f[7];
            this._isInOrBlock = this._eventBlock.IsOrBlock();
            this._behaviorType =
                this._objectClass = null;
            this._behaviorIndex = -1;
            this._systemPlugin = null;
            this.DebugRun = this.Run = b;
            this._parameters = [];
            this._results = [];
            this._anyParamVariesPerInstance = !1;
            this._unsavedData = this._savedData = null;
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: f[8][0],
                canDebug: f[8][1]
            } : null; - 1 === f[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(f[0]), f[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(f[2]), this._behaviorIndex =
                this._objectClass.GetBehaviorIndexByName(f[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds());
            if (10 === f.length) {
                c = f[9];
                for (let g of c) this._parameters.push(e.Parameter.Create(this, g, this._parameters.length)), this._results.push(0)
            }
            0 === this._parameters.length && (this._results = this._parameters = a);
            this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
        }
        static Create(c, f, h) {
            return e.New(e.Condition, c, f, h)
        }
        _PostInit() {
            for (const c of this._parameters) c._PostInit(),
                c.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject)
        }
        _SetSystemRunMethod() {
            this._SetRunMethodForBoundFunc(this._systemPlugin,
                this._systemPlugin, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const c = this._objectClass.GetPlugin(),
                f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(c, f, this._RunSingleGlobal)
        }
        _SetRunMethodForBoundFunc(c, f, h) {
            const g = this._func,
                k = this._isInverted,
                m = this._parameters;
            if (0 === m.length) {
                const r = c._GetBoundACEMethod(g, f);
                this.Run = k ? function() {
                    return e.xor(r(), k)
                } : r
            } else if (1 === m.length) {
                const r = m[0];
                if (!k && r.IsConstant()) this.Run = c._GetBoundACEMethod_1param(g,
                    f, r.Get(0));
                else {
                    const w = c._GetBoundACEMethod(g, f);
                    this.Run = function() {
                        return e.xor(w(r.Get(0)), k)
                    }
                }
            } else if (2 === m.length) {
                const r = m[0],
                    w = m[1];
                if (!k && r.IsConstant() && w.IsConstant()) this.Run = c._GetBoundACEMethod_2params(g, f, r.Get(0), w.Get(0));
                else {
                    const p = c._GetBoundACEMethod(g, f);
                    this.Run = function() {
                        return e.xor(p(r.Get(0), w.Get(0)), k)
                    }
                }
            } else if (3 === m.length) {
                const r = m[0],
                    w = m[1],
                    p = m[2];
                if (!k && r.IsConstant() && w.IsConstant() && p.IsConstant()) this.Run = c._GetBoundACEMethod_3params(g, f, r.Get(0), w.Get(0),
                    p.Get(0));
                else {
                    const t = c._GetBoundACEMethod(g, f);
                    this.Run = function() {
                        return e.xor(t(r.Get(0), w.Get(0), p.Get(0)), k)
                    }
                }
            } else this.Run = h
        }
        GetSID() {
            return this._sid
        }
        _GetFunc() {
            return this._func
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this.GetIndex()
        }
        IsTrigger() {
            return this._isTrigger
        }
        IsFastTrigger() {
            return this._isFastTrigger
        }
        IsInverted() {
            return this._isInverted
        }
        IsLooping() {
            return this._isLooping
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(c) {
            this._debugData.isBreakpoint = !!c;
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        _RunSystem() {
            const c = this._results;
            d(this._parameters, c);
            return e.xor(this._func.apply(this._systemPlugin, c),
                this._isInverted)
        }* _DebugRunSystem() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                d(this._parameters, c);
                c = this._func.apply(this._systemPlugin, c);
                e.IsIterator(c) && (c = yield* c);
                return e.xor(c, this._isInverted)
            }
            return this.Run()
        }
        _RunSingleGlobal() {
            const c = this._results;
            d(this._parameters, c);
            const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            return e.xor(this._func.apply(f, c), this._isInverted)
        }* _DebugRunSingleGlobal() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                d(this._parameters, c);
                const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
                c = this._func.apply(f, c);
                e.IsIterator(c) && (c = yield* c);
                return e.xor(c, this._isInverted)
            }
            return this.Run()
        }
        _RunFastTrigger() {
            return !0
        }* _DebugRunFastTrigger() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return !0
        }
        _RunStatic() {
            var c = this._results;
            d(this._parameters, c);
            c = this._func.apply(this._behaviorType ||
                this._objectClass, c);
            this._objectClass.ApplySolToContainer();
            return c
        }* _DebugRunStatic() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                d(this._parameters, c);
                c = this._func.apply(this._behaviorType || this._objectClass, c);
                e.IsIterator(c) && (c = yield* c);
                this._objectClass.ApplySolToContainer();
                return c
            }
            return this.Run()
        }
        _RunObject() {
            const c = this._parameters,
                f = this._results,
                h = this._objectClass.GetCurrentSol();
            for (let g = 0, k = c.length; g <
                k; ++g) {
                const m = c[g];
                m.VariesPerInstance() || (f[g] = m.Get(0))
            }
            return h.IsSelectAll() ? this._RunObject_FirstFilter(h) : this._RunObject_NextFilter(h)
        }* _DebugRunObject() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return this._RunObject()
        }
        _EvaluateVaryingParameters(c) {
            const f = this._parameters,
                h = this._results;
            for (let g = 0, k = f.length; g < k; ++g) {
                const m = f[g];
                m.VariesPerInstance() && (h[g] = m.Get(c))
            }
        }
        _RunObject_FirstFilter(c) {
            const f = this._objectClass,
                h = f.IsFamily(),
                g = f.GetFamilyIndex(),
                k = this._behaviorIndex,
                m = 0 <= k,
                r = f.GetInstances(),
                w = this._anyParamVariesPerInstance,
                p = this._results,
                t = this._func,
                u = this._isInverted,
                q = this._isInOrBlock && !this._isTrigger;
            c.ClearArrays();
            for (let y = 0, B = r.length; y < B; ++y) {
                const F = r[y];
                w && this._EvaluateVaryingParameters(y);
                var x = void 0;
                m ? (x = h ? F.GetObjectClass().GetFamilyBehaviorOffset(g) : 0, x = t.apply(F.GetBehaviorInstances()[k + x].GetSdkInstance(), p)) : x = t.apply(F.GetSdkInstance(), p);
                e.xor(x, u) ? c._PushInstance(F) : q && c._PushElseInstance(F)
            }
            f.FinishCondition(!0);
            c._SetSelectAll(!1);
            f.ApplySolToContainer();
            return c.HasAnyInstances()
        }
        _RunObject_NextFilter(c) {
            const f = this._objectClass;
            var h = f.IsFamily();
            const g = f.GetFamilyIndex(),
                k = f.IsInContainer(),
                m = this._behaviorIndex,
                r = 0 <= m,
                w = this._anyParamVariesPerInstance,
                p = this._results,
                t = this._func,
                u = this._isInverted,
                q = this._isInOrBlock && !this._isTrigger,
                x = c._GetOwnInstances(),
                y = c._GetOwnElseInstances(),
                B = q && !this._eventBlock.IsFirstConditionOfType(this),
                F = B ? y : x;
            let H = 0,
                K = !1;
            for (let A = 0, G = F.length; A < G; ++A) {
                const J = F[A];
                w && this._EvaluateVaryingParameters(A);
                var C = void 0;
                r ? (C = h ? J.GetObjectClass().GetFamilyBehaviorOffset(g) : 0, C = t.apply(J.GetBehaviorInstances()[m + C].GetSdkInstance(), p)) : C = t.apply(J.GetSdkInstance(), p);
                e.xor(C, u) ? (K = !0, B ? (x.push(J), k && J._PushSiblingsToSolInstances()) : (F[H] = J, k && J._SetSiblingsToSolInstancesIndex(H), ++H)) : B ? (F[H] = J, k && J._SetSiblingsToSolElseInstancesIndex(H), ++H) : q && (y.push(J), k && J._PushSiblingsToSolElseInstances())
            }
            e.truncateArray(F, H);
            k && f._TruncateContainerSols(B, H);
            h = K;
            B && !K && (K = this._OrBlockCheckInstances(x));
            f.FinishCondition(h ||
                q);
            return q ? K : c.HasAnyInstances()
        }
        _OrBlockCheckInstances(c) {
            var f = this._objectClass;
            const h = f.IsFamily();
            f = f.GetFamilyIndex();
            const g = this._anyParamVariesPerInstance,
                k = this._behaviorIndex,
                m = 0 <= k,
                r = this._results,
                w = this._func,
                p = this._isInverted;
            for (let u = 0, q = c.length; u < q; ++u) {
                var t = c[u];
                g && this._EvaluateVaryingParameters(u);
                if (m) {
                    const x = h ? t.GetObjectClass().GetFamilyBehaviorOffset(f) : 0;
                    t = w.apply(t.GetBehaviorInstances()[k + x].GetSdkInstance(), r)
                } else t = w.apply(t.GetSdkInstance(), r);
                if (e.xor(t, p)) return !0
            }
            return !1
        }
        ReevaluateParameter(c,
            f) {
            return this._parameters[c].Get(f)
        }
        GetFastTriggerValue() {
            const c = this._parameters;
            if (!c.length) throw Error("no parameters");
            return c[0]._GetFastTriggerValue()
        }
        _SaveToJson() {
            if (!this._savedData || !this._savedData.size) return null;
            const c = {};
            for (const [f, h] of this._savedData.entries()) {
                let g = h;
                "collmemory" === f && (g = [...h.entries()].map(k => [k[0].GetUID(), k[1].GetUID(), k[2]]));
                c[f] = g
            }
            return {
                ex: c
            }
        }
        _LoadFromJson(c) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            if (c) {
                var f = this._runtime,
                    h = c.ex;
                if (h) {
                    c = this.GetSavedDataMap();
                    c.clear();
                    for (const [g, k] of Object.entries(h)) h = k, "collmemory" === g && (h = e.New(e.PairMap, k.map(m => [f.GetInstanceByUID(m[0]), f.GetInstanceByUID(m[1]), m[2]]).filter(m => m[0] && m[1]))), c.set(g, h)
                }
            }
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(f, h) {
        for (let g = 0, k = f.length; g < k; ++g) h[g] = f[g].Get(0)
    }
    const a = [],
        b = function() {},
        c = function*() {};
    e.Action = class extends e.DefendedBase {
        constructor(f, h, g) {
            super();
            this._eventBlock = f;
            this._runtime = f = f.GetRuntime();
            this._index = g;
            this._sid = 4 <= h.length ? h[3] : -1;
            this._actionReturnType = 5 <= h.length ? h[4] : 0;
            this._behaviorType = this._objectClass = this._func = null;
            this._behaviorIndex = -1;
            this._systemPlugin = null;
            this._callFunctionName = "";
            this._combinedSolModifiers = this._callEventBlock =
                null;
            this.DebugRun = this.Run = b;
            this._parameters = [];
            this._results = [];
            this._anyParamVariesPerInstance = !1;
            this._unsavedData = this._savedData = null;
            const k = (g = -3 === h[0]) ? h[2] : h[5];
            this._debugData = f.IsDebug() || g ? {
                isBreakpoint: k[0],
                canDebug: k[1],
                index: k[2]
            } : null; - 1 === h[0] ? (this._systemPlugin = f.GetSystemPlugin(), this._func = f.GetObjectReference(h[1])) : -2 === h[0] ? this._callFunctionName = h[1] : g ? (this._func = f.GetObjectReference(h[1]), this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._actionReturnType =
                1) : (this._func = f.GetObjectReference(h[1]), this._objectClass = f.GetObjectClassByIndex(h[0]), h[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(h[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(h[2])));
            if (7 === h.length) {
                h = h[6];
                for (const m of h) this._parameters.push(e.Parameter.Create(this, m, this._parameters.length)), this._results.push(0)
            }
            0 === this._parameters.length && (this._results = this._parameters = a);
            this._eventBlock.GetEventSheetManager()._RegisterAction(this)
        }
        static Create(f,
            h, g) {
            return e.New(e.Action, f, h, g)
        }
        _PostInit() {
            for (var f of this._parameters) f._PostInit(), f.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
            else if (this._callFunctionName) this._SetCallFunctionRunMethod(), this._callFunctionName = "";
            else if (this.Run === this.RunUserScript) {
                f = this._func;
                const h = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
                this._func = f.bind(null, this._runtime.GetIRuntime(),
                    h)
            } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this._parameters.length ? this._parameters.every(h => h.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary,
                this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(h => h.IsConstant()) ? (d(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst)
        }
        _SetSystemRunMethod() {
            this._SetRunMethodForBoundFunc(this._systemPlugin,
                this._systemPlugin, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const f = this._objectClass.GetPlugin(),
                h = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(f, h, this._RunSingleGlobal)
        }
        _SetCallFunctionRunMethod() {
            const f = this._eventBlock.GetEventSheetManager(),
                h = f.GetFunctionBlockByName(this._callFunctionName);
            h.IsEnabled() ? (this._callEventBlock = h.GetEventBlock(), this._combinedSolModifiers = [...new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])],
                this._combinedSolModifiers = f._DeduplicateSolModifierList(this._combinedSolModifiers), this.Run = e.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters), this.DebugRun = this._DebugRunCallFunction) : (this.Run = b, this.DebugRun = c)
        }
        _SetRunMethodForBoundFunc(f, h, g) {
            const k = this._func,
                m = this._parameters;
            if (0 === m.length) this.Run = f._GetBoundACEMethod(k, h);
            else if (1 === m.length) {
                const r = m[0];
                if (r.IsConstant()) this.Run = f._GetBoundACEMethod_1param(k, h, r.Get(0));
                else {
                    const w = f._GetBoundACEMethod(k, h);
                    this.Run = function() {
                        return w(r.Get(0))
                    }
                }
            } else if (2 === m.length) {
                const r = m[0],
                    w = m[1];
                if (r.IsConstant() && w.IsConstant()) this.Run = f._GetBoundACEMethod_2params(k, h, r.Get(0), w.Get(0));
                else {
                    const p = f._GetBoundACEMethod(k, h);
                    this.Run = function() {
                        return p(r.Get(0), w.Get(0))
                    }
                }
            } else if (3 === m.length) {
                const r = m[0],
                    w = m[1],
                    p = m[2];
                if (r.IsConstant() && w.IsConstant() && p.IsConstant()) this.Run = f._GetBoundACEMethod_3params(k, h, r.Get(0), w.Get(0), p.Get(0));
                else {
                    const t = f._GetBoundACEMethod(k,
                        h);
                    this.Run = function() {
                        return t(r.Get(0), w.Get(0), p.Get(0))
                    }
                }
            } else this.Run = g
        }
        GetSID() {
            return this._sid
        }
        IsAsync() {
            return 1 === this._actionReturnType
        }
        CanBailOut() {
            return 2 === this._actionReturnType
        }
        HasReturnType() {
            return 0 !== this._actionReturnType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this._debugData.index
        }
        GetCombinedSolModifiers() {
            return this._combinedSolModifiers
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(f) {
            this._debugData.isBreakpoint = !!f;
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        _RunSystem() {
            const f = this._results;
            d(this._parameters, f);
            return this._func.apply(this._systemPlugin, f)
        }* _DebugRunSystem() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results;
                d(this._parameters, f);
                return yield* this._func.apply(this._systemPlugin, f)
            }
            return this.Run()
        }* _DebugRunCallFunction() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return yield* this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters)
        }
        _RunSingleGlobal() {
            const f = this._results;
            d(this._parameters, f);
            return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(),
                f)
        }* _DebugRunSingleGlobal() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results;
                d(this._parameters, f);
                return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), f)
            }
            return this.Run()
        }
        _RunObject_ParamsConst() {
            const f = this._results,
                h = this._objectClass.GetCurrentSol().GetInstances();
            for (let g = 0, k = h.length; g < k; ++g) this._func.apply(h[g].GetSdkInstance(), f)
        }* _DebugRunObject_ParamsConst() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results,
                    h = this._objectClass.GetCurrentSol().GetInstances();
                for (let g = 0, k = h.length; g < k; ++g) yield* this._func.apply(h[g].GetSdkInstance(), f)
            } else this._RunObject_ParamsConst()
        }
        _RunObject_ParamsDontVary() {
            const f = this._results;
            d(this._parameters, f);
            const h = this._objectClass.GetCurrentSol().GetInstances();
            for (let g = 0, k = h.length; g < k; ++g) this._func.apply(h[g].GetSdkInstance(), f)
        }* _DebugRunObject_ParamsDontVary() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results;
                d(this._parameters, f);
                const h = this._objectClass.GetCurrentSol().GetInstances();
                for (let g = 0, k = h.length; g < k; ++g) yield* this._func.apply(h[g].GetSdkInstance(), f)
            } else this._RunObject_ParamsDontVary()
        }
        _RunObject_AllParamsVary() {
            const f = this._parameters,
                h = this._results,
                g = this._func,
                k = this._objectClass.GetCurrentSol().GetInstances();
            for (let m = 0, r = k.length; m < r; ++m) {
                const w = k[m];
                for (let p = 0, t = f.length; p < t; ++p) h[p] =
                    f[p].Get(m);
                g.apply(w.GetSdkInstance(), h)
            }
        }* _DebugRunObject_AllParamsVary() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._parameters,
                    h = this._results,
                    g = this._func,
                    k = this._objectClass.GetCurrentSol().GetInstances();
                for (let m = 0, r = k.length; m < r; ++m) {
                    const w = k[m];
                    for (let p = 0, t = f.length; p < t; ++p) h[p] = f[p].Get(m);
                    yield* g.apply(w.GetSdkInstance(), h)
                }
            } else this._RunObject_AllParamsVary()
        }
        _RunObject_SomeParamsVary() {
            const f = this._parameters,
                h = this._results,
                g = this._func,
                k = this._objectClass.GetCurrentSol().GetInstances();
            for (let r = 0, w = f.length; r < w; ++r) {
                var m = f[r];
                m.VariesPerInstance() || (h[r] = m.Get(0))
            }
            for (let r = 0, w = k.length; r < w; ++r) {
                m = k[r];
                for (let p = 0, t = f.length; p < t; ++p) {
                    const u = f[p];
                    u.VariesPerInstance() && (h[p] = u.Get(r))
                }
                g.apply(m.GetSdkInstance(), h)
            }
        }* _DebugRunObject_SomeParamsVary() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const h = this._parameters,
                    g = this._results,
                    k = this._func,
                    m = this._objectClass.GetCurrentSol().GetInstances();
                for (let r = 0, w = h.length; r < w; ++r) {
                    var f = h[r];
                    f.VariesPerInstance() || (g[r] = f.Get(0))
                }
                for (let r = 0, w = m.length; r < w; ++r) {
                    f = m[r];
                    for (let p = 0, t = h.length; p < t; ++p) {
                        const u = h[p];
                        u.VariesPerInstance() && (g[p] = u.Get(r))
                    }
                    yield* k.apply(f.GetSdkInstance(), g)
                }
            } else this._RunObject_SomeParamsVary()
        }
        _RunBehavior() {
            var f = this._objectClass;
            const h = f.IsFamily(),
                g = f.GetFamilyIndex(),
                k = this._parameters,
                m = this._anyParamVariesPerInstance,
                r = this._results,
                w = this._func,
                p = this._behaviorIndex;
            f = f.GetCurrentSol().GetInstances();
            for (let q = 0, x = k.length; q < x; ++q) {
                var t = k[q];
                t.VariesPerInstance() || (r[q] = t.Get(0))
            }
            for (let q = 0, x = f.length; q < x; ++q) {
                t = f[q];
                if (m)
                    for (let y = 0, B = k.length; y < B; ++y) {
                        var u = k[y];
                        u.VariesPerInstance() && (r[y] = u.Get(q))
                    }
                u = h ? t.GetObjectClass().GetFamilyBehaviorOffset(g) : 0;
                w.apply(t.GetBehaviorInstances()[p + u].GetSdkInstance(), r)
            }
        }* _DebugRunBehavior() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var f = this._objectClass;
                const k =
                    f.IsFamily(),
                    m = f.GetFamilyIndex(),
                    r = this._parameters,
                    w = this._anyParamVariesPerInstance,
                    p = this._results,
                    t = this._func,
                    u = this._behaviorIndex;
                f = f.GetCurrentSol().GetInstances();
                for (let q = 0, x = r.length; q < x; ++q) {
                    var h = r[q];
                    h.VariesPerInstance() || (p[q] = h.Get(0))
                }
                for (let q = 0, x = f.length; q < x; ++q) {
                    h = f[q];
                    if (w)
                        for (let y = 0, B = r.length; y < B; ++y) {
                            var g = r[y];
                            g.VariesPerInstance() && (p[y] = g.Get(q))
                        }
                    g = k ? h.GetObjectClass().GetFamilyBehaviorOffset(m) : 0;
                    yield* t.apply(h.GetBehaviorInstances()[u + g].GetSdkInstance(), p)
                }
            } else this._RunBehavior()
        }
        _RunObject_Async() {
            const f =
                this._parameters,
                h = this._results,
                g = this._func,
                k = this._objectClass.GetCurrentSol().GetInstances(),
                m = [];
            for (let r = 0, w = k.length; r < w; ++r) {
                const p = k[r];
                for (let t = 0, u = f.length; t < u; ++t) h[t] = f[t].Get(r);
                m.push(g.apply(p.GetSdkInstance(), h))
            }
            return Promise.all(m)
        }* _DebugRunObject_Async() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._parameters,
                    h = this._results,
                    g = this._func,
                    k = this._objectClass.GetCurrentSol().GetInstances(),
                    m = [];
                for (let r = 0,
                        w = k.length; r < w; ++r) {
                    const p = k[r];
                    for (let t = 0, u = f.length; t < u; ++t) h[t] = f[t].Get(r);
                    m.push(yield* g.apply(p.GetSdkInstance(), h))
                }
                return Promise.all(m)
            }
            return this._RunObject_Async()
        }
        _RunBehavior_Async() {
            var f = this._objectClass;
            const h = f.IsFamily(),
                g = f.GetFamilyIndex(),
                k = this._parameters,
                m = this._results,
                r = this._func,
                w = this._behaviorIndex;
            f = f.GetCurrentSol().GetInstances();
            const p = [];
            for (let t = 0, u = f.length; t < u; ++t) {
                const q = f[t];
                for (let y = 0, B = k.length; y < B; ++y) m[y] = k[y].Get(t);
                const x = h ? q.GetObjectClass().GetFamilyBehaviorOffset(g) :
                    0;
                p.push(r.apply(q.GetBehaviorInstances()[w + x].GetSdkInstance(), m))
            }
            return Promise.all(p)
        }* _DebugRunBehavior_Async() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var f = this._objectClass;
                const h = f.IsFamily(),
                    g = f.GetFamilyIndex(),
                    k = this._parameters,
                    m = this._results,
                    r = this._func,
                    w = this._behaviorIndex;
                f = f.GetCurrentSol().GetInstances();
                const p = [];
                for (let t = 0, u = f.length; t < u; ++t) {
                    const q = f[t];
                    for (let y = 0, B = k.length; y < B; ++y) m[y] = k[y].Get(t);
                    const x = h ?
                        q.GetObjectClass().GetFamilyBehaviorOffset(g) : 0;
                    p.push(yield* r.apply(q.GetBehaviorInstances()[w + x].GetSdkInstance(), m))
                }
                return Promise.all(p)
            }
            return this._RunBehavior_Async()
        }
        async RunUserScript() {
            try {
                await this._func()
            } catch (f) {
                console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex()+1}:`, "font-size: 1.2em; font-weight: bold;", f), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                    e.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), e.EventScript.SetHadUserScriptException())
            }
        }* DebugRunUserScript() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return this.RunUserScript()
        }
        _SaveToJson() {
            return this._savedData && this._savedData.size ? {
                ex: e.ToSuperJSON(this._savedData)
            } : null
        }
        _LoadFromJson(f) {
            this._savedData &&
                (this._savedData.clear(), this._savedData = null);
            f && (f = f.ex) && (this._savedData = e.FromSuperJSON(f))
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new e.Color;

    function a(N, P) {
        return e.compare(this.GetWorldInfo().GetX(), N, P)
    }

    function b(N, P) {
        return e.compare(this.GetWorldInfo().GetY(), N, P)
    }

    function c() {
        const N = this.GetWorldInfo(),
            P = N.GetLayer();
        return P.Has3DCamera() ? N.IsInViewport3D(P._GetViewFrustum()) : N.IsInViewport(P.GetViewport(), N.GetLayout().HasVanishingPointOutsideViewport(), N.GetLayout().IsOrthographicProjection())
    }

    function f() {
        var N = this.GetWorldInfo();
        const P = N.GetLayout();
        N = N.GetBoundingBox();
        return 0 >
            N.getRight() || 0 > N.getBottom() || N.getLeft() > P.GetWidth() || N.getTop() > P.GetHeight()
    }

    function h(N, P, W) {
        const Z = this.GetCurrentSol(),
            fa = Z.GetInstances();
        if (!fa.length) return !1;
        let ha = fa[0];
        var ka = ha.GetWorldInfo();
        let sa = ha,
            ma = e.distanceSquared(ka.GetX(), ka.GetY(), P, W);
        for (let xa = 1, ya = fa.length; xa < ya; ++xa)
            if (ha = fa[xa], ka = ha.GetWorldInfo(), ka = e.distanceSquared(ka.GetX(), ka.GetY(), P, W), 0 === N && ka < ma || 1 === N && ka > ma) ma = ka, sa = ha;
        Z.PickOne(sa);
        return !0
    }

    function g(N) {
        const P = this.GetWorldInfo();
        P.GetX() !== N &&
            (P.SetX(N), P.SetBboxChanged())
    }

    function k(N) {
        const P = this.GetWorldInfo();
        P.GetY() !== N && (P.SetY(N), P.SetBboxChanged())
    }

    function m(N, P) {
        const W = this.GetWorldInfo();
        W.EqualsXY(N, P) || (W.SetXY(N, P), W.SetBboxChanged())
    }

    function r(N, P) {
        if (N && (N = N.GetPairedInstance(this._inst))) {
            var [W, Z] = N.GetImagePoint(P);
            P = this.GetWorldInfo();
            if (P.GetX() !== W || P.GetY() !== Z) P.SetXY(W, Z), P.SetBboxChanged()
        }
    }

    function w(N) {
        if (0 !== N) {
            var P = this.GetWorldInfo();
            P.OffsetXY(P.GetCosAngle() * N, P.GetSinAngle() * N);
            P.SetBboxChanged()
        }
    }

    function p(N, P) {
        if (0 !== P) {
            var W = this.GetWorldInfo();
            N = e.toRadians(N);
            W.OffsetXY(Math.cos(N) * P, Math.sin(N) * P);
            W.SetBboxChanged()
        }
    }

    function t() {
        return this.GetWorldInfo().GetX()
    }

    function u() {
        return this.GetWorldInfo().GetY()
    }

    function q() {
        return this._runtime.GetDt(this._inst)
    }

    function x(N, P) {
        return e.compare(this.GetWorldInfo().GetWidth(), N, P)
    }

    function y(N, P) {
        return e.compare(this.GetWorldInfo().GetHeight(), N, P)
    }

    function B(N) {
        const P = this.GetWorldInfo();
        P.GetWidth() !== N && (P.SetWidth(N), P.SetBboxChanged())
    }

    function F(N) {
        const P = this.GetWorldInfo();
        P.GetHeight() !== N && (P.SetHeight(N), P.SetBboxChanged())
    }

    function H(N, P) {
        const W = this.GetWorldInfo();
        if (W.GetWidth() !== N || W.GetHeight() !== P) W.SetSize(N, P), W.SetBboxChanged()
    }

    function K() {
        return this.GetWorldInfo().GetWidth()
    }

    function C() {
        return this.GetWorldInfo().GetHeight()
    }

    function A() {
        return this.GetWorldInfo().GetBoundingBox().getLeft()
    }

    function G() {
        return this.GetWorldInfo().GetBoundingBox().getTop()
    }

    function J() {
        return this.GetWorldInfo().GetBoundingBox().getRight()
    }

    function M() {
        return this.GetWorldInfo().GetBoundingBox().getBottom()
    }

    function R(N, P) {
        return e.angleDiff(this.GetWorldInfo().GetAngle(), e.toRadians(P)) <= e.toRadians(N)
    }

    function U(N) {
        return e.angleClockwise(this.GetWorldInfo().GetAngle(), e.toRadians(N))
    }

    function V(N, P) {
        N = e.toRadians(N);
        P = e.toRadians(P);
        const W = this.GetWorldInfo().GetAngle();
        return e.angleClockwise(P, N) ? e.angleClockwise(W, N) && !e.angleClockwise(W, P) : !(!e.angleClockwise(W, N) && e.angleClockwise(W, P))
    }

    function ba(N) {
        const P = this.GetWorldInfo();
        N = e.clampAngle(e.toRadians(N));
        isNaN(N) || P.GetAngle() === N || (P.SetAngle(N), P.SetBboxChanged())
    }

    function ia(N) {
        if (!isNaN(N) && 0 !== N) {
            var P = this.GetWorldInfo();
            P.SetAngle(P.GetAngle() + e.toRadians(N));
            P.SetBboxChanged()
        }
    }

    function ja(N) {
        if (!isNaN(N) && 0 !== N) {
            var P = this.GetWorldInfo();
            P.SetAngle(P.GetAngle() - e.toRadians(N));
            P.SetBboxChanged()
        }
    }

    function qa(N, P) {
        const W = this.GetWorldInfo(),
            Z = W.GetAngle();
        N = e.angleRotate(Z, e.toRadians(P), e.toRadians(N));
        isNaN(N) || Z === N || (W.SetAngle(N), W.SetBboxChanged())
    }

    function za(N,
        P, W) {
        const Z = this.GetWorldInfo(),
            fa = Z.GetAngle();
        P -= Z.GetX();
        W -= Z.GetY();
        N = e.angleRotate(fa, Math.atan2(W, P), e.toRadians(N));
        isNaN(N) || fa === N || (Z.SetAngle(N), Z.SetBboxChanged())
    }

    function Ca(N, P) {
        const W = this.GetWorldInfo(),
            Z = W.GetAngle();
        N -= W.GetX();
        P -= W.GetY();
        P = Math.atan2(P, N);
        isNaN(P) || Z === P || (W.SetAngle(P), W.SetBboxChanged())
    }

    function Ma() {
        return e.toDegrees(this.GetWorldInfo().GetAngle())
    }

    function Fa(N, P) {
        return e.compare(e.round6dp(100 * this.GetWorldInfo().GetOpacity()), N, P)
    }

    function La() {
        return this.GetWorldInfo().IsVisible()
    }

    function na(N) {
        const P = this.GetWorldInfo();
        N = 2 === N ? !P.IsVisible() : 0 !== N;
        P.IsVisible() !== N && (P.SetVisible(N), this._runtime.UpdateRender())
    }

    function Sa(N) {
        N = e.clamp(N / 100, 0, 1);
        const P = this.GetWorldInfo();
        P.GetOpacity() !== N && (P.SetOpacity(N), this._runtime.UpdateRender())
    }

    function Aa(N) {
        d.setFromRgbValue(N);
        N = this.GetWorldInfo();
        N.GetUnpremultipliedColor().equalsIgnoringAlpha(d) || (N.SetUnpremultipliedColor(d), this._runtime.UpdateRender())
    }

    function Na() {
        const N = this.GetWorldInfo().GetUnpremultipliedColor();
        return e.PackRGBAEx(N.getR(), N.getG(), N.getB(), N.getA())
    }

    function lb() {
        return e.round6dp(100 * this.GetWorldInfo().GetOpacity())
    }

    function mb(N) {
        return N ? this.GetWorldInfo().GetLayer() === N : !1
    }

    function nb(N) {
        const P = this.GetCurrentSol(),
            W = P.GetInstances();
        if (!W.length) return !1;
        let Z = W[0];
        for (let fa = 1, ha = W.length; fa < ha; ++fa) {
            const ka = W[fa],
                sa = ka.GetWorldInfo(),
                ma = Z.GetWorldInfo(),
                xa = sa.GetLayer().GetIndex(),
                ya = ma.GetLayer().GetIndex();
            if (0 === N) {
                if (xa > ya || xa === ya && sa.GetZIndex() > ma.GetZIndex()) Z = ka
            } else if (xa <
                ya || xa === ya && sa.GetZIndex() < ma.GetZIndex()) Z = ka
        }
        P.PickOne(Z);
        return !0
    }

    function ab(N, P, W) {
        const Z = this.GetWorldInfo();
        N = 0 === N ? Z.GetZElevation() : Z.GetTotalZElevation();
        return e.compare(N, P, W)
    }

    function ob() {
        this.GetWorldInfo().ZOrderMoveToTop()
    }

    function pb() {
        this.GetWorldInfo().ZOrderMoveToBottom()
    }

    function qb(N) {
        N && this.GetWorldInfo().ZOrderMoveToLayer(N)
    }

    function rb(N, P) {
        N = 0 === N;
        P && (P = P.GetFirstPicked(this.GetInstance())) && this.GetWorldInfo().ZOrderMoveAdjacentToInstance(P, N)
    }

    function sb(N) {
        const P =
            this.GetWorldInfo();
        P.GetZElevation() !== N && (P.SetZElevation(N), this._runtime.UpdateRender())
    }

    function tb() {
        return this.GetWorldInfo().GetLayer().GetIndex()
    }

    function ub() {
        return this.GetWorldInfo().GetLayer().GetName()
    }

    function bb() {
        return this.GetWorldInfo().GetZIndex()
    }

    function vb() {
        return this.GetWorldInfo().GetZElevation()
    }

    function wb() {
        return this.GetWorldInfo().GetTotalZElevation()
    }

    function xb(N, P) {
        if (P = this.GetObjectClass().GetEffectList().GetEffectTypeByName(P)) {
            P = P.GetIndex();
            N = 1 === N;
            var W =
                this.GetWorldInfo().GetInstanceEffectList();
            W.IsEffectIndexActive(P) !== N && (W.SetEffectIndexActive(P, N), W.UpdateActiveEffects(), this._runtime.UpdateRender())
        }
    }

    function yb(N, P, W) {
        var Z = this.GetObjectClass().GetEffectList().GetEffectTypeByName(N);
        if (Z) {
            N = Z.GetIndex();
            var fa = this.GetWorldInfo().GetInstanceEffectList(),
                ha = fa.GetEffectParametersForIndex(N);
            P = Math.floor(P);
            if (!(0 > P || P >= ha.length)) {
                Z = Z.GetShaderProgram().GetParameterType(P);
                if ("color" === Z) {
                    d.setFromRgbValue(W);
                    P = ha[P];
                    if (d.equalsIgnoringAlpha(P)) return;
                    P.copyRgb(d)
                } else {
                    "percent" === Z && (W /= 100);
                    if (ha[P] === W) return;
                    ha[P] = W
                }
                fa.IsEffectIndexActive(N) && this._runtime.UpdateRender()
            }
        }
    }
    const cb = e.New(e.Rect),
        Xa = [],
        db = [];
    let eb = !1,
        Ya = null,
        fb = !1;
    const Ta = new Set;

    function gb(N, P, W, Z) {
        const fa = P.GetUID(),
            ha = W.GetUID();
        fa < ha ? N.Set(P, W, Z) : N.Set(W, P, Z)
    }

    function ra(N, P, W) {
        const Z = P.GetUID(),
            fa = W.GetUID();
        Z < fa ? N.Delete(P, W) : N.Delete(W, P)
    }

    function Qa(N, P) {
        N.DeleteEither(P)
    }

    function zb(N, P, W) {
        const Z = P.GetUID(),
            fa = W.GetUID();
        return Z < fa ? N.Get(P, W) : N.Get(W, P)
    }

    function Ab(N,
        P, W, Z) {
        if (!P) return !1;
        N = N.GetInstance();
        const fa = 0 !== W || 0 !== Z,
            ha = N.GetWorldInfo(),
            ka = N.GetRuntime(),
            sa = ka.GetCollisionEngine();
        var ma = ka.GetCurrentCondition();
        const xa = ma.GetEventBlock().IsOrBlock();
        var ya = ma.GetObjectClass();
        ma = ma.IsInverted();
        const Ka = P.GetCurrentSol();
        ya = ya !== P;
        Ya = P;
        eb = ya && !ma;
        fb = !1;
        let Ra = 0,
            Ea = 0,
            la = !1;
        Ka.IsSelectAll() ? (cb.copy(ha.GetBoundingBox()), cb.offset(W, Z), sa.GetCollisionCandidates(ha.GetLayer(), P, cb, db), P = db) : xa ? ka.IsCurrentConditionFirst() && !Ka._GetOwnElseInstances().length &&
            Ka._GetOwnInstances().length ? P = Ka._GetOwnInstances() : (P = Ka._GetOwnElseInstances(), fb = !0) : P = Ka._GetOwnInstances();
        fa && (Ra = ha.GetX(), Ea = ha.GetY(), ha.OffsetXY(W, Z), ha.SetBboxChanged());
        for (const da of P)
            if (sa.TestOverlap(N, da)) {
                la = !0;
                if (ma) break;
                ya && Ta.add(da)
            }
        fa && (ha.SetXY(Ra, Ea), ha.SetBboxChanged());
        e.clearArray(db);
        return la
    }

    function Db(N) {
        N = N.GetRuntime().GetCurrentEvent().IsOrBlock();
        const P = Ya.GetCurrentSol(),
            W = P._GetOwnInstances(),
            Z = P._GetOwnElseInstances();
        P.IsSelectAll() ? (P.SetSetPicked(Ta),
            N && (e.clearArray(Z), P.AddElseInstances(Ta, Ya.GetInstances()))) : N ? fb ? P.TransferElseInstancesToOwn(Ta) : (P.AddElseInstances(Ta, W), P.SetSetPicked(Ta)) : P.SetSetPicked(Ta);
        Ya.ApplySolToContainer()
    }

    function Eb(N, P) {
        eb && (P && Db(N), Ta.clear(), Ya = null, eb = !1)
    }

    function Fb(N) {
        if (this._runtime.IsDebugging()) return Gb.call(this, N);
        if (!N) return !1;
        var P = this._runtime;
        const W = P.GetCollisionEngine(),
            Z = P.GetEventSheetManager(),
            fa = Z.GetEventStack();
        var ha = Z.GetCurrentCondition();
        const ka = ha.GetObjectClass();
        var sa = ha.GetSavedDataMap(),
            ma = ha.GetUnsavedDataMap();
        ha = fa.GetCurrentStackFrame();
        const xa = P.GetTickCount(),
            ya = xa - 1,
            Ka = ha.GetCurrentEvent(),
            Ra = fa.Push(Ka);
        let Ea = sa.get("collmemory");
        Ea || (Ea = e.New(e.PairMap), sa.set("collmemory", Ea));
        ma.get("collisionCreatedDestroyCallback") || (ma.set("collisionCreatedDestroyCallback", !0), P.Dispatcher().addEventListener("instancedestroy", Ua => Qa(Ea, Ua.instance)));
        sa = ka.GetCurrentSol();
        P = N.GetCurrentSol();
        sa = sa.GetInstances();
        ma = null;
        for (let Ua = 0; Ua < sa.length; ++Ua) {
            const Da = sa[Ua];
            P.IsSelectAll() ?
                (W.GetCollisionCandidates(Da.GetWorldInfo().GetLayer(), N, Da.GetWorldInfo().GetBoundingBox(), Xa), ma = Xa, W.AddRegisteredCollisionCandidates(Da, N, ma)) : ma = P.GetInstances();
            for (let $a = 0; $a < ma.length; ++$a) {
                const Pa = ma[$a];
                if (W.TestOverlap(Da, Pa) || W.CheckRegisteredCollision(Da, Pa)) {
                    var la = zb(Ea, Da, Pa),
                        da = !1,
                        oa = -2;
                    "number" === typeof la && (da = !0, oa = la);
                    la = !da || oa < ya;
                    gb(Ea, Da, Pa, xa);
                    la && (la = Ka.GetSolModifiers(), Z.PushCopySol(la), oa = ka.GetCurrentSol(), da = N.GetCurrentSol(), oa._SetSelectAll(!1), da._SetSelectAll(!1),
                        ka === N ? (da = oa._GetOwnInstances(), e.clearArray(da), da.push(Da), da.push(Pa), ka.ApplySolToContainer()) : (oa = oa._GetOwnInstances(), da = da._GetOwnInstances(), e.clearArray(oa), e.clearArray(da), oa.push(Da), da.push(Pa), ka.ApplySolToContainer(), N.ApplySolToContainer()), Ka.Retrigger(ha, Ra), Z.PopSol(la))
                } else ra(Ea, Da, Pa)
            }
            e.clearArray(Xa)
        }
        fa.Pop();
        return !1
    }

    function* Gb(N) {
        if (!N) return !1;
        var P = this._runtime;
        const W = P.GetCollisionEngine(),
            Z = P.GetEventSheetManager(),
            fa = Z.GetEventStack(),
            ha = fa.GetCurrentStackFrame(),
            ka = P.GetTickCount(),
            sa = ka - 1,
            ma = ha.GetCurrentEvent(),
            xa = fa.Push(ma);
        var ya = Z.GetCurrentCondition();
        const Ka = ya.GetObjectClass();
        var Ra = ya.GetSavedDataMap();
        ya = ya.GetUnsavedDataMap();
        let Ea = Ra.get("collmemory");
        Ea || (Ea = e.New(e.PairMap), Ra.set("collmemory", Ea));
        ya.get("collisionCreatedDestroyCallback") || (ya.set("collisionCreatedDestroyCallback", !0), P.Dispatcher().addEventListener("instancedestroy", Ua => Qa(Ea, Ua.instance)));
        Ra = Ka.GetCurrentSol();
        P = N.GetCurrentSol();
        Ra = Ra.GetInstances();
        ya = null;
        for (let Ua =
                0; Ua < Ra.length; ++Ua) {
            const Da = Ra[Ua];
            P.IsSelectAll() ? (W.GetCollisionCandidates(Da.GetWorldInfo().GetLayer(), N, Da.GetWorldInfo().GetBoundingBox(), Xa), ya = Xa, W.AddRegisteredCollisionCandidates(Da, N, ya)) : ya = P.GetInstances();
            for (let $a = 0; $a < ya.length; ++$a) {
                const Pa = ya[$a];
                if (W.TestOverlap(Da, Pa) || W.CheckRegisteredCollision(Da, Pa)) {
                    var la = zb(Ea, Da, Pa),
                        da = !1,
                        oa = -2;
                    "number" === typeof la && (da = !0, oa = la);
                    la = !da || oa < sa;
                    gb(Ea, Da, Pa, ka);
                    la && (la = ma.GetSolModifiers(), Z.PushCopySol(la), oa = Ka.GetCurrentSol(), da = N.GetCurrentSol(),
                        oa._SetSelectAll(!1), da._SetSelectAll(!1), Ka === N ? (da = oa._GetOwnInstances(), e.clearArray(da), da.push(Da), da.push(Pa), Ka.ApplySolToContainer()) : (oa = oa._GetOwnInstances(), da = da._GetOwnInstances(), e.clearArray(oa), e.clearArray(da), oa.push(Da), da.push(Pa), Ka.ApplySolToContainer(), N.ApplySolToContainer()), yield* ma.DebugRetrigger(ha, xa), Z.PopSol(la))
                } else ra(Ea, Da, Pa)
            }
            e.clearArray(Xa)
        }
        fa.Pop();
        return !1
    }

    function hb(N) {
        return Ab(this, N, 0, 0)
    }

    function ib(N, P, W) {
        return Ab(this, N, P, W)
    }

    function jb() {
        return this.GetWorldInfo().HasParent()
    }

    function kb() {
        return this.GetWorldInfo().HasChildren()
    }

    function Za(N, P) {
        const W = this.GetCurrentSol().GetInstances();
        if (0 === W.length) return !1;
        const Z = N.GetCurrentSol();
        var fa = Z.GetInstances();
        if (0 === fa.length) return !1;
        fa = new Set(fa);
        const ha = new Set;
        for (let sa = 0, ma = W.length; sa < ma; ++sa) {
            var ka = W[sa];
            if (1 === P)
                for (const xa of ka.parents()) xa.BelongsToObjectClass(N) && fa.has(xa) && ha.add(xa);
            else {
                if (0 === P) {
                    if (ka = ka.GetParent(), null === ka) continue
                } else ka = ka.GetTopParent();
                ka.BelongsToObjectClass(N) && fa.has(ka) &&
                    ha.add(ka)
            }
        }
        if (0 === ha.size) return !1;
        Z.SetSetPicked(ha);
        N.ApplySolToContainer();
        return !0
    }

    function l(N, P) {
        const W = this.GetCurrentSol().GetInstances();
        if (0 === W.length) return !1;
        const Z = N.GetCurrentSol();
        var fa = Z.GetInstances();
        if (Z.IsSelectAll()) {
            var ha = [...this._runtime.instancesPendingCreateForObjectClass(N)];
            0 < ha.length && (fa = fa.concat(ha))
        }
        if (0 === fa.length) return !1;
        fa = new Set(fa);
        ha = new Set;
        for (let ka = 0, sa = W.length; ka < sa; ++ka) {
            const ma = W[ka];
            2 === P && !ma.HasChildren() && ma.BelongsToObjectClass(N) && fa.has(ma) &&
                ha.add(ma);
            for (const xa of 0 === P ? ma.children() : ma.allChildren()) 2 === P && xa.HasChildren() || xa.BelongsToObjectClass(N) && fa.has(xa) && ha.add(xa)
        }
        if (0 === ha.size) return !1;
        Z.SetSetPicked(ha);
        N.ApplySolToContainer();
        return !0
    }

    function n(N, P) {
        const W = this.GetCurrentSol().GetInstances();
        if (0 === W.length) return !1;
        const Z = N.GetCurrentSol();
        var fa = Z.GetInstances();
        if (Z.IsSelectAll()) {
            var ha = [...this._runtime.instancesPendingCreateForObjectClass(N)];
            0 < ha.length && (fa = fa.concat(ha))
        }
        if (0 === fa.length) return !1;
        fa = new Set(fa);
        ha = [];
        for (let ka = 0, sa = W.length; ka < sa; ++ka) {
            const ma = W[ka].GetChildAt(P);
            null !== ma && ma.BelongsToObjectClass(N) && fa.has(ma) && ha.push(ma)
        }
        if (0 === ha.length) return !1;
        Z.SetArrayPicked(ha);
        N.ApplySolToContainer();
        return !0
    }

    function v(N, P) {
        return e.compare(this._inst.GetChildCount(), N, P)
    }

    function z(N, P, W, Z, fa, ha, ka, sa) {
        const ma = this._inst,
            xa = this._runtime.GetCurrentAction().GetObjectClass();
        for (const ya of N.allCorrespondingInstances(ma, xa)) {
            if (!ya.GetPlugin().SupportsSceneGraph()) break;
            ma.AddChild(ya, {
                transformX: P,
                transformY: W,
                transformWidth: Z,
                transformHeight: fa,
                transformAngle: ha,
                transformZElevation: ka,
                destroyWithParent: sa
            })
        }
    }

    function D(N) {
        const P = this._inst,
            W = this._runtime.GetCurrentAction().GetObjectClass();
        for (const Z of N.allCorrespondingInstances(P, W)) P.RemoveChild(Z)
    }

    function E() {
        this._inst.HasParent() && this._inst.GetParent().RemoveChild(this._inst)
    }

    function I() {
        return this._inst.GetChildCount()
    }

    function L(N, P) {
        N = Math.floor(N);
        P = Math.floor(P);
        const W = this.GetWorldInfo();
        2 > N || 2 > P || !isFinite(N) || !isFinite(P) ?
            (W.ReleaseMesh(), W.SetBboxChanged()) : W.CreateMesh(N, P)
    }

    function O(N, P, W, Z, fa, ha, ka, sa) {
        const ma = this.GetWorldInfo();
        ma.SetMeshPoint(N, P, {
            mode: 0 === W ? "absolute" : "relative",
            x: Z,
            y: fa,
            zElevation: ha,
            u: ka,
            v: sa
        }) && ma.SetBboxChanged()
    }

    function Q() {
        const N = this.GetWorldInfo();
        return N.HasMesh() ? N.GetSourceMesh().GetHSize() : 0
    }

    function S() {
        const N = this.GetWorldInfo();
        return N.HasMesh() ? N.GetSourceMesh().GetVSize() : 0
    }

    function T(N) {
        const P = this.GetWorldInfo();
        N = 2 === N ? !P.IsVisible() : 0 !== N;
        P.IsVisible() !== N && P.SetVisible(N)
    }

    function Y(N, P) {
        this.SetElementCSSStyle(N, P)
    }

    function X(N, P) {
        this.SetElementAttribute(N, "" + P)
    }

    function ea(N) {
        this.RemoveElementAttribute(N)
    }

    function ca() {
        this.FocusElement()
    }

    function aa() {
        this.BlurElement()
    }

    function wa() {
        return this.IsElementFocused()
    }

    function pa(N) {
        this._SetEnabled(0 !== N)
    }

    function ua() {
        return this._IsEnabled()
    }

    function va(N, P, W) {
        return e.compare(this.GetInstance().GetInstanceVariableValue(N), P, W)
    }

    function ta(N) {
        return !!this.GetInstance().GetInstanceVariableValue(N)
    }

    function Ga(N,
        P) {
        const W = this.GetCurrentSol(),
            Z = W.GetInstances();
        if (!Z.length) return !1;
        let fa = Z[0],
            ha = fa,
            ka = fa.GetInstanceVariableValue(P);
        for (let sa = 1, ma = Z.length; sa < ma; ++sa) {
            fa = Z[sa];
            const xa = fa.GetInstanceVariableValue(P);
            if (0 === N && xa < ka || 1 === N && xa > ka) ka = xa, ha = fa
        }
        W.PickOne(ha);
        return !0
    }

    function Ha(N) {
        return this._runtime.GetCurrentCondition().IsInverted() ? Ja(this, N) : Ia(this, N)
    }

    function Ia(N, P) {
        P = N.GetRuntime().GetInstanceByUID(P);
        if (!P) return !1;
        const W = N.GetCurrentSol();
        if (!W.IsSelectAll() && !W._GetOwnInstances().includes(P)) return !1;
        if (N.IsFamily()) {
            if (P.GetObjectClass().BelongsToFamily(N)) return W.PickOne(P), N.ApplySolToContainer(), !0
        } else if (P.GetObjectClass() === N) return W.PickOne(P), N.ApplySolToContainer(), !0;
        return !1
    }

    function Ja(N, P) {
        const W = N.GetCurrentSol();
        if (W.IsSelectAll()) {
            W._SetSelectAll(!1);
            W.ClearArrays();
            var Z = N.GetInstances();
            for (let ha = 0, ka = Z.length; ha < ka; ++ha) {
                var fa = Z[ha];
                fa.GetUID() === P ? W._PushElseInstance(fa) : W._PushInstance(fa)
            }
            N.ApplySolToContainer();
            return !!W._GetOwnInstances().length
        }
        Z = W._GetOwnInstances();
        fa = 0;
        for (let ha = 0, ka = Z.length; ha < ka; ++ha) {
            const sa = Z[ha];
            Z[fa] = sa;
            sa.GetUID() === P ? W._PushElseInstance(sa) : ++fa
        }
        e.truncateArray(Z, fa);
        N.ApplySolToContainer();
        return !!Z.length
    }

    function Oa() {
        this._runtime.DestroyInstance(this._inst)
    }

    function Va() {
        return !0
    }

    function Wa() {
        return !0
    }

    function Ba(N, P) {
        this.GetInstance().SetInstanceVariableValue(N, P)
    }

    function Bb(N, P) {
        const W = this.GetInstance(),
            Z = W.GetInstanceVariableValue(N);
        "number" === typeof Z && "number" !== typeof P ? P = parseFloat(P) : "string" === typeof Z && "string" !==
            typeof P && (P = P.toString());
        W.SetInstanceVariableValue(N, Z + P)
    }

    function Cb(N, P) {
        const W = this.GetInstance(),
            Z = W.GetInstanceVariableValue(N);
        "number" === typeof Z && ("number" !== typeof P && (P = parseFloat(P)), W.SetInstanceVariableValue(N, Z - P))
    }

    function Hb(N, P) {
        this.GetInstance().SetInstanceVariableValue(N, P ? 1 : 0)
    }

    function Ib(N) {
        const P = this.GetInstance();
        P.SetInstanceVariableValue(N, 0 === P.GetInstanceVariableValue(N) ? 1 : 0)
    }

    function Jb(N) {
        let P;
        try {
            P = JSON.parse(N)
        } catch (W) {
            console.error("Failed to load from JSON string: ",
                W);
            return
        }
        N = this.GetInstance();
        N._OnBeforeLoad("state");
        N.LoadFromJson(P, "state")
    }

    function Kb() {
        return JSON.stringify(this.GetInstance().SaveToJson("state"))
    }

    function Lb() {
        return this.GetInstance().GetObjectClass().GetName()
    }

    function Mb() {
        const N = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let P = N.GetInstanceCount();
        for (const W of this._runtime.instancesPendingCreateForObjectClass(N)) ++P;
        return P
    }

    function Nb() {
        return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
    }

    function Ob() {
        return this._inst.GetIID()
    }

    function Pb() {
        return this._inst.GetUID()
    }
    e.AddCommonACEs = function(N, P) {
        const W = N[1],
            Z = N[4],
            fa = N[5],
            ha = N[6],
            ka = N[7],
            sa = N[8],
            ma = N[10],
            xa = N[11],
            ya = N[12],
            Ka = N[13],
            Ra = N[14],
            Ea = N[15],
            la = P.Cnds,
            da = P.Acts,
            oa = P.Exps;
        N[3] && (la.CompareX = a, la.CompareY = b, la.IsOnScreen = c, la.IsOutsideLayout = f, la.PickDistance = h, da.SetX = g, da.SetY = k, da.SetPos = m, da.SetPosToObject = r, da.MoveForward = w, da.MoveAtAngle = p, oa.X = t, oa.Y = u, oa.dt = q);
        Z && (la.CompareWidth = x, la.CompareHeight = y, da.SetWidth = B,
            da.SetHeight = F, da.SetSize = H, oa.Width = K, oa.Height = C, oa.BBoxLeft = A, oa.BBoxTop = G, oa.BBoxRight = J, oa.BBoxBottom = M);
        fa && (la.AngleWithin = R, la.IsClockwiseFrom = U, la.IsBetweenAngles = V, da.SetAngle = ba, da.RotateClockwise = ia, da.RotateCounterclockwise = ja, da.RotateTowardAngle = qa, da.RotateTowardPosition = za, da.SetTowardPosition = Ca, oa.Angle = Ma);
        ha && (la.IsVisible = La, la.CompareOpacity = Fa, da.SetVisible = na, da.SetOpacity = Sa, da.SetDefaultColor = Aa, oa.Opacity = lb, oa.ColorValue = Na);
        ka && (la.IsOnLayer = mb, la.PickTopBottom = nb, la.CompareZElevation =
            ab, da.MoveToTop = ob, da.MoveToBottom = pb, da.MoveToLayer = qb, da.ZMoveToObject = rb, da.SetZElevation = sb, oa.LayerNumber = tb, oa.LayerName = ub, oa.ZIndex = bb, oa.ZElevation = vb, oa.TotalZElevation = wb);
        sa && (da.SetEffectEnabled = xb, da.SetEffectParam = yb);
        Ka && (la.HasParent = jb, la.HasChildren = kb, la.PickParent = Za, la.PickChildren = l, la.PickNthChild = n, la.CompareChildCount = v, da.AddChild = z, da.RemoveChild = D, da.RemoveFromParent = E, oa.ChildCount = I);
        Ra && (da.SetMeshSize = L, da.SetMeshPoint = O, oa.MeshColumns = Q, oa.MeshRows = S);
        ma && (la.IsVisible =
            La, da.SetVisible = T, da.SetCSSStyle = Y, da.SetElemAttribute = X, da.RemoveElemAttribute = ea);
        xa && (la.IsFocused = wa, da.SetFocus = ca, da.SetBlur = aa);
        ya && (la.IsEnabled = ua, da.SetEnabled = pa);
        Ea && (la.OnCollision = Fb, la.IsOverlapping = hb, la.IsOverlappingOffset = ib, P.FinishCollisionCondition = Eb);
        W || (la.CompareInstanceVar = va, la.IsBoolInstanceVarSet = ta, la.PickInstVarHiLow = Ga, la.PickByUID = Ha, da.SetInstanceVar = Ba, da.AddInstanceVar = Bb, da.SubInstanceVar = Cb, da.SetBoolInstanceVar = Hb, da.ToggleBoolInstanceVar = Ib, la.OnCreated = Va,
            la.OnDestroyed = Wa, da.Destroy = Oa, da.LoadFromJsonString || (da.LoadFromJsonString = Jb), oa.AsJSON || (oa.AsJSON = Kb), oa.Count = Mb, oa.PickedCount = Nb, oa.IID = Ob, oa.UID = Pb, oa.ObjectTypeName = Lb)
    }
} {
    "use strict";
    const e = self.C3;
    e.ScheduledWait = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._eventSheetManager = d;
            this._type = "";
            this._time = -1;
            this._signalTag = "";
            this._isSignalled = !1;
            this._event = null;
            this._actIndex = 0;
            this._solModifiers = [];
            this._sols = new Map;
            this._callingFunctionBlock = null;
            this._asyncId = -1;
            this._functionInnerLocalVars = this._functionParameters = null;
            this._shouldRelease = !1
        }
        Release() {
            this._type = "";
            this._time = -1;
            this._signalTag = "";
            this._functionInnerLocalVars = this._functionParameters =
                this._callingFunctionBlock = this._event = null;
            this._asyncId = -1;
            e.clearArray(this._solModifiers);
            for (const d of this._sols.values()) d.Release();
            this._sols.clear()
        }
        _Init() {
            var d = this._eventSheetManager,
                a = d.GetRuntime().GetAllObjectClasses();
            const b = d.GetCurrentEventStackFrame();
            this._event = b.GetCurrentEvent();
            this._actIndex = b.GetActionIndex() + 1;
            if (d = d.FindFirstFunctionBlockParent(this._event)) this._callingFunctionBlock = d, this._functionParameters = d.CaptureFunctionParameters(), this._functionInnerLocalVars =
                d._GetAllInnerLocalVariables().map(c => c.GetValue()), d.IsAsync() && (this._asyncId = d.PauseCurrentAsyncFunction());
            for (const c of a)
                if (a = c.GetCurrentSol(), !a.IsSelectAll() || this._event.HasSolModifier(c)) this._solModifiers.push(c), this._sols.set(c, e.New(e.SolState, a))
        }
        InitTimer(d) {
            this._type = "timer";
            this._Init();
            this._time = this._eventSheetManager.GetRuntime().GetGameTime() + d
        }
        InitSignal(d) {
            this._type = "signal";
            this._Init();
            this._signalTag = d.toLowerCase()
        }
        InitPromise(d) {
            this._type = "promise";
            this._Init();
            d.then(() => this.SetSignalled()).catch(a => {
                console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", a);
                this.SetSignalled()
            })
        }
        IsTimer() {
            return "timer" === this._type
        }
        IsSignal() {
            return "signal" === this._type
        }
        IsPromise() {
            return "promise" === this._type
        }
        GetSignalTag() {
            return this._signalTag
        }
        IsSignalled() {
            return this._isSignalled
        }
        SetSignalled() {
            this._isSignalled = !0
        }
        _ShouldRun() {
            return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
        }
        _RestoreState(d) {
            d._Restore(this._event,
                this._actIndex);
            for (const [a, b] of this._sols.entries()) d = a.GetCurrentSol(), b._Restore(d);
            if (d = this._callingFunctionBlock) d.SetFunctionParameters(this._functionParameters), d._GetAllInnerLocalVariables().map((a, b) => a.SetValue(this._functionInnerLocalVars[b])), d.IsAsync() && d.ResumeAsyncFunction(this._asyncId)
        }
        _Run(d) {
            this._RestoreState(d);
            this._event._ResumeActionsAndSubEvents(d);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
            this._eventSheetManager.ClearSol(this._solModifiers);
            this._shouldRelease = !0
        }
        async _DebugRun(d) {
            this._RestoreState(d);
            for (const a of this._event._DebugResumeActionsAndSubEvents(d)) await this._eventSheetManager.GetRuntime().DebugBreak(a);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
            this._eventSheetManager.ClearSol(this._solModifiers);
            this._shouldRelease = !0
        }
        ShouldRelease() {
            return this._shouldRelease
        }
        RemoveInstances(d) {
            for (const a of this._sols.values()) a.RemoveInstances(d)
        }
        _SaveToJson() {
            const d = {},
                a = {
                    t: this._time,
                    st: this._signalTag,
                    s: this._isSignalled,
                    ev: this._event.GetSID(),
                    sm: this._solModifiers.map(b => b.GetSID()),
                    sols: d
                };
            this._event._HasActionIndex(this._actIndex) && (a.act = this._event.GetActionAt(this._actIndex).GetSID());
            for (const [b, c] of this._sols) d[b.GetSID().toString()] = c._SaveToJson();
            return a
        }
        static _CreateFromJson(d, a) {
            const b = d.GetRuntime();
            var c = d.GetEventBlockBySID(a.ev);
            if (!c) return null;
            let f = 0;
            if (a.hasOwnProperty("act")) {
                var h = d.GetActionBySID(a.act);
                if (!h) return null;
                f = h.GetIndex()
            }
            h =
                e.New(e.ScheduledWait, d);
            h._time = a.t;
            h._type = -1 === h._time ? "signal" : "timer";
            h._signalTag = a.st;
            h._isSignalled = a.s;
            h._event = c;
            h._actIndex = f;
            for (var g of a.sm)(c = b.GetObjectClassBySID(g)) && h._solModifiers.push(c);
            for (const [k, m] of Object.entries(a.sols))
                if (a = parseInt(k, 10), a = b.GetObjectClassBySID(a)) g = e.New(e.SolState, null), g._LoadFromJson(d, m), h._sols.set(a, g);
            return h
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SolState = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._objectClass = null;
            this._isSelectAll = !0;
            this._instances = [];
            d && (this._objectClass = d.GetObjectClass(), this._isSelectAll = d.IsSelectAll(), e.shallowAssignArray(this._instances, d._GetOwnInstances()))
        }
        Release() {
            this._objectClass = null;
            e.clearArray(this._instances)
        }
        _Restore(d) {
            d._SetSelectAll(this._isSelectAll);
            e.shallowAssignArray(d._GetOwnInstances(), this._instances)
        }
        RemoveInstances(d) {
            e.arrayRemoveAllInSet(this._instances,
                d)
        }
        _SaveToJson() {
            return {
                sa: this._isSelectAll,
                insts: this._instances.map(d => d.GetUID())
            }
        }
        _LoadFromJson(d, a) {
            d = d.GetRuntime();
            this._isSelectAll = !!a.sa;
            e.clearArray(this._instances);
            for (const b of a.insts)(a = d.GetInstanceByUID(b)) && this._instances.push(a)
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(a, b) {
        let c = a.get(b);
        c || (c = new Map, a.set(b, c));
        return c
    }
    e.SDKPluginBase = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.runtime;
            this._isSingleGlobal = !!a.isSingleGlobal;
            this._isWorldType = !!a.isWorld;
            this._isRotatable = !!a.isRotatable;
            this._mustPredraw = !!a.mustPredraw;
            this._hasEffects = !!a.hasEffects;
            this._supportsSceneGraph = !!a.supportsSceneGraph;
            this._supportsMesh = !!a.supportsMesh;
            this._singleGlobalObjectClass = null;
            this._boundACEMethodCache =
                new Map;
            this._boundACEMethodCache_1param = new Map;
            this._boundACEMethodCache_2params = new Map;
            this._boundACEMethodCache_3params = new Map
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        IsSingleGlobal() {
            return this._isSingleGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        IsRotatable() {
            return this._isRotatable
        }
        MustPreDraw() {
            return this._mustPredraw
        }
        HasEffects() {
            return this._hasEffects
        }
        SupportsSceneGraph() {
            return this._supportsSceneGraph
        }
        SupportsMesh() {
            return this._supportsMesh
        }
        _GetBoundACEMethod(a,
            b) {
            if (!b) throw Error("missing 'this' binding");
            let c = this._boundACEMethodCache.get(a);
            if (c) return c;
            c = a.bind(b);
            this._boundACEMethodCache.set(a, c);
            return c
        }
        _GetBoundACEMethod_1param(a, b, c) {
            if (!b) throw Error("missing 'this' binding");
            const f = d(this._boundACEMethodCache_1param, a);
            let h = f.get(c);
            if (h) return h;
            h = a.bind(b, c);
            f.set(c, h);
            return h
        }
        _GetBoundACEMethod_2params(a, b, c, f) {
            if (!b) throw Error("missing 'this' binding");
            var h = d(this._boundACEMethodCache_2params, a);
            h = d(h, c);
            let g = h.get(f);
            if (g) return g;
            g = a.bind(b, c, f);
            h.set(f, g);
            return g
        }
        _GetBoundACEMethod_3params(a, b, c, f, h) {
            if (!b) throw Error("missing 'this' binding");
            var g = d(this._boundACEMethodCache_3params, a);
            g = d(g, c);
            g = d(g, f);
            let k = g.get(h);
            if (k) return k;
            k = a.bind(b, c, f, h);
            g.set(h, k);
            return k
        }
        _SetSingleGlobalObjectClass(a) {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            this._singleGlobalObjectClass = a
        }
        GetSingleGlobalObjectClass() {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            return this._singleGlobalObjectClass
        }
        GetSingleGlobalInstance() {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            return this._singleGlobalObjectClass.GetSingleGlobalInstance()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKDOMPluginBase = class extends e.SDKPluginBase {
        constructor(d, a) {
            super(d);
            this._domComponentId = a;
            this._nextElementId = 0;
            this._instMap = new Map;
            this.AddElementMessageHandler("elem-focused", b => b._OnElemFocused());
            this.AddElementMessageHandler("elem-blurred", b => {
                b && b._OnElemBlurred()
            })
        }
        Release() {
            super.Release()
        }
        _AddElement(d) {
            const a = this._nextElementId++;
            this._instMap.set(a, d);
            return a
        }
        _RemoveElement(d) {
            this._instMap.delete(d)
        }
        AddElementMessageHandler(d, a) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
                d, b => {
                    const c = this._instMap.get(b.elementId);
                    a(c, b)
                })
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKTypeBase = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._objectClass = d;
            this._runtime = d.GetRuntime();
            this._plugin = d.GetPlugin()
        }
        Release() {
            this._plugin = this._runtime = this._objectClass = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetImageInfo() {
            return this._objectClass.GetImageInfo()
        }
        FinishCondition(d) {}
        LoadTextures(d) {}
        ReleaseTextures() {}
        OnDynamicTextureLoadComplete() {}
        PreloadTexturesWithInstances(d) {}
        LoadTilemapData() {}
        GetScriptInterfaceClass() {
            return null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKInstanceBase = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._inst = d;
            this._domComponentId = a;
            this._runtime = d.GetRuntime();
            this._objectClass = this._inst.GetObjectClass();
            this._sdkType = this._objectClass.GetSdkType();
            this._tick2Func = this._tickFunc = null;
            this._isTicking2 = this._isTicking = !1;
            this._disposables = null;
            this._wasReleased = !1
        }
        Release() {
            this._wasReleased = !0;
            this._StopTicking();
            this._StopTicking2();
            this._tick2Func = this._tickFunc = null;
            this._disposables &&
                (this._disposables.Release(), this._disposables = null);
            this._sdkType = this._objectClass = this._runtime = this._inst = null
        }
        WasReleased() {
            return this._wasReleased
        }
        GetInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetPlugin() {
            return this._sdkType.GetPlugin()
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._inst.GetInterfaceClass()
        }
        Trigger(d) {
            return this._runtime.Trigger(d, this._inst, null)
        }
        DebugTrigger(d) {
            return this._runtime.DebugTrigger(d,
                this._inst, null)
        }
        TriggerAsync(d) {
            return this._runtime.TriggerAsync(d, this._inst, null)
        }
        FastTrigger(d, a) {
            return this._runtime.FastTrigger(d, this._inst, a)
        }
        DebugFastTrigger(d, a) {
            return this._runtime.DebugFastTrigger(d, this._inst, a)
        }
        ScheduleTriggers(d) {
            return this._runtime.ScheduleTriggers(d)
        }
        AddDOMMessageHandler(d, a) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, d, a)
        }
        AddDOMMessageHandlers(d) {
            for (const [a, b] of d) this.AddDOMMessageHandler(a, b)
        }
        PostToDOM(d, a) {
            this._runtime.PostComponentMessageToDOM(this._domComponentId,
                d, a)
        }
        PostToDOMAsync(d, a) {
            return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, d, a)
        }
        _PostToDOMMaybeSync(d, a) {
            if (this._runtime.IsInWorker()) this.PostToDOM(d, a);
            else return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: d,
                data: a,
                responseId: null
            })
        }
        Tick() {}
        Tick2() {}
        _StartTicking() {
            this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = !0)
        }
        _StopTicking() {
            this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = !1)
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = !0)
        }
        _StopTicking2() {
            this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = !1)
        }
        IsTicking2() {
            return this._isTicking2
        }
        GetDebuggerProperties() {
            return []
        }
        SaveToJson() {
            return null
        }
        LoadFromJson(d) {}
        GetPropertyValueByIndex(d) {}
        SetPropertyValueByIndex(d,
            a) {}
        OffsetPropertyValueByIndex(d, a) {
            if (0 !== a) {
                var b = this.GetPropertyValueByIndex(d);
                if ("number" !== typeof b) throw Error("expected number");
                this.SetPropertyValueByIndex(d, b + a)
            }
        }
        SetPropertyColorOffsetValueByIndex(d, a, b, c) {}
        CallAction(d, ...a) {
            d.call(this, ...a)
        }
        CallExpression(d, ...a) {
            return d.call(this, ...a)
        }
        GetScriptInterfaceClass() {
            return null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKWorldInstanceBase = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d, a);
            this._worldInfo = d.GetWorldInfo();
            this._webglcontextrestored_handler = this._webglcontextlost_handler = null
        }
        Release() {
            if (this._webglcontextlost_handler) {
                const d = this._runtime.Dispatcher();
                d.removeEventListener("webglcontextlost", this._webglcontextlost_handler);
                d.removeEventListener("webglcontextrestored", this._webglcontextrestored_handler);
                this._webglcontextrestored_handler = this._webglcontextlost_handler =
                    null
            }
            this._worldInfo = null;
            super.Release()
        }
        HandleWebGLContextLoss() {
            if (!this._webglcontextlost_handler) {
                this._webglcontextlost_handler = () => this.OnWebGLContextLost();
                this._webglcontextrestored_handler = () => this.OnWebGLContextRestored();
                var d = this._runtime.Dispatcher();
                d.addEventListener("webglcontextlost", this._webglcontextlost_handler);
                d.addEventListener("webglcontextrestored", this._webglcontextrestored_handler)
            }
        }
        OnWebGLContextLost() {}
        OnWebGLContextRestored() {}
        GetWorldInfo() {
            return this._worldInfo
        }
        IsOriginalSizeKnown() {
            return !1
        }
        GetOriginalWidth() {
            if (!this.IsOriginalSizeKnown()) throw Error("original size not known");
            const d = this.GetCurrentImageInfo();
            if (d) return d.GetWidth()
        }
        GetOriginalHeight() {
            if (!this.IsOriginalSizeKnown()) throw Error("original size not known");
            const d = this.GetCurrentImageInfo();
            if (d) return d.GetHeight()
        }
        GetCurrentImageInfo() {
            return null
        }
        GetCurrentSurfaceSize() {
            var d = this.GetCurrentImageInfo();
            return d && (d = d.GetTexture()) ? [d.GetWidth(), d.GetHeight()] : [100, 100]
        }
        GetCurrentTexRect() {
            const d = this.GetCurrentImageInfo();
            return d ? d.GetTexRect() : null
        }
        GetCurrentTexQuad() {
            const d = this.GetCurrentImageInfo();
            return d ? d.GetTexQuad() : null
        }
        GetImagePoint(d) {
            d = this._inst.GetWorldInfo();
            return [d.GetX(), d.GetY()]
        }
        LoadTilemapData(d, a, b) {}
        TestPointOverlapTile(d, a) {}
        RendersToOwnZPlane() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.New(e.Rect);
    e.SDKDOMInstanceBase = class extends e.SDKWorldInstanceBase {
        constructor(a, b) {
            super(a, b);
            this._elementId = this.GetPlugin()._AddElement(this);
            this._isElementShowing = !0;
            this._autoFontSize = this._elemHasFocus = !1;
            this._lastRect = e.New(e.Rect, 0, 0, -1, -1);
            a = this._runtime.GetCanvasManager();
            this._lastWindowWidth = a.GetLastWidth();
            this._lastWindowHeight = a.GetLastHeight();
            this._isPendingUpdateState = !1;
            this._StartTicking()
        }
        Release() {
            this.GetPlugin()._RemoveElement(this._elementId);
            this.PostToDOMElement("destroy");
            this._elementId = -1;
            super.Release()
        }
        _GetElementInDOMMode() {
            if (this._runtime.IsInWorker()) throw Error("not valid in worker mode");
            return this._PostToDOMElementMaybeSync("get-element")
        }
        PostToDOMElement(a, b) {
            b || (b = {});
            b.elementId = this._elementId;
            this.PostToDOM(a, b)
        }
        _PostToDOMElementMaybeSync(a, b) {
            b || (b = {});
            b.elementId = this._elementId;
            return this._PostToDOMMaybeSync(a, b)
        }
        PostToDOMElementAsync(a, b) {
            b || (b = {});
            b.elementId = this._elementId;
            return this.PostToDOMAsync(a, b)
        }
        CreateElement(a) {
            a ||
                (a = {});
            const b = this.GetWorldInfo().IsVisible();
            a.elementId = this._elementId;
            a.isVisible = b;
            Object.assign(a, this.GetElementState());
            this._isElementShowing = !!a.isVisible;
            this._PostToDOMMaybeSync("create", a);
            this._UpdatePosition(!0)
        }
        SetElementVisible(a) {
            a = !!a;
            this._isElementShowing !== a && (this._isElementShowing = a, this.PostToDOMElement("set-visible", {
                isVisible: a
            }))
        }
        Tick() {
            this._UpdatePosition(!1)
        }
        _ShouldPreserveElement() {
            const a = this._runtime.GetCanvasManager().GetFullscreenMode();
            return "Android" === e.Platform.OS &&
                ("scale-inner" === a || "scale-outer" === a || "crop" === a)
        }
        _UpdatePosition(a) {
            var b = this.GetWorldInfo();
            const c = b.GetLayer();
            var f = b.GetX(),
                h = b.GetY();
            let [g, k] = c.LayerToCanvasCss(f, h), [m, r] = c.LayerToCanvasCss(f + b.GetWidth(), h + b.GetHeight());
            f = this._runtime.GetCanvasManager();
            h = f.GetCssWidth();
            const w = f.GetCssHeight();
            if (b.IsVisible() && c.IsVisible()) {
                if (!this._ShouldPreserveElement()) {
                    if (0 >= m || 0 >= r || g >= h || k >= w) {
                        this.SetElementVisible(!1);
                        return
                    }
                    1 > g && (g = 1);
                    1 > k && (k = 1);
                    m >= h && (m = h - 1);
                    r >= w && (r = w - 1)
                }
                d.set(g, k,
                    m, r);
                b = f.GetLastWidth();
                h = f.GetLastHeight();
                !a && d.equals(this._lastRect) && this._lastWindowWidth === b && this._lastWindowHeight === h ? this.SetElementVisible(!0) : (this._lastRect.copy(d), this._lastWindowWidth = b, this._lastWindowHeight = h, this.SetElementVisible(!0), a = null, this._autoFontSize && (a = c.GetDisplayScale() - .2), this.PostToDOMElement("update-position", {
                    left: Math.round(this._lastRect.getLeft()) + f.GetCanvasClientX(),
                    top: Math.round(this._lastRect.getTop()) + f.GetCanvasClientY(),
                    width: Math.round(this._lastRect.width()),
                    height: Math.round(this._lastRect.height()),
                    fontSize: a
                }))
            } else this.SetElementVisible(!1)
        }
        FocusElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !0
            })
        }
        BlurElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !1
            })
        }
        _OnElemFocused() {
            this._elemHasFocus = !0
        }
        _OnElemBlurred() {
            this._elemHasFocus = !1
        }
        IsElementFocused() {
            return this._elemHasFocus
        }
        SetElementCSSStyle(a, b) {
            this.PostToDOMElement("set-css-style", {
                prop: e.CSSToCamelCase(a),
                val: b
            })
        }
        SetElementAttribute(a, b) {
            this.PostToDOMElement("set-attribute", {
                name: a,
                val: b
            })
        }
        RemoveElementAttribute(a) {
            this.PostToDOMElement("remove-attribute", {
                name: a
            })
        }
        UpdateElementState() {
            this._isPendingUpdateState || (this._isPendingUpdateState = !0, Promise.resolve().then(() => {
                this._isPendingUpdateState = !1;
                this.PostToDOMElement("update-state", this.GetElementState())
            }))
        }
        GetElementState() {}
        GetElementId() {
            return this._elementId
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.IBehavior;
    e.SDKBehaviorBase = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.runtime;
            this._myObjectClasses = e.New(e.ArraySet);
            this._myInstances = e.New(e.ArraySet);
            this._iBehavior = null;
            this._scriptInterfaceClass = a.scriptInterfaceClass || null
        }
        Release() {
            this._myInstances.Release();
            this._myObjectClasses.Release();
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        _AddObjectClass(a) {
            this._myObjectClasses.Add(a)
        }
        GetObjectClasses() {
            return this._myObjectClasses.GetArray()
        }
        _AddInstance(a) {
            this._myInstances.Add(a)
        }
        _RemoveInstance(a) {
            this._myInstances.Delete(a)
        }
        GetInstances() {
            return this._myInstances.GetArray()
        }
        GetIBehavior() {
            if (null ===
                this._iBehavior) {
                const a = this._scriptInterfaceClass;
                if (a) {
                    if (this._iBehavior = new a(this), !(this._iBehavior instanceof d)) throw new TypeError("script interface class must derive from IBehavior");
                } else this._iBehavior = new d(this)
            }
            return this._iBehavior
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKBehaviorTypeBase = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._runtime = d.GetRuntime();
            this._behaviorType = d;
            this._objectClass = d.GetObjectClass();
            this._behavior = d.GetBehavior();
            this._behavior._AddObjectClass(this._objectClass)
        }
        Release() {
            this._behavior = this._objectClass = this._behaviorType = this._runtime = null
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehavior() {
            return this._behavior
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKBehaviorInstanceBase = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._behInst = d;
            this._domComponentId = a;
            this._inst = d.GetObjectInstance();
            this._runtime = d.GetRuntime();
            this._behaviorType = d.GetBehaviorType();
            this._sdkType = this._behaviorType.GetSdkType();
            this._isPostTicking = this._isTicking2 = this._isTicking = !1;
            this._disposables = null
        }
        Release() {
            this._StopTicking();
            this._StopTicking2();
            this._StopPostTicking();
            this._disposables && (this._disposables.Release(), this._disposables =
                null);
            this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
        }
        GetBehavior() {
            return this._behaviorType.GetBehavior()
        }
        GetBehaviorInstance() {
            return this._behInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetObjectClass() {
            return this._inst.GetObjectClass()
        }
        GetWorldInfo() {
            return this._inst.GetWorldInfo()
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._behInst.GetScriptInterface()
        }
        Trigger(d) {
            return this._runtime.Trigger(d,
                this._inst, this._behaviorType)
        }
        DebugTrigger(d) {
            return this._runtime.DebugTrigger(d, this._inst, this._behaviorType)
        }
        TriggerAsync(d) {
            return this._runtime.TriggerAsync(d, this._inst, this._behaviorType)
        }
        PostCreate() {}
        Tick() {}
        Tick2() {}
        PostTick() {}
        _StartTicking() {
            this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = !0)
        }
        _StopTicking() {
            this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = !1)
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
                this._isTicking2 = !0)
        }
        _StopTicking2() {
            this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = !1)
        }
        IsTicking2() {
            return this._isTicking2
        }
        _StartPostTicking() {
            this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = !0)
        }
        _StopPostTicking() {
            this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = !1)
        }
        IsPostTicking() {
            return this._isPostTicking
        }
        GetDebuggerProperties() {
            return []
        }
        AddDOMMessageHandler(d, a) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
                d, a)
        }
        OnSpriteFrameChanged(d, a) {}
        SaveToJson() {
            return null
        }
        LoadFromJson(d) {}
        GetPropertyValueByIndex(d) {}
        SetPropertyValueByIndex(d, a) {}
        OffsetPropertyValueByIndex(d, a) {
            if (0 !== a) {
                var b = this.GetPropertyValueByIndex(d);
                if ("number" !== typeof b) throw Error("expected number");
                this.SetPropertyValueByIndex(d, b + a)
            }
        }
        SetPropertyColorOffsetValueByIndex(d, a, b, c) {}
        CallAction(d, ...a) {
            d.call(this, ...a)
        }
        CallExpression(d, ...a) {
            return d.call(this, ...a)
        }
        GetScriptInterfaceClass() {
            return null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins = {};
    e.Behaviors = {};
    e.PluginManager = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._runtime = d;
            this._allPlugins = [];
            this._pluginsByCtor = new Map;
            this._systemPlugin = null;
            this._allBehaviors = [];
            this._behaviorsByCtor = new Map;
            this._jumpthruBehavior = this._solidBehavior = null
        }
        CreatePlugin(d) {
            const a = this._runtime.GetObjectReference(d[0]);
            if (!a) throw Error("missing plugin");
            e.AddCommonACEs(d, a);
            d = e.New(a, {
                runtime: this._runtime,
                isSingleGlobal: d[1],
                isWorld: d[2],
                isRotatable: d[5],
                hasEffects: d[8],
                mustPredraw: d[9],
                supportsSceneGraph: d[13],
                supportsMesh: d[14]
            });
            d.OnCreate();
            this._allPlugins.push(d);
            this._pluginsByCtor.set(a, d)
        }
        CreateSystemPlugin() {
            this._systemPlugin = e.New(e.Plugins.System, {
                runtime: this._runtime,
                isSingleGlobal: !0
            });
            this._systemPlugin.OnCreate()
        }
        CreateBehavior(d) {
            d = this._runtime.GetObjectReference(d[1]);
            if (!d) throw Error("missing behavior");
            const a = e.New(d, {
                runtime: this._runtime
            });
            a.OnCreate();
            this._allBehaviors.push(a);
            this._behaviorsByCtor.set(d, a);
            !this._solidBehavior &&
                e.Behaviors.solid && a instanceof e.Behaviors.solid ? this._solidBehavior = a : !this._jumpthruBehavior && e.Behaviors.jumpthru && a instanceof e.Behaviors.jumpthru && (this._jumpthruBehavior = a)
        }
        GetPluginByConstructorFunction(d) {
            return this._pluginsByCtor.get(d) || null
        }
        HasBehaviorByConstructorFunction(d) {
            return this._behaviorsByCtor.has(d)
        }
        GetBehaviorByConstructorFunction(d) {
            return this._behaviorsByCtor.get(d) || null
        }
        GetSystemPlugin() {
            return this._systemPlugin
        }
        GetSolidBehavior() {
            return this._solidBehavior
        }
        GetJumpthruBehavior() {
            return this._jumpthruBehavior
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new Set;
    e.ImageInfo = class extends e.DefendedBase {
        constructor() {
            super();
            this._url = "";
            this._height = this._width = this._offsetY = this._offsetX = this._size = 0;
            this._hasMetaData = this._isRotated = !1;
            this._imageAsset = null;
            this._textureState = "";
            this._rcTex = e.New(e.Rect);
            this._quadTex = e.New(e.Quad);
            d.add(this)
        }
        Release() {
            this.ReleaseTexture();
            this._imageAsset = null;
            d.delete(this)
        }
        static OnWebGLContextLost() {
            for (const a of d) a._textureState = "", a._rcTex.set(0, 0, 0, 0), a._quadTex.setFromRect(a._rcTex)
        }
        LoadData(a) {
            this._url =
                a[0];
            this._size = a[1];
            this._offsetX = a[2];
            this._offsetY = a[3];
            this._width = a[4];
            this._height = a[5];
            this._isRotated = a[6];
            this._hasMetaData = !0
        }
        LoadDynamicAsset(a, b) {
            if (this._imageAsset) throw Error("already loaded asset");
            this._url = b;
            const c = {};
            e.IsAbsoluteURL(b) && (c.loadPolicy = "remote");
            this.LoadAsset(a, c);
            return this._imageAsset.Load()
        }
        ReplaceWith(a) {
            if (a === this) throw Error("cannot replace with self");
            this.ReleaseTexture();
            this._url = a._url;
            this._size = a._size;
            this._offsetX = a._offsetX;
            this._offsetY = a._offsetY;
            this._width = a._width;
            this._height = a._height;
            this._hasMetaData = a._hasMetaData;
            this._imageAsset = a._imageAsset;
            this._textureState = a._textureState;
            this._rcTex = a._rcTex;
            this._quadTex = a._quadTex
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        GetOffsetX() {
            return this._offsetX
        }
        GetOffsetY() {
            return this._offsetY
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetSheetWidth() {
            return this._imageAsset.GetWidth()
        }
        GetSheetHeight() {
            return this._imageAsset.GetHeight()
        }
        LoadAsset(a, b) {
            if (this._imageAsset) throw Error("already got asset");
            b = Object.assign({}, b, {
                url: this.GetURL(),
                size: this.GetSize()
            });
            this._imageAsset = a.LoadImage(b)
        }
        IsLoaded() {
            return this._imageAsset && this._imageAsset.IsLoaded()
        }
        async LoadStaticTexture(a, b) {
            if (!this._imageAsset) throw Error("no asset");
            if (this._textureState) throw Error("already loaded texture");
            this._textureState = "loading";
            a = await this._imageAsset.LoadStaticTexture(a, b);
            if (!a) return this._textureState = "", null;
            this._textureState = "loaded";
            this._hasMetaData || (this._width = a.GetWidth(), this._height = a.GetHeight(),
                this._hasMetaData = !0);
            this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + (this._isRotated ? this._height : this._width), this._offsetY + (this._isRotated ? this._width : this._height));
            this._rcTex.divide(a.GetWidth(), a.GetHeight());
            this._quadTex.setFromRect(this._rcTex);
            this._isRotated && this._quadTex.rotatePointsAnticlockwise();
            return a
        }
        ReleaseTexture() {
            this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex))
        }
        GetTexture() {
            return this._imageAsset ?
                this._imageAsset.GetTexture() : null
        }
        GetTexRect() {
            return this._rcTex
        }
        GetTexQuad() {
            return this._quadTex
        }
        async ExtractImageToCanvas() {
            const a = await this._imageAsset.LoadToDrawable(),
                b = e.CreateCanvas(this._width, this._height);
            b.getContext("2d").drawImage(a, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);
            return b
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.AnimationInfo = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._name = d[0];
            this._speed = d[1];
            this._isLooping = !!d[2];
            this._repeatCount = d[3];
            this._repeatTo = d[4];
            this._isPingPong = !!d[5];
            this._sid = d[6];
            this._frames = d[7].map(a => e.New(e.AnimationFrameInfo, a))
        }
        Release() {
            for (const d of this._frames) d.Release();
            e.clearArray(this._frames)
        }
        LoadAllAssets(d) {
            for (const a of this._frames) a.GetImageInfo().LoadAsset(d)
        }
        LoadAllTextures(d, a) {
            return Promise.all(this._frames.map(b =>
                b.GetImageInfo().LoadStaticTexture(d, a)))
        }
        ReleaseAllTextures() {
            for (const d of this._frames) d.GetImageInfo().ReleaseTexture()
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetFrameCount() {
            return this._frames.length
        }
        GetFrames() {
            return this._frames
        }
        GetFrameAt(d) {
            d = Math.floor(d);
            if (0 > d || d >= this._frames.length) throw new RangeError("invalid frame");
            return this._frames[d]
        }
        GetSpeed() {
            return this._speed
        }
        IsLooping() {
            return this._isLooping
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        GetRepeatTo() {
            return this._repeatTo
        }
        IsPingPong() {
            return this._isPingPong
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.AnimationFrameInfo = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._imageInfo = e.New(e.ImageInfo);
            this._imageInfo.LoadData(d);
            this._duration = d[7];
            this._origin = e.New(e.Vector2, d[8], d[9]);
            this._imagePoints = d[10].map(a => e.New(e.ImagePoint, this, a));
            this._imagePointsByName = new Map;
            for (const a of this._imagePoints) this._imagePointsByName.set(a.GetName().toLowerCase(), a);
            this._collisionPoly = null;
            d = d[11];
            6 <= d.length && (this._collisionPoly = e.New(e.CollisionPoly, d))
        }
        Release() {
            this._collisionPoly &&
                (this._collisionPoly.Release(), this._collisionPoly = null);
            this._imageInfo.Release();
            this._imageInfo = null
        }
        GetImageInfo() {
            return this._imageInfo
        }
        GetDuration() {
            return this._duration
        }
        GetOriginX() {
            return this._origin.getX()
        }
        GetOriginY() {
            return this._origin.getY()
        }
        GetCollisionPoly() {
            return this._collisionPoly
        }
        GetImagePointByName(d) {
            return this._imagePointsByName.get(d.toLowerCase()) || null
        }
        GetImagePointByIndex(d) {
            d = Math.floor(d);
            return 0 > d || d >= this._imagePoints.length ? null : this._imagePoints[d]
        }
        GetImagePointCount() {
            return this._imagePoints.length
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ImagePoint = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._afi = d;
            this._name = a[0];
            this._pos = e.New(e.Vector2, a[1], a[2])
        }
        Release() {}
        GetName() {
            return this._name
        }
        GetX() {
            return this._pos.getX()
        }
        GetY() {
            return this._pos.getY()
        }
        GetVec2() {
            return this._pos
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3Debugger,
        a = self.IObjectClass;
    e.ObjectClass = class extends e.DefendedBase {
        constructor(b, c, f) {
            super();
            const h = b.GetObjectReference(f[1]);
            this._runtime = b;
            this._plugin = b.GetPluginManager().GetPluginByConstructorFunction(h);
            this._sdkType = null;
            this._instSdkCtor = h.Instance;
            this._index = c;
            this._sid = f[11];
            this._name = f[0];
            this._jsPropName = this._runtime.GetJsPropName(f[14]);
            this._isGlobal = !!f[9];
            this._isFamily = !!f[2];
            this._isOnLoaderLayout = !!f[10];
            this._instVars = f[3].map(g =>
                ({
                    sid: g[0],
                    type: g[1],
                    name: g[2],
                    jsPropName: b.GetJsPropName(g[3])
                }));
            this._behaviorsCount = f[4];
            this._effectsCount = f[5];
            this._isWorldType = this._plugin.IsWorldType();
            this._effectList = null;
            this._collisionGrid = e.New(e.SparseGrid, b.GetOriginalViewportWidth(), b.GetOriginalViewportHeight());
            this._anyCollisionCellChanged = !0;
            this._anyInstanceParallaxed = !1;
            this._familyMembersSet = this._familyMembers = null;
            this._familyIndex = -1;
            this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet =
                this._families = null;
            this._isInContainer = !1;
            this._container = null;
            this._behaviorTypes = f[8].map(g => e.BehaviorType.Create(this, g));
            this._behaviorTypesIncludingInherited = [];
            this._behaviorsByName = new Map;
            this._behaviorNameToIndex = new Map;
            this._usedBehaviorCtors = new Set;
            this._solStack = e.New(e.SolStack, this);
            this._defaultInstanceData = null;
            this._defaultLayerIndex = 0;
            this._isContained = !1;
            this._animationsBySid = this._animationsByName = this._animations = this._imageInfo = this._container = null;
            this._textureRefCount =
                0;
            this._savedData = new Map;
            this._unsavedData = new Map;
            this._instances = [];
            this._iidsStale = !0;
            this._plugin.HasEffects() && (this._effectList = e.New(e.EffectList, this, f[12]));
            f[6] && (this._imageInfo = e.New(e.ImageInfo), this._imageInfo.LoadData(f[6]));
            if (f[7]) {
                this._animations = f[7].map(g => e.New(e.AnimationInfo, g));
                this._animationsByName = new Map;
                this._animationsBySid = new Map;
                for (const g of this._animations) this._animationsByName.set(g.GetName().toLowerCase(), g), this._animationsBySid.set(g.GetSID(), g)
            }
            this._isFamily ?
                (this._familyMembers = [], this._familyMembersSet = new Set, this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = new Set, this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
            this._sdkType = e.New(h.Type, this, f[15]);
            this._instanceUserScriptClass = this._iObjectClass = null;
            this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            if (c = this._sdkType.GetScriptInterfaceClass()) {
                if (this._iObjectClass = new c(this), !(this._iObjectClass instanceof a)) throw new TypeError("script interface class must derive from IObjectClass");
            } else this._iObjectClass = new a(this);
            f[13] && (c = f[13]) && this._sdkType.LoadTilemapData(c[0], c[1], c[2]);
            this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate();
            this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(f))
        }
        static Create(b, c, f) {
            return e.New(e.ObjectClass, b, c, f)
        }
        Release() {
            this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null);
            if (this._animations) {
                for (const b of this._animations) b.Release();
                e.clearArray(this._animations);
                this._animationsByName.clear();
                this._animationsBySid.clear()
            }
            this._solStack.Release();
            this._solStack = null;
            this._savedData.clear();
            this._unsavedData.clear();
            this._runtime = this._container = null
        }
        _LoadFamily(b) {
            for (let c = 1, f = b.length; c < f; ++c) {
                const h = this._runtime.GetObjectClassByIndex(b[c]);
                this._familyMembers.push(h);
                this._familyMembersSet.add(h);
                h._families.push(this);
                h._familiesSet.add(this)
            }
        }
        _SetContainer(b) {
            this._isInContainer = !0;
            this._container = b
        }
        IsInContainer() {
            return this._isInContainer
        }
        GetContainer() {
            return this._container
        }
        _OnAfterCreate() {
            var b =
                0;
            if (!this._isFamily)
                for (var c of this._families)
                    for (var f of c.GetBehaviorTypes()) {
                        const k = f.GetName().toLowerCase();
                        this._behaviorsByName.set(k, f);
                        this._behaviorNameToIndex.set(k, b);
                        this._behaviorTypesIncludingInherited.push(f);
                        ++b
                    }
            for (var h of this.GetBehaviorTypes()) c = h.GetName().toLowerCase(), this._behaviorsByName.set(c, h), this._behaviorNameToIndex.set(c, b), this._behaviorTypesIncludingInherited.push(h), ++b;
            for (var g of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(g.GetBehavior().constructor);
            if (!this._isFamily && this._families.length) {
                b = this._runtime.GetFamilyCount();
                e.extendArray(this._familyInstVarMap, b, 0);
                e.extendArray(this._familyBehaviorMap, b, 0);
                e.extendArray(this._familyEffectMap, b, 0);
                b = [];
                c = g = h = 0;
                for (const k of this._families)
                    if (f = k.GetFamilyIndex(), this._familyInstVarMap[f] = h, h += k.GetInstanceVariablesCount(), this._familyBehaviorMap[f] = g, g += k.GetBehaviorTypesCount(), this._familyEffectMap[f] = c, c += k.GetEffectTypesCount(), (f = k.GetEffectList()) && this._effectList)
                        for (const m of f.GetAllEffectTypes()) b.push(m.Clone(this._effectList));
                this._effectList && this._effectList.PrependEffectTypes(b)
            }
        }
        _CreateSingleGlobalInstance(b) {
            const c = this._runtime._GetNewUID(),
                f = e.New(e.Instance, {
                    runtime: this._runtime,
                    objectType: this,
                    uid: c
                });
            f._CreateSdkInstance(b[16], []);
            this._runtime._MapInstanceByUID(c, f);
            this._instances.push(f)
        }
        GetSdkType() {
            return this._sdkType
        }
        IsOnLoaderLayout() {
            return this._isOnLoaderLayout
        }
        OnCreate() {
            this._isFamily || this._sdkType.OnCreate()
        }
        HasLoadedTextures() {
            return 0 < this._textureRefCount
        }
        LoadTextures(b) {
            if (this._isFamily) return Promise.resolve();
            this._textureRefCount++;
            return 1 === this._textureRefCount ? this._sdkType.LoadTextures(b) || Promise.resolve() : Promise.resolve()
        }
        ReleaseTextures() {
            if (!this._isFamily) {
                this._textureRefCount--;
                if (0 > this._textureRefCount) throw Error("released textures too many times");
                0 === this._textureRefCount && this._sdkType.ReleaseTextures()
            }
        }
        OnDynamicTextureLoadComplete() {
            if (this._isFamily) throw Error("not applicable to family");
            this._sdkType.OnDynamicTextureLoadComplete()
        }
        PreloadTexturesWithInstances(b) {
            return this._isFamily ?
                Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(b)
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        IsFamily() {
            return this._isFamily
        }
        IsGlobal() {
            return this._isGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        GetFamilyIndex() {
            return this._familyIndex
        }
        GetBehaviorTypes() {
            return this._behaviorTypes
        }
        GetBehaviorTypesCount() {
            return this._behaviorsCount
        }
        UsesBehaviorByCtor(b) {
            return b &&
                this._usedBehaviorCtors.has(b)
        }
        GetInstanceVariablesCount() {
            return this._instVars.length
        }
        GetInstanceVariableSIDs() {
            return this._instVars.map(b => b.sid)
        }
        GetInstanceVariableIndexBySID(b) {
            return this._instVars.findIndex(c => c.sid === b)
        }
        GetInstanceVariableIndexByName(b) {
            return this._instVars.findIndex(c => c.name === b)
        }
        _GetAllInstanceVariableNames() {
            return this._instVars.map(b => b.name)
        }
        _GetAllInstanceVariableJsPropNames() {
            return this._instVars.map(b => b.jsPropName)
        }
        GetInstanceVariableType(b) {
            b = Math.floor(b);
            if (0 > b || b >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[b].type
        }
        GetInstanceVariableName(b) {
            b = Math.floor(b);
            if (0 > b || b >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[b].name
        }
        GetEffectTypesCount() {
            return this._effectsCount
        }
        GetBehaviorTypesIncludingInherited() {
            return this._behaviorTypesIncludingInherited
        }
        GetBehaviorTypeByName(b) {
            return this._behaviorsByName.get(b.toLowerCase()) || null
        }
        GetBehaviorIndexByName(b) {
            b =
                this._behaviorNameToIndex.get(b.toLowerCase());
            return "undefined" === typeof b ? -1 : b
        }
        GetEffectList() {
            return this._effectList
        }
        HasEffects() {
            return this._plugin.HasEffects()
        }
        UsesEffects() {
            return this._effectList && this._effectList.HasAnyEffectType()
        }
        GetSolStack() {
            return this._solStack
        }
        GetCurrentSol() {
            return this._solStack.GetCurrentSol()
        }
        GetImageInfo() {
            return this._imageInfo
        }
        SetDefaultInstanceData(b) {
            this._defaultInstanceData = b
        }
        GetDefaultInstanceData() {
            return this._defaultInstanceData
        }
        _SetDefaultLayerIndex(b) {
            this._defaultLayerIndex =
                b
        }
        GetDefaultLayerIndex() {
            return this._defaultLayerIndex
        }
        GetAnimations() {
            return this._animations
        }
        GetAnimationCount() {
            return this._animations.length
        }
        GetFamilies() {
            return this._families
        }
        BelongsToFamily(b) {
            return this._familiesSet.has(b)
        }
        GetFamilyMembers() {
            return this._familyMembers
        }
        FamilyHasMember(b) {
            return this._familyMembersSet.has(b)
        }
        GetFamilyBehaviorOffset(b) {
            return this._familyBehaviorMap[b]
        }
        GetFamilyInstanceVariableOffset(b) {
            return this._familyInstVarMap[b]
        }
        GetAnimationByName(b) {
            if (!this._animations) throw Error("no animations");
            return this._animationsByName.get(b.toLowerCase()) || null
        }
        GetAnimationBySID(b) {
            if (!this._animations) throw Error("no animations");
            return this._animationsBySid.get(b) || null
        }
        GetFirstAnimationFrame() {
            if (!this._animations) throw Error("no animations");
            return this._animations[0].GetFrameAt(0)
        }
        GetDefaultInstanceSize() {
            if (this._animations) {
                const b = this.GetFirstAnimationFrame().GetImageInfo();
                return [b.GetWidth(), b.GetHeight()]
            }
            return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100,
                100
            ]
        }
        GetSingleGlobalInstance() {
            if (!this._plugin.IsSingleGlobal()) throw Error("not a single-global plugin");
            return this._instances[0]
        }
        GetInstances() {
            return this._instances
        }* instances() {
            yield* this._instances
        }* instancesIncludingPendingCreate() {
            yield* this._instances;
            for (const b of this._runtime._GetInstancesPendingCreate()) b.GetObjectClass() === this && (yield b)
        }
        GetInstanceCount() {
            return this._instances.length
        }
        _AddInstance(b) {
            this._instances.push(b)
        }
        _SetIIDsStale() {
            this._iidsStale = !0
        }
        _UpdateIIDs() {
            if (this._iidsStale &&
                !this._isFamily) {
                var b = this._instances,
                    c = 0;
                for (let f = b.length; c < f; ++c) b[c]._SetIID(c);
                b = this._runtime._GetInstancesPendingCreate();
                for (const f of b) f.GetObjectClass() === this && f._SetIID(c++);
                this._iidsStale = !1
            }
        }
        GetInstanceByIID(b) {
            var c = this._instances;
            if (b < c.length) return c[b];
            b -= c.length;
            c = this._runtime._GetInstancesPendingCreate();
            for (const f of c)
                if (f.GetObjectClass() === this) {
                    if (0 === b) return f;
                    --b
                }
            return null
        }
        GetFirstPicked(b) {
            if (b && b.IsInContainer() && b.GetObjectClass() !== this)
                for (const c of b.siblings())
                    if (c.GetObjectClass() ===
                        this) return c;
            b = this.GetCurrentSol().GetInstances();
            return b.length ? b[0] : null
        }
        GetPairedInstance(b) {
            const c = this.GetCurrentSol().GetInstances();
            return 0 < c.length ? c[b.GetIID() % c.length] : null
        }* allCorrespondingInstances(b, c) {
            const f = this.GetCurrentSol().GetInstances();
            var h = f.length;
            const g = c.GetCurrentSol(),
                k = c.GetCurrentSol().GetInstances(),
                m = k.length;
            var r = b.GetIID();
            if (c.IsFamily() || !g.IsSelectAll()) r = k.indexOf(b);
            b = Math.ceil(h / m);
            h %= m;
            0 === h || r < h ? (r *= b, h = b) : (r = h * b + (r - h) * (b - 1), h = b - 1);
            for (let w = r, p =
                    r + h; w < p; ++w) yield f[w]
        }
        FinishCondition(b) {
            this._sdkType.FinishCondition(b)
        }
        ApplySolToContainer() {
            if (this._isInContainer && !this._isFamily) {
                this._UpdateIIDs();
                var b = this.GetCurrentSol(),
                    c = b._GetOwnInstances(),
                    f = b.IsSelectAll(),
                    h = this._runtime.GetCurrentEventStackFrame();
                h = h && h.GetCurrentEvent() && h.GetCurrentEvent().IsOrBlock();
                for (const m of this._container.objectTypes())
                    if (m !== this) {
                        m._UpdateIIDs();
                        var g = m.GetCurrentSol();
                        g._SetSelectAll(f);
                        if (!f) {
                            var k = g._GetOwnInstances();
                            e.clearArray(k);
                            for (const r of c) k.push(m.GetInstanceByIID(r.GetIID()));
                            if (h) {
                                k = b._GetOwnElseInstances();
                                g = g._GetOwnElseInstances();
                                e.clearArray(g);
                                for (const r of k) g.push(m.GetInstanceByIID(r.GetIID()))
                            }
                        }
                    }
            }
        }
        _TruncateContainerSols(b, c) {
            for (const f of this.GetContainer().objectTypes()) {
                const h = f.GetCurrentSol();
                b ? e.truncateArray(h._GetOwnElseInstances(), c) : e.truncateArray(h._GetOwnInstances(), c)
            }
        }
        _GetCollisionCellGrid() {
            return this._collisionGrid
        }
        _SetAnyCollisionCellChanged(b) {
            this._anyCollisionCellChanged = !!b
        }
        _SetAnyInstanceParallaxed(b) {
            this._anyInstanceParallaxed = !!b
        }
        IsAnyInstanceParallaxed() {
            return this._anyInstanceParallaxed
        }
        _UpdateAllCollisionCells() {
            if (this._anyCollisionCellChanged &&
                this._isWorldType) {
                for (const b of this._instances) b.GetWorldInfo()._UpdateCollisionCell();
                for (const b of this._runtime._GetInstancesPendingCreate()) b.GetObjectClass() === this && b.GetWorldInfo()._UpdateCollisionCell();
                this._anyCollisionCellChanged = !1
            }
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        HasSolidBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.solid)
        }
        HasNoSaveBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.NoSave)
        }
        HasPersistBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.Persist)
        }
        _SaveToJson() {
            const b = {
                instances: this._instances.map(c => c.SaveToJson())
            };
            this._savedData && this._savedData.size && (b.ex = e.ToSuperJSON(this._savedData));
            return b
        }
        _LoadFromJson(b) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            var c = b.ex;
            c && (this._savedData = e.FromSuperJSON(c));
            c = this._instances;
            b = b.instances;
            for (let f = 0, h = Math.min(c.length, b.length); f < h; ++f) c[f].LoadFromJson(b[f]);
            for (let f = b.length, h = c.length; f < h; ++f) this._runtime.DestroyInstance(c[f]);
            for (let f = c.length, h = b.length; f < h; ++f) {
                c = b[f];
                let g =
                    null;
                if (this.IsWorldType() && (g = this._runtime.GetMainRunningLayout().GetLayerBySID(c.w.l), !g)) continue;
                this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, g, !1, 0, 0, !0).LoadFromJson(c)
            }
            this._SetIIDsStale()
        }
        GetIObjectClass() {
            return this._iObjectClass
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        _GetUserScriptInstanceClass() {
            return this._instanceUserScriptClass
        }
        _SetUserScriptInstanceClass(b) {
            this._instanceUserScriptClass = b
        }
        DispatchUserScriptEvent(b) {
            var c = this._runtime;
            (c =
                c.IsDebug() && !c.GetEventSheetManager().IsInEventEngine()) && d.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(b);
            c && d.AddScriptTime()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Container = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._runtime = d;
            this._objectTypes = a;
            for (const b of this._objectTypes) b._SetContainer(this)
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectTypes() {
            return this._objectTypes
        }
        objectTypes() {
            return this._objectTypes
        }
        HasAnyWorldType() {
            return this._objectTypes.some(d => d.IsWorldType())
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3Debugger,
        a = self.IInstance,
        b = [];
    let c = 0;
    const f = new WeakMap,
        h = new WeakMap;
    e.Instance = class extends e.DefendedBase {
        constructor(g) {
            super();
            this._runtime = g.runtime;
            this._objectType = g.objectType;
            this._iScriptInterface = this._sdkInst = this._worldInfo = null;
            this._iid = 0;
            this._uid = g.uid;
            this._puid = c++;
            this._flags = 0;
            this._behaviorInstances = this._instVarValues = b;
            var k = this._objectType.GetBehaviorTypesIncludingInherited();
            0 < k.length && (this._behaviorInstances = k.map((m, r) => e.New(e.BehaviorInstance, {
                runtime: this._runtime,
                behaviorType: m,
                instance: this,
                index: r
            })));
            this._siblings = this._objectType.IsInContainer() ? [] : null;
            this._timeScale = -1;
            this._dispatcher = null;
            k = this.GetPlugin();
            k.MustPreDraw() && (this._flags |= 4);
            if (k.IsWorldType())
                if (this._worldInfo = e.New(e.WorldInfo, this, g.layer), g.worldData) this._worldInfo.Init(g.worldData);
                else {
                    this._worldInfo.InitNoData();
                    const [m, r] = this._objectType.GetDefaultInstanceSize();
                    this._worldInfo.SetSize(m, r);
                    this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
                }
            g.instVarData ?
                this._LoadInstanceVariableData(g.instVarData) : this._LoadDefaultInstanceVariables()
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null);
            if (0 < this._behaviorInstances.length) {
                for (var g of this._behaviorInstances) g.Release();
                e.clearArray(this._behaviorInstances)
            }
            this._sdkInst.Release();
            this._sdkInst = null;
            if (g = f.get(this)) g.clear(), f.delete(this);
            if (g = h.get(this)) g.clear(), h.delete(this);
            this._siblings && e.clearArray(this._siblings);
            this._dispatcher && (this._dispatcher.Release(),
                this._dispatcher = null);
            this._objectType = this._runtime = null;
            0 < this._instVarValues.length && e.clearArray(this._instVarValues);
            this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null)
        }
        _LoadInstanceVariableData(g) {
            0 < g.length && (this._instVarValues = [], e.shallowAssignArray(this._instVarValues, g))
        }
        _LoadDefaultInstanceVariables() {
            const g = this._objectType.GetInstanceVariablesCount();
            if (0 !== g) {
                this._instVarValues = [];
                var k = [0, 0, ""];
                for (let m = 0; m < g; ++m) this._instVarValues.push(k[this._objectType.GetInstanceVariableType(m)])
            }
        }
        _CreateSdkInstance(g,
            k) {
            if (this._sdkInst) throw Error("already got sdk instance");
            for (let m = 0, r = this._behaviorInstances.length; m < r; ++m) this._behaviorInstances[m]._CreateSdkInstance(k ? k[m] : null);
            this._sdkInst = e.New(this._objectType.GetInstanceSdkCtor(), this, g);
            if (!(this._sdkInst instanceof e.SDKInstanceBase)) throw Error("sdk type must derive from SDKInstanceBase");
            for (let m = 0, r = this._behaviorInstances.length; m < r; ++m) this._behaviorInstances[m].PostCreate();
            this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetWorldInfo() {
            return this._worldInfo
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimeScale() {
            return this._timeScale
        }
        GetActiveTimeScale() {
            const g =
                this._timeScale;
            return -1 === g ? this.GetRuntime().GetTimeScale() : g
        }
        SetTimeScale(g) {
            g = +g;
            if (0 > g || !isFinite(g)) g = 0;
            this._timeScale = g
        }
        RestoreTimeScale() {
            this._timeScale = -1
        }
        Dispatcher() {
            this._dispatcher || (this._dispatcher = e.New(e.Event.Dispatcher));
            return this._dispatcher
        }
        Draw(g) {
            this._sdkInst.Draw(g)
        }
        OnCreate(g) {
            this._sdkInst.OnCreate(g)
        }
        _SetHasTilemap() {
            this._flags |= 2
        }
        HasTilemap() {
            return 0 !== (this._flags & 2)
        }
        _MarkDestroyed() {
            this._flags |= 1
        }
        IsDestroyed() {
            return 0 !== (this._flags & 1)
        }
        MustPreDraw() {
            return 0 !==
                (this._flags & 4)
        }
        SetMustMitigateZFighting() {
            this._flags |= 32
        }
        MustMitigateZFighting() {
            return 0 !== (this._flags & 32)
        }
        _IsSolidEnabled() {
            return 0 !== (this._flags & 8)
        }
        _SetSolidEnabled(g) {
            this._flags = g ? this._flags | 8 : this._flags & -9
        }
        _IsJumpthruEnabled() {
            return 0 !== (this._flags & 16)
        }
        _SetJumpthruEnabled(g) {
            this._flags = g ? this._flags | 16 : this._flags & -17
        }
        SetFlag(g, k) {
            g <<= 16;
            this._flags = k ? this._flags | g : this._flags & ~g
        }
        GetFlag(g) {
            return 0 !== (this._flags & g << 16)
        }
        GetCurrentImageInfo() {
            return this._sdkInst.GetCurrentImageInfo()
        }
        GetCurrentSurfaceSize() {
            return this._sdkInst.GetCurrentSurfaceSize()
        }
        GetCurrentTexRect() {
            return this._sdkInst.GetCurrentTexRect()
        }
        GetCurrentTexQuad() {
            return this._sdkInst.GetCurrentTexQuad()
        }
        GetImagePoint(g) {
            return this._sdkInst.GetImagePoint(g)
        }
        GetObjectClass() {
            return this._objectType
        }
        RendersToOwnZPlane() {
            return this._sdkInst.RendersToOwnZPlane()
        }
        BelongsToObjectClass(g) {
            return g.IsFamily() ?
                g.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === g
        }
        VerifySupportsSceneGraph() {
            if (!this.GetPlugin().SupportsSceneGraph()) throw Error("object does not support scene graph");
        }
        HasParent() {
            return null !== this.GetParent()
        }
        GetParent() {
            var g = this.GetWorldInfo();
            return g ? (g = g.GetParent()) ? g.GetInstance() : null : null
        }
        GetTopParent() {
            var g = this.GetWorldInfo();
            return g ? (g = g.GetTopParent()) ? g.GetInstance() : null : null
        }* parents() {
            const g = this.GetWorldInfo();
            if (g)
                for (const k of g.parents()) yield k.GetInstance()
        }
        HasChildren() {
            const g =
                this.GetWorldInfo();
            return g ? g.HasChildren() : !1
        }
        GetChildren() {
            const g = this.GetWorldInfo();
            return g ? g.GetChildren().map(k => k.GetInstance()) : []
        }* children() {
            const g = this.GetWorldInfo();
            if (g)
                for (const k of g.children()) yield k.GetInstance()
        }* allChildren() {
            const g = this.GetWorldInfo();
            if (g)
                for (const k of g.allChildren()) yield k.GetInstance()
        }
        GetChildCount() {
            const g = this.GetWorldInfo();
            return g ? g.GetChildCount() : 0
        }
        GetChildAt(g) {
            const k = this.GetWorldInfo();
            return k ? (g = k.GetChildAt(g)) ? g.GetInstance() : null :
                null
        }
        AddChild(g, k) {
            this.VerifySupportsSceneGraph();
            g.VerifySupportsSceneGraph();
            this.GetWorldInfo().AddChild(g.GetWorldInfo(), k || {})
        }
        RemoveChild(g) {
            const k = this.GetWorldInfo();
            k && k.RemoveChild(g.GetWorldInfo())
        }
        GetDestroyWithParent() {
            const g = this.GetWorldInfo();
            return g ? g.GetDestroyWithParent() : !1
        }
        SetupInitialSceneGraphConnections() {
            var g = this.GetWorldInfo();
            if (g && (g = g.GetSceneGraphChildrenExportData()))
                for (const k of g)
                    if (g = this._runtime.GetInstanceByUID(k[2])) {
                        const m = k[3];
                        this.AddChild(g, {
                            transformX: !!(m >>
                                0 & 1),
                            transformY: !!(m >> 1 & 1),
                            transformWidth: !!(m >> 2 & 1),
                            transformHeight: !!(m >> 3 & 1),
                            transformAngle: !!(m >> 4 & 1),
                            destroyWithParent: !!(m >> 5 & 1),
                            transformZElevation: !!(m >> 6 & 1)
                        })
                    }
        }
        IsInContainer() {
            return null !== this._siblings
        }
        _AddSibling(g) {
            this._siblings.push(g)
        }
        GetSiblings() {
            return this._siblings
        }
        HasSibling(g) {
            return !!this.GetSibling(g)
        }
        GetSibling(g) {
            const k = this.siblings();
            if (null === k || 0 === k.length) return !1;
            for (const m of k)
                if (m.GetObjectClass() === g) return m;
            return null
        }
        siblings() {
            return this._siblings
        }
        SetSiblingsSinglePicked() {
            for (const g of this.siblings()) g.GetObjectClass().GetCurrentSol().SetSinglePicked(g)
        }
        _PushSiblingsToSolInstances() {
            for (const g of this.siblings()) g.GetObjectClass().GetCurrentSol()._PushInstance(g)
        }
        _SetSiblingsToSolInstancesIndex(g) {
            for (const k of this.siblings()) k.GetObjectClass().GetCurrentSol()._GetOwnInstances()[g] =
                k
        }
        _PushSiblingsToSolElseInstances() {
            for (const g of this.siblings()) g.GetObjectClass().GetCurrentSol()._PushElseInstance(g)
        }
        _SetSiblingsToSolElseInstancesIndex(g) {
            for (const k of this.siblings()) k.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[g] = k
        }
        GetPlugin() {
            return this._objectType.GetPlugin()
        }
        _SetIID(g) {
            this._iid = g
        }
        GetIID() {
            this._objectType._UpdateIIDs();
            return this._iid
        }
        GetUID() {
            return this._uid
        }
        GetPUID() {
            return this._puid
        }
        GetBehaviorInstances() {
            return this._behaviorInstances
        }
        GetBehaviorInstanceFromCtor(g) {
            if (!g) return null;
            for (const k of this._behaviorInstances)
                if (k.GetBehavior() instanceof g) return k;
            return null
        }
        GetBehaviorSdkInstanceFromCtor(g) {
            return g ? (g = this.GetBehaviorInstanceFromCtor(g)) ? g.GetSdkInstance() : null : null
        }
        GetBehaviorIndexBySID(g) {
            const k = this._behaviorInstances;
            for (let m = 0, r = k.length; m < r; ++m)
                if (k[m].GetBehaviorType().GetSID() === g) return m;
            return -1
        }
        GetAllInstanceVariableValues() {
            return this._instVarValues
        }
        _GetAllInstanceVariableNames() {
            return this._objectType._GetAllInstanceVariableNames()
        }
        GetInstanceVariableCount() {
            return this._instVarValues.length
        }
        GetInstanceVariableValue(g) {
            g |=
                0;
            const k = this._instVarValues;
            if (0 > g || g >= k.length) throw new RangeError("invalid instance variable");
            return k[g]
        }
        _GetInstanceVariableValueUnchecked(g) {
            return this._instVarValues[g]
        }
        _GetInstanceVariableTypedValue(g) {
            const k = this._instVarValues[g];
            return 0 === this._objectType.GetInstanceVariableType(g) ? !!k : k
        }
        SetInstanceVariableValue(g, k) {
            g |= 0;
            const m = this._instVarValues;
            if (0 > g || g >= m.length) throw new RangeError("invalid instance variable");
            switch (this._objectType.GetInstanceVariableType(g)) {
                case 0:
                    m[g] =
                        k ? 1 : 0;
                    break;
                case 1:
                    m[g] = "number" === typeof k ? k : parseFloat(k);
                    break;
                case 2:
                    m[g] = "string" === typeof k ? k : k.toString();
                    break;
                default:
                    throw Error("unknown instance variable type");
            }
        }
        SetInstanceVariableOffset(g, k) {
            if (0 !== k) {
                g |= 0;
                var m = this._instVarValues;
                if (0 > g || g >= m.length) throw new RangeError("invalid instance variable");
                var r = m[g];
                if ("number" === typeof r) m[g] = "number" === typeof k ? m[g] + k : m[g] + parseFloat(k);
                else {
                    if ("boolean" === typeof r) throw Error("can not set offset of boolean variable");
                    if ("string" === typeof r) throw Error("can not set offset of string variable");
                    throw Error("unknown instance variable type");
                }
            }
        }
        GetSavedDataMap() {
            let g = f.get(this);
            if (g) return g;
            g = new Map;
            f.set(this, g);
            return g
        }
        GetUnsavedDataMap() {
            let g = h.get(this);
            if (g) return g;
            g = new Map;
            h.set(this, g);
            return g
        }
        _HasAnyCreateDestroyHandler(g) {
            const k = this.GetObjectClass();
            if (k.UserScriptDispatcher().HasAnyHandlerFor(g)) return !0;
            for (const m of k.GetFamilies())
                if (m.UserScriptDispatcher().HasAnyHandlerFor(g)) return !0;
            return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(g) ? !0 : !1
        }
        _TriggerOnCreatedOnSelfAndRelated() {
            const g =
                new Set;
            g.add(this);
            const k = this.GetWorldInfo();
            if (k && k.HasChildren())
                for (const m of this.allChildren())
                    if (g.add(m), m.IsInContainer())
                        for (const r of m.siblings()) g.add(r);
            if (this.IsInContainer())
                for (const m of this.siblings()) g.add(m);
            for (const m of g.values()) m._TriggerOnCreated()
        }
        _TriggerOnCreated() {
            if (this._HasAnyCreateDestroyHandler("instancecreate")) {
                const g = this.GetObjectClass(),
                    k = new e.Event("instancecreate");
                k.instance = this.GetInterfaceClass();
                g.DispatchUserScriptEvent(k);
                for (const m of g.GetFamilies()) m.DispatchUserScriptEvent(k);
                this._runtime.DispatchUserScriptEvent(k)
            }
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
        }
        _TriggerOnDestroyed() {
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
        }
        _FireDestroyedScriptEvents(g) {
            if (this._iScriptInterface) {
                var k = new e.Event("destroy");
                k.isEndingLayout = g;
                this.DispatchUserScriptEvent(k)
            }
            if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
                k = this.GetObjectClass();
                var m = new e.Event("instancedestroy");
                m.instance = this.GetInterfaceClass();
                m.isEndingLayout = g;
                k.DispatchUserScriptEvent(m);
                for (const r of k.GetFamilies()) r.DispatchUserScriptEvent(m);
                this._runtime.DispatchUserScriptEvent(m)
            }
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson(g = "full") {
            const k = {};
            "full" === g ? k.uid = this.GetUID() : k.c3 = !0;
            if ("visual-state" !== g) {
                var m = f.get(this);
                m && m.size && (k.ex = e.ToSuperJSON(m)); - 1 !== this.GetTimeScale() && (k.mts = this.GetTimeScale());
                if (0 < this._objectType.GetInstanceVariablesCount()) {
                    m = {};
                    var r = this._objectType.GetInstanceVariableSIDs();
                    for (let w = 0, p = this._instVarValues.length; w < p; ++w) m[r[w].toString()] = this._instVarValues[w];
                    k.ivs = m
                }
                if (this._behaviorInstances.length) {
                    m = {};
                    for (const w of this._behaviorInstances)(r = w.SaveToJson()) && (m[w.GetBehaviorType().GetSID().toString()] = r);
                    k.behs = m
                }
            }
            this._worldInfo && (k.w = this._worldInfo._SaveToJson(g));
            (g = this._sdkInst.SaveToJson()) && (k.data = g);
            return k
        }
        _OnBeforeLoad(g = "full") {
            this._worldInfo && this._worldInfo._OnBeforeLoad(g)
        }
        LoadFromJson(g, k = "full") {
            if ("full" === k) this._uid = g.uid;
            else if (!g.c3) return;
            if ("visual-state" !== k) {
                var m = f.get(this);
                m && (m.clear(), f.delete(this));
                if (m = g.ex) m = e.FromSuperJSON(m), f.set(this, m);
                this._timeScale = g.hasOwnProperty("mts") ? g.mts : -1;
                if (m = g.ivs)
                    for (const [p, t] of Object.entries(m))
                        if (m = parseInt(p, 10), m = this._objectType.GetInstanceVariableIndexBySID(m), !(0 > m || m >= this._instVarValues.length)) {
                            var r = t;
                            null === r && (r = NaN);
                            this._instVarValues[m] = r
                        }
            }
            if (this.GetPlugin().IsWorldType()) {
                m = g.w;
                var w = m.l;
                this._worldInfo.GetLayer().GetSID() !== w && (r = this._worldInfo.GetLayer(), (w = r.GetLayout().GetLayerBySID(w)) ?
                    (this._worldInfo._SetLayer(w), r._RemoveInstance(this, !0), w._AddInstance(this, !0), w.SetZIndicesChanged(), this._worldInfo.SetBboxChanged()) : "full" === k && this._runtime.DestroyInstance(this));
                this._worldInfo._LoadFromJson(m, k)
            }
            if ("visual-state" !== k && (k = g.behs))
                for (const [p, t] of Object.entries(k)) k = parseInt(p, 10), k = this.GetBehaviorIndexBySID(k), 0 > k || k >= this._behaviorInstances.length || this._behaviorInstances[k].LoadFromJson(t);
            (g = g.data) && this._sdkInst.LoadFromJson(g)
        }
        GetInterfaceClass() {
            return this._iScriptInterface ||
                this._InitUserScriptInterface()
        }
        _InitUserScriptInterface() {
            var g = this._worldInfo ? self.IWorldInstance : a;
            const k = this._sdkInst.GetScriptInterfaceClass(),
                m = this._objectType._GetUserScriptInstanceClass(),
                r = m || k || g;
            a._Init(this);
            this._iScriptInterface = new r;
            a._Init(null);
            if (k && !(this._iScriptInterface instanceof g)) throw new TypeError(`script interface class '${k.name}' does not extend the right base class '${g.name}'`);
            if (m && (g = k || g, !(this._iScriptInterface instanceof g))) throw new TypeError(`setInstanceClass(): class '${m.name}' does not extend the right base class '${g.name}'`);
            return this._iScriptInterface
        }
        _GetInstVarsScriptDescriptor(g) {
            if (0 !== this._instVarValues.length) {
                var k = {},
                    m = this._objectType._GetAllInstanceVariableJsPropNames();
                for (let r = 0, w = m.length; r < w; ++r) k[m[r]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: e.Instance.prototype._GetInstanceVariableTypedValue.bind(this, r),
                    set: e.Instance.prototype.SetInstanceVariableValue.bind(this, r)
                };
                k = Object.create(Object.prototype, k);
                g.instVars = {
                    value: k,
                    writable: !1
                }
            }
        }
        _GetBehaviorsScriptDescriptor(g) {
            var k = this._behaviorInstances;
            if (0 !==
                k.length) {
                var m = {};
                for (const r of k) m[r.GetBehaviorType().GetJsPropName()] = {
                    value: r.GetScriptInterface(),
                    writable: !1
                };
                k = Object.create(Object.prototype, m);
                g.behaviors = {
                    value: k,
                    writable: !1
                }
            }
        }
        DispatchUserScriptEvent(g) {
            g.instance = this.GetInterfaceClass();
            var k = this._runtime;
            (k = k.IsDebug() && !k.GetEventSheetManager().IsInEventEngine()) && d.StartMeasuringScriptTime();
            this.GetInterfaceClass().dispatchEvent(g);
            k && d.AddScriptTime()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SceneGraphInfo = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._owner = d;
            this._parent = null;
            this._children = [];
            this._startWidth = d.GetWidth();
            this._startHeight = d.GetHeight();
            this._startScaleY = this._startScaleX = 1;
            this._parentStartAngle = 0
        }
        Release() {
            this._parent = null;
            e.clearArray(this._children)
        }
        SetParent(d) {
            this._parentStartAngle = (this._parent = d) ? d.GetAngle() : 0
        }
        GetParent() {
            return this._parent
        }
        HasChildren() {
            return 0 < this._children.length
        }
        GetChildren() {
            return this._children
        }
        GetStartScaleX() {
            return this._startScaleX
        }
        SetStartScaleX(d) {
            this._startScaleX =
                d
        }
        GetStartScaleY() {
            return this._startScaleY
        }
        SetStartScaleY(d) {
            this._startScaleY = d
        }
        _GetStartWidth() {
            return this._startWidth
        }
        _GetStartHeight() {
            return this._startHeight
        }
        GetParentScaleX() {
            return this._owner.GetTransformWithParentWidth() ? this._parent.GetWidth() / this._parent._GetSceneGraphInfo()._GetStartWidth() : 1
        }
        GetParentScaleY() {
            return this._owner.GetTransformWithParentHeight() ? this._parent.GetHeight() / this._parent._GetSceneGraphInfo()._GetStartHeight() : 1
        }
        GetParentStartAngle() {
            return this._parentStartAngle
        }
        _SaveToJson() {
            return {
                sw: this._startWidth,
                sh: this._startHeight,
                sx: this._startScaleX,
                sy: this._startScaleY,
                psa: this._parentStartAngle,
                c: this._children.map(d => {
                    let a = "";
                    d.GetTransformWithParentX() && (a += "x");
                    d.GetTransformWithParentY() && (a += "y");
                    d.GetTransformWithParentWidth() && (a += "w");
                    d.GetTransformWithParentHeight() && (a += "h");
                    d.GetTransformWithParentAngle() && (a += "a");
                    d.GetTransformWithParentZElevation() && (a += "z");
                    d.GetDestroyWithParent() && (a += "d");
                    return {
                        uid: d.GetInstance().GetUID(),
                        f: a
                    }
                })
            }
        }
        _LoadFromJson(d) {
            this._startWidth = d.sw;
            this._startHeight =
                d.sh;
            this._startScaleX = d.sx;
            this._startScaleY = d.sy;
            this._parentStartAngle = d.psa
        }
        _OnAfterLoad(d) {
            const a = this._owner,
                b = a.GetRuntime();
            for (const c of d.c) {
                d = b.GetInstanceByUID(c.uid).GetWorldInfo();
                const f = c.f,
                    h = {};
                h.transformX = f.includes("x");
                h.transformY = f.includes("y");
                h.transformWidth = f.includes("w");
                h.transformHeight = f.includes("h");
                h.transformAngle = f.includes("a");
                h.transformZElevation = f.includes("z");
                h.destroyWithParent = f.includes("d");
                a.AddChild(d, h)
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.New(e.Rect),
        a = e.New(e.Quad),
        b = e.New(e.Event, "bboxchange", !1),
        c = e.New(e.Color, 0, 0, 0, 0),
        f = e.New(e.CollisionPoly),
        h = e.New(e.Color, 1, 1, 1, 1),
        g = e.New(e.Rect, 0, 0, -1, -1),
        k = e.New(e.Rect, 0, 0, -1, -1),
        m = new Set(["absolute", "relative"]),
        r = [];
    let w = !0;
    e.WorldInfo = class extends e.DefendedBase {
        constructor(p, t) {
            super();
            this._inst = p;
            this._objectClass = p.GetObjectClass();
            this._runtime = p.GetRuntime();
            this._layer = t;
            this._zIndex = -1;
            this._flags = 196635;
            this._objectClass.GetPlugin().IsRotatable() &&
                (this._flags |= 128);
            this._oy = this._ox = this._cosA = this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = NaN;
            this._boundingBox = e.New(e.Rect);
            this._boundingQuad = e.New(e.Quad);
            this._collisionCells = k;
            this._renderCells = g;
            this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null;
            this._colorPremultiplied = this._color = h;
            this._instanceEffectList = this._stateGroup = null;
            this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = e.New(e.InstanceEffectList,
                this._inst, this));
            this._sceneGraphInfo = null;
            this._sceneGraphFlagsExportData = NaN;
            this._sceneGraphChildrenExportData = null;
            this._sceneGraphZIndex = this._sceneGraphZIndexExportData = NaN;
            this._meshInfo = null
        }
        _MarkDestroyed() {
            this._flags |= 256
        }
        Release() {
            this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null);
            this._sourceCollisionPoly = null;
            this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null);
            this._solidFilterTags &&
                (this._solidFilterTags.clear(), this._solidFilterTags = null);
            this.ReleaseMesh();
            this.HasParent() && this.GetParent().RemoveChild(this);
            if (this.HasChildren()) {
                const p = [...this.GetChildren()];
                for (const t of p) this.RemoveChild(t)
            }
            this._ReleaseSceneGraphInfo();
            this._layer = this._runtime = this._objectClass = this._inst = null
        }
        Init(p) {
            w = !1;
            this.SetXY(p[0], p[1]);
            this.SetZElevation(p[2]);
            this.SetSize(p[3], p[4]);
            this._depth = 0;
            this.IsRotatable() ? this.SetAngle(p[6]) : this._a = 0;
            c.setFromJSON(p[7]);
            this._SetColor(c);
            this.SetOriginX(p[8]);
            this.SetOriginY(p[9]);
            this.SetBlendMode(p[10]);
            this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(p[12]);
            p[14] && (this._sceneGraphFlagsExportData = p[14][0], this._sceneGraphChildrenExportData = p[14][1], this._sceneGraphZIndexExportData = p[14][2]);
            if (p[15]) {
                var t = p[15];
                this.CreateMesh(t[0], t[1]);
                p = this.GetSourceMesh();
                t = t[2];
                for (let u = 0, q = t.length; u < q; ++u) {
                    const x = t[u];
                    for (let y = 0, B = x.length; y < B; ++y) {
                        const F = x[y],
                            H = p.GetMeshPointAt(y, u);
                        H.SetX(F[0]);
                        H.SetY(F[1]);
                        H.SetZElevation(F[2]);
                        H.SetU(F[3]);
                        H.SetV(F[4])
                    }
                }
            }
            w = !0;
            this._UpdateRendererStateGroup()
        }
        InitNoData() {
            this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = 0;
            this._cosA = 1;
            this._oy = this._ox = 0;
            this._UpdateRendererStateGroup()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetInstance() {
            return this._inst
        }
        _GetParentOffsetAngle() {
            return this.GetTransformWithParentAngle() ? this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle() : 0
        }
        SetX(p) {
            p = +p;
            if (this.GetTransformWithParentX()) {
                const t =
                    this._sceneGraphInfo;
                p -= this.GetX();
                const u = -this._GetParentOffsetAngle();
                0 === u ? this._x += p / t.GetParentScaleX() : (this._x += Math.cos(u) * p / t.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(u) * p / t.GetParentScaleY()))
            } else this._x = p
        }
        OffsetX(p) {
            p = +p;
            this.GetTransformWithParentX() ? this.SetX(this.GetX() + p) : this._x += p
        }
        GetX() {
            if (this.GetTransformWithParentX()) {
                let p = this._x;
                const t = this._sceneGraphInfo,
                    u = this.GetParent(),
                    q = this._GetParentOffsetAngle();
                0 === q ? p *= t.GetParentScaleX() : (p = p * t.GetParentScaleX() *
                    Math.cos(q), this.GetTransformWithParentY() && (p -= this._y * t.GetParentScaleY() * Math.sin(q)));
                return u.GetX() + p
            }
            return this._x
        }
        SetY(p) {
            p = +p;
            if (this.GetTransformWithParentY()) {
                const t = this._sceneGraphInfo;
                p -= this.GetY();
                const u = -this._GetParentOffsetAngle();
                0 === u ? this._y += p / t.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(u) * p / t.GetParentScaleX()), this._y += Math.cos(u) * p / t.GetParentScaleY())
            } else this._y = p
        }
        OffsetY(p) {
            p = +p;
            this.GetTransformWithParentY() ? this.SetY(this.GetY() + p) : this._y +=
                p
        }
        GetY() {
            if (this.GetTransformWithParentY()) {
                let p = this._y;
                const t = this._sceneGraphInfo,
                    u = this.GetParent(),
                    q = this._GetParentOffsetAngle();
                0 === q ? p *= t.GetParentScaleY() : (p = p * t.GetParentScaleY() * Math.cos(q), this.GetTransformWithParentX() && (p += this._x * t.GetParentScaleX() * Math.sin(q)));
                return u.GetY() + p
            }
            return this._y
        }
        SetXY(p, t) {
            p = +p;
            t = +t;
            if (this.GetTransformWithParentXOrY()) {
                const q = this.GetTransformWithParentX(),
                    x = this.GetTransformWithParentY(),
                    y = this._sceneGraphInfo,
                    B = p - this.GetX(),
                    F = t - this.GetY();
                var u = -this._GetParentOffsetAngle();
                if (0 === u) this._x = q ? this._x + B / y.GetParentScaleX() : p, this._y = x ? this._y + F / y.GetParentScaleY() : t;
                else {
                    const H = Math.sin(u);
                    u = Math.cos(u);
                    this._x = q ? x ? this._x + (u * B - H * F) / y.GetParentScaleX() : this._x + u * B / y.GetParentScaleX() : p;
                    this._y = x ? q ? this._y + (H * B + u * F) / y.GetParentScaleY() : this._y + u * F / y.GetParentScaleY() : t
                }
            } else this._x = p, this._y = t
        }
        OffsetXY(p, t) {
            p = +p;
            t = +t;
            this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + p, this.GetY() + t) : (this._x += p, this._y += t)
        }
        EqualsXY(p, t) {
            return this.GetX() ===
                p && this.GetY() === t
        }
        SetZElevation(p) {
            p = +p;
            this.GetTransformWithParentZElevation() && (p -= this.GetParent().GetZElevation());
            this._zElevation !== p && (this._zElevation = p, this._UpdateZElevation(), p = this.GetLayer(), 0 !== this._zElevation && p._SetAnyInstanceZElevated(), p.SetZIndicesChanged())
        }
        _UpdateZElevation() {
            this._UpdateRendererStateGroup();
            if (this.HasChildren()) {
                const p = this.GetChildren();
                for (let t = 0, u = p.length; t < u; t++) {
                    const q = p[t];
                    q.GetTransformWithParentZElevation() && q._UpdateZElevation()
                }
            }
        }
        OffsetZElevation(p) {
            this.SetZElevation(this.GetZElevation() +
                p)
        }
        GetZElevation() {
            return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
        }
        GetTotalZElevation() {
            return this.GetLayer().GetZElevation() + this.GetZElevation()
        }
        SetWidth(p) {
            p = +p;
            this.GetTransformWithParentWidth() ? this._w *= p / this.GetWidth() : this._w = p
        }
        OffsetWidth(p) {
            p = +p;
            this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + p) : this._w += p
        }
        GetWidth() {
            return this.GetTransformWithParentWidth() ? this.GetParent().GetWidth() * this._w : this._w
        }
        SetHeight(p) {
            p = +p;
            this.GetTransformWithParentHeight() ? this._h *= p / this.GetHeight() : this._h = p
        }
        OffsetHeight(p) {
            p = +p;
            this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + p) : this._h += p
        }
        GetHeight() {
            return this.GetTransformWithParentHeight() ? this.GetParent().GetHeight() * this._h : this._h
        }
        SetSize(p, t) {
            p = +p;
            t = +t;
            this.GetTransformWithParentWidth() ? this._w *= p / this.GetWidth() : this._w = p;
            this.GetTransformWithParentHeight() ? this._h *= t / this.GetHeight() : this._h = t
        }
        GetDepth() {
            return this._depth
        }
        SetDepth(p) {
            if (0 > p) throw new RangeError("invalid depth");
            this._depth = p
        }
        GetSceneGraphScale() {
            if (this.HasParent()) {
                const p = this._sceneGraphInfo;
                return Math.min(p.GetParentScaleX(), p.GetParentScaleY())
            }
            return 1
        }
        IsRotatable() {
            return 0 !== (this._flags & 128)
        }
        SetAngle(p) {
            p = +p;
            this.IsRotatable() && (this.GetTransformWithParentAngle() && (p -= this.GetParent().GetAngle()), p = e.clampAngle(p), this._a !== p && (this._a = p, this._MarkSinCosAngleChanged()))
        }
        OffsetAngle(p) {
            p = +p;
            0 !== p && this.IsRotatable() && (this._a = e.clampAngle(this._a + p), this._MarkSinCosAngleChanged())
        }
        _MarkSinCosAngleChanged() {
            this._flags |=
                262144;
            if (this.HasChildren()) {
                const p = this.GetChildren();
                for (let t = 0, u = p.length; t < u; t++) p[t]._MarkSinCosAngleChanged()
            }
        }
        GetAngle() {
            return this.GetTransformWithParentAngle() ? e.clampAngle(this.GetParent().GetAngle() + this._a) : this._a
        }
        _MaybeUpdateSinCosAngle() {
            const p = this._flags;
            if (0 !== (p & 262144)) {
                var t = this.GetAngle();
                this._sinA = Math.sin(t);
                this._cosA = Math.cos(t);
                this._flags = p & -262145
            }
        }
        GetSinAngle() {
            this._MaybeUpdateSinCosAngle();
            return this._sinA
        }
        GetCosAngle() {
            this._MaybeUpdateSinCosAngle();
            return this._cosA
        }
        SetOriginX(p) {
            this._ox = +p
        }
        OffsetOriginX(p) {
            this._ox += +p
        }
        GetOriginX() {
            return this._ox
        }
        SetOriginY(p) {
            this._oy = +p
        }
        OffsetOriginY(p) {
            this._oy += +p
        }
        GetOriginY() {
            return this._oy
        }
        _SetColor(p) {
            this._color.equals(p) || (this._color === h ? (this._color = e.New(e.Color, p), this._colorPremultiplied = e.New(e.Color, p), this._colorPremultiplied.premultiply()) : p.equalsRgba(1, 1, 1, 1) ? this._colorPremultiplied = this._color = h : (this._color.set(p), this._colorPremultiplied.set(p), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup())
        }
        SetOpacity(p) {
            p =
                e.clamp(+p, 0, 1);
            this._color.a !== p && (c.copyRgb(this._color), c.a = p, this._SetColor(c))
        }
        OffsetOpacity(p) {
            this.SetOpacity(this.GetOpacity() + p)
        }
        GetOpacity() {
            return this._color.a
        }
        SetUnpremultipliedColor(p) {
            this._color.equalsIgnoringAlpha(p) || (c.copyRgb(p), c.a = this._color.a, this._SetColor(c))
        }
        SetUnpremultipliedColorRGB(p, t, u) {
            c.setRgb(p, t, u);
            this.SetUnpremultipliedColor(c)
        }
        OffsetUnpremultipliedColorRGB(p, t, u) {
            if (0 !== p || 0 !== t || 0 !== u) c.copyRgb(this._color), c.r += p, c.g += t, c.b += u, this.SetUnpremultipliedColor(c)
        }
        GetUnpremultipliedColor() {
            return this._color
        }
        GetPremultipliedColor() {
            return this._colorPremultiplied
        }
        GetDestroyWithParent() {
            return 0 !==
                (this._flags & 512)
        }
        SetDestroyWithParent(p) {
            this._SetFlag(512, p)
        }
        GetTransformWithParentX() {
            return 0 !== (this._flags & 1024)
        }
        SetTransformWithParentX(p) {
            this._SetFlag(1024, p)
        }
        GetTransformWithParentY() {
            return 0 !== (this._flags & 2048)
        }
        GetTransformWithParentXOrY() {
            return 0 !== (this._flags & 3072)
        }
        SetTransformWithParentY(p) {
            this._SetFlag(2048, p)
        }
        GetTransformWithParentWidth() {
            return 0 !== (this._flags & 4096)
        }
        SetTransformWithParentWidth(p) {
            this._SetFlag(4096, p)
        }
        GetTransformWithParentHeight() {
            return 0 !== (this._flags & 8192)
        }
        SetTransformWithParentHeight(p) {
            this._SetFlag(8192,
                p)
        }
        GetTransformWithParentAngle() {
            return 0 !== (this._flags & 16384)
        }
        SetTransformWithParentAngle(p) {
            this._SetFlag(16384, p)
        }
        GetTransformWithParentZElevation() {
            return 0 !== (this._flags & 32768)
        }
        SetTransformWithParentZElevation(p) {
            this._SetFlag(32768, p)
        }
        _ClearAllSceneGraphFlags() {
            this._flags &= -65025
        }
        AddChild(p, t) {
            if (p !== this && !p.HasParent() && !this._HasChildRecursive(p) && !this._HasAnyParent(p)) {
                var u = p.GetX(),
                    q = p.GetY(),
                    x = p.GetWidth(),
                    y = p.GetHeight(),
                    B = p.GetAngle(),
                    F = p.GetZElevation();
                p._SetParent(this);
                p.SetTransformWithParentX(t.transformX);
                p.SetTransformWithParentY(t.transformY);
                p.SetTransformWithParentWidth(t.transformWidth);
                p.SetTransformWithParentHeight(t.transformHeight);
                p.SetTransformWithParentAngle(t.transformAngle);
                p.SetTransformWithParentZElevation(t.transformZElevation);
                p.SetDestroyWithParent(t.destroyWithParent);
                t.transformX && (p._x = u - this.GetX(), t.transformWidth && (p._x /= this.GetWidth() / this._sceneGraphInfo._GetStartWidth()));
                t.transformY && (p._y = q - this.GetY(), t.transformHeight && (p._y /= this.GetHeight() / this._sceneGraphInfo._GetStartHeight()));
                t.transformWidth && (p._w = x / this.GetWidth(), p._sceneGraphInfo.SetStartScaleX(p._w));
                t.transformHeight && (p._h = y / this.GetHeight(), p._sceneGraphInfo.SetStartScaleY(p._h));
                t.transformAngle && (p._a = B - this.GetAngle());
                t.transformZElevation && (p._zElevation = F - this.GetZElevation());
                this._AddChildToSceneGraphInfo(p);
                this.SetBboxChanged()
            }
        }
        RemoveChild(p) {
            if (p.GetParent() === this) {
                var t = p.GetX(),
                    u = p.GetY(),
                    q = p.GetWidth(),
                    x = p.GetHeight(),
                    y = p.GetAngle(),
                    B = p.GetZElevation();
                p._SetParent(null);
                p._ClearAllSceneGraphFlags();
                p.SetXY(t, u);
                p.SetSize(q, x);
                p.SetAngle(y);
                p.SetZElevation(B);
                this._RemoveChildFromSceneGraphInfo(p);
                this.SetBboxChanged()
            }
        }
        _ResetAllSceneGraphState() {
            for (var p of this.children()) this.RemoveChild(p);
            (p = this.GetParent()) && p.RemoveChild(this);
            this._ClearAllSceneGraphFlags()
        }
        HasParent() {
            return null !== this.GetParent()
        }
        GetParent() {
            const p = this._sceneGraphInfo;
            return null !== p ? p.GetParent() : null
        }
        GetTopParent() {
            let p = this;
            for (; p.HasParent();) p = p.GetParent();
            return p
        }* parents() {
            let p = this.GetParent();
            for (; p;) yield p,
                p = p.GetParent()
        }
        HasChild(p) {
            return this.GetChildren().includes(p)
        }
        HasChildren() {
            const p = this._sceneGraphInfo;
            return null !== p ? p.HasChildren() : !1
        }
        GetChildren() {
            const p = this._sceneGraphInfo;
            return null !== p ? p.GetChildren() : r
        }
        children() {
            return this.GetChildren()
        }* allChildren() {
            for (const p of this.children()) yield p, yield* p.allChildren()
        }
        GetChildCount() {
            return this.GetChildren().length
        }
        GetChildAt(p) {
            const t = this.GetChildren();
            p = Math.floor(+p);
            return 0 > p || p >= t.length ? null : t[p]
        }
        _CreateSceneGraphInfo(p) {
            this._sceneGraphInfo ||
                (this._sceneGraphInfo = e.New(e.SceneGraphInfo, this));
            p && this._sceneGraphInfo.SetParent(p)
        }
        _GetSceneGraphInfo() {
            return this._sceneGraphInfo
        }
        _ReleaseSceneGraphInfo() {
            this._sceneGraphInfo && (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null)
        }
        _SetParent(p) {
            p ? (p._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(p)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo())
        }
        _HasAnyParent(p) {
            if (!this.HasParent()) return !1;
            const t = this.GetParent();
            return t === p ? !0 : t._HasAnyParent(p)
        }
        _HasChildRecursive(p) {
            if (this.HasChild(p)) return !0;
            for (const t of this.GetChildren())
                if (t._HasChildRecursive(p)) return !0;
            return !1
        }
        _AddChildToSceneGraphInfo(p) {
            this._sceneGraphInfo.GetChildren().push(p)
        }
        _RemoveChildFromSceneGraphInfo(p) {
            const t = this._sceneGraphInfo.GetChildren(),
                u = t.indexOf(p); - 1 !== u && t.splice(u, 1);
            0 !== t.length || this.HasParent() || this._ReleaseSceneGraphInfo();
            p.HasChildren() || p._ReleaseSceneGraphInfo()
        }
        GetSceneGraphChildrenExportData() {
            return this._sceneGraphChildrenExportData
        }
        GetSceneGraphZIndexExportData() {
            return this._sceneGraphZIndexExportData
        }
        GetSceneGraphZIndex() {
            return this._sceneGraphZIndex
        }
        SetSceneGraphZIndex(p) {
            this._sceneGraphZIndex =
                p
        }
        SetUsePointsShaderProgram() {
            this._SetFlag(524288, !0);
            this._UpdateRendererStateGroup()
        }
        _UpdateRendererStateGroup() {
            if (w) {
                var p = this._runtime.GetRenderer();
                this._stateGroup && p.ReleaseStateGroup(this._stateGroup);
                var t = 0 !== (this._flags & 524288) ? p.GetPointsRenderingProgram() || "<point>" : p.GetTextureFillShaderProgram() || "<default>";
                this._stateGroup = p.AcquireStateGroup(t, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
            }
        }
        GetRendererStateGroup() {
            return this._stateGroup
        }
        HasDefaultColor() {
            return this._color ===
                h
        }
        SetBlendMode(p) {
            p |= 0;
            if (0 > p || 31 < p) throw new RangeError("invalid blend mode");
            this.GetBlendMode() !== p && (this._flags = this._flags & -2080374785 | p << 26, this._UpdateRendererStateGroup())
        }
        GetBlendMode() {
            return (this._flags & 2080374784) >> 26
        }
        _SetLayer(p) {
            this._layer = p;
            0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
        }
        GetLayer() {
            return this._layer
        }
        GetLayout() {
            return this.GetLayer().GetLayout()
        }
        _SetZIndex(p) {
            this._zIndex = p | 0
        }
        GetZIndex() {
            this._layer._UpdateZIndices();
            return this._zIndex
        }
        _GetLastCachedZIndex() {
            return this._zIndex
        }
        _SetFlag(p,
            t) {
            this._flags = t ? this._flags | p : this._flags & ~p
        }
        IsVisible() {
            return 0 !== (this._flags & 1)
        }
        SetVisible(p) {
            this._SetFlag(1, p)
        }
        IsCollisionEnabled() {
            return 0 !== (this._flags & 8)
        }
        SetCollisionEnabled(p) {
            p = !!p;
            this.IsCollisionEnabled() !== p && (this._SetFlag(8, p), p ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
        }
        SetSolidCollisionFilter(p, t) {
            this._SetFlag(32, p);
            this._solidFilterTags && this._solidFilterTags.clear();
            if (t.trim()) {
                this._solidFilterTags || (this._solidFilterTags = new Set);
                for (const u of t.split(" ")) u &&
                    this._solidFilterTags.add(u.toLowerCase())
            } else this._solidFilterTags = null
        }
        IsSolidCollisionAllowed(p) {
            const t = 0 !== (this._flags & 32),
                u = this._solidFilterTags;
            if (!p || !u) return !t;
            for (const q of u)
                if (p.has(q)) return t;
            return !t
        }
        SetBboxChanged() {
            this._flags |= 65554;
            this._objectClass._SetAnyCollisionCellChanged(!0);
            this._runtime.UpdateRender();
            this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags &= -3, this._UpdateRenderCell());
            0 !== (this._flags & 4) && this._inst.Dispatcher().dispatchEvent(b);
            if (null !== this._sceneGraphInfo) {
                const p = this._sceneGraphInfo.GetChildren();
                for (let t = 0, u = p.length; t < u; ++t) p[t].SetBboxChanged()
            }
        }
        CalculateBbox(p, t, u) {
            const q = this.GetX(),
                x = this.GetY(),
                y = this.GetWidth(),
                B = this.GetHeight(),
                F = this.GetAngle();
            p.setWH(q - this._ox * y, x - this._oy * B, y, B);
            u && this.HasMesh() && this._ExpandBboxForMesh(p);
            0 === F ? t.setFromRect(p) : (p.offset(-q, -x), t.setFromRotatedRectPrecalc(p, this.GetSinAngle(), this.GetCosAngle()), t.offset(q, x), t.getBoundingBox(p));
            p.normalize()
        }
        _UpdateBbox() {
            const p =
                this._flags;
            0 !== (p & 2) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags = p & -3)
        }
        GetBoundingBox() {
            this._UpdateBbox();
            return this._boundingBox
        }
        GetBoundingQuad() {
            this._UpdateBbox();
            return this._boundingQuad
        }
        PixelRoundQuad(p) {
            var t = this.GetX(),
                u = this.GetY();
            t = Math.round(t) - t;
            u = Math.round(u) - u;
            if (0 === t && 0 === u) return p;
            a.copy(p);
            a.offset(t, u);
            return a
        }
        OverwriteBoundingBox(p) {
            this._boundingBox.copy(p);
            this._boundingQuad.setFromRect(this._boundingBox);
            this._flags &= -3;
            this._UpdateCollisionCell();
            this._UpdateRenderCell()
        }
        SetBboxChangeEventEnabled(p) {
            this._SetFlag(4, p)
        }
        IsBboxChangeEventEnabled() {
            return 0 !== (this._flags & 4)
        }
        IsInViewport(p, t, u) {
            return t && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || u ? p.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
        }
        _IsInViewport_ZElevated() {
            const p = this.GetLayer(),
                t = this.GetTotalZElevation();
            if (t >= p.GetCameraZ()) return !1;
            p.GetViewportForZ(t, d);
            return d.intersectsRect(this.GetBoundingBox())
        }
        IsInViewport3D(p) {
            var t =
                this.GetBoundingBox();
            const u = t.getLeft(),
                q = t.getRight(),
                x = t.getTop();
            t = t.getBottom();
            const y = this.GetTotalZElevation(),
                B = y + this.GetDepth();
            return p.ContainsAABB(u, x, y, q, t, B)
        }
        _SetDrawBackFaceOnly(p) {
            this._SetFlag(1048576, p)
        }
        _SetDrawNonBackFacesOnly(p) {
            this._SetFlag(2097152, p)
        }
        IsDrawBackFaceOnly() {
            return 0 !== (this._flags & 1048576)
        }
        IsDrawNonBackFacesOnly() {
            return 0 !== (this._flags & 2097152)
        }
        SetSourceCollisionPoly(p) {
            this._sourceCollisionPoly = p;
            this._DiscardTransformedCollisionPoly();
            this.HasMesh() && (this._meshInfo.meshPoly =
                null)
        }
        GetSourceCollisionPoly() {
            return this._sourceCollisionPoly
        }
        HasOwnCollisionPoly() {
            return null !== this._sourceCollisionPoly || this.HasMesh()
        }
        GetTransformedCollisionPoly() {
            return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
        }
        GetCustomTransformedCollisionPoly(p, t, u) {
            let q = 0,
                x = 1;
            0 !== u && (q = Math.sin(u), x = Math.cos(u));
            return this._GetCustomTransformedCollisionPolyPrecalc(p, t, u, q, x)
        }
        _GetCustomTransformedCollisionPolyPrecalc(p,
            t, u, q, x) {
            let y = this._transformedPolyInfo;
            null === y && (this._transformedPolyInfo = y = {
                poly: e.New(e.CollisionPoly),
                width: NaN,
                height: NaN,
                angle: NaN
            });
            const B = y.poly;
            if (y.width === p && y.height === t && y.angle === u) return B;
            const F = this._sourceCollisionPoly;
            if (this.HasMesh()) {
                const H = this.GetOriginX(),
                    K = this.GetOriginY(),
                    C = this.GetSourceMesh();
                let A = this._meshInfo.meshPoly;
                A || (F ? (f.copy(F), f.offset(H, K)) : f.setDefaultPoints(), A = C.InsertPolyMeshVertices(f), this._meshInfo.meshPoly = A);
                C.TransformCollisionPoly(A, B);
                B.offset(-H, -K);
                B.transformPrecalc(p, t, q, x)
            } else F ? (B.copy(F), B.transformPrecalc(p, t, q, x)) : B.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
            y.width = p;
            y.height = t;
            y.angle = u;
            return B
        }
        _DiscardTransformedCollisionPoly() {
            this.SetPhysicsBodyChanged(!0);
            const p = this._transformedPolyInfo;
            null !== p && (p.width = NaN)
        }
        CreateMesh(p, t) {
            p = Math.floor(p);
            t = Math.floor(t);
            if (!this.GetInstance().GetPlugin().SupportsMesh()) throw Error("object does not support mesh");
            this.ReleaseMesh();
            this._meshInfo = {
                sourceMesh: e.New(e.Gfx.Mesh,
                    p, t),
                transformedMesh: e.New(e.Gfx.Mesh, p, t),
                meshPoly: null
            }
        }
        HasMesh() {
            return null !== this._meshInfo
        }
        GetSourceMesh() {
            if (!this.HasMesh()) throw Error("no mesh");
            return this._meshInfo.sourceMesh
        }
        GetTransformedMesh() {
            if (!this.HasMesh()) throw Error("no mesh");
            return this._meshInfo.transformedMesh
        }
        SetMeshChanged(p) {
            this._SetFlag(65536, p)
        }
        IsMeshChanged() {
            return 0 !== (this._flags & 65536)
        }
        SetPhysicsBodyChanged(p) {
            this._SetFlag(131072, p)
        }
        IsPhysicsBodyChanged() {
            return 0 !== (this._flags & 131072)
        }
        _ExpandBboxForMesh(p) {
            const t =
                this._meshInfo.sourceMesh,
                u = Math.min(t.GetMinX(), 0),
                q = Math.min(t.GetMinY(), 0),
                x = Math.max(t.GetMaxX(), 1),
                y = Math.max(t.GetMaxY(), 1),
                B = p.width(),
                F = p.height();
            p.offsetLeft(u * B);
            p.offsetTop(q * F);
            p.offsetRight((x - 1) * B);
            p.offsetBottom((y - 1) * F);
            this._depth = t.GetMaxZ()
        }
        ReleaseMesh() {
            this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly())
        }
        SetMeshPoint(p, t, u) {
            p = Math.floor(p);
            t = Math.floor(t);
            var q = u.mode || "absolute";
            if (!m.has(q)) throw Error("invalid mode");
            q = "relative" === q;
            let x = u.x,
                y = u.y;
            const B = u.zElevation;
            let F = "number" === typeof u.u ? u.u : q ? 0 : -1;
            u = "number" === typeof u.v ? u.v : q ? 0 : -1;
            if (!this.HasMesh()) return !1;
            const H = this.GetSourceMesh(),
                K = H.GetMeshPointAt(p, t);
            if (null === K) return !1;
            let C = !1;
            "number" === typeof B && K.GetZElevation() !== B && (K.SetZElevation(B), C = !0);
            q && (x += p / (H.GetHSize() - 1), y += t / (H.GetVSize() - 1)); - 1 !== F || q ? (q && (F += p / (H.GetHSize() - 1)), F = e.clamp(F, 0, 1)) : F = K.GetU(); - 1 !== u || q ? (q && (u += t / (H.GetVSize() - 1)),
                u = e.clamp(u, 0, 1)) : u = K.GetV();
            if (K.GetX() === x && K.GetY() === y && K.GetU() === F && K.GetV() === u) return C;
            K.SetX(x);
            K.SetY(y);
            K.SetU(F);
            K.SetV(u);
            this._DiscardTransformedCollisionPoly();
            return !0
        }
        HasTilemap() {
            return this._inst.HasTilemap()
        }
        ContainsPoint(p, t) {
            return this.GetBoundingBox().containsPoint(p, t) && this.GetBoundingQuad().containsPoint(p, t) ? this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(p, t) : this.HasOwnCollisionPoly() ? this.GetTransformedCollisionPoly().containsPoint(p - this.GetX(),
                t - this.GetY()) : !0 : !1
        }
        _IsCollisionCellChanged() {
            return 0 !== (this._flags & 16)
        }
        _UpdateCollisionCell() {
            if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags & 256)) {
                var p = this.GetBoundingBox(),
                    t = this._objectClass._GetCollisionCellGrid(),
                    u = this._collisionCells;
                d.set(t.XToCell(p.getLeft()), t.YToCell(p.getTop()), t.XToCell(p.getRight()), t.YToCell(p.getBottom()));
                u.equals(d) || (p = this._inst, u === k ? (t.Update(p, null, d), this._collisionCells = e.New(e.Rect, d)) : (t.Update(p, u, d), u.copy(d)), this._flags &=
                    -17)
            }
        }
        _RemoveFromCollisionCells() {
            const p = this._collisionCells;
            p !== k && (this._objectClass._GetCollisionCellGrid().Update(this._inst, p, null), this._collisionCells = k)
        }
        _UpdateRenderCell() {
            const p = this.GetLayer();
            if (p.UsesRenderCells() && 0 === (this._flags & 256)) {
                var t = p.GetRenderGrid(),
                    u = this.GetBoundingBox(),
                    q = this._renderCells;
                d.set(t.XToCell(u.getLeft()), t.YToCell(u.getTop()), t.XToCell(u.getRight()), t.YToCell(u.getBottom()));
                q.equals(d) || (u = this._inst, q === g ? (t.Update(u, null, d), this._renderCells = e.New(e.Rect,
                    d)) : (t.Update(u, q, d), q.copy(d)), p.SetRenderListStale())
            }
        }
        _RemoveFromRenderCells() {
            const p = this._renderCells;
            p !== g && (this.GetLayer().GetRenderGrid().Update(this._inst, p, null), this._renderCells = g)
        }
        GetRenderCellRange() {
            return this._renderCells
        }
        ZOrderMoveToTop() {
            const p = this._inst,
                t = this._layer,
                u = t._GetInstances();
            u.length && u.at(-1) === p || (t._RemoveInstance(p, !1), t._AddInstance(p, !1), this._runtime.UpdateRender())
        }
        ZOrderMoveToBottom() {
            const p = this._inst,
                t = this._layer,
                u = t._GetInstances();
            u.length && u[0] ===
                p || (t._RemoveInstance(p, !1), t._PrependInstance(p, !1), this._runtime.UpdateRender())
        }
        ZOrderMoveToLayer(p) {
            const t = this._inst,
                u = this._layer;
            if (u.GetLayout() !== p.GetLayout()) throw Error("layer from different layout");
            p !== u && (u._RemoveInstance(t, !0), this._SetLayer(p), p._AddInstance(t, !0), this._runtime.UpdateRender())
        }
        ZOrderMoveAdjacentToInstance(p, t) {
            const u = this._inst;
            let q = !1;
            const x = this._layer;
            if (p.GetUID() !== u.GetUID()) {
                var y = p.GetWorldInfo();
                if (!y) throw Error("expected world instance");
                y = y.GetLayer();
                x.GetIndex() !== y.GetIndex() && (x._RemoveInstance(u, !0), this._SetLayer(y), y._AddInstance(u, !0), q = !0);
                p = y.MoveInstanceAdjacent(u, p, !!t);
                (q || p) && this._runtime.UpdateRender()
            }
        }
        GetInstanceEffectList() {
            return this._instanceEffectList
        }
        _SetHasAnyActiveEffect(p) {
            this._SetFlag(64, p)
        }
        HasAnyActiveEffect() {
            return 0 !== (this._flags & 64)
        }
        _SaveToJson(p) {
            const t = {
                x: this.GetX(),
                y: this.GetY(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                l: this.GetLayer().GetSID(),
                zi: this.GetZIndex()
            };
            0 !== this.GetZElevation() && (t.ze = this.GetZElevation());
            0 !== this.GetAngle() && (t.a = this.GetAngle());
            this.HasDefaultColor() || (t.c = this._color.toJSON());
            .5 !== this.GetOriginX() && (t.oX = this.GetOriginX());
            .5 !== this.GetOriginY() && (t.oY = this.GetOriginY());
            0 !== this.GetBlendMode() && (t.bm = this.GetBlendMode());
            this.IsVisible() || (t.v = this.IsVisible());
            this.IsCollisionEnabled() || (t.ce = this.IsCollisionEnabled());
            this.IsBboxChangeEventEnabled() && (t.be = this.IsBboxChangeEventEnabled());
            this._instanceEffectList && (t.fx = this._instanceEffectList._SaveToJson());
            const u = 0 !==
                (this._flags & 32);
            u && (t.sfi = u);
            this._solidFilterTags && (t.sft = [...this._solidFilterTags].join(" "));
            this._sceneGraphInfo && "visual-state" !== p && (t.sgi = this._sceneGraphInfo._SaveToJson());
            this.HasMesh() && (t.mesh = this.GetSourceMesh().SaveToJson());
            return t
        }
        _OnBeforeLoad(p) {
            "visual-state" !== p && this._ResetAllSceneGraphState()
        }
        _LoadFromJson(p, t) {
            w = !1;
            this.SetX(p.x);
            this.SetY(p.y);
            this.SetWidth(p.w);
            this.SetHeight(p.h);
            this._SetZIndex(p.zi);
            this.SetZElevation(p.hasOwnProperty("ze") ? p.ze : 0);
            this.SetAngle(p.hasOwnProperty("a") ?
                p.a : 0);
            p.hasOwnProperty("c") ? c.setFromJSON(p.c) : p.hasOwnProperty("o") ? (c.copyRgb(this._color), c.a = p.o) : c.setRgba(1, 1, 1, 1);
            this._SetColor(c);
            this.SetOriginX(p.hasOwnProperty("oX") ? p.oX : .5);
            this.SetOriginY(p.hasOwnProperty("oY") ? p.oY : .5);
            this.SetBlendMode(p.hasOwnProperty("bm") ? p.bm : 0);
            this.SetVisible(p.hasOwnProperty("v") ? p.v : !0);
            this.SetCollisionEnabled(p.hasOwnProperty("ce") ? p.ce : !0);
            this.SetBboxChangeEventEnabled(p.hasOwnProperty("be") ? p.be : !1);
            this.SetSolidCollisionFilter(p.hasOwnProperty("sfi") ?
                p.sfi : !1, p.hasOwnProperty("sft") ? p.sft : "");
            this._instanceEffectList && p.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(p.fx);
            if (p.hasOwnProperty("sgi") && "visual-state" !== t) {
                this._CreateSceneGraphInfo(null);
                const u = this._sceneGraphInfo,
                    q = p.sgi;
                u._LoadFromJson(q);
                const x = this.GetRuntime().Dispatcher(),
                    y = () => {
                        x.removeEventListener("afterload", y);
                        0 === (this._flags & 256) && u._OnAfterLoad(q)
                    };
                x.addEventListener("afterload", y)
            }
            p.hasOwnProperty("mesh") ? (p = p.mesh, this.CreateMesh(p.cols, p.rows), this.GetSourceMesh().LoadFromJson(p)) :
                this.ReleaseMesh();
            this.SetBboxChanged();
            w = !0;
            this._UpdateRendererStateGroup()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.BehaviorType = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            const b = d.GetRuntime(),
                c = b.GetPluginManager(),
                f = b.GetObjectReference(a[1]);
            c.HasBehaviorByConstructorFunction(f) || c.CreateBehavior(a);
            this._runtime = b;
            this._objectClass = d;
            this._behavior = c.GetBehaviorByConstructorFunction(f);
            this._sdkType = null;
            this._instSdkCtor = f.Instance;
            this._sid = a[2];
            this._name = a[0];
            this._jsPropName = this._runtime.GetJsPropName(a[3]);
            this._sdkType = e.New(f.Type, this);
            this.OnCreate()
        }
        static Create(d,
            a) {
            return e.New(e.BehaviorType, d, a)
        }
        Release() {
            this._behavior = this._runtime = null;
            this._sdkType.Release();
            this._instSdkCtor = this._sdkType = null
        }
        GetSdkType() {
            return this._sdkType
        }
        OnCreate() {
            this._sdkType.OnCreate()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehavior() {
            return this._behavior
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetJsPropName() {
            return this._jsPropName
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.IBehaviorInstance;
    e.BehaviorInstance = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.runtime;
            this._behaviorType = a.behaviorType;
            this._behavior = this._behaviorType.GetBehavior();
            this._inst = a.instance;
            this._index = a.index;
            this._iScriptInterface = this._sdkInst = null;
            this._behavior._AddInstance(this._inst)
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null);
            this._behavior._RemoveInstance(this._inst);
            this._sdkInst.Release();
            this._inst = this._behavior = this._behaviorType = this._runtime = this._iScriptInterface = this._sdkInst = null
        }
        _CreateSdkInstance(a) {
            if (this._sdkInst) throw Error("already got sdk instance");
            this._sdkInst = e.New(this._behaviorType.GetInstanceSdkCtor(), this, a);
            this._InitScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetBehavior() {
            return this._behavior
        }
        _GetIndex() {
            return this._index
        }
        PostCreate() {
            this._sdkInst.PostCreate()
        }
        OnSpriteFrameChanged(a,
            b) {
            this._sdkInst.OnSpriteFrameChanged(a, b)
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson() {
            return this._sdkInst.SaveToJson()
        }
        LoadFromJson(a) {
            return this._sdkInst.LoadFromJson(a)
        }
        static SortByTickSequence(a, b) {
            var c = a.GetObjectInstance(),
                f = b.GetObjectInstance();
            const h = c.GetObjectClass().GetIndex(),
                g = f.GetObjectClass().GetIndex();
            if (h !== g) return h - g;
            c = c.GetPUID();
            f = f.GetPUID();
            return c !== f ? c - f : a.GetBehaviorInstance()._GetIndex() - b.GetBehaviorInstance()._GetIndex()
        }
        _InitScriptInterface() {
            const a =
                this._sdkInst.GetScriptInterfaceClass(),
                b = a || d;
            d._Init(this);
            this._iScriptInterface = new b;
            d._Init(null);
            if (a && !(this._iScriptInterface instanceof d)) throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${d.name}'`);
        }
        GetScriptInterface() {
            return this._iScriptInterface
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EffectList = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._owner = d;
            this._allEffectTypes = [];
            this._activeEffectTypes = [];
            this._effectTypesByName = new Map;
            this._effectParams = [];
            this._preservesOpaqueness = !0;
            for (const b of a) d = e.New(e.EffectType, this, b, this._allEffectTypes.length), this._allEffectTypes.push(d), this._effectTypesByName.set(d.GetName().toLowerCase(), d), 3 <= b.length && this._effectParams.push(this._LoadSingleEffectParameters(b[2]));
            this.GetRuntime()._AddEffectList(this)
        }
        Release() {
            e.clearArray(this._allEffectTypes);
            e.clearArray(this._activeEffectTypes);
            this._effectTypesByName.clear();
            e.clearArray(this._effectParams);
            this._owner = null
        }
        PrependEffectTypes(d) {
            if (d.length) {
                this._allEffectTypes = d.concat(this._allEffectTypes);
                for (const a of d) this._effectTypesByName.set(a.GetName().toLowerCase(), a);
                for (let a = 0, b = this._allEffectTypes.length; a < b; ++a) this._allEffectTypes[a]._SetIndex(a)
            }
        }
        _LoadSingleEffectParameters(d) {
            d = d.slice(0);
            for (let a = 0, b = d.length; a < b; ++a) {
                const c = d[a];
                if (Array.isArray(c)) {
                    const f = e.New(e.Color);
                    f.setFromJSON(c);
                    d[a] = f
                }
            }
            return d
        }
        GetOwner() {
            return this._owner
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        UpdateActiveEffects() {
            e.clearArray(this._activeEffectTypes);
            let d = !0;
            for (const a of this._allEffectTypes) a.IsActive() && (this._activeEffectTypes.push(a), a.GetShaderProgram().PreservesOpaqueness() || (d = !1));
            this._preservesOpaqueness = d
        }
        GetAllEffectTypes() {
            return this._allEffectTypes
        }
        HasAnyEffectType() {
            return 0 < this._allEffectTypes.length
        }
        GetEffectTypeByName(d) {
            return this._effectTypesByName.get(d.toLowerCase()) ||
                null
        }
        GetEffectTypeByIndex(d) {
            d = Math.floor(+d);
            if (0 > d || d >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
            return this._allEffectTypes[d]
        }
        IsEffectIndexActive(d) {
            return this.GetEffectTypeByIndex(d).IsActive()
        }
        SetEffectIndexActive(d, a) {
            this.GetEffectTypeByIndex(d).SetActive(a)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        HasAnyActiveEffect() {
            return 0 < this._activeEffectTypes.length
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        GetEffectParametersForIndex(d) {
            return this._effectParams[d]
        }
        static SaveFxParamToJson(d) {
            return d &&
                d instanceof e.Color ? {
                    t: "color",
                    v: d.toJSON()
                } : d
        }
        static LoadFxParamFromJson(d) {
            if ("object" === typeof d) {
                if ("color" === d.t) {
                    const a = e.New(e.Color);
                    a.setFromJSON(d.v);
                    return a
                }
                throw Error("invalid effect parameter type");
            }
            return d
        }
        static SaveFxParamsToJson(d) {
            return d.map(e.EffectList.SaveFxParamToJson)
        }
        static LoadFxParamsFromJson(d) {
            return d.map(e.EffectList.LoadFxParamFromJson)
        }
        SaveToJson() {
            return this._allEffectTypes.map(d => ({
                name: d.GetName(),
                active: d.IsActive(),
                params: e.EffectList.SaveFxParamsToJson(this._effectParams[d.GetIndex()])
            }))
        }
        LoadFromJson(d) {
            for (const a of d)
                if (d =
                    this.GetEffectTypeByName(a.name)) d.SetActive(a.active), this._effectParams[d.GetIndex()] = e.EffectList.LoadFxParamsFromJson(a.params);
            this.UpdateActiveEffects()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EffectType = class extends e.DefendedBase {
        constructor(d, a, b) {
            super();
            this._effectList = d;
            this._id = a[0];
            this._name = a[1];
            this._index = b;
            this._shaderProgram = null;
            this._isActive = !0
        }
        Release() {
            this._shaderProgram = this._effectList = null
        }
        Clone(d) {
            d = e.New(e.EffectType, d, [this._id, this._name], -1);
            d._shaderProgram = this._shaderProgram;
            d._isActive = this._isActive;
            return d
        }
        _InitRenderer(d) {
            d = d.GetShaderProgramByName(this._id);
            if (!d) throw Error("failed to find shader program '" + this._id +
                "'");
            this._shaderProgram = d
        }
        GetEffectList() {
            return this._effectList
        }
        GetName() {
            return this._name
        }
        _SetIndex(d) {
            this._index = d
        }
        GetIndex() {
            return this._index
        }
        GetOwner() {
            return this._effectList.GetOwner()
        }
        GetRuntime() {
            return this._effectList.GetRuntime()
        }
        SetActive(d) {
            this._isActive = !!d
        }
        IsActive() {
            return this._isActive
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        GetDefaultParameterValues() {
            const d = [];
            for (let a = 0, b = this._shaderProgram.GetParameterCount(); a < b; ++a) {
                const c = this._shaderProgram.GetParameterType(a);
                if ("float" === c || "percent" === c) d.push(0);
                else if ("color" === c) d.push(e.New(e.Color, 1, 1, 1, 1));
                else throw new TypeError("unknown effect parameter type");
            }
            return d
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.InstanceEffectList = class extends e.DefendedBase {
        constructor(d, a, b) {
            super();
            this._inst = d;
            this._wi = a;
            this._effectList = d.GetObjectClass().GetEffectList();
            this._activeEffectFlags = [];
            this._activeEffectTypes = [];
            this._preservesOpaqueness = !0;
            this._effectParams = [];
            for (const c of this._effectList.GetAllEffectTypes()) this._activeEffectFlags.push(!0);
            this.UpdateActiveEffects()
        }
        Release() {
            e.clearArray(this._activeEffectFlags);
            e.clearArray(this._activeEffectTypes);
            e.clearArray(this._effectParams);
            this._effectList = this._inst = null
        }
        _LoadEffectParameters(d) {
            for (const a of d) this._effectParams.push(this._LoadSingleEffectParameters(a))
        }
        _LoadSingleEffectParameters(d) {
            d = d.slice(0);
            for (let a = 0, b = d.length; a < b; ++a) {
                const c = d[a];
                if (Array.isArray(c)) {
                    const f = e.New(e.Color);
                    f.setFromJSON(c);
                    d[a] = f
                }
            }
            return d
        }
        LoadDefaultEffectParameters() {
            for (const d of this._effectList.GetAllEffectTypes()) this._effectParams.push(d.GetDefaultParameterValues())
        }
        GetOwner() {
            return this._owner
        }
        GetEffectList() {
            return this._effectList
        }
        GetRuntime() {
            return this._inst.GetRuntime()
        }
        UpdateActiveEffects() {
            e.clearArray(this._activeEffectTypes);
            const d = this._effectList.GetAllEffectTypes(),
                a = this._activeEffectTypes,
                b = this._activeEffectFlags;
            let c = !0;
            for (let f = 0, h = d.length; f < h; ++f)
                if (b[f]) {
                    const g = d[f];
                    a.push(g);
                    g.GetShaderProgram().PreservesOpaqueness() || (c = !1)
                }
            this._preservesOpaqueness = c;
            this._wi._SetHasAnyActiveEffect(!!a.length)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        GetEffectParametersForIndex(d) {
            return this._effectParams[d]
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        HasAnyActiveBackgroundBlendingEffect() {
            return this._activeEffectTypes.some(d =>
                d.GetShaderProgram().UsesDest())
        }
        IsEffectIndexActive(d) {
            return this._activeEffectFlags[d]
        }
        SetEffectIndexActive(d, a) {
            this._activeEffectFlags[d] = !!a
        }
        GetAllEffectTypes() {
            return this._effectList.GetAllEffectTypes()
        }
        _SaveToJson() {
            return this._effectList.GetAllEffectTypes().map(d => ({
                name: d.GetName(),
                active: this._activeEffectFlags[d.GetIndex()],
                params: e.EffectList.SaveFxParamsToJson(this._effectParams[d.GetIndex()])
            }))
        }
        _LoadFromJson(d) {
            for (const a of d)
                if (d = this._effectList.GetEffectTypeByName(a.name)) this._activeEffectFlags[d.GetIndex()] =
                    a.active, this._effectParams[d.GetIndex()] = e.EffectList.LoadFxParamsFromJson(a.params);
            this.UpdateActiveEffects()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [],
        a = [],
        b = [],
        c = e.New(e.CollisionPoly),
        f = e.New(e.CollisionPoly),
        h = e.New(e.Quad),
        g = e.New(e.Rect),
        k = e.New(e.Rect);
    let m = null,
        r = null,
        w = null;
    e.CollisionEngine = class extends e.DefendedBase {
        constructor(p) {
            super();
            this._runtime = p;
            this._registeredCollisions = [];
            this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0
        }
        Release() {
            this._runtime = null
        }
        _Update1sStats() {
            this._collisionCheckSec = this._collisionCheckCount;
            this._collisionCheckCount = 0;
            this._polyCheckSec =
                this._polyCheckCount;
            this._polyCheckCount = 0
        }
        Get1secCollisionChecks() {
            return this._collisionCheckSec
        }
        Get1secPolyChecks() {
            return this._polyCheckSec
        }
        RegisterCollision(p, t) {
            const u = p.GetWorldInfo(),
                q = t.GetWorldInfo();
            u && q && u.IsCollisionEnabled() && q.IsCollisionEnabled() && this._registeredCollisions.push([p, t])
        }
        AddRegisteredCollisionCandidates(p, t, u) {
            for (const [q, x] of this._registeredCollisions) {
                let y;
                if (p === q) y = x;
                else if (p === x) y = q;
                else continue;
                y.BelongsToObjectClass(t) && (u.includes(y) || u.push(y))
            }
        }
        CheckRegisteredCollision(p,
            t) {
            if (!this._registeredCollisions.length) return !1;
            for (const [u, q] of this._registeredCollisions)
                if (p === u && t === q || p === q && t === u) return !0;
            return !1
        }
        ClearRegisteredCollisions() {
            e.clearArray(this._registeredCollisions)
        }
        TestOverlap(p, t) {
            if (!p || !t || p === t) return !1;
            p = p.GetWorldInfo();
            t = t.GetWorldInfo();
            if (!p.IsCollisionEnabled() || !t.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            const u = p.GetLayer(),
                q = t.GetLayer();
            return u.IsTransformCompatibleWith(q) ? this._TestOverlap_SameLayers(p, t) : this._TestOverlap_DifferentLayers(p,
                t)
        }
        _TestOverlap_SameLayers(p, t) {
            if (!p.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return !1;
            this._polyCheckCount++;
            if (!p.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad()) || p.HasTilemap() && t.HasTilemap()) return !1;
            if (p.HasTilemap()) return this.TestTilemapOverlap(p, t);
            if (t.HasTilemap()) return this.TestTilemapOverlap(t, p);
            if (!p.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return !0;
            const u = p.GetTransformedCollisionPoly(),
                q = t.GetTransformedCollisionPoly();
            return u.intersectsPoly(q, t.GetX() -
                p.GetX(), t.GetY() - p.GetY())
        }
        _TestOverlap_DifferentLayers(p, t) {
            var u = p.HasTilemap(),
                q = t.HasTilemap();
            if (u && !q) return this.TestTilemapOverlapDifferentLayers(p, t);
            if (q && !u) return this.TestTilemapOverlapDifferentLayers(t, p);
            if (q || u) return !1;
            q = p.GetLayer();
            u = t.GetLayer();
            c.copy(p.GetTransformedCollisionPoly());
            f.copy(t.GetTransformedCollisionPoly());
            var x = c.pointsArr();
            for (let y = 0, B = x.length; y < B; y += 2) {
                const F = y + 1,
                    H = x[F],
                    [K, C] = q.LayerToCanvasCss(x[y] + p.GetX(), H + p.GetY());
                x[y] = K;
                x[F] = C
            }
            p = f.pointsArr();
            for (let y =
                    0, B = p.length; y < B; y += 2) {
                q = y + 1;
                x = p[q];
                const [F, H] = u.LayerToCanvasCss(p[y] + t.GetX(), x + t.GetY());
                p[y] = F;
                p[q] = H
            }
            c.setBboxChanged();
            f.setBboxChanged();
            this._polyCheckCount++;
            return c.intersectsPoly(f, 0, 0)
        }
        TestTilemapOverlapDifferentLayers(p, t) {
            var u = p.GetLayer(),
                q = t.GetLayer();
            m || (m = e.New(e.CollisionPoly));
            r || (r = e.New(e.Rect));
            w || (w = e.New(e.Quad));
            var x = t.GetX(),
                y = t.GetY();
            const [B, F] = q.LayerToCanvasCss(x, y), [H, K] = u.CanvasCssToLayer(B, F);
            u = H - x;
            y = K - y;
            r.copy(t.GetBoundingBox());
            r.offset(u, y);
            if (!p.GetBoundingBox().intersectsRect(r)) return !1;
            w.copy(t.GetBoundingQuad());
            w.offset(u, y);
            this._polyCheckCount++;
            if (!p.GetBoundingQuad().intersectsQuad(w)) return !1;
            m.copy(t.GetTransformedCollisionPoly());
            q = m.pointsArr();
            for (let C = 0, A = q.length; C < A; C += 2) x = C + 1, q[C] += u, q[x] += y;
            m.setBboxChanged();
            return this.TestTilemapOverlap(p, t, H, K, m, r, w)
        }
        TestTilemapOverlap(p, t, u, q, x, y, B) {
            y = void 0 !== y ? y : t.GetBoundingBox();
            const F = p.GetX(),
                H = p.GetY();
            var K = p.GetInstance().GetSdkInstance();
            u = void 0 !== u ? u : t.GetX();
            q = void 0 !== q ? q : t.GetY();
            p = t.HasOwnCollisionPoly();
            B =
                void 0 !== B ? B : t.GetBoundingQuad();
            K.GetCollisionRectCandidates(y, a);
            for (let G = 0, J = a.length; G < J; ++G) {
                var C = a[G];
                K = C.GetRect();
                this._collisionCheckCount++;
                if (y.intersectsRectOffset(K, F, H) && (h.setFromRect(K), h.offset(F, H), h.intersectsQuad(B)))
                    if (p) {
                        var A = void 0 !== x ? x : t.GetTransformedCollisionPoly();
                        if (C = C.GetPoly()) {
                            if (this._polyCheckCount++, C.intersectsPoly(A, u - (F + K.getLeft()), q - (H + K.getTop()))) return e.clearArray(a), !0
                        } else if (c.setFromQuad(h, 0, 0), c.intersectsPoly(A, u, q)) return e.clearArray(a), !0
                    } else if (A =
                    C.GetPoly()) {
                    if (c.setFromQuad(B, 0, 0), A.intersectsPoly(c, -(F + K.getLeft()), -(H + K.getTop()))) return e.clearArray(a), !0
                } else return e.clearArray(a), !0
            }
            e.clearArray(a);
            return !1
        }
        TestAndSelectCanvasPointOverlap(p, t, u, q) {
            const x = p.GetCurrentSol();
            var y = this._runtime.GetCurrentEvent();
            if (!y) throw Error("cannot call outside event");
            y = y.IsOrBlock();
            if (x.IsSelectAll()) {
                q || (x._SetSelectAll(!1), e.clearArray(x._GetOwnInstances()));
                for (var B of p.GetInstances()) {
                    var F = B.GetWorldInfo(),
                        H = F.GetLayer();
                    const [K, C] =
                    H.CanvasCssToLayer(t, u, F.GetTotalZElevation());
                    if (F.ContainsPoint(K, C)) {
                        if (q) return !1;
                        x._PushInstance(B)
                    } else y && x._PushElseInstance(B)
                }
            } else {
                B = y ? x._GetOwnElseInstances() : x._GetOwnInstances();
                F = 0;
                for (let K = 0, C = B.length; K < C; ++K) {
                    H = B[K];
                    const A = H.GetWorldInfo(),
                        G = A.GetLayer(),
                        [J, M] = G.CanvasCssToLayer(t, u, A.GetTotalZElevation());
                    if (A.ContainsPoint(J, M)) {
                        if (q) return !1;
                        y ? x._PushInstance(H) : B[F++] = H
                    } else y && (B[F++] = H)
                }
                q || (B.length = F)
            }
            p.ApplySolToContainer();
            return q ? !0 : x.HasAnyInstances()
        }
        GetCollisionCandidates(p,
            t, u, q) {
            p = p ? 1 !== p.GetParallaxX() || 1 !== p.GetParallaxY() : !1;
            if (t.IsFamily())
                for (const x of t.GetFamilyMembers()) p || x.IsAnyInstanceParallaxed() ? e.appendArray(q, x.GetInstances()) : (x._UpdateAllCollisionCells(), x._GetCollisionCellGrid().QueryRange(u, q));
            else p || t.IsAnyInstanceParallaxed() ? e.appendArray(q, t.GetInstances()) : (t._UpdateAllCollisionCells(), t._GetCollisionCellGrid().QueryRange(u, q))
        }
        GetObjectClassesCollisionCandidates(p, t, u, q) {
            for (const x of t) this.GetCollisionCandidates(p, x, u, q)
        }
        GetSolidCollisionCandidates(p,
            t, u) {
            const q = this._runtime.GetSolidBehavior();
            q && this.GetObjectClassesCollisionCandidates(p, q.GetObjectClasses(), t, u)
        }
        GetJumpthruCollisionCandidates(p, t, u) {
            const q = this._runtime.GetJumpthruBehavior();
            q && this.GetObjectClassesCollisionCandidates(p, q.GetObjectClasses(), t, u)
        }
        IsSolidCollisionAllowed(p, t) {
            return p._IsSolidEnabled() && (!t || t.GetWorldInfo().IsSolidCollisionAllowed(p.GetSavedDataMap().get("solidTags")))
        }
        TestOverlapSolid(p) {
            const t = p.GetWorldInfo();
            this.GetSolidCollisionCandidates(t.GetLayer(),
                t.GetBoundingBox(), d);
            for (const u of d)
                if (this.IsSolidCollisionAllowed(u, p) && this.TestOverlap(p, u)) return e.clearArray(d), u;
            e.clearArray(d);
            return null
        }
        TestRectOverlapSolid(p, t) {
            this.GetSolidCollisionCandidates(null, p, d);
            for (const u of d)
                if (this.IsSolidCollisionAllowed(u, t) && this.TestRectOverlap(p, u)) return e.clearArray(d), u;
            e.clearArray(d);
            return null
        }
        TestOverlapJumpthru(p, t) {
            let u = null;
            t && (u = b, e.clearArray(u));
            const q = p.GetWorldInfo();
            this.GetJumpthruCollisionCandidates(q.GetLayer(), q.GetBoundingBox(),
                d);
            for (const x of d)
                if (x._IsJumpthruEnabled() && this.TestOverlap(p, x))
                    if (t) u.push(x);
                    else return e.clearArray(d), x;
            e.clearArray(d);
            return u
        }
        PushOut(p, t, u, q, x) {
            q = q || 50;
            const y = p.GetWorldInfo(),
                B = y.GetX(),
                F = y.GetY();
            for (let H = 0; H < q; ++H)
                if (y.SetXY(B + t * H, F + u * H), y.SetBboxChanged(), !this.TestOverlap(p, x)) return !0;
            y.SetXY(B, F);
            y.SetBboxChanged();
            return !1
        }
        PushOutSolid(p, t, u, q, x, y) {
            q = q || 50;
            const B = p.GetWorldInfo(),
                F = B.GetX(),
                H = B.GetY();
            let K = null,
                C = null;
            for (let A = 0; A < q; ++A)
                if (B.SetXY(F + t * A, H + u * A), B.SetBboxChanged(), !this.TestOverlap(p, K))
                    if (K = this.TestOverlapSolid(p)) C = K;
                    else if (x && (K = y ? this.TestOverlap(p, y) ? y : null : this.TestOverlapJumpthru(p)) && (C = K), !K) return C && this.PushInFractional(p, t, u, C, 16, !0), !0;
            B.SetXY(F, H);
            B.SetBboxChanged();
            return !1
        }
        PushOutSolidAxis(p, t, u, q) {
            q = q || 50;
            const x = p.GetWorldInfo(),
                y = x.GetX(),
                B = x.GetY();
            let F = null,
                H = null;
            for (let K = 0; K < q; ++K)
                for (let C = 0; 2 > C; ++C) {
                    const A = 2 * C - 1;
                    x.SetXY(y + t * K * A, B + u * K * A);
                    x.SetBboxChanged();
                    if (!this.TestOverlap(p, F))
                        if (F = this.TestOverlapSolid(p)) H = F;
                        else return H &&
                            this.PushInFractional(p, t * A, u * A, H, 16, !0), !0
                }
            x.SetXY(y, B);
            x.SetBboxChanged();
            return !1
        }
        PushInFractional(p, t, u, q, x, y) {
            let B = 2,
                F = !1;
            var H = !1;
            const K = p.GetWorldInfo();
            let C = K.GetX(),
                A = K.GetY();
            for (; B <= x;) H = 1 / B, B *= 2, K.OffsetXY(t * H * (F ? 1 : -1), u * H * (F ? 1 : -1)), K.SetBboxChanged(), this.TestOverlap(p, q) || y && this.TestOverlapSolid(p) ? H = F = !0 : (H = F = !1, C = K.GetX(), A = K.GetY());
            H && (K.SetXY(C, A), K.SetBboxChanged())
        }
        PushOutSolidNearest(p, t = 100) {
            let u = 0;
            const q = p.GetWorldInfo(),
                x = q.GetX(),
                y = q.GetY();
            let B = 0,
                F = this.TestOverlapSolid(p);
            if (!F) return !0;
            for (; u <= t;) {
                let H = 0,
                    K = 0;
                switch (B) {
                    case 0:
                        H = 0;
                        K = -1;
                        u++;
                        break;
                    case 1:
                        H = 1;
                        K = -1;
                        break;
                    case 2:
                        H = 1;
                        K = 0;
                        break;
                    case 3:
                        K = H = 1;
                        break;
                    case 4:
                        H = 0;
                        K = 1;
                        break;
                    case 5:
                        H = -1;
                        K = 1;
                        break;
                    case 6:
                        H = -1;
                        K = 0;
                        break;
                    case 7:
                        K = H = -1
                }
                B = (B + 1) % 8;
                q.SetXY(Math.floor(x + H * u), Math.floor(y + K * u));
                q.SetBboxChanged();
                if (!this.TestOverlap(p, F) && (F = this.TestOverlapSolid(p), !F)) return !0
            }
            q.SetXY(x, y);
            q.SetBboxChanged();
            return !1
        }
        CalculateBounceAngle(p, t, u, q) {
            const x = p.GetWorldInfo(),
                y = x.GetX(),
                B = x.GetY(),
                F = Math.max(10, e.distanceTo(t,
                    u, y, B));
            var H = e.angleTo(t, u, y, B),
                K = q || this.TestOverlapSolid(p);
            if (!K) return e.clampAngle(H + Math.PI);
            let C = K;
            var A = 0,
                G = 0;
            const J = e.toRadians(5);
            let M;
            for (M = 1; 36 > M; ++M) {
                const R = H - M * J;
                x.SetXY(t + Math.cos(R) * F, u + Math.sin(R) * F);
                x.SetBboxChanged();
                if (!this.TestOverlap(p, C) && (C = q ? null : this.TestOverlapSolid(p), !C)) {
                    A = R;
                    break
                }
            }
            36 === M && (A = e.clampAngle(H + Math.PI));
            C = K;
            for (M = 1; 36 > M; ++M)
                if (K = H + M * J, x.SetXY(t + Math.cos(K) * F, u + Math.sin(K) * F), x.SetBboxChanged(), !this.TestOverlap(p, C) && (C = q ? null : this.TestOverlapSolid(p), !C)) {
                    G = K;
                    break
                }
            36 === M && (G = e.clampAngle(H + Math.PI));
            x.SetXY(y, B);
            x.SetBboxChanged();
            if (G === A) return G;
            p = e.angleDiff(G, A) / 2;
            p = e.angleClockwise(G, A) ? e.clampAngle(A + p + Math.PI) : e.clampAngle(G + p);
            A = Math.cos(H);
            H = Math.sin(H);
            G = Math.cos(p);
            p = Math.sin(p);
            t = A * G + H * p;
            return e.angleTo(0, 0, A - 2 * t * G, H - 2 * t * p)
        }
        TestSegmentOverlap(p, t, u, q, x) {
            if (!x) return !1;
            const y = x.GetWorldInfo();
            if (!y.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            g.set(Math.min(p, u), Math.min(t, q), Math.max(p, u), Math.max(t, q));
            if (!y.GetBoundingBox().intersectsRect(g)) return !1;
            if (x.HasTilemap()) return this._TestSegmentOverlapTilemap(p, t, u, q, x, y);
            this._polyCheckCount++;
            return y.GetBoundingQuad().intersectsSegment(p, t, u, q) ? y.HasOwnCollisionPoly() ? y.GetTransformedCollisionPoly().intersectsSegment(y.GetX(), y.GetY(), p, t, u, q) : !0 : !1
        }
        _TestSegmentOverlapTilemap(p, t, u, q, x, y) {
            const B = y.GetX();
            y = y.GetY();
            x = x.GetSdkInstance();
            k.set(p, t, u, q);
            k.normalize();
            x.GetCollisionRectCandidates(k, a);
            for (let H = 0, K = a.length; H < K; ++H) {
                var F = a[H];
                x = F.GetRect();
                this._collisionCheckCount++;
                if (g.intersectsRectOffset(x,
                        B, y) && (h.setFromRect(x), h.offset(B, y), h.intersectsSegment(p, t, u, q)))
                    if (F = F.GetPoly()) {
                        if (this._polyCheckCount++, F.intersectsSegment(B + x.getLeft(), y + x.getTop(), p, t, u, q)) return e.clearArray(a), !0
                    } else return e.clearArray(a), !0
            }
            e.clearArray(a);
            return !1
        }
        TestRectOverlap(p, t) {
            if (!t) return !1;
            const u = t.GetWorldInfo();
            if (!u.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            if (!u.GetBoundingBox().intersectsRect(p)) return !1;
            if (t.HasTilemap()) return this._TestRectOverlapTilemap(p, t, u);
            this._polyCheckCount++;
            h.setFromRect(p);
            if (!u.GetBoundingQuad().intersectsQuad(h)) return !1;
            if (!u.HasOwnCollisionPoly()) return !0;
            c.setFromRect(p, u.GetX(), u.GetY());
            p = u.GetTransformedCollisionPoly();
            return c.intersectsPoly(p, 0, 0)
        }
        _TestRectOverlapTilemap(p, t, u) {
            const q = u.GetX();
            u = u.GetY();
            t.GetSdkInstance().GetCollisionRectCandidates(p, a);
            for (let y = 0, B = a.length; y < B; ++y) {
                var x = a[y];
                t = x.GetRect();
                this._collisionCheckCount++;
                if (p.intersectsRectOffset(t, q, u))
                    if (x = x.GetPoly()) {
                        if (this._polyCheckCount++, c.setFromRect(p, 0, 0), x.intersectsPoly(c, -(q + t.getLeft()), -(u + t.getTop()))) return e.clearArray(a), !0
                    } else return e.clearArray(a), !0
            }
            e.clearArray(a);
            return !1
        }
        TestRayIntersectsInstance(p, t) {
            if (p) {
                var u = p.GetWorldInfo();
                u.IsCollisionEnabled() && (this._collisionCheckCount++, u.GetBoundingBox().intersectsRect(t.rect) && (p.HasTilemap() ? this._TestRayIntersectsTilemap(p, u, t) : (this._polyCheckCount++, u.HasOwnCollisionPoly() ? t.TestInstancePoly(p, u.GetX(), u.GetY(), u.GetTransformedCollisionPoly()) : t.TestInstanceQuad(p, u.GetBoundingQuad()))))
            }
        }
        _TestRayIntersectsTilemap(p,
            t, u) {
            const q = t.GetX(),
                x = t.GetY();
            p.GetSdkInstance().GetCollisionRectCandidates(u.rect, a);
            for (let B = 0, F = a.length; B < F; B++) {
                var y = a[B];
                const H = y.GetRect();
                this._collisionCheckCount++;
                u.rect.intersectsRectOffset(H, q, x) && (y = y.GetPoly(), this._polyCheckCount++, y ? u.TestInstancePoly(p, q + H.getLeft(), x + H.getTop(), y) : u.TestInstanceRect(p, t.GetX(), t.GetY(), H))
            }
            e.clearArray(a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SparseGrid = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._cellWidth = d;
            this._cellHeight = a;
            this._cells = e.New(e.PairMap)
        }
        Release() {
            this._cells.Release();
            this._cells = null
        }
        GetCell(d, a, b) {
            let c = this._cells.Get(d, a);
            return c ? c : b ? (c = e.New(e.GridCell, this, d, a), this._cells.Set(d, a, c), c) : null
        }
        XToCell(d) {
            d = Math.floor(d / this._cellWidth);
            return isFinite(d) ? d : 0
        }
        YToCell(d) {
            d = Math.floor(d / this._cellHeight);
            return isFinite(d) ? d : 0
        }
        Update(d, a, b) {
            if (a)
                for (let c = a.getLeft(),
                        f = a.getRight(); c <= f; ++c)
                    for (let h = a.getTop(), g = a.getBottom(); h <= g; ++h) {
                        if (b && b.containsPoint(c, h)) continue;
                        const k = this.GetCell(c, h, !1);
                        k && (k.Remove(d), k.IsEmpty() && this._cells.Delete(c, h))
                    }
            if (b)
                for (let c = b.getLeft(), f = b.getRight(); c <= f; ++c)
                    for (let h = b.getTop(), g = b.getBottom(); h <= g; ++h) a && a.containsPoint(c, h) || this.GetCell(c, h, !0).Insert(d)
        }
        QueryRange(d, a) {
            let b = this.XToCell(d.getLeft());
            const c = this.YToCell(d.getTop()),
                f = this.XToCell(d.getRight());
            d = this.YToCell(d.getBottom());
            if (isFinite(f) && isFinite(d))
                for (; b <=
                    f; ++b)
                    for (let h = c; h <= d; ++h) {
                        const g = this.GetCell(b, h, !1);
                        g && g.Dump(a)
                    }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.GridCell = class extends e.DefendedBase {
        constructor(d, a, b) {
            super();
            this._grid = d;
            this._x = a;
            this._y = b;
            this._instances = e.New(e.ArraySet)
        }
        Release() {
            this._instances.Release();
            this._grid = this._instances = null
        }
        IsEmpty() {
            return this._instances.IsEmpty()
        }
        Insert(d) {
            this._instances.Add(d)
        }
        Remove(d) {
            this._instances.Delete(d)
        }
        Dump(d) {
            e.appendArray(d, this._instances.GetArray())
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Ray = class {
        constructor() {
            this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
            this.rect = new e.Rect;
            this.hitFraction = 2;
            this.hitUid = null;
            this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
            this.normalX = 1;
            this.normalY = 0;
            this.reflectionX = 1;
            this.reflectionY = 0
        }
        DidCollide() {
            return 1.000001 > this.hitFraction
        }
        Set(d, a, b, c) {
            this.x1 = d;
            this.y1 = a;
            this.x2 = b;
            this.y2 = c;
            this.dx = b - d;
            this.dy = c - a;
            this.rect.set(d, a, b, c);
            this.rect.normalize();
            this.hitFraction =
                2;
            this.hitUid = null;
            this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
            this.normalX = 1;
            this.normalY = 0;
            this.reflectionX = 1;
            this.reflectionY = 0;
            return this
        }
        Complete() {
            if (!1 !== this.DidCollide()) {
                var d = this.dx * this.hitFraction,
                    a = this.dy * this.hitFraction,
                    b = Math.sqrt(d * d + a * a);
                d /= b;
                a /= b;
                this.distance = b - 1E-6;
                this.hitX = this.x1 + d * this.distance;
                this.hitY = this.y1 + a * this.distance;
                this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
                this.normalX = Math.cos(this.hitNormal);
                this.normalY = Math.sin(this.hitNormal);
                b = d * this.normalX + a * this.normalY;
                this.reflectionX = d - 2 * this.normalX * b;
                this.reflectionY = a - 2 * this.normalY * b;
                0 < b && (this.hitNormal = e.clampAngle(this.hitNormal + Math.PI), this.normalX = -this.normalX, this.normalY = -this.normalY)
            }
        }
        TestInstanceSegment(d, a, b, c, f) {
            const h = e.rayIntersect(this.x1, this.y1, this.x2, this.y2, a, b, c, f);
            0 <= h && h < this.hitFraction && (this.hitFraction = h, this.hitUid = d.GetUID(), this.hitNormalDx = a - c, this.hitNormalDy = b - f)
        }
        TestInstanceRect(d, a, b, c) {
            const f = a + c.getLeft();
            a += c.getRight();
            const h = b + c.getTop();
            b += c.getBottom();
            this.TestInstanceSegment(d, f, h, a, h);
            this.TestInstanceSegment(d, a, h, a, b);
            this.TestInstanceSegment(d, a, b, f, b);
            this.TestInstanceSegment(d, f, b, f, h)
        }
        TestInstanceQuad(d, a) {
            const b = a.getTlx(),
                c = a.getTly(),
                f = a.getTrx(),
                h = a.getTry(),
                g = a.getBrx(),
                k = a.getBry(),
                m = a.getBlx();
            a = a.getBly();
            this.TestInstanceSegment(d, b, c, f, h);
            this.TestInstanceSegment(d, f, h, g, k);
            this.TestInstanceSegment(d, g, k, m, a);
            this.TestInstanceSegment(d, m, a, b, c)
        }
        TestInstancePoly(d, a, b, c) {
            c =
                c.pointsArr();
            for (let f = 0, h = c.length; f < h; f += 2) {
                const g = (f + 2) % h;
                this.TestInstanceSegment(d, c[f] + a, c[f + 1] + b, c[g] + a, c[g + 1] + b)
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new Set("off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(" ")),
        a = new Set(["high", "low"]),
        b = self.glMatrix.mat4,
        c = b.create(),
        f = e.New(e.Quad),
        h = e.New(e.Rect);
    e.CanvasManager = class extends e.DefendedBase {
        constructor(g) {
            super();
            this._runtime = g;
            this._canvas = null;
            this._isWebGPUEnabled = !1;
            this._webgpuRenderer = this._webglRenderer = null;
            this._gpuPreference = "high-performance";
            this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight =
                this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = this._windowInnerHeight = this._windowInnerWidth = 0;
            this._enableMipmaps = !0;
            this._drawHeight = this._drawWidth = this._textureAnisotropy = 0;
            this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
            this._deviceTransformOffY = this._deviceTransformOffX = 0;
            this._defaultProjectionMatrix = b.create();
            this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = "high";
            this._isDocumentFullscreen = !1;
            this._availableAdditionalRenderTargets = [];
            this._usedAdditionalRenderTargets = new Set;
            this._shaderData = self.C3_Shaders;
            this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
            this._gpuLastUtilisation = NaN;
            this._gpuFrameTimingsBuffer = null;
            this._layersGpuProfile = new Map;
            this._gpuCurUtilisation = NaN;
            this._webgpuFrameTimings = new Map;
            this._snapshotFormat = "";
            this._snapshotQuality = 1;
            this._snapshotArea = e.New(e.Rect);
            this._snapshotUrl = "";
            this._snapshotResolve = this._snapshotPromise = null;
            this._loaderStartTime = this._isPastingToDrawingCanvas = 0;
            this._rafId = -1;
            this._loadingProgress = 0;
            this._loadingprogress_handler = k => this._loadingProgress = k.progress;
            this._percentText = null;
            this._splashTextures = {
                logo: null,
                powered: null,
                website: null
            };
            this._splashFadeOutStartTime = this._splashFadeInFinishTime = this._splashFrameNumber = 0;
            this._splashState = "fade-in";
            this._splashDoneResolve = null;
            this._splashDonePromise = new Promise(k => this._splashDoneResolve = k)
        }
        _SetGPUPowerPreference(g) {
            this._gpuPreference = g
        }
        _SetWebGPUEnabled(g) {
            this._isWebGPUEnabled = !!g
        }
        async CreateCanvas(g) {
            this._canvas =
                g.canvas;
            this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", r => this._OnWindowResize(r));
            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", r => this._OnFullscreenChange(r));
            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", r => this._OnFullscreenError(r));
            this._canvas.addEventListener("webglcontextlost", r => this._OnWebGLContextLost(r));
            this._canvas.addEventListener("webglcontextrestored", r => this._OnWebGLContextRestored(r));
            this._isDocumentFullscreen = !!g.isFullscreen;
            var k = navigator.gpu && this._isWebGPUEnabled;
            let m = !1;
            if (k) try {
                await this._InitWebGPUContext(!0)
            } catch (r) {
                this._webgpuRenderer = null
            }
            if (!this.GetRenderer()) try {
                await this._InitWebGLContext(!0)
            } catch (r) {
                this._webglRenderer = null
            }
            this.GetRenderer() || (m = !0);
            if (!this.GetRenderer() && k) try {
                await this._InitWebGPUContext(!1)
            } catch (r) {
                this._webgpuRenderer = null
            }
            if (!this.GetRenderer()) try {
                await this._InitWebGLContext(!1)
            } catch (r) {
                this._webglRenderer = null
            }
            k = this.GetRenderer();
            if (!k) throw Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
            k.SetHasMajorPerformanceCaveat(m);
            this.SetSize(g.windowInnerWidth, g.windowInnerHeight, !0);
            this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
            k.SetMipmapsEnabled(this._enableMipmaps);
            k.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
            g = !1;
            for (const r of this._runtime._GetAllEffectLists()) {
                for (const w of r.GetAllEffectTypes()) w._InitRenderer(k), w.GetShaderProgram().UsesDest() && (g = !0);
                r.UpdateActiveEffects()
            }
            this._runtime._SetUsesAnyBackgroundBlending(g)
        }
        async _InitWebGPUContext(g) {
            g = {
                powerPreference: this._gpuPreference,
                depth: this._runtime.Uses3DFeatures(),
                failIfMajorPerformanceCaveat: g
            };
            this._webgpuRenderer = e.New(e.Gfx.WebGPURenderer);
            await this._webgpuRenderer.Create(this._canvas, g)
        }
        async _InitWebGLContext(g) {
            g = {
                powerPreference: this._gpuPreference,
                enableGpuProfiling: !0,
                depth: this._runtime.Uses3DFeatures(),
                failIfMajorPerformanceCaveat: g
            };
            "Android" === e.Platform.OS && "Chromium" === e.Platform.BrowserEngine && 75 > e.Platform.BrowserVersionNumber && (console.warn("[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this."),
                g.maxWebGLVersion = 1);
            "standard" === this._runtime.GetCompositingMode() ? g.alpha = !0 : (g.alpha = !1, g.lowLatency = !0);
            this._webglRenderer = e.New(e.Gfx.WebGLRenderer, this._canvas, g);
            await this._webglRenderer.InitState()
        }
        async _InitWebGPU() {
            if (this._shaderData) {
                const g = [];
                for (const [k, m] of Object.entries(this._shaderData)) {
                    const r = e.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
                    g.push(this._webgpuRenderer.CreateShaderProgram(k, m.wgsl, r))
                }
                await Promise.all(g)
            }
        }
        async _InitWebGL() {
            if (this._shaderData) {
                const g = [];
                for (const [k, m] of Object.entries(this._shaderData)) {
                    m.src = m.glsl;
                    const r = e.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
                    g.push(this._webglRenderer.CreateShaderProgram(m, r, k))
                }
                await Promise.all(g);
                this._webglRenderer.ResetLastProgram();
                this._webglRenderer.SetTextureFillMode()
            }
            this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
        }
        Release() {
            this._canvas = this._webglRenderer = this._runtime = null
        }
        _OnWindowResize(g) {
            const k =
                this._runtime,
                m = g.devicePixelRatio;
            k.IsInWorker() && (self.devicePixelRatio = m);
            k._SetDevicePixelRatio(m);
            this._isDocumentFullscreen = !!g.isFullscreen;
            this.SetSize(g.innerWidth, g.innerHeight);
            k.UpdateRender();
            k.IsDebug() && (k.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && k.Render()
        }
        _OnFullscreenChange(g) {
            this._isDocumentFullscreen = !!g.isFullscreen;
            this.SetSize(g.innerWidth, g.innerHeight, !0);
            this._runtime.UpdateRender()
        }
        _OnFullscreenError(g) {
            this._isDocumentFullscreen = !!g.isFullscreen;
            this.SetSize(g.innerWidth,
                g.innerHeight, !0);
            this._runtime.UpdateRender()
        }
        SetSize(g, k, m = !1) {
            g = Math.floor(g);
            k = Math.floor(k);
            if (0 >= g || 0 >= k) throw Error("invalid size");
            if (this._windowInnerWidth !== g || this._windowInnerHeight !== k || m) {
                this._windowInnerWidth = g;
                this._windowInnerHeight = k;
                m = this.GetCurrentFullscreenMode();
                "letterbox-scale" === m ? this._CalculateLetterboxScale(g, k) : "letterbox-integer-scale" === m ? this._CalculateLetterboxIntegerScale(g, k) : "off" === m ? this._CalculateFixedSizeCanvas(g, k) : this._CalculateFullsizeCanvas(g, k);
                this._UpdateFullscreenScalingQuality(m);
                this._canvas.width = this._canvasDeviceWidth;
                this._canvas.height = this._canvasDeviceHeight;
                this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                    marginLeft: this._canvasCssOffsetX,
                    marginTop: this._canvasCssOffsetY,
                    styleWidth: this._canvasCssWidth,
                    styleHeight: this._canvasCssHeight
                });
                g = this.GetRenderer();
                g.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0);
                for (var r of this._availableAdditionalRenderTargets) g.DeleteRenderTarget(r);
                e.clearArray(this._availableAdditionalRenderTargets);
                g.CalculatePerspectiveMatrix(this._defaultProjectionMatrix,
                    this.GetDrawWidth() / this.GetDrawHeight());
                r = this._runtime.GetLayoutManager();
                r.SetAllLayerProjectionChanged();
                r.SetAllLayerMVChanged()
            }
        }
        GetDefaultProjectionMatrix() {
            return this._defaultProjectionMatrix
        }
        _CalculateLetterboxScale(g, k) {
            const m = this._runtime.GetDevicePixelRatio(),
                r = this._runtime.GetOriginalViewportWidth(),
                w = this._runtime.GetOriginalViewportHeight(),
                p = r / w;
            g / k > p ? (this._canvasCssWidth = Math.round(k * p), this._canvasCssHeight = k, this._canvasCssOffsetX = Math.floor((g - this._canvasCssWidth) / 2), this._canvasCssOffsetY =
                0) : (this._canvasCssWidth = g, this._canvasCssHeight = Math.round(g / p), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((k - this._canvasCssHeight) / 2));
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * m);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * m);
            this._runtime.SetViewportSize(r, w)
        }
        _CalculateLetterboxIntegerScale(g, k) {
            const m = this._runtime.GetDevicePixelRatio();
            1 !== m && (g += 1, k += 1);
            const r = this._runtime.GetOriginalViewportWidth(),
                w = this._runtime.GetOriginalViewportHeight();
            var p = r / w;
            p = g / k > p ? k * p * m / r : g / p * m / w;
            1 < p ? p = Math.floor(p) : 1 > p && (p = 1 / Math.ceil(1 / p));
            this._canvasDeviceWidth = Math.round(r * p);
            this._canvasDeviceHeight = Math.round(w * p);
            this._canvasCssWidth = this._canvasDeviceWidth / m;
            this._canvasCssHeight = this._canvasDeviceHeight / m;
            this._canvasCssOffsetX = Math.max(Math.floor((g - this._canvasCssWidth) / 2), 0);
            this._canvasCssOffsetY = Math.max(Math.floor((k - this._canvasCssHeight) / 2), 0);
            this._runtime.SetViewportSize(r, w)
        }
        _CalculateFullsizeCanvas(g, k) {
            const m = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = g;
            this._canvasCssHeight = k;
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * m);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * m);
            this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
            g = this.GetDisplayScale();
            this._runtime.SetViewportSize(this._canvasCssWidth / g, this._canvasCssHeight / g)
        }
        _CalculateFixedSizeCanvas(g, k) {
            const m = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = this._runtime.GetViewportWidth();
            this._canvasCssHeight = this._runtime.GetViewportHeight();
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * m);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * m);
            this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((g - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((k - this._canvasCssHeight) / 2)) : this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
            this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
        }
        _UpdateFullscreenScalingQuality(g) {
            if ("high" === this._wantFullscreenScalingQuality) this._drawWidth =
                this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
            else {
                let m;
                if ("off" === this.GetCurrentFullscreenMode()) {
                    var k = this._runtime.GetViewportWidth();
                    m = this._runtime.GetViewportHeight()
                } else k = this._runtime.GetOriginalViewportWidth(), m = this._runtime.GetOriginalViewportHeight();
                this._canvasDeviceWidth < k && this._canvasDeviceHeight < m ? (this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high") :
                    (this._drawWidth = k, this._drawHeight = m, this._fullscreenScalingQuality = "low", "scale-inner" === g ? (g = k / m, k = this._windowInnerWidth / this._windowInnerHeight, k < g ? this._drawWidth = this._drawHeight * k : k > g && (this._drawHeight = this._drawWidth / k)) : "scale-outer" === g && (g = k / m, k = this._windowInnerWidth / this._windowInnerHeight, k > g ? this._drawWidth = this._drawHeight * k : k < g && (this._drawHeight = this._drawWidth / k)))
            }
        }
        IsDocumentFullscreen() {
            return this._isDocumentFullscreen
        }
        SetFullscreenMode(g) {
            if (!d.has(g)) throw Error("invalid fullscreen mode");
            this._fullscreenMode = g;
            g = this._runtime.GetLayoutManager();
            g.SetAllLayerProjectionChanged();
            g.SetAllLayerMVChanged()
        }
        GetFullscreenMode() {
            return this._fullscreenMode
        }
        SetDocumentFullscreenMode(g) {
            if (!d.has(g)) throw Error("invalid fullscreen mode");
            this._documentFullscreenMode = g;
            g = this._runtime.GetLayoutManager();
            g.SetAllLayerProjectionChanged();
            g.SetAllLayerMVChanged()
        }
        GetDocumentFullscreenMode() {
            return this._documentFullscreenMode
        }
        GetCurrentFullscreenMode() {
            return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() :
                this.GetFullscreenMode()
        }
        SetFullscreenScalingQuality(g) {
            if (!a.has(g)) throw Error("invalid fullscreen scaling quality");
            this._wantFullscreenScalingQuality = g;
            this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()
        }
        GetSetFullscreenScalingQuality() {
            return this._wantFullscreenScalingQuality
        }
        GetCurrentFullscreenScalingQuality() {
            return this._fullscreenScalingQuality
        }
        static _FullscreenModeNumberToString(g) {
            switch (g) {
                case 0:
                    return "off";
                case 1:
                    return "crop";
                case 2:
                    return "scale-inner";
                case 3:
                    return "scale-outer";
                case 4:
                    return "letterbox-scale";
                case 5:
                    return "letterbox-integer-scale";
                default:
                    throw Error("invalid fullscreen mode");
            }
        }
        GetLastWidth() {
            return this._windowInnerWidth
        }
        GetLastHeight() {
            return this._windowInnerHeight
        }
        GetDrawWidth() {
            return this._drawWidth
        }
        GetDrawHeight() {
            return this._drawHeight
        }
        SetMipmapsEnabled(g) {
            this._enableMipmaps = !!g
        }
        _SetTextureAnisotropy(g) {
            this._textureAnisotropy = g
        }
        GetTextureAnisotropy() {
            return this._textureAnisotropy
        }
        IsRendererContextLost() {
            return this.GetRenderer().IsContextLost()
        }
        _OnWebGLContextLost(g) {
            console.log("[Construct 3] WebGL context lost");
            g.preventDefault();
            this._availableAdditionalRenderTargets = [];
            this._usedAdditionalRenderTargets.clear();
            this._webglRenderer.OnContextLost();
            this._runtime._OnWebGLContextLost()
        }
        async _OnWebGLContextRestored(g) {
            await this._webglRenderer.OnContextRestored();
            await this._LoadWebGLShaderPrograms();
            for (const k of this._runtime._GetAllEffectLists())
                for (const m of k.GetAllEffectTypes()) m._InitRenderer(this._webglRenderer);
            await this._runtime._OnWebGLContextRestored();
            console.log("[Construct 3] WebGL context restored")
        }
        GetWebGLRenderer() {
            return this._webglRenderer
        }
        GetWebGPURenderer() {
            return this._webgpuRenderer
        }
        GetRenderer() {
            return this._webgpuRenderer ||
                this._webglRenderer
        }
        GetRenderScale() {
            return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
        }
        GetDisplayScale() {
            const g = this.GetCurrentFullscreenMode();
            if ("off" === g || "crop" === g) return 1;
            const k = this._runtime.GetOriginalViewportWidth(),
                m = this._runtime.GetOriginalViewportHeight(),
                r = k / m,
                w = this._canvasDeviceWidth / this._canvasDeviceHeight;
            return "scale-inner" !== g && w > r || "scale-inner" === g && w < r ? this._canvasCssHeight / m : this._canvasCssWidth / k
        }
        SetDeviceTransformOffset(g,
            k) {
            this._deviceTransformOffX = g;
            this._deviceTransformOffY = k
        }
        SetDeviceTransform(g, k, m, r = !0) {
            k = k || this._drawWidth;
            m = m || this._drawHeight;
            const w = k / 2 + this._deviceTransformOffX,
                p = m / 2 + this._deviceTransformOffY;
            if (r) {
                r = this.GetDefaultProjectionMatrix();
                if (k !== this._drawWidth || m !== this._drawHeight) g.CalculatePerspectiveMatrix(c, k / m), r = c;
                g.SetProjectionMatrix(r)
            }
            k = g.CalculateLookAtModelView2(w, p, g.GetDefaultCameraZ() * this._runtime.GetDevicePixelRatio(), w, p, 0, m || this._drawHeight);
            g.SetModelViewMatrix(k)
        }
        SetCssTransform(g,
            k = !0) {
            const m = this._canvasCssWidth / 2,
                r = this._canvasCssHeight / 2;
            k && g.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
            k = g.CalculateLookAtModelView2(m, r, g.GetDefaultCameraZ(), m, r, 0);
            g.SetModelViewMatrix(k)
        }
        GetDeviceWidth() {
            return this._canvasDeviceWidth
        }
        GetDeviceHeight() {
            return this._canvasDeviceHeight
        }
        GetCssWidth() {
            return this._canvasCssWidth
        }
        GetCssHeight() {
            return this._canvasCssHeight
        }
        GetCanvasClientX() {
            return this._canvasCssOffsetX
        }
        GetCanvasClientY() {
            return this._canvasCssOffsetY
        }
        GetAdditionalRenderTarget(g) {
            g.depth =
                this._runtime.Uses3DFeatures();
            const k = this._availableAdditionalRenderTargets,
                m = k.findIndex(w => w.IsCompatibleWithOptions(g));
            let r; - 1 !== m ? (r = k[m], k.splice(m, 1)) : r = this.GetRenderer().CreateRenderTarget(g);
            this._usedAdditionalRenderTargets.add(r);
            return r
        }
        ReleaseAdditionalRenderTarget(g) {
            if (!this._usedAdditionalRenderTargets.has(g)) throw Error("render target not in use");
            this._usedAdditionalRenderTargets.delete(g);
            this._availableAdditionalRenderTargets.push(g)
        }* activeLayersGpuProfiles() {
            for (const g of this._runtime.GetLayoutManager().runningLayouts())
                for (const k of g.GetLayers()) {
                    const m =
                        this._layersGpuProfile.get(k);
                    m && (yield m)
                }
        }
        GetLayerTimingsBuffer(g) {
            if (!this.GetRenderer().SupportsGPUProfiling()) return null;
            let k = this._layersGpuProfile.get(g);
            k || (k = {
                name: g.GetName(),
                timingsBuffer: e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
                curUtilisation: 0,
                lastUtilisation: 0
            }, this._layersGpuProfile.set(g, k));
            return k.timingsBuffer
        }
        _Update1sFrameRange() {
            const g = this.GetRenderer();
            if (g.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
                this._gpuTimeEndFrame = g.GetFrameNumber();
                this._gpuCurUtilisation =
                    NaN;
                for (const k of this.activeLayersGpuProfiles()) k.curUtilisation = NaN
            }
        }
        _UpdateTick() {
            this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL();
            this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU()
        }
        _UpdateTick_WebGL() {
            if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
                if (this._runtime.IsDebug())
                    for (const g of this.activeLayersGpuProfiles())
                        if (g.curUtilisation =
                            g.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(g.curUtilisation)) return;
                this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);
                this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
                if (this._runtime.IsDebug()) {
                    for (const g of this.activeLayersGpuProfiles()) g.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), g.lastUtilisation = Math.min(g.curUtilisation, 1);
                    self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
                }
                this._gpuTimeStartFrame = this._gpuTimeEndFrame;
                this._gpuTimeEndFrame = 0
            }
        }
        GetGPUFrameTimingsBuffer() {
            return this._gpuFrameTimingsBuffer
        }
        _UpdateTick_WebGPU() {
            if (0 !== this._gpuTimeEndFrame) {
                for (var g = this._gpuTimeStartFrame; g < this._gpuTimeEndFrame; ++g) {
                    var k = this._webgpuFrameTimings.get(g);
                    if (k && !k.HasResult()) return
                }
                k = this._runtime.GetMainRunningLayout();
                g = e.MakeFilledArray(k.GetLayerCount() + 1, 0);
                for (var m = this._gpuTimeStartFrame; m < this._gpuTimeEndFrame; ++m) {
                    var r =
                        this._webgpuFrameTimings.get(m);
                    if (r) {
                        r = r.GetResult();
                        for (let w = 0, p = Math.min(g.length, r.length / 2); w < p; ++w) {
                            const t = r[2 * w],
                                u = r[2 * w + 1];
                            g[w] = 0 === Number(t) || 0 === Number(u) ? NaN : g[w] + Number(u - t) / 1E9
                        }
                    }
                }
                this._gpuLastUtilisation = e.clamp(g[0], 0, 1);
                if (this._runtime.IsDebug()) {
                    m = [];
                    k = k.GetLayers();
                    for (let w = 0, p = Math.min(k.length, g.length - 1); w < p; ++w) m.push({
                        name: k[w].GetName(),
                        lastUtilisation: e.clamp(g[w + 1], 0, 1)
                    });
                    self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, m)
                }
                for (g = this._gpuTimeStartFrame; g < this._gpuTimeEndFrame; ++g) this._webgpuFrameTimings.delete(g);
                this._gpuTimeStartFrame = this._gpuTimeEndFrame;
                this._gpuTimeEndFrame = 0
            }
        }
        _AddWebGPUFrameTiming(g) {
            this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), g)
        }
        GetGPUUtilisation() {
            return this._gpuLastUtilisation
        }
        SnapshotCanvas(g, k, m, r, w, p) {
            this._snapshotFormat = g;
            this._snapshotQuality = k;
            this._snapshotArea.setWH(m, r, w, p);
            return this._snapshotPromise ? this._snapshotPromise : this._snapshotPromise = new Promise(t => {
                this._snapshotResolve = t
            })
        }
        _MaybeTakeSnapshot() {
            if (this._snapshotFormat) {
                var g = this._canvas,
                    k = this._snapshotArea,
                    m = e.clamp(Math.floor(k.getLeft()), 0, g.width),
                    r = e.clamp(Math.floor(k.getTop()), 0, g.height),
                    w = k.width();
                w = 0 === w ? g.width - m : e.clamp(Math.floor(w), 0, g.width - m);
                k = k.height();
                k = 0 === k ? g.height - r : e.clamp(Math.floor(k), 0, g.height - r);
                (0 !== m || 0 !== r || w !== g.width || k !== g.height) && 0 < w && 0 < k && (g = e.CreateCanvas(w, k), g.getContext("2d").drawImage(this._canvas, m, r, w, k, 0, 0, w, k));
                e.CanvasToBlob(g, this._snapshotFormat, this._snapshotQuality).then(p => {
                    this._snapshotUrl = URL.createObjectURL(p);
                    this._snapshotPromise =
                        null;
                    this._snapshotResolve(this._snapshotUrl)
                });
                this._snapshotFormat = "";
                this._snapshotQuality = 1
            }
        }
        GetCanvasSnapshotUrl() {
            return this._snapshotUrl
        }
        SetIsPastingToDrawingCanvas(g) {
            g ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--
        }
        IsPastingToDrawingCanvas() {
            return 0 < this._isPastingToDrawingCanvas
        }
        InitLoadingScreen(g) {
            this._webglRenderer && (2 === g ? (this._percentText = e.New(e.Gfx.RendererText, this.GetRenderer()), this._percentText.SetIsAsync(!1), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16),
                this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(300, 200)) : 0 === g ? (g = this._runtime.GetLoadingLogoAsset()) && g.LoadStaticTexture(this._webglRenderer).catch(k => console.warn("[C3 runtime] Failed to create texture for loading logo: ", k)) : 4 === g && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(k => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(k) : this._splashTextures.logo = k
            }).catch(k => console.warn("Failed to load splash image: ",
                k)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(k => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(k) : this._splashTextures.powered = k
            }).catch(k => console.warn("Failed to load splash image: ", k)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(k => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(k) : this._splashTextures.website = k
            }).catch(k => console.warn("Failed to load splash image: ", k))))
        }
        async _LoadSvgSplashImage(g) {
            g =
                (new URL(g, this._runtime.GetBaseURL())).toString();
            g = await e.FetchBlob(g);
            g = await this._runtime.RasterSvgImage(g, 2048, 2048);
            return await this._webglRenderer.CreateStaticTextureAsync(g, {
                mipMapQuality: "high"
            })
        }
        async _LoadBitmapSplashImage(g) {
            g = (new URL(g, this._runtime.GetBaseURL())).toString();
            g = await e.FetchBlob(g);
            return await this._webglRenderer.CreateStaticTextureAsync(g, {
                mipMapQuality: "high"
            })
        }
        HideCordovaSplashScreen() {
            this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
        }
        StartLoadingScreen() {
            this._loaderStartTime =
                Date.now();
            this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler);
            this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
            3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
        }
        async EndLoadingScreen() {
            if (this._webglRenderer) {
                this._loadingProgress = 1;
                var g = this._runtime.GetLoaderStyle();
                4 === g && await this._splashDonePromise;
                this._splashDonePromise = this._splashDoneResolve = null; - 1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1);
                this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);
                this._loadingprogress_handler = null;
                this._percentText && (this._percentText.Release(), this._percentText = null);
                this._runtime.ReleaseLoadingLogoAsset();
                this._webglRenderer.Start();
                this._splashTextures.logo && (this._webglRenderer.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null);
                this._splashTextures.powered && (this._webglRenderer.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered =
                    null);
                this._splashTextures.website && (this._webglRenderer.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null);
                this._webglRenderer.ClearRgba(0, 0, 0, 0);
                this._webglRenderer.Finish();
                this._splashState = "done";
                this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber();
                3 === g && this.HideCordovaSplashScreen()
            }
        }
        _DrawLoadingScreen() {
            if (-1 !== this._rafId) {
                var g = this._webglRenderer;
                if (g) {
                    g.Start();
                    this._rafId = -1;
                    var k = this._runtime.GetAssetManager().HasHadErrorLoading(),
                        m = this._runtime.GetLoaderStyle();
                    3 !== m && (this.SetCssTransform(g), g.ClearRgba(0, 0, 0, 0), g.ResetColor(), g.SetTextureFillMode(), g.SetTexture(null));
                    if (0 === m) this._DrawProgressBarAndLogoLoadingScreen(k);
                    else if (1 === m) this._DrawProgressBarLoadingScreen(k, 120, 0);
                    else if (2 === m) this._DrawPercentTextLoadingScreen(k);
                    else if (3 === m) e.noop();
                    else if (4 === m) this._DrawSplashLoadingScreen(k);
                    else throw Error("invalid loader style");
                    g.Finish();
                    this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
                }
            }
        }
        _DrawPercentTextLoadingScreen(g) {
            g ? this._percentText.SetColorRgb(1,
                0, 0) : this._percentText.SetColorRgb(.6, .6, .6);
            this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
            g = this._canvasCssWidth / 2;
            const k = this._canvasCssHeight / 2;
            f.setRect(g - 150, k - 100, g + 150, k + 100);
            this._webglRenderer.SetTexture(this._percentText.GetTexture());
            this._webglRenderer.Quad3(f, this._percentText.GetTexRect())
        }
        _DrawProgressBarLoadingScreen(g, k, m) {
            const r = this._webglRenderer;
            r.SetColorFillMode();
            g ? r.SetColorRgba(1, 0, 0, 1) : r.SetColorRgba(.118, .565, 1, 1);
            g = this._canvasCssWidth / 2;
            const w =
                this._canvasCssHeight / 2,
                p = k / 2;
            h.setWH(g - p, w - 4 + m, Math.floor(k * this._loadingProgress), 8);
            r.Rect(h);
            h.setWH(g - p, w - 4 + m, k, 8);
            h.offset(-.5, -.5);
            h.inflate(.5, .5);
            r.SetColorRgba(0, 0, 0, 1);
            r.LineRect2(h);
            h.inflate(1, 1);
            r.SetColorRgba(1, 1, 1, 1);
            r.LineRect2(h)
        }
        _DrawProgressBarAndLogoLoadingScreen(g) {
            var k = this._runtime.GetLoadingLogoAsset();
            if (k)
                if (k = k.GetTexture()) {
                    var m = k.GetWidth(),
                        r = k.GetHeight(),
                        w = this._canvasCssWidth / 2,
                        p = this._canvasCssHeight / 2,
                        t = m / 2;
                    r /= 2;
                    f.setRect(w - t, p - r, w + t, p + r);
                    this._webglRenderer.SetTexture(k);
                    this._webglRenderer.Quad(f);
                    this._DrawProgressBarLoadingScreen(g, m, r + 16)
                } else this._DrawProgressBarLoadingScreen(g, 120, 0);
            else this._DrawProgressBarLoadingScreen(g, 120, 0)
        }
        _DrawSplashLoadingScreen(g) {
            const k = this._webglRenderer,
                m = this._splashTextures.logo,
                r = this._splashTextures.powered,
                w = this._splashTextures.website,
                p = Date.now();
            0 === this._splashFrameNumber && (this._loaderStartTime = p);
            const t = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(),
                u = t ? 0 : 200,
                q = t ? 0 :
                3E3;
            let x = 1;
            "fade-in" === this._splashState ? x = Math.min((p - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState && (x = Math.max(1 - (p - this._splashFadeOutStartTime) / 300, 0));
            k.SetColorFillMode();
            k.SetColorRgba(.231 * x, .251 * x, .271 * x, x);
            h.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
            k.Rect(h);
            const y = Math.ceil(this._canvasCssWidth),
                B = Math.ceil(this._canvasCssHeight);
            let F;
            256 < this._canvasCssHeight ? (k.SetColorRgba(.302 * x, .334 * x, .365 * x, x), F = Math.max(.005 * B, 2), h.setWH(0, .8 * B - F / 2, y, F), k.Rect(h), g ?
                k.SetColorRgba(x, 0, 0, x) : k.SetColorRgba(.161 * x, .953 * x, .816 * x, x), g = y * this._loadingProgress, h.setWH(.5 * y - g / 2, .8 * B - F / 2, g, F), k.Rect(h), k.SetColorRgba(x, x, x, x), k.SetTextureFillMode(), r && (g = 1.5 * e.clamp(.22 * B, 105, .6 * y), F = g / 8, h.setWH(.5 * y - g / 2, .2 * B - F / 2, g, F), k.SetTexture(r), k.Rect(h)), m && (F = g = Math.min(.395 * B, .95 * y), h.setWH(.5 * y - g / 2, .485 * B - F / 2, g, F), k.SetTexture(m), k.Rect(h)), w && (g = 1.5 * e.clamp(.22 * B, 105, .6 * y), F = g / 8, h.setWH(.5 * y - g / 2, .868 * B - F / 2, g, F), k.SetTexture(w), k.Rect(h))) : (k.SetColorRgba(.302 * x, .334 * x, .365 *
                x, x), F = Math.max(.005 * B, 2), h.setWH(0, .85 * B - F / 2, y, F), k.Rect(h), g ? k.SetColorRgba(x, 0, 0, x) : k.SetColorRgba(.161 * x, .953 * x, .816 * x, x), g = y * this._loadingProgress, h.setWH(.5 * y - g / 2, .85 * B - F / 2, g, F), k.Rect(h), k.SetColorRgba(x, x, x, x), k.SetTextureFillMode(), m && (F = g = .55 * B, h.setWH(.5 * y - g / 2, .45 * B - F / 2, g, F), k.SetTexture(m), k.Rect(h)));
            this._splashFrameNumber++;
            "fade-in" === this._splashState && 300 <= p - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = "wait", this._splashFadeInFinishTime = p);
            "wait" === this._splashState &&
                p - this._splashFadeInFinishTime >= q && 1 <= this._loadingProgress && (this._splashState = "fade-out", this._splashFadeOutStartTime = p);
            ("fade-out" === this._splashState && p - this._splashFadeOutStartTime >= 300 + u || t && 1 <= this._loadingProgress && 500 > p - this._loaderStartTime) && this._splashDoneResolve()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3Debugger,
        a = {
            messagePort: null,
            baseUrl: "",
            headless: !1,
            hasDom: !0,
            isInWorker: !1,
            useAudio: !0,
            projectData: "",
            exportType: ""
        };
    let b = !0;
    e.Runtime = class extends e.DefendedBase {
        constructor(c) {
            c = Object.assign({}, a, c);
            super();
            this._messagePort = c.messagePort;
            this._baseUrl = c.baseUrl;
            this._isHeadless = !!c.headless;
            this._hasDom = !!c.hasDom;
            this._isInWorker = !!c.isInWorker;
            b = c.ife;
            this._useAudio = !!c.useAudio;
            this._exportType = c.exportType;
            this._isiOSCordova = !!c.isiOSCordova;
            this._isiOSWebView = !!c.isiOSWebView;
            this._isFBInstantAvailable = !!c.isFBInstantAvailable;
            this._opusWasmScriptUrl = c.opusWasmScriptUrl;
            this._opusWasmBinaryUrl = c.opusWasmBinaryUrl;
            this._isDebugging = this._breakpointsEnabled = this._isDebug = !("preview" !== this._exportType || !c.isDebug);
            this._debuggingDisabled = 0;
            this._additionalLoadPromises = [];
            this._additionalCreatePromises = [];
            this._isUsingCreatePromises = !1;
            this._appId = this._projectUniqueId = this._projectVersion = this._projectName = "";
            this._originalViewportHeight = this._originalViewportWidth =
                0;
            this._devicePixelRatio = self.devicePixelRatio;
            this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0;
            this._usesLoaderLayout = !1;
            this._isLoading = !0;
            this._usesAnyBackgroundBlending = !1;
            this._loadingLogoAsset = null;
            this._assetManager = e.New(e.AssetManager, this, c);
            this._layoutManager = e.New(e.LayoutManager, this);
            this._eventSheetManager = e.New(e.EventSheetManager, this);
            this._pluginManager = e.New(e.PluginManager, this);
            this._collisionEngine = e.New(e.CollisionEngine,
                this);
            this._timelineManager = e.New(e.TimelineManager, this);
            this._transitionManager = e.New(e.TransitionManager, this);
            this._allObjectClasses = [];
            this._objectClassesByName = new Map;
            this._objectClassesBySid = new Map;
            this._familyCount = 0;
            this._allContainers = [];
            this._allEffectLists = [];
            this._currentLayoutStack = [];
            this._instancesPendingCreate = [];
            this._instancesPendingDestroy = new Map;
            this._isFlushingPendingInstances = this._hasPendingInstances = !1;
            this._nextUid = this._objectCount = 0;
            this._instancesByUid = new Map;
            this._instancesToReleaseAtEndOfTick =
                new Set;
            this._instancesToReleaseAffectedObjectClasses = new Set;
            this._objectReferenceTable = [];
            this._jsPropNameTable = [];
            this._canvasManager = null;
            this._uses3dFeatures = !1;
            this._framerateMode = "vsync";
            this._compositingMode = "standard";
            this._sampling = "trilinear";
            this._isPixelRoundingEnabled = !1;
            this._needRender = !0;
            this._isPausedOnBlur = this._pauseOnBlur = !1;
            this._tickCallbacks = {
                normal: f => {
                    this._ruafId = this._rafId = -1;
                    this.Tick(f)
                },
                tickOnly: f => {
                    this._ruafId = -1;
                    this.Tick(f, !1, "skip-render")
                },
                renderOnly: () => {
                    this._rafId = -1;
                    this.Render()
                }
            };
            this._ruafId = this._rafId = -1;
            this._execCount = this._tickCountNoSave = this._tickCount = 0;
            this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
            this._isLayoutFirstTick = !0;
            this._suspendCount = 0;
            this._scheduleTriggersThrottle = new e.PromiseThrottle(1);
            this._randomNumberCallback = () => Math.random();
            this._dt = this._dt1 = this._lastTickTime = this._startTime = 0;
            this._timeScale = 1;
            this._minimumFramerate = 30;
            this._gameTime = e.New(e.KahanSum);
            this._gameTimeRaw = e.New(e.KahanSum);
            this._wallTime = e.New(e.KahanSum);
            this._fpsFrameCount = -1;
            this._mainThreadTime = this._mainThreadTimeCounter = this._fps = this._fpsLastTime = 0;
            this._isLoadingState = !1;
            this._loadFromSlotName = this._saveToSlotName = "";
            this._loadFromJson = null;
            this._lastSaveJson = "";
            this._savegamesStorage = this._projectStorage = null;
            this._dispatcher = e.New(e.Event.Dispatcher);
            this._domEventHandlers = new Map;
            this._pendingResponsePromises = new Map;
            this._nextDomResponseId = 0;
            this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent = this._didRequestDeviceOrientationEvent = !1;
            this._waitingToHandleEvents = [];
            this._eventObjects = {
                pretick: e.New(e.Event, "pretick", !1),
                tick: e.New(e.Event, "tick", !1),
                tick2: e.New(e.Event, "tick2", !1),
                instancedestroy: e.New(e.Event, "instancedestroy", !1),
                beforelayoutchange: e.New(e.Event, "beforelayoutchange", !1),
                layoutchange: e.New(e.Event, "layoutchange", !1)
            };
            this._eventObjects.instancedestroy.instance = null;
            this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            this._userScriptEventObjects = null;
            this._behInstsToTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence);
            this._behInstsToPostTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence);
            this._behInstsToTick2 = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence);
            this._jobScheduler = e.New(e.JobSchedulerRuntime, this, c.jobScheduler);
            c.canvas && (this._canvasManager = e.New(e.CanvasManager, this));
            this._messagePort.onmessage = f => this._OnMessageFromDOM(f.data);
            this.AddDOMComponentMessageHandler("runtime", "visibilitychange", f => this._OnVisibilityChange(f));
            this.AddDOMComponentMessageHandler("runtime", "opus-decode",
                f => this._WasmDecodeWebMOpus(f.arrayBuffer));
            this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo());
            this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", f => this._InvokeFunctionFromJS(f));
            this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript);
            this._dispatcher.addEventListener("window-blur", f => this._OnWindowBlur(f));
            this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus());
            this._timelineManager.AddRuntimeListeners();
            this._iRuntime = null;
            this._interfaceMap = new WeakMap;
            this._commonScriptInterfaces = {
                keyboard: null,
                mouse: null,
                touch: null
            }
        }
        static Create(c) {
            return e.New(e.Runtime, c)
        }
        Release() {
            e.clearArray(this._allObjectClasses);
            this._objectClassesByName.clear();
            this._objectClassesBySid.clear();
            this._layoutManager.Release();
            this._layoutManager = null;
            this._eventSheetManager.Release();
            this._eventSheetManager = null;
            this._pluginManager.Release();
            this._pluginManager = null;
            this._assetManager.Release();
            this._assetManager = null;
            this._collisionEngine.Release();
            this._collisionEngine = null;
            this._timelineManager.Release();
            this._timelineManager = null;
            this._transitionManager.Release();
            this._transitionManager = null;
            this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null);
            this._dispatcher.Release();
            this._tickEvent = this._dispatcher = null
        }["_OnMessageFromDOM"](c) {
            const f = c.type;
            if ("event" === f) this._OnEventFromDOM(c);
            else if ("result" === f) this._OnResultFromDOM(c);
            else throw Error(`unknown message '${f}'`);
        }
        _OnEventFromDOM(c) {
            if (this._isReadyToHandleEvents) {
                var f = c.component,
                    h = c.handler,
                    g = c.data,
                    k = c.dispatchOpts,
                    m = !(!k || !k.dispatchRuntimeEvent);
                k = !(!k || !k.dispatchUserScriptEvent);
                var r = c.responseId;
                if ("runtime" === f && (m && (c = new e.Event(h), c.data = g, this._dispatcher.dispatchEventAndWaitAsyncSequential(c)), k)) {
                    c = new e.Event(h, !0);
                    for (const [w, p] of Object.entries(g)) c[w] = p;
                    this.DispatchUserScriptEvent(c)
                }
                if (c = this._domEventHandlers.get(f))
                    if (c = c.get(h)) {
                        m = null;
                        try {
                            m = c(g)
                        } catch (w) {
                            console.error(`Exception in '${f}' handler '${h}':`,
                                w);
                            null !== r && this._PostResultToDOM(r, !1, "" + w);
                            return
                        }
                        null !== r && (m && m.then ? m.then(w => this._PostResultToDOM(r, !0, w)).catch(w => {
                            console.error(`Rejection from '${f}' handler '${h}':`, w);
                            this._PostResultToDOM(r, !1, "" + w)
                        }) : this._PostResultToDOM(r, !0, m))
                    } else m || k || console.warn(`[Runtime] No DOM handler '${h}' for component '${f}'`);
                else m || k || console.warn(`[Runtime] No DOM event handlers for component '${f}'`)
            } else this._waitingToHandleEvents.push(c)
        }
        _PostResultToDOM(c, f, h) {
            this._messagePort.postMessage({
                type: "result",
                responseId: c,
                isOk: f,
                result: h
            })
        }
        _OnResultFromDOM(c) {
            const f = c.responseId,
                h = c.isOk;
            c = c.result;
            const g = this._pendingResponsePromises.get(f);
            h ? g.resolve(c) : g.reject(c);
            this._pendingResponsePromises.delete(f)
        }
        AddDOMComponentMessageHandler(c, f, h) {
            let g = this._domEventHandlers.get(c);
            g || (g = new Map, this._domEventHandlers.set(c, g));
            if (g.has(f)) throw Error(`[Runtime] Component '${c}' already has handler '${f}'`);
            g.set(f, h)
        }
        PostComponentMessageToDOM(c, f, h) {
            this._messagePort.postMessage({
                type: "event",
                component: c,
                handler: f,
                data: h,
                responseId: null
            })
        }
        PostComponentMessageToDOMAsync(c, f, h) {
            const g = this._nextDomResponseId++,
                k = new Promise((m, r) => {
                    this._pendingResponsePromises.set(g, {
                        resolve: m,
                        reject: r
                    })
                });
            this._messagePort.postMessage({
                type: "event",
                component: c,
                handler: f,
                data: h,
                responseId: g
            });
            return k
        }
        PostToDebugger(c) {
            if (!this.IsDebug()) throw Error("not in debug mode");
            this.PostComponentMessageToDOM("runtime", "post-to-debugger", c)
        }
        async Init(c) {
            this.IsDebug() ? await d.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
            var [f] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
            this._LoadDataJson(f);
            await this._InitialiseCanvas(c);
            this.IsPreview() || console.info("Made with Construct 3, the game and app creator :: https://www.construct.net");
            this.GetWebGLRenderer() ? (f = this.GetWebGLRenderer(), console.info(`[C3 runtime] Hosted in ${this.IsInWorker()?"worker":"DOM"}, rendering with WebGL ${f.GetWebGLVersionNumber()} [${f.GetUnmaskedRenderer()}] (${f.IsDesynchronized()?
"desynchronized":"standard"} compositing)`)) : this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker()?"worker":"DOM"}, rendering with experimental WebGPU`);
            this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");
            this._isReadyToHandleEvents = !0;
            for (const h of this._waitingToHandleEvents) this._OnEventFromDOM(h);
            e.clearArray(this._waitingToHandleEvents);
            this._canvasManager && this._canvasManager.StartLoadingScreen();
            for (const h of c.runOnStartupFunctions) this._additionalLoadPromises.push(this._RunOnStartupFunction(h));
            await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);
            e.clearArray(this._additionalLoadPromises);
            if (this._assetManager.HasHadErrorLoading()) this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
            else return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new e.Event("beforeruntimestart")),
                await this.Start(), this._messagePort.postMessage({
                    type: "runtime-ready"
                }), this
        }
        async _RunOnStartupFunction(c) {
            try {
                await c(this._iRuntime)
            } catch (f) {
                console.error("[C3 runtime] Error in runOnStartup function: ", f)
            }
        }
        _LoadDataJson(c) {
            c = c.project;
            this._projectName = c[0];
            this._projectVersion = c[16];
            this._projectUniqueId = c[31];
            this._appId = c[38];
            const f = c[39] || "loading-logo.png";
            this._isPixelRoundingEnabled = !!c[9];
            this._originalViewportWidth = this._viewportWidth = c[10];
            this._originalViewportHeight = this._viewportHeight =
                c[11];
            this._parallaxXorigin = this._originalViewportWidth / 2;
            this._parallaxYorigin = this._originalViewportHeight / 2;
            this._compositingMode = c[36];
            this._framerateMode = c[37];
            "low-latency" === this._compositingMode && this.IsAndroidWebView() && 77 >= e.Platform.BrowserVersionNumber && (console.warn("[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing."), this._compositingMode = "standard");
            this._uses3dFeatures = !!c[40];
            this._sampling = c[14];
            this._usesLoaderLayout = !!c[18];
            this._loaderStyle = c[19];
            this._nextUid = c[21];
            this._pauseOnBlur = c[22];
            const h = this._assetManager;
            h._SetAudioFiles(c[7], c[25]);
            h._SetMediaSubfolder(c[8]);
            h._SetFontsSubfolder(c[32]);
            h._SetIconsSubfolder(c[28]);
            h._SetWebFonts(c[29]);
            if (0 === this._loaderStyle) {
                let w = "";
                this.IsPreview() ? h._HasLocalUrlBlob(f) && (w = h.GetLocalUrlAsBlobUrl(f)) : w = h.GetIconsSubfolder() + f;
                w && (this._loadingLogoAsset = h.LoadImage({
                    url: w
                }))
            }
            this._canvasManager &&
                (this._canvasManager.SetFullscreenMode(e.CanvasManager._FullscreenModeNumberToString(c[12])), this._canvasManager.SetFullscreenScalingQuality(c[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== c[24]), this._canvasManager._SetGPUPowerPreference(c[34]), this._canvasManager._SetTextureAnisotropy(c[41]), this._canvasManager._SetWebGPUEnabled(c[13]));
            this._pluginManager.CreateSystemPlugin();
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            for (var g of c[2]) this._pluginManager.CreatePlugin(g);
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            this._LoadJsPropNameTable();
            for (var k of c[3]) g = e.ObjectClass.Create(this, this._allObjectClasses.length, k), this._allObjectClasses.push(g), this._objectClassesByName.set(g.GetName().toLowerCase(), g), this._objectClassesBySid.set(g.GetSID(), g);
            for (const w of c[4]) this._allObjectClasses[w[0]]._LoadFamily(w);
            for (var m of c[27]) k = m.map(w => this._allObjectClasses[w]), this._allContainers.push(e.New(e.Container, this, k));
            for (const w of this._allObjectClasses) w._OnAfterCreate();
            for (const w of c[5]) this._layoutManager.Create(w);
            (m = c[1]) && (m = this._layoutManager.GetLayoutByName(m)) && this._layoutManager.SetFirstLayout(m);
            for (var r of c[33]) this._timelineManager.Create(r);
            for (const w of c[35]) this._transitionManager.Create(w);
            this._InitScriptInterfaces();
            for (const w of c[6]) this._eventSheetManager.Create(w);
            this._eventSheetManager._PostInit();
            this._InitGlobalVariableScriptInterface();
            e.clearArray(this._objectReferenceTable);
            this.FlushPendingInstances();
            r = "any";
            c = c[20];
            1 === c ?
                r = "portrait" : 2 === c && (r = "landscape");
            this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
                targetOrientation: r
            })
        }
        GetLoaderStyle() {
            return this._loaderStyle
        }
        IsFBInstantAvailable() {
            return this._isFBInstantAvailable
        }
        IsLoading() {
            return this._isLoading
        }
        AddLoadPromise(c) {
            this._additionalLoadPromises.push(c)
        }
        SetUsingCreatePromises(c) {
            this._isUsingCreatePromises = !!c
        }
        AddCreatePromise(c) {
            this._isUsingCreatePromises && this._additionalCreatePromises.push(c)
        }
        GetCreatePromises() {
            return this._additionalCreatePromises
        }
        _GetNextFamilyIndex() {
            return this._familyCount++
        }
        GetFamilyCount() {
            return this._familyCount
        }
        _AddEffectList(c) {
            this._allEffectLists.push(c)
        }
        _GetAllEffectLists() {
            return this._allEffectLists
        }
        async _InitialiseCanvas(c) {
            this._canvasManager &&
                (await this._canvasManager.CreateCanvas(c), this._canvasManager.InitLoadingScreen(this._loaderStyle))
        }
        async _MaybeLoadOpusDecoder() {
            if (!this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")) {
                var c = null;
                try {
                    c = this.IsiOSCordova() && this._assetManager.IsFileProtocol() ? await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : await this._assetManager.FetchArrayBuffer(this._opusWasmBinaryUrl)
                } catch (f) {
                    console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.",
                        f);
                    return
                }
                c ? this.AddJobWorkerBuffer(c, "opus-decoder-wasm") : this.AddJobWorkerBlob(null, "opus-decoder-wasm");
                await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
            }
        }
        async _WasmDecodeWebMOpus(c) {
            return await this.AddJob("OpusDecode", {
                arrayBuffer: c
            }, [c])
        }
        async Start() {
            this._hasStarted = !0;
            this._startTime = Date.now();
            if (this._usesLoaderLayout) {
                for (var c of this._allObjectClasses) c.IsFamily() || c.IsOnLoaderLayout() || !c.IsWorldType() || c.OnCreate();
                this._assetManager.WaitForAllToLoad().then(() => {
                    this._isLoading = !1;
                    this._OnLoadFinished()
                })
            } else this._isLoading = !1;
            this._assetManager.SetInitialLoadFinished();
            this.IsDebug() && d.RuntimeInit(b);
            for (const f of this._layoutManager.GetAllLayouts()) f._CreateGlobalNonWorlds();
            c = this._layoutManager.GetFirstLayout();
            await c._Load(null, this.GetRenderer());
            await c._StartRunning(!0);
            this._fpsLastTime = performance.now();
            this._usesLoaderLayout || this._OnLoadFinished();
            (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking")).isSuspended ? this._suspendCount++ :
                this.Tick()
        }
        _OnLoadFinished() {
            this.Trigger(e.Plugins.System.Cnds.OnLoadFinished, null, null);
            this.PostComponentMessageToDOM("runtime", "register-sw")
        }
        GetObjectReference(c) {
            c = Math.floor(c);
            const f = this._objectReferenceTable;
            if (0 > c || c >= f.length) throw Error("invalid object reference");
            return f[c]
        }
        _LoadJsPropNameTable() {
            for (const c of self.C3_JsPropNameTable) {
                const f = e.first(Object.keys(c));
                this._jsPropNameTable.push(f)
            }
        }
        GetJsPropName(c) {
            c = Math.floor(c);
            const f = this._jsPropNameTable;
            if (0 > c || c >= f.length) throw Error("invalid prop reference");
            return f[c]
        }
        HasDOM() {
            return this._hasDom
        }
        IsHeadless() {
            return this._isHeadless
        }
        IsInWorker() {
            return this._isInWorker
        }
        GetBaseURL() {
            return this._baseUrl
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetEventStack() {
            return this._eventSheetManager.GetEventStack()
        }
        GetCurrentEventStackFrame() {
            return this._eventSheetManager.GetCurrentEventStackFrame()
        }
        GetCurrentEvent() {
            return this._eventSheetManager.GetCurrentEvent()
        }
        GetCurrentCondition() {
            return this._eventSheetManager.GetCurrentCondition()
        }
        IsCurrentConditionFirst() {
            return 0 ===
                this.GetCurrentEventStackFrame().GetConditionIndex()
        }
        GetCurrentAction() {
            return this._eventSheetManager.GetCurrentAction()
        }
        GetPluginManager() {
            return this._pluginManager
        }
        GetSystemPlugin() {
            return this._pluginManager.GetSystemPlugin()
        }
        GetObjectClassByIndex(c) {
            c = Math.floor(c);
            if (0 > c || c >= this._allObjectClasses.length) throw new RangeError("invalid index");
            return this._allObjectClasses[c]
        }
        GetObjectClassByName(c) {
            return this._objectClassesByName.get(c.toLowerCase()) || null
        }
        GetObjectClassBySID(c) {
            return this._objectClassesBySid.get(c) ||
                null
        }
        GetSingleGlobalObjectClassByCtor(c) {
            return (c = this._pluginManager.GetPluginByConstructorFunction(c)) ? c.GetSingleGlobalObjectClass() : null
        }
        GetAllObjectClasses() {
            return this._allObjectClasses
        }* allInstances() {
            for (const c of this._allObjectClasses) c.IsFamily() || (yield* c.instances())
        }
        Dispatcher() {
            return this._dispatcher
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(c) {
            c.runtime = this.GetIRuntime();
            const f = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
            f &&
                d.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(c);
            f && d.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(c) {
            c.runtime = this.GetIRuntime();
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(c)
        }
        GetOriginalViewportWidth() {
            return this._originalViewportWidth
        }
        GetOriginalViewportHeight() {
            return this._originalViewportHeight
        }
        SetOriginalViewportSize(c, f) {
            if (this._originalViewportWidth !== c || this._originalViewportHeight !== f) this._originalViewportWidth = c, this._originalViewportHeight =
                f, c = this.GetLayoutManager(), c.SetAllLayerProjectionChanged(), c.SetAllLayerMVChanged()
        }
        GetViewportWidth() {
            return this._viewportWidth
        }
        GetViewportHeight() {
            return this._viewportHeight
        }
        SetViewportSize(c, f) {
            if (this._viewportWidth !== c || this._viewportHeight !== f) this._viewportWidth = c, this._viewportHeight = f, c = this.GetLayoutManager(), c.SetAllLayerProjectionChanged(), c.SetAllLayerMVChanged()
        }
        _SetDevicePixelRatio(c) {
            this._devicePixelRatio = c
        }
        GetDevicePixelRatio() {
            return this._devicePixelRatio
        }
        GetParallaxXOrigin() {
            return this._parallaxXorigin
        }
        GetParallaxYOrigin() {
            return this._parallaxYorigin
        }
        GetCanvasManager() {
            return this._canvasManager
        }
        GetDrawWidth() {
            return this._canvasManager ?
                this._canvasManager.GetDrawWidth() : this._viewportWidth
        }
        GetDrawHeight() {
            return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
        }
        GetRenderScale() {
            return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
        }
        GetDisplayScale() {
            return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
        }
        GetCanvasClientX() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
        }
        GetCanvasClientY() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
        }
        GetCanvasCssWidth() {
            return this._canvasManager ?
                this._canvasManager.GetCssWidth() : 0
        }
        GetCanvasCssHeight() {
            return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
        }
        GetFullscreenMode() {
            return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off"
        }
        GetAdditionalRenderTarget(c) {
            return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(c) : null
        }
        ReleaseAdditionalRenderTarget(c) {
            this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(c)
        }
        _SetUsesAnyBackgroundBlending(c) {
            this._usesAnyBackgroundBlending = !!c
        }
        UsesAnyBackgroundBlending() {
            return this._usesAnyBackgroundBlending
        }
        GetGPUUtilisation() {
            return this._canvasManager ?
                this._canvasManager.GetGPUUtilisation() : NaN
        }
        IsLinearSampling() {
            return "nearest" !== this.GetSampling()
        }
        GetFramerateMode() {
            return this._framerateMode
        }
        GetCompositingMode() {
            return this._compositingMode
        }
        GetSampling() {
            return this._sampling
        }
        UsesLoaderLayout() {
            return this._usesLoaderLayout
        }
        GetLoadingLogoAsset() {
            return this._loadingLogoAsset
        }
        ReleaseLoadingLogoAsset() {
            this._loadingLogoAsset && (this._loadingLogoAsset.Release(), this._loadingLogoAsset = null)
        }
        GetLayoutManager() {
            return this._layoutManager
        }
        GetMainRunningLayout() {
            return this._layoutManager.GetMainRunningLayout()
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetTransitionManager() {
            return this._transitionManager
        }
        GetAssetManager() {
            return this._assetManager
        }
        LoadImage(c) {
            return this._assetManager.LoadImage(c)
        }
        CreateInstance(c,
            f, h, g, k) {
            return this.CreateInstanceFromData(c, f, !1, h, g, !1, k, void 0, k)
        }
        CreateInstanceFromData(c, f, h, g, k, m, r, w, p) {
            var t = null;
            let u = null;
            if (c instanceof e.ObjectClass) {
                u = c;
                if (u.IsFamily()) {
                    c = u.GetFamilyMembers();
                    var q = Math.floor(this.Random() * c.length);
                    u = c[q]
                }
                t = u.GetDefaultInstanceData()
            } else t = c, u = this.GetObjectClassByIndex(t[1]);
            var x = u.GetPlugin().IsWorldType();
            if (this._isLoading && x && !u.IsOnLoaderLayout()) return null;
            const y = f;
            x || (f = null);
            var B = h && !m && t && !this._instancesByUid.has(t[2]) ? t[2] : this._nextUid++;
            q = t ? t[0] : null;
            c = e.New(e.Instance, {
                runtime: this,
                objectType: u,
                layer: f,
                worldData: q,
                instVarData: t ? t[3] : null,
                uid: B
            });
            this._instancesByUid.set(B, c);
            B = null;
            x && (B = c.GetWorldInfo(), "undefined" !== typeof g && "undefined" !== typeof k && (B.SetX(g), B.SetY(k)), u._SetAnyCollisionCellChanged(!0));
            f && (p || f._AddInstance(c, !0), 1 === f.GetParallaxX() && 1 === f.GetParallaxY() || u._SetAnyInstanceParallaxed(!0), f.GetLayout().MaybeLoadTexturesFor(u));
            this._objectCount++;
            let F = !0;
            if (w) {
                var H = w.GetObjectClass();
                H.IsInContainer() && u.IsInContainer() &&
                    (w = u.GetContainer(), H = H.GetContainer(), w === H && (F = !1))
            }
            if (u.IsInContainer() && !h && !m && F) {
                for (var K of u.GetContainer().objectTypes()) K !== u && (w = this.CreateInstanceFromData(K, y, !1, B ? B.GetX() : g, B ? B.GetY() : k, !0, !1, void 0, p), c._AddSibling(w));
                for (var C of c.siblings()) {
                    C._AddSibling(c);
                    for (const A of c.siblings()) C !== A && C._AddSibling(A)
                }
            }
            x && !h && r && this._CreateChildInstancesFromData(c, q, B, f, g, k, p);
            if (u.IsInContainer() && !h && !m && r)
                for (const A of c.siblings())
                    if (h = A.GetWorldInfo()) K = A.GetPlugin(), C = A.GetObjectClass().GetDefaultInstanceData()[0],
                        K.IsWorldType() ? this._CreateChildInstancesFromData(A, C, h, f, h.GetX(), h.GetY(), p) : this._CreateChildInstancesFromData(A, C, h, f, void 0, void 0, p);
            !m && r && ("undefined" === typeof g && (g = q[0]), "undefined" === typeof k && (k = q[1]), f = B.GetTopParent(), g = g - B.GetX() + f.GetX(), k = k - B.GetY() + f.GetY(), f.SetXY(g, k));
            u._SetIIDsStale();
            k = t ? e.cloneArray(t[5]) : null;
            t = t ? t[4].map(A => e.cloneArray(A)) : null;
            (x = x && q && q[13]) && c._SetHasTilemap();
            c._CreateSdkInstance(k, t);
            x && (q = q[13], c.GetSdkInstance().LoadTilemapData(q[2], q[0], q[1]));
            this._instancesPendingCreate.push(c);
            this._hasPendingInstances = !0;
            this.IsDebug() && d.InstanceCreated(c);
            return c
        }
        _CreateChildInstancesFromData(c, f, h, g, k, m, r) {
            var w = h.GetSceneGraphZIndexExportData(),
                p = h.GetSceneGraphChildrenExportData();
            c.GetWorldInfo().SetSceneGraphZIndex(w);
            if (p) {
                "undefined" === typeof k && (k = f[0]);
                "undefined" === typeof m && (m = f[1]);
                w = new Set;
                h = f[0];
                f = f[1];
                for (const y of p) {
                    var t = y[1],
                        u = y[2];
                    p = y[3];
                    var q = !!y[4];
                    const B = y[5];
                    u = this._layoutManager.GetLayoutBySID(y[0]).GetLayer(t).GetInitialInstanceData(u);
                    t = this.GetObjectClassByIndex(u[1]);
                    var x = c.HasSibling(t);
                    const F = w.has(t);
                    x && !F && q ? (q = c.GetSibling(t), x = k + u[0][0] - h, u = m + u[0][1] - f, q.GetWorldInfo().SetXY(x, u), q.GetWorldInfo().SetSceneGraphZIndex(B), c.AddChild(q, {
                        transformX: !!(p >> 0 & 1),
                        transformY: !!(p >> 1 & 1),
                        transformWidth: !!(p >> 2 & 1),
                        transformHeight: !!(p >> 3 & 1),
                        transformAngle: !!(p >> 4 & 1),
                        destroyWithParent: !!(p >> 5 & 1),
                        transformZElevation: !!(p >> 6 & 1)
                    }), w.add(t)) : (t = this.CreateInstanceFromData(u, g, !1, k + u[0][0] - h, m + u[0][1] - f, !1, !0, c, r), t.GetWorldInfo().SetSceneGraphZIndex(B),
                        c.AddChild(t, {
                            transformX: !!(p >> 0 & 1),
                            transformY: !!(p >> 1 & 1),
                            transformWidth: !!(p >> 2 & 1),
                            transformHeight: !!(p >> 3 & 1),
                            transformAngle: !!(p >> 4 & 1),
                            destroyWithParent: !!(p >> 5 & 1),
                            transformZElevation: !!(p >> 6 & 1)
                        }))
                }
            }
        }
        DestroyInstance(c) {
            if (!this._instancesToReleaseAtEndOfTick.has(c)) {
                var f = c.GetObjectClass(),
                    h = this._instancesPendingDestroy.get(f);
                if (h) {
                    if (h.has(c)) return;
                    h.add(c)
                } else h = new Set, h.add(c), this._instancesPendingDestroy.set(f, h);
                this.IsDebug() && d.InstanceDestroyed(c);
                c._MarkDestroyed();
                this._hasPendingInstances = !0;
                if (c.IsInContainer())
                    for (const g of c.siblings()) this.DestroyInstance(g);
                for (const g of c.children()) g.GetDestroyWithParent() && this.DestroyInstance(g);
                this._layoutManager.IsEndingLayout() || this._isLoadingState || (f = this.GetEventSheetManager(), f.BlockFlushingInstances(!0), c._TriggerOnDestroyed(), f.BlockFlushingInstances(!1));
                c._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
            }
        }
        FlushPendingInstances() {
            this._hasPendingInstances && (this._isFlushingPendingInstances = !0, this._FlushInstancesPendingCreate(),
                this._FlushInstancesPendingDestroy(), this._hasPendingInstances = this._isFlushingPendingInstances = !1, this.UpdateRender())
        }
        _FlushInstancesPendingCreate() {
            for (const c of this._instancesPendingCreate) {
                const f = c.GetObjectClass();
                f._AddInstance(c);
                for (const h of f.GetFamilies()) h._AddInstance(c), h._SetIIDsStale()
            }
            e.clearArray(this._instancesPendingCreate)
        }
        _FlushInstancesPendingDestroy() {
            this._dispatcher.SetDelayRemoveEventsEnabled(!0);
            for (const [c, f] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(c,
                f), f.clear();
            this._instancesPendingDestroy.clear();
            this._dispatcher.SetDelayRemoveEventsEnabled(!1)
        }
        _FlushInstancesPendingDestroyForObjectClass(c, f) {
            for (const g of f) {
                var h = this._eventObjects.instancedestroy;
                h.instance = g;
                this._dispatcher.dispatchEvent(h);
                this._instancesByUid.delete(g.GetUID());
                if (h = g.GetWorldInfo()) h._RemoveFromCollisionCells(), h._RemoveFromRenderCells(), h._MarkDestroyed();
                this._instancesToReleaseAtEndOfTick.add(g);
                this._objectCount--
            }
            e.arrayRemoveAllInSet(c.GetInstances(), f);
            c._SetIIDsStale();
            this._instancesToReleaseAffectedObjectClasses.add(c);
            0 === c.GetInstances().length && c._SetAnyInstanceParallaxed(!1);
            for (const g of c.GetFamilies()) e.arrayRemoveAllInSet(g.GetInstances(), f), g._SetIIDsStale(), this._instancesToReleaseAffectedObjectClasses.add(g);
            if (c.GetPlugin().IsWorldType()) {
                c = new Set([...f].map(g => g.GetWorldInfo().GetLayer()));
                for (const g of c) g._RemoveAllInstancesInSet(f)
            }
        }
        _GetInstancesPendingCreate() {
            return this._instancesPendingCreate
        }* instancesPendingCreateForObjectClass(c) {
            for (const f of this._GetInstancesPendingCreate()) c.IsFamily() ?
                f.GetObjectClass().BelongsToFamily(c) && (yield f) : f.GetObjectClass() === c && (yield f)
        }
        _GetNewUID() {
            return this._nextUid++
        }
        _MapInstanceByUID(c, f) {
            this._instancesByUid.set(c, f)
        }
        _OnWebGLContextLost() {
            this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextlost"));
            this.SetSuspended(!0);
            for (var c of this._allObjectClasses) !c.IsFamily() && c.HasLoadedTextures() && c.ReleaseTextures();
            (c = this.GetMainRunningLayout()) && c._OnWebGLContextLost();
            e.ImageInfo.OnWebGLContextLost();
            e.ImageAsset.OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this.GetMainRunningLayout()._Load(null,
                this.GetWebGLRenderer());
            this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextrestored"));
            this.SetSuspended(!1);
            this.UpdateRender()
        }
        _OnVisibilityChange(c) {
            this.SetSuspended(c.hidden)
        }
        _OnWindowBlur(c) {
            this.IsPreview() && this._pauseOnBlur && !e.Platform.IsMobile && !c.data.parentHasFocus && (this.SetSuspended(!0), this._isPausedOnBlur = !0)
        }
        _OnWindowFocus() {
            this._isPausedOnBlur && (this.SetSuspended(!1), this._isPausedOnBlur = !1)
        }
        _RequestAnimationFrame() {
            const c = this._tickCallbacks;
            "vsync" === this._framerateMode ?
                -1 === this._rafId && (this._rafId = self.requestAnimationFrame(c.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = e.RequestUnlimitedAnimationFrame(c.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(c.renderOnly))) : -1 === this._ruafId && (this._ruafId = e.RequestUnlimitedAnimationFrame(c.normal))
        }
        _CancelAnimationFrame() {
            -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1); - 1 !== this._ruafId && (e.CancelUnlimitedAnimationFrame(this._ruafId),
                this._ruafId = -1)
        }
        IsSuspended() {
            return 0 < this._suspendCount
        }
        SetSuspended(c) {
            var f = this.IsSuspended();
            this._suspendCount += c ? 1 : -1;
            0 > this._suspendCount && (this._suspendCount = 0);
            c = this.IsSuspended();
            !f && c ? (console.log("[Construct 3] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(e.New(e.Event, "suspend")), this.Trigger(e.Plugins.System.Cnds.OnSuspend, null, null)) : f && !c && (console.log("[Construct 3] Resuming"), this._fpsLastTime = this._lastTickTime = f = performance.now(), this._mainThreadTimeCounter =
                this._mainThreadTime = this._fps = this._fpsFrameCount = 0, this._dispatcher.dispatchEvent(e.New(e.Event, "resume")), this.Trigger(e.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(f))
        }
        _AddBehInstToTick(c) {
            this._behInstsToTick.Add(c)
        }
        _AddBehInstToPostTick(c) {
            this._behInstsToPostTick.Add(c)
        }
        _AddBehInstToTick2(c) {
            this._behInstsToTick2.Add(c)
        }
        _RemoveBehInstToTick(c) {
            this._behInstsToTick.Remove(c)
        }
        _RemoveBehInstToPostTick(c) {
            this._behInstsToPostTick.Remove(c)
        }
        _RemoveBehInstToTick2(c) {
            this._behInstsToTick2.Remove(c)
        }
        _BehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick) c.Tick();
            this._behInstsToTick.SetQueueingEnabled(!1)
        }
        _BehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToPostTick) c.PostTick();
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }
        _BehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick2) c.Tick2();
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick) {
                const f =
                    c.Tick();
                e.IsIterator(f) && (yield* f)
            }
            this._behInstsToTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToPostTick) {
                const f = c.PostTick();
                e.IsIterator(f) && (yield* f)
            }
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick2) {
                const f = c.Tick2();
                e.IsIterator(f) && (yield* f)
            }
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }
        async Tick(c, f,
            h) {
            this._hasStartedTicking = !0;
            const g = "background-wake" === h;
            h = "background-wake" !== h && "skip-render" !== h;
            this._hasStarted && (!this.IsSuspended() || f || g) && (f = performance.now(), this._isInTick = !0, this._MeasureDt(c || 0), c = this.Step_BeforePreTick(), this.IsDebugging() && await c, c = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick), c instanceof Promise && await c, c = this.Step_AfterPreTick(), this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), this.GetLayoutManager().IsPendingChangeMainLayout() &&
                await this._MaybeChangeLayout(), c = this.Step_RunEventsEtc(), this.IsDebugging() && await c, h && this.Render(), this.IsSuspended() || g || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._execCount++, this._isInTick = !1, this._mainThreadTimeCounter += performance.now() - f)
        }
        async Step_BeforePreTick() {
            const c = this._eventSheetManager,
                f = this.IsDebug();
            this.FlushPendingInstances();
            c.BlockFlushingInstances(!0);
            this.PushCurrentLayout(this.GetMainRunningLayout());
            f && d.StartMeasuringTime();
            this.IsDebugging() ?
                await c.DebugRunScheduledWaits() : c.RunScheduledWaits();
            f && d.AddEventsTime();
            this.PopCurrentLayout();
            c.BlockFlushingInstances(!1);
            this.FlushPendingInstances();
            c.BlockFlushingInstances(!0)
        }
        async Step_AfterPreTick() {
            const c = this.IsDebug(),
                f = this.IsDebugging(),
                h = this._dispatcher,
                g = this._eventObjects,
                k = this._userScriptEventObjects;
            c && d.StartMeasuringTime();
            f ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick();
            f ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) :
                this._BehaviorPostTick();
            c && d.AddBehaviorTickTime();
            c && d.StartMeasuringTime();
            f ? await this.DebugFireGeneratorEventAndBreak(g.tick) : h.dispatchEvent(g.tick);
            c && d.AddPluginTickTime();
            this._eventSheetManager.BlockFlushingInstances(!1);
            this.DispatchUserScriptEvent(k.tick)
        }
        async Step_RunEventsEtc() {
            const c = this._eventSheetManager,
                f = this._dispatcher,
                h = this._eventObjects,
                g = this.IsDebug(),
                k = this.IsDebugging();
            g && d.StartMeasuringTime();
            k ? await c.DebugRunEvents(this._layoutManager) : c.RunEvents(this._layoutManager);
            g && d.AddEventsTime();
            this._collisionEngine.ClearRegisteredCollisions();
            this._ReleaseInstancesAtEndOfTick();
            this._isLayoutFirstTick = !1;
            c.BlockFlushingInstances(!0);
            g && d.StartMeasuringTime();
            k ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2();
            g && d.AddBehaviorTickTime();
            g && d.StartMeasuringTime();
            k ? await this.DebugFireGeneratorEventAndBreak(h.tick2) : f.dispatchEvent(h.tick2);
            g && d.AddPluginTickTime();
            c.BlockFlushingInstances(!1);
            k && await c.RunQueuedDebugTriggersAsync()
        }
        _ReleaseInstancesAtEndOfTick() {
            if (0 !==
                this._instancesToReleaseAtEndOfTick.size) {
                var c = this._dispatcher;
                c.SetDelayRemoveEventsEnabled(!0);
                for (const f of this._instancesToReleaseAffectedObjectClasses) f.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
                this._instancesToReleaseAffectedObjectClasses.clear();
                this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);
                for (const f of this._instancesToReleaseAtEndOfTick) f.Release();
                this._instancesToReleaseAtEndOfTick.clear();
                c.SetDelayRemoveEventsEnabled(!1)
            }
        }
        async _MaybeChangeLayout() {
            const c =
                this.GetLayoutManager();
            let f = 0;
            for (; c.IsPendingChangeMainLayout() && 10 > f++;) await this._DoChangeLayout(c.GetPendingChangeMainLayout())
        }
        _MeasureDt(c) {
            let f = 0;
            0 !== this._lastTickTime && (f = Math.max(c - this._lastTickTime, 0) / 1E3, .5 < f && (f = 0), this._dt1 = Math.min(f, 1 / this._minimumFramerate));
            this._lastTickTime = c;
            this._dt = this._dt1 * this._timeScale;
            this._gameTime.Add(this._dt);
            this._gameTimeRaw.Add(f * this._timeScale);
            this._wallTime.Add(this._dt1);
            this._canvasManager && this._canvasManager._UpdateTick();
            1E3 <= c - this._fpsLastTime &&
                (this._fpsLastTime += 1E3, 1E3 <= c - this._fpsLastTime && (this._fpsLastTime = c), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1E3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && d.Update1sPerfStats());
            this._fpsFrameCount++
        }
        async _DoChangeLayout(c) {
            const f = this._dispatcher,
                h = this.GetLayoutManager().GetMainRunningLayout();
            await h._StopRunning();
            h._Unload(c, this.GetRenderer());
            h === c && this._eventSheetManager.ClearAllScheduledWaits();
            this._collisionEngine.ClearRegisteredCollisions();
            this._ReleaseInstancesAtEndOfTick();
            f.dispatchEvent(this._eventObjects.beforelayoutchange);
            e.Asyncify.SetHighThroughputMode(!0);
            await c._Load(h, this.GetRenderer());
            e.Asyncify.SetHighThroughputMode(!1);
            await c._StartRunning(!1);
            f.dispatchEvent(this._eventObjects.layoutchange);
            this.UpdateRender();
            this._isLayoutFirstTick = !0;
            this.FlushPendingInstances()
        }
        UpdateRender() {
            this._needRender = !0
        }
        GetWebGLRenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
        }
        GetWebGPURenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null
        }
        GetRenderer() {
            return this._canvasManager ? this._canvasManager.GetRenderer() : null
        }
        Render() {
            const c = this._canvasManager;
            if (c && !c.IsRendererContextLost()) {
                var f = this.GetRenderer(),
                    h = f.SupportsGPUProfiling(),
                    g = h && f.IsWebGL();
                h = h && f.IsWebGPU();
                g && f.CheckForQueryResults();
                if (this._needRender) {
                    var k = this._layoutManager.GetMainRunningLayout();
                    f.Start();
                    var m = this.IsDebug();
                    m && d.StartMeasuringTime();
                    this._needRender = !1;
                    var r = null;
                    g && (r = c.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), f.StartQuery(r));
                    g = null;
                    h && (g = f.StartFrameTiming(2 * (1 + k.GetLayerCount())), f.WriteTimestamp(0));
                    this.Uses3DFeatures() && "low" === c.GetCurrentFullscreenScalingQuality() ? f.SetFixedSizeDepthBuffer(c.GetDrawWidth(), c.GetDrawHeight()) : f.SetAutoSizeDepthBuffer();
                    this._Render(this.GetRenderer(), k);
                    r && f.EndQuery(r);
                    h && (f.WriteTimestamp(1), this._canvasManager._AddWebGPUFrameTiming(g));
                    f.Finish();
                    m && (d.AddDrawCallsTime(), d.UpdateInspectHighlight());
                    c && c._MaybeTakeSnapshot()
                } else f.IncrementFrameNumber()
            }
        }
        _Render(c, f) {
            c.SetTextureFillMode();
            c.SetAlphaBlend();
            c.SetColorRgba(1, 1, 1, 1);
            c.SetRenderTarget(null);
            c.SetTexture(null);
            c.SetDepthEnabled(this.Uses3DFeatures());
            f.Draw(c)
        }
        Trigger(c, f, h) {
            if (!this._hasStarted) return !1;
            var g = !this._isInTick && !this._eventSheetManager.IsInTrigger();
            let k = 0;
            g && (k = performance.now());
            const m = this.IsDebug();
            m && this.SetDebuggingEnabled(!1);
            c = this._eventSheetManager._Trigger(this._layoutManager,
                c, f, h);
            g && (g = performance.now() - k, this._mainThreadTimeCounter += g, m && d.AddTriggersTime(g));
            m && this.SetDebuggingEnabled(!0);
            return c
        }
        DebugTrigger(c, f, h) {
            if (!this.IsDebug()) return this.Trigger(c, f, h);
            if (this.HitBreakpoint()) throw Error("called DebugTrigger() while stopped on breakpoint");
            if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
            return this._eventSheetManager._DebugTrigger(this._layoutManager, c, f,
                h)
        }
        async TriggerAsync(c, f, h) {
            if (!this.IsDebugging()) return this.Trigger(c, f, h);
            if (!this._hasStarted) return !1;
            if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(c, f, h);
            if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(c, f, h);
            const g = performance.now();
            c = this._eventSheetManager._DebugTrigger(this._layoutManager, c, f, h);
            for (f = c.next(); !f.done;) await this.DebugBreak(f.value), f = c.next();
            this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
                this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame());
            this._mainThreadTimeCounter += performance.now() - g;
            return f.value
        }
        FastTrigger(c, f, h) {
            const g = this.IsDebug();
            g && this.SetDebuggingEnabled(!1);
            c = this._eventSheetManager._FastTrigger(this._layoutManager, c, f, h);
            g && this.SetDebuggingEnabled(!0);
            return c
        }
        DebugFastTrigger(c, f, h) {
            return this._eventSheetManager._DebugFastTrigger(this._layoutManager, c, f, h)
        }
        ScheduleTriggers(c) {
            return this._scheduleTriggersThrottle.Add(c)
        }
        PushCurrentLayout(c) {
            this._currentLayoutStack.push(c)
        }
        PopCurrentLayout() {
            if (!this._currentLayoutStack.length) throw Error("layout stack empty");
            this._currentLayoutStack.pop()
        }
        GetCurrentLayout() {
            return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout()
        }
        GetDt(c) {
            return c && -1 !== c.GetTimeScale() ? this._dt1 * c.GetTimeScale() : this._dt
        }
        _GetDtFast() {
            return this._dt
        }
        GetDt1() {
            return this._dt1
        }
        GetTimeScale() {
            return this._timeScale
        }
        SetTimeScale(c) {
            if (isNaN(c) || 0 > c) c = 0;
            this._timeScale = c
        }
        SetMinimumFramerate(c) {
            this._minimumFramerate = e.clamp(c, 1, 120)
        }
        GetMinimumFramerate() {
            return this._minimumFramerate
        }
        GetFPS() {
            return this._fps
        }
        GetMainThreadTime() {
            return this._mainThreadTime
        }
        GetStartTime() {
            return this._startTime
        }
        GetGameTime() {
            return this._gameTime.Get()
        }
        GetGameTimeRaw() {
            return this._gameTimeRaw.Get()
        }
        GetWallTime() {
            return this._wallTime.Get()
        }
        GetTickCount() {
            return this._tickCount
        }
        GetTickCountNoSave() {
            return this._tickCountNoSave
        }
        IncrementExecCount() {
            ++this._execCount
        }
        GetExecCount() {
            return this._execCount
        }
        GetObjectCount() {
            return this._objectCount
        }
        GetProjectName() {
            return this._projectName
        }
        GetProjectVersion() {
            return this._projectVersion
        }
        GetProjectUniqueId() {
            return this._projectUniqueId
        }
        GetAppId() {
            return this._appId
        }
        GetInstanceByUID(c) {
            if (this._isLoadingState) throw Error("cannot call while loading state - wait until afterload event");
            return this._instancesByUid.get(c) || null
        }
        _RefreshUidMap() {
            this._instancesByUid.clear();
            for (const c of this._allObjectClasses)
                if (!c.IsFamily())
                    for (const f of c.GetInstances()) this._instancesByUid.set(f.GetUID(), f)
        }
        IsPreview() {
            return "preview" === this._exportType
        }
        IsDebug() {
            return this._isDebug
        }
        GetExportType() {
            return this._exportType
        }
        IsCordova() {
            return "cordova" === this._exportType
        }
        IsAndroidWebView() {
            return "Android" === e.Platform.OS && ("cordova" === this._exportType || "playable-ad" === this._exportType || "instant-games" ===
                this._exportType)
        }
        IsiOSCordova() {
            return this._isiOSCordova
        }
        IsiOSWebView() {
            return this._isiOSWebView
        }
        GetCollisionEngine() {
            return this._collisionEngine
        }
        GetSolidBehavior() {
            return this._pluginManager.GetSolidBehavior()
        }
        GetJumpthruBehavior() {
            return this._pluginManager.GetJumpthruBehavior()
        }
        Uses3DFeatures() {
            return this._uses3dFeatures
        }
        GetZScaleFactor() {
            const c = this.GetRenderer();
            return this.GetViewportHeight() / 2 / Math.tan(c.GetFovY() / 2) / c.GetDefaultCameraZ()
        }
        IsLayoutFirstTick() {
            return this._isLayoutFirstTick
        }
        SetPixelRoundingEnabled(c) {
            c = !!c;
            this._isPixelRoundingEnabled !== c && (this._isPixelRoundingEnabled = c, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender())
        }
        IsPixelRoundingEnabled() {
            return this._isPixelRoundingEnabled
        }
        SaveToSlot(c) {
            this._saveToSlotName = c
        }
        LoadFromSlot(c) {
            this._loadFromSlotName = c
        }
        LoadFromJsonString(c) {
            this._loadFromJson = c
        }
        GetLastSaveJsonString() {
            return this._lastSaveJson
        }
        _NeedsHandleSaveOrLoad() {
            return !(!this._saveToSlotName && !this._loadFromSlotName && null === this._loadFromJson)
        }
        async _HandleSaveOrLoad() {
            this._saveToSlotName &&
                (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad());
            this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && d.StepIfPausedInDebugger());
            if (null !== this._loadFromJson) {
                this.FlushPendingInstances();
                try {
                    await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = ""
                } catch (c) {
                    console.error("[Construct 3] Failed to load state from JSON string: ",
                        c), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
                }
                this._ClearSaveOrLoad()
            }
        }
        _ClearSaveOrLoad() {
            this._loadFromSlotName = this._saveToSlotName = "";
            this._loadFromJson = null
        }
        _GetProjectStorage() {
            this._projectStorage || (this._projectStorage = localforage.createInstance({
                name: "c3-localstorage-" + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            }));
            return this._projectStorage
        }
        _GetSavegamesStorage() {
            this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
                name: "c3-savegames-" +
                    this.GetProjectUniqueId(),
                description: this.GetProjectName()
            }));
            return this._savegamesStorage
        }
        async _DoSaveToSlot(c) {
            const f = await this._SaveToJsonString();
            try {
                await this._GetSavegamesStorage().setItem(c, f), console.log("[Construct 3] Saved state to storage (" + f.length + " chars)"), this._lastSaveJson = f, await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = ""
            } catch (h) {
                console.error("[Construct 3] Failed to save state to storage: ", h), await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveFailed,
                    null)
            }
        }
        async _DoLoadFromSlot(c) {
            try {
                const f = await this._GetSavegamesStorage().getItem(c);
                if (!f) throw Error("empty slot");
                console.log("[Construct 3] Loaded state from storage (" + f.length + " chars)");
                await this._DoLoadFromJsonString(f);
                this._lastSaveJson = f;
                await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null);
                this._lastSaveJson = ""
            } catch (f) {
                console.error("[Construct 3] Failed to load state from storage: ", f), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
            }
        }
        async _SaveToJsonString() {
            const c = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this.GetGameTime(),
                    timeRaw: this.GetGameTimeRaw(),
                    walltime: this.GetWallTime(),
                    timescale: this.GetTimeScale(),
                    tickcount: this.GetTickCount(),
                    execcount: this.GetExecCount(),
                    next_uid: this._nextUid,
                    running_layout: this.GetMainRunningLayout().GetSID(),
                    start_time_offset: Date.now() - this._startTime
                },
                types: {},
                layouts: {},
                events: this._eventSheetManager._SaveToJson(),
                timelines: this._timelineManager._SaveToJson(),
                user_script_data: null
            };
            for (var f of this._allObjectClasses) f.IsFamily() ||
                f.HasNoSaveBehavior() || (c.types[f.GetSID().toString()] = f._SaveToJson());
            for (const h of this._layoutManager.GetAllLayouts()) c.layouts[h.GetSID().toString()] = h._SaveToJson();
            f = this._CreateUserScriptEvent("save");
            f.saveData = null;
            await this.DispatchUserScriptEventAsyncWait(f);
            c.user_script_data = f.saveData;
            return JSON.stringify(c)
        }
        IsLoadingState() {
            return this._isLoadingState
        }
        async _DoLoadFromJsonString(c) {
            var f = this.GetLayoutManager();
            c = JSON.parse(c);
            if (c.c2save) throw Error("C2 saves are incompatible with C3 runtime");
            if (!c.c3save) throw Error("not valid C3 save data");
            if (1 < c.version) throw Error("C3 save data from future version");
            this._dispatcher.dispatchEvent(e.New(e.Event, "beforeload"));
            for (var h of this.allInstances()) h._OnBeforeLoad();
            this._isLoadingState = !0;
            h = c.rt;
            this._gameTime.Set(h.time);
            h.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(h.timeRaw);
            this._wallTime.Set(h.walltime);
            this._timeScale = h.timescale;
            this._tickCount = h.tickcount;
            this._execCount = h.execcount;
            this._startTime = Date.now() - h.start_time_offset;
            var g = h.running_layout;
            if (g !== this.GetMainRunningLayout().GetSID())
                if (g = f.GetLayoutBySID(g)) await this._DoChangeLayout(g);
                else return;
            for (const [k, m] of Object.entries(c.types)) g = parseInt(k, 10), g = this.GetObjectClassBySID(g), !g || g.IsFamily() || g.HasNoSaveBehavior() || g._LoadFromJson(m);
            this.FlushPendingInstances();
            this._RefreshUidMap();
            this._isLoadingState = !1;
            this._nextUid = h.next_uid;
            for (const [k, m] of Object.entries(c.layouts)) h = parseInt(k, 10), (h = f.GetLayoutBySID(h)) && h._LoadFromJson(m);
            this._eventSheetManager._LoadFromJson(c.events);
            for (const k of this._allObjectClasses)
                if (!k.IsFamily() && k.IsInContainer())
                    for (const m of k.GetInstances()) {
                        h = m.GetIID();
                        for (const r of k.GetContainer().objectTypes())
                            if (r !== k) {
                                g = r.GetInstances();
                                if (0 > h || h >= g.length) throw Error("missing sibling instance");
                                m._AddSibling(g[h])
                            }
                    }
            this._timelineManager._LoadFromJson(c.timelines);
            f.SetAllLayerProjectionChanged();
            f.SetAllLayerMVChanged();
            this._dispatcher.dispatchEvent(e.New(e.Event, "afterload"));
            f = this._CreateUserScriptEvent("load");
            f.saveData = c.user_script_data;
            await this.DispatchUserScriptEventAsyncWait(f);
            this.UpdateRender()
        }
        async AddJobWorkerScripts(c) {
            c = (await Promise.all(c.map(f => this._assetManager.FetchBlob(f)))).map(f => URL.createObjectURL(f));
            this._jobScheduler.ImportScriptsToJobWorkers(c)
        }
        AddJobWorkerBlob(c, f) {
            this._jobScheduler.SendBlobToJobWorkers(c, f)
        }
        AddJobWorkerBuffer(c, f) {
            this._jobScheduler.SendBufferToJobWorkers(c, f)
        }
        AddJob(c, f, h) {
            return this._jobScheduler.AddJob(c, f, h)
        }
        BroadcastJob(c, f, h) {
            return this._jobScheduler.BroadcastJob(c, f, h)
        }
        InvokeDownload(c,
            f) {
            this.PostComponentMessageToDOM("runtime", "invoke-download", {
                url: c,
                filename: f
            })
        }
        async RasterSvgImage(c, f, h, g, k, m) {
            g = g || f;
            k = k || h;
            if (this.IsInWorker()) return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                blob: c,
                imageWidth: f,
                imageHeight: h,
                surfaceWidth: g,
                surfaceHeight: k,
                imageBitmapOpts: m
            })).imageBitmap;
            c = await self.C3_RasterSvgImageBlob(c, f, h, g, k);
            return m ? await self.createImageBitmap(c, m) : c
        }
        async GetSvgImageSize(c) {
            return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime",
                "get-svg-image-size", {
                    blob: c
                }) : await self.C3_GetSvgImageSize(c)
        }
        RequestDeviceOrientationEvent() {
            this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"))
        }
        RequestDeviceMotionEvent() {
            this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-motion"))
        }
        Random() {
            return this._randomNumberCallback()
        }
        SetRandomNumberGeneratorCallback(c) {
            this._randomNumberCallback =
                c
        }
        _GetRemotePreviewStatusInfo() {
            const c = this.GetWebGLRenderer();
            return {
                fps: this.GetFPS(),
                cpu: this.GetMainThreadTime(),
                gpu: this.GetGPUUtilisation(),
                layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
                renderer: c ? c.GetUnmaskedRenderer() : "<unavailable>"
            }
        }
        HitBreakpoint() {
            return this.IsDebug() ? d.HitBreakpoint() : !1
        }
        DebugBreak(c) {
            return this.IsDebugging() ? d.DebugBreak(c) : Promise.resolve()
        }
        DebugBreakNext() {
            return this.IsDebugging() ? d.BreakNext() : !1
        }
        SetDebugBreakpointsEnabled(c) {
            this._breakpointsEnabled = !!c;
            this._UpdateDebuggingFlag()
        }
        AreDebugBreakpointsEnabled() {
            return this._breakpointsEnabled
        }
        IsDebugging() {
            return this._isDebugging
        }
        SetDebuggingEnabled(c) {
            c ? this._debuggingDisabled-- : this._debuggingDisabled++;
            this._UpdateDebuggingFlag()
        }
        _UpdateDebuggingFlag() {
            this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
        }
        IsCPUProfiling() {
            return this.IsDebug() && d.IsCPUProfiling()
        }
        IsGPUProfiling() {
            return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && d.IsGPUProfiling()
        }
        async DebugIterateAndBreak(c) {
            if (c)
                for (const f of c) await this.DebugBreak(f)
        }
        DebugFireGeneratorEventAndBreak(c) {
            return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(c))
        }
        _InvokeFunctionFromJS(c) {
            return this._eventSheetManager._InvokeFunctionFromJS(c.name,
                c.params)
        }
        GetIRuntime() {
            return this._iRuntime
        }
        _CreateUserScriptEvent(c) {
            c = e.New(e.Event, c, !1);
            c.runtime = this._iRuntime;
            return c
        }
        _InitScriptInterfaces() {
            var c = {};
            for (const f of this._allObjectClasses) c[f.GetJsPropName()] = {
                value: f.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
            c = Object.create(Object.prototype, c);
            this._iRuntime = new self.IRuntime(this, c);
            this._userScriptEventObjects = {
                tick: this._CreateUserScriptEvent("tick")
            }
        }
        _InitGlobalVariableScriptInterface() {
            const c = {};
            for (const f of this.GetEventSheetManager().GetAllGlobalVariables()) c[f.GetJsPropName()] =
                f._GetScriptInterfaceDescriptor();
            this._iRuntime._InitGlobalVars(c)
        }
        _GetCommonScriptInterfaces() {
            return this._commonScriptInterfaces
        }
        _MapScriptInterface(c, f) {
            this._interfaceMap.set(c, f)
        }
        _UnwrapScriptInterface(c) {
            return this._interfaceMap.get(c)
        }
        _UnwrapIObjectClass(c) {
            if (!(c instanceof self.IObjectClass)) throw new TypeError("expected IObjectClass");
            c = this._UnwrapScriptInterface(c);
            if (!(c && c instanceof e.ObjectClass)) throw Error("invalid IObjectClass");
            return c
        }
        _UnwrapIWorldInstance(c) {
            if (!(c instanceof self.IWorldInstance)) throw new TypeError("expected IWorldInstance");
            c = this._UnwrapScriptInterface(c);
            if (!(c && c instanceof e.Instance)) throw Error("invalid IInstance");
            return c
        }
    };
    self.C3_CreateRuntime = e.Runtime.Create;
    self.C3_InitRuntime = (c, f) => c.Init(f)
} {
    "use strict";
    const e = self.C3;
    e.JobSchedulerRuntime = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._runtime = d;
            this._jobPromises = new Map;
            this._nextJobId = 0;
            this._inputPort = a.inputPort;
            a.outputPort.onmessage = b => this._OnJobWorkerMessage(b);
            this._maxNumWorkers = a.maxNumWorkers;
            this._jobWorkerCount = 1;
            this._hadErrorCreatingWorker = this._isCreatingWorker = !1
        }
        async Init() {}
        ImportScriptsToJobWorkers(d) {
            this._inputPort.postMessage({
                type: "_import_scripts",
                scripts: d
            })
        }
        SendBlobToJobWorkers(d, a) {
            this._inputPort.postMessage({
                type: "_send_blob",
                blob: d,
                id: a
            })
        }
        SendBufferToJobWorkers(d, a) {
            this._inputPort.postMessage({
                type: "_send_buffer",
                buffer: d,
                id: a
            }, [d])
        }
        AddJob(d, a, b, c, f) {
            b || (b = []);
            const h = this._nextJobId++;
            d = {
                type: d,
                isBroadcast: !1,
                jobId: h,
                params: a,
                transferables: b
            };
            a = new Promise((g, k) => {
                this._jobPromises.set(h, {
                    resolve: g,
                    progress: c,
                    reject: k,
                    cancelled: !1
                })
            });
            f && f.SetAction(() => this._CancelJob(h));
            this._inputPort.postMessage(d, b);
            this._MaybeCreateExtraWorker();
            return a
        }
        BroadcastJob(d, a, b) {
            b || (b = []);
            const c = this._nextJobId++;
            this._inputPort.postMessage({
                type: d,
                isBroadcast: !0,
                jobId: c,
                params: a,
                transferables: b
            }, b)
        }
        _CancelJob(d) {
            const a = this._jobPromises.get(d);
            a && (a.cancelled = !0, a.resolve = null, a.progress = null, a.reject = null, this._inputPort.postMessage({
                type: "_cancel",
                jobId: d
            }))
        }
        _OnJobWorkerMessage(d) {
            d = d.data;
            const a = d.type,
                b = d.jobId;
            switch (a) {
                case "result":
                    this._OnJobResult(b, d.result);
                    break;
                case "progress":
                    this._OnJobProgress(b, d.progress);
                    break;
                case "error":
                    this._OnJobError(b, d.error);
                    break;
                case "ready":
                    this._OnJobWorkerReady();
                    break;
                default:
                    throw Error(`unknown message from worker '${a}'`);
            }
        }
        _OnJobResult(d, a) {
            const b = this._jobPromises.get(d);
            if (!b) throw Error("invalid job ID");
            b.cancelled || b.resolve(a);
            this._jobPromises.delete(d)
        }
        _OnJobProgress(d, a) {
            d = this._jobPromises.get(d);
            if (!d) throw Error("invalid job ID");
            !d.cancelled && d.progress && d.progress(a)
        }
        _OnJobError(d, a) {
            const b = this._jobPromises.get(d);
            if (!b) throw Error("invalid job ID");
            b.cancelled || b.reject(a);
            this._jobPromises.delete(d)
        }
        _OnJobWorkerReady() {
            this._isCreatingWorker && (this._isCreatingWorker = !1, this._jobWorkerCount++, this._jobWorkerCount <
                this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
                    type: "_no_more_workers"
                }))
        }
        async _MaybeCreateExtraWorker() {
            if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount)) try {
                this._isCreatingWorker = !0, (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker")).outputPort.onmessage = d => this._OnJobWorkerMessage(d)
            } catch (d) {
                this._hadErrorCreatingWorker = !0, this._isCreatingWorker = !1, console.error(`[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, d)
            }
        }
    }
}
self.C3_Shaders = {};
self.C3_Shaders.darken = {
    glsl: "varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform lowp sampler2D samplerBack;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nfront.rgb /= front.a;\nmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\nlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\nback.rgb /= back.a;\nfront.rgb = min(front.rgb, back.rgb) * front.a;\ngl_FragColor = front * back.a;\n}",
    wgsl: "",
    extendBoxHorizontal: 0,
    extendBoxVertical: 0,
    crossSampling: !1,
    mustPreDraw: !1,
    preservesOpaqueness: !1,
    animated: !1,
    parameters: []
}; {
    "use strict";
    const e = self.C3;
    let d = null,
        a = "",
        b = "",
        c = [],
        f = "",
        h = "",
        g = "";
    const k = e.New(e.ArrayStack);

    function m(r, w) {
        r = r[1];
        w = w[1];
        if ("number" === typeof r && "number" === typeof w) return r - w;
        r = "" + r;
        w = "" + w;
        return r < w ? -1 : r > w ? 1 : 0
    }
    e.Plugins.System = class extends e.SDKPluginBase {
        constructor(r) {
            super(r);
            this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
            this._functionMaps =
                new Map
        }
        Release() {
            super.Release()
        }
        UpdateRender() {
            this._runtime.UpdateRender()
        }
        Trigger(r) {
            this._runtime.Trigger(r, null, null)
        }
        GetRegex(r, w) {
            d && r === a && w === b || (d = new RegExp(r, w), a = r, b = w);
            d.lastIndex = 0;
            return d
        }
        GetRegexMatches(r, w, p) {
            if (r === f && w === h && p === g) return c;
            const t = this.GetRegex(w, p);
            c = r.match(t);
            f = r;
            h = w;
            g = p;
            return c
        }
        async _LoadTexturesForObjectClasses(r, w) {
            if (w.length) {
                this._imagesLoadingTotal += w.length;
                var p = [];
                for (const t of w) p.push(r.MaybeLoadTexturesFor(t));
                await e.PromiseAllWithProgress(p,
                    () => {
                        this._imagesLoadingComplete++
                    });
                this._imagesLoadingComplete++;
                this._imagesLoadingComplete === this._imagesLoadingTotal && (this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null), this._imagesLoadingTotal = this._imagesLoadingComplete = 0)
            }
        }
        _UnloadTexturesForObjectClasses(r, w) {
            for (const p of w) 0 === p.GetInstanceCount() && r.MaybeUnloadTexturesFor(p)
        }
        _GetForEachStack() {
            return k
        }
        _Repeat(r) {
            var w = this._runtime.GetEventSheetManager();
            const p = w.GetEventStack(),
                t = p.GetCurrentStackFrame(),
                u = t.GetCurrentEvent(),
                q = u.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = p.Push(u),
                B = w.GetLoopStack(),
                F = B.Push();
            F.SetEnd(r);
            if (x)
                for (x = 0; x < r && !F.IsStopped(); ++x) w.PushCopySol(q), F.SetIndex(x), u.Retrigger(t, y), w.PopSol(q);
            else
                for (w = 0; w < r && !F.IsStopped(); ++w) F.SetIndex(w), u.Retrigger(t, y);
            p.Pop();
            B.Pop();
            return !1
        }* _DebugRepeat(r) {
            var w = this._runtime.GetEventSheetManager();
            const p = w.GetEventStack(),
                t = p.GetCurrentStackFrame(),
                u = t.GetCurrentEvent(),
                q = u.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = p.Push(u),
                B = w.GetLoopStack(),
                F = B.Push();
            F.SetEnd(r);
            if (x)
                for (x = 0; x < r && !F.IsStopped(); ++x) w.PushCopySol(q), F.SetIndex(x), yield* u.DebugRetrigger(t, y), w.PopSol(q);
            else
                for (w = 0; w < r && !F.IsStopped(); ++w) F.SetIndex(w), yield* u.DebugRetrigger(t, y);
            p.Pop();
            B.Pop();
            return !1
        }
        _While() {
            var r = this._runtime.GetEventSheetManager();
            const w = r.GetEventStack(),
                p = w.GetCurrentStackFrame(),
                t = p.GetCurrentEvent(),
                u = t.GetSolModifiers();
            var q = p.IsSolModifierAfterCnds();
            const x = w.Push(t),
                y = r.GetLoopStack(),
                B = y.Push();
            if (q)
                for (q = 0; !B.IsStopped(); ++q) r.PushCopySol(u), B.SetIndex(q), t.Retrigger(p, x) || B.Stop(), r.PopSol(u);
            else
                for (r = 0; !B.IsStopped(); ++r) B.SetIndex(r), t.Retrigger(p, x) || B.Stop();
            w.Pop();
            y.Pop();
            return !1
        }* _DebugWhile() {
            var r = this._runtime.GetEventSheetManager();
            const w = r.GetEventStack(),
                p = w.GetCurrentStackFrame(),
                t = p.GetCurrentEvent(),
                u = t.GetSolModifiers();
            var q = p.IsSolModifierAfterCnds();
            const x = w.Push(t),
                y = r.GetLoopStack(),
                B = y.Push();
            if (q)
                for (q = 0; !B.IsStopped(); ++q) r.PushCopySol(u), B.SetIndex(q), (yield* t.DebugRetrigger(p,
                    x)) || B.Stop(), r.PopSol(u);
            else
                for (r = 0; !B.IsStopped(); ++r) B.SetIndex(r), (yield* t.DebugRetrigger(p, x)) || B.Stop();
            w.Pop();
            y.Pop();
            return !1
        }
        _For(r, w, p) {
            var t = this._runtime.GetEventSheetManager();
            const u = t.GetEventStack(),
                q = u.GetCurrentStackFrame(),
                x = q.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                B = q.IsSolModifierAfterCnds(),
                F = u.Push(x),
                H = t.GetLoopStack(),
                K = H.Push();
            K.SetName(r);
            K.SetEnd(p);
            if (p < w)
                if (B)
                    for (r = w; r >= p && !K.IsStopped(); --r) t.PushCopySol(y), K.SetIndex(r), x.Retrigger(q, F), t.PopSol(y);
                else
                    for (t =
                        w; t >= p && !K.IsStopped(); --t) K.SetIndex(t), x.Retrigger(q, F);
            else if (B)
                for (r = w; r <= p && !K.IsStopped(); ++r) t.PushCopySol(y), K.SetIndex(r), x.Retrigger(q, F), t.PopSol(y);
            else
                for (t = w; t <= p && !K.IsStopped(); ++t) K.SetIndex(t), x.Retrigger(q, F);
            u.Pop();
            H.Pop();
            return !1
        }* _DebugFor(r, w, p) {
            var t = this._runtime.GetEventSheetManager();
            const u = t.GetEventStack(),
                q = u.GetCurrentStackFrame(),
                x = q.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                B = q.IsSolModifierAfterCnds(),
                F = u.Push(x),
                H = t.GetLoopStack(),
                K = H.Push();
            K.SetName(r);
            K.SetEnd(p);
            if (p < w)
                if (B)
                    for (r = w; r >= p && !K.IsStopped(); --r) t.PushCopySol(y), K.SetIndex(r), yield* x.DebugRetrigger(q, F), t.PopSol(y);
                else
                    for (t = w; t >= p && !K.IsStopped(); --t) K.SetIndex(t), yield* x.DebugRetrigger(q, F);
            else if (B)
                for (r = w; r <= p && !K.IsStopped(); ++r) t.PushCopySol(y), K.SetIndex(r), yield* x.DebugRetrigger(q, F), t.PopSol(y);
            else
                for (t = w; t <= p && !K.IsStopped(); ++t) K.SetIndex(t), yield* x.DebugRetrigger(q, F);
            u.Pop();
            H.Pop();
            return !1
        }
        _ForEach(r) {
            var w = this._runtime.GetEventSheetManager();
            const p = w.GetEventStack(),
                t = p.GetCurrentStackFrame(),
                u = t.GetCurrentEvent(),
                q = u.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = p.Push(u),
                B = w.GetLoopStack(),
                F = B.Push(),
                H = r.IsInContainer(),
                K = r.GetCurrentSol(),
                C = k.Push();
            e.shallowAssignArray(C, K.GetInstances());
            F.SetEnd(C.length);
            if (x)
                for (let A = 0, G = C.length; A < G && !F.IsStopped(); ++A) w.PushCopySol(q), x = C[A], r.GetCurrentSol().SetSinglePicked(x), H && x.SetSiblingsSinglePicked(), F.SetIndex(A), u.Retrigger(t, y), w.PopSol(q);
            else {
                K._SetSelectAll(!1);
                r = K._GetOwnInstances();
                e.clearArray(r);
                r.push(null);
                for (let A =
                        0, G = C.length; A < G && !F.IsStopped(); ++A) w = C[A], r[0] = w, H && w.SetSiblingsSinglePicked(), F.SetIndex(A), u.Retrigger(t, y)
            }
            p.Pop();
            B.Pop();
            e.clearArray(C);
            k.Pop();
            return !1
        }* _DebugForEach(r) {
            var w = this._runtime.GetEventSheetManager();
            const p = w.GetEventStack(),
                t = p.GetCurrentStackFrame(),
                u = t.GetCurrentEvent(),
                q = u.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = p.Push(u),
                B = w.GetLoopStack(),
                F = B.Push(),
                H = r.IsInContainer(),
                K = r.GetCurrentSol(),
                C = k.Push();
            e.shallowAssignArray(C, K.GetInstances());
            F.SetEnd(C.length);
            if (x)
                for (let A = 0, G = C.length; A < G && !F.IsStopped(); ++A) w.PushCopySol(q), x = C[A], r.GetCurrentSol().SetSinglePicked(x), H && x.SetSiblingsSinglePicked(), F.SetIndex(A), yield* u.DebugRetrigger(t, y), w.PopSol(q);
            else {
                K._SetSelectAll(!1);
                r = K._GetOwnInstances();
                e.clearArray(r);
                r.push(null);
                for (let A = 0, G = C.length; A < G && !F.IsStopped(); ++A) w = C[A], r[0] = w, H && w.SetSiblingsSinglePicked(), F.SetIndex(A), yield* u.DebugRetrigger(t, y)
            }
            p.Pop();
            B.Pop();
            e.clearArray(C);
            k.Pop();
            return !1
        }
        _ForEachOrdered(r, w) {
            var p = this._runtime.GetEventSheetManager();
            const t = p.GetEventStack(),
                u = p.GetCurrentCondition(),
                q = t.GetCurrentStackFrame(),
                x = q.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                B = q.IsSolModifierAfterCnds(),
                F = t.Push(x),
                H = p.GetLoopStack(),
                K = H.Push(),
                C = r.IsInContainer(),
                A = r.GetCurrentSol(),
                G = k.Push();
            e.clearArray(G);
            const J = A.GetInstances();
            K.SetEnd(J.length);
            for (let M = 0, R = J.length; M < R; ++M) G.push([J[M], u.ReevaluateParameter(1, M)]);
            G.sort(m);
            1 === w && G.reverse();
            if (B)
                for (let M = 0, R = G.length; M < R && !K.IsStopped(); ++M) p.PushCopySol(y), w = G[M][0], r.GetCurrentSol().SetSinglePicked(w),
                    C && w.SetSiblingsSinglePicked(), K.SetIndex(M), x.Retrigger(q, F), p.PopSol(y);
            else {
                A._SetSelectAll(!1);
                r = A._GetOwnInstances();
                e.clearArray(r);
                r.push(null);
                for (let M = 0, R = G.length; M < R && !K.IsStopped(); ++M) p = G[M][0], r[0] = p, C && p.SetSiblingsSinglePicked(), K.SetIndex(M), x.Retrigger(q, F)
            }
            t.Pop();
            H.Pop();
            e.clearArray(G);
            k.Pop();
            return !1
        }* _DebugForEachOrdered(r, w) {
            var p = this._runtime.GetEventSheetManager();
            const t = p.GetEventStack(),
                u = p.GetCurrentCondition(),
                q = t.GetCurrentStackFrame(),
                x = q.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                B = q.IsSolModifierAfterCnds(),
                F = t.Push(x),
                H = p.GetLoopStack(),
                K = H.Push(),
                C = r.IsInContainer(),
                A = r.GetCurrentSol(),
                G = k.Push();
            e.clearArray(G);
            const J = A.GetInstances();
            K.SetEnd(J.length);
            for (let M = 0, R = J.length; M < R; ++M) G.push([J[M], u.ReevaluateParameter(1, M)]);
            G.sort(m);
            1 === w && G.reverse();
            if (B)
                for (let M = 0, R = G.length; M < R && !K.IsStopped(); ++M) p.PushCopySol(y), w = G[M][0], r.GetCurrentSol().SetSinglePicked(w), C && w.SetSiblingsSinglePicked(), K.SetIndex(M), yield* x.DebugRetrigger(q, F), p.PopSol(y);
            else {
                A._SetSelectAll(!1);
                r = A._GetOwnInstances();
                e.clearArray(r);
                r.push(null);
                for (let M = 0, R = G.length; M < R && !K.IsStopped(); ++M) p = G[M][0], r[0] = p, C && p.SetSiblingsSinglePicked(), K.SetIndex(M), yield* x.DebugRetrigger(q, F)
            }
            t.Pop();
            H.Pop();
            e.clearArray(G);
            k.Pop();
            return !1
        }
        _GetFunctionMap(r, w) {
            let p = this._functionMaps.get(r);
            if (p) return p;
            if (!w) return null;
            p = {
                defaultFunc: null,
                strMap: new Map
            };
            this._functionMaps.set(r, p);
            return p
        }
        _DoCallMappedFunction(r, w, p, t, u) {
            w.GetEventBlock().RunAsMappedFunctionCall(p);
            t && r.PopSol(u)
        }* _DebugDoCallMappedFunction(r,
            w, p, t, u) {
            yield* w.GetEventBlock().DebugRunAsMappedFunctionCall(p);
            t && r.PopSol(u)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.System.Type = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._objectClass = d;
            this._runtime = d.GetRuntime();
            this._plugin = d.GetPlugin()
        }
        OnCreate() {}
        Release() {
            this._plugin = this._runtime = this._objectClass = null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.System.Instance = class extends e.DefendedBase {
        constructor(d, a) {
            super();
            this._inst = d;
            this._objectClass = this._inst.GetObjectClass();
            this._sdkType = this._objectClass.GetSdkType();
            this._runtime = this._inst.GetRuntime()
        }
        Release() {
            this._runtime = this._sdkType = this._objectClass = this._inst = null
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [];
    e.Plugins.System.Cnds = {
        EveryTick() {
            return !0
        },
        OnLayoutStart() {
            return !0
        },
        OnLayoutEnd() {
            return !0
        },
        OnSuspend() {
            return !0
        },
        OnResume() {
            return !0
        },
        IsSuspended() {
            return this._runtime.IsSuspended()
        },
        Else() {
            const a = this._runtime.GetCurrentEventStackFrame();
            return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue()
        },
        TriggerOnce() {
            const a = this._runtime.GetCurrentCondition().GetSavedDataMap();
            let b = a.get("TriggerOnce_lastTick");
            "undefined" === typeof b && (b = -1, a.set("TriggerOnce_lastTick", -1));
            const c = this._runtime.GetTickCount();
            a.set("TriggerOnce_lastTick", c);
            return this._runtime.IsLayoutFirstTick() || b !== c - 1
        },
        Every(a) {
            const b = this._runtime.GetCurrentCondition().GetSavedDataMap(),
                c = b.get("Every_lastTime") || 0,
                f = this._runtime.GetGameTime();
            b.has("Every_seconds") || b.set("Every_seconds", a);
            const h = b.get("Every_seconds");
            if (f >= c + h) return b.set("Every_lastTime", c + h), f >= b.get("Every_lastTime") + .04 && b.set("Every_lastTime", f), b.set("Every_seconds", a), !0;
            f < c - .1 && b.set("Every_lastTime", f);
            return !1
        },
        IsGroupActive(a) {
            return (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && a.IsGroupActive()
        },
        IsPreview() {
            return this._runtime.IsPreview()
        },
        IsMobile() {
            return e.Platform.IsMobile
        },
        OnLoadFinished() {
            return !0
        },
        OnCanvasSnapshot() {
            return !0
        },
        EffectsSupported() {
            return !0
        },
        OnSaveComplete() {
            return !0
        },
        OnSaveFailed() {
            return !0
        },
        OnLoadComplete() {
            return !0
        },
        OnLoadFailed() {
            return !0
        },
        ObjectUIDExists(a) {
            return !!this._runtime.GetInstanceByUID(a)
        },
        IsOnPlatform(a) {
            switch (a) {
                case 0:
                    return "browser" === e.Platform.Context;
                case 1:
                    return "iOS" === e.Platform.OS;
                case 2:
                    return "Android" === e.Platform.OS;
                case 8:
                    return "cordova" === e.Platform.Context;
                case 9:
                    return "scirra-arcade" === this._runtime.GetExportType();
                case 10:
                    return "nwjs" === e.Platform.Context;
                case 13:
                    return "windows-uwp" === this._runtime.GetExportType();
                default:
                    return !1
            }
        },
        RegexTest(a, b, c) {
            return this.GetRegex(b, c).test(a)
        },
        Compare(a, b, c) {
            return e.compare(a, b, c)
        },
        CompareBetween(a, b, c) {
            return a >= b && a <= c
        },
        CompareVar(a, b, c) {
            return e.compare(a.GetValue(), b, c)
        },
        CompareBoolVar(a) {
            return !!a.GetValue()
        },
        CompareTime(a, b) {
            const c = this._runtime.GetGameTime();
            return 0 === a ? (a = this._runtime.GetCurrentCondition().GetSavedDataMap(), !a.get("CompareTime_executed") && c >= b ? (a.set("CompareTime_executed", !0), !0) : !1) : e.compare(c, a, b)
        },
        IsNaN(a) {
            return isNaN(a)
        },
        AngleWithin(a, b, c) {
            return e.angleDiff(e.toRadians(a), e.toRadians(c)) <= e.toRadians(b)
        },
        IsClockwiseFrom(a, b) {
            return e.angleClockwise(e.toRadians(a), e.toRadians(b))
        },
        IsBetweenAngles(a, b, c) {
            a = e.toRadians(a);
            b = e.toRadians(b);
            c = e.toRadians(c);
            return e.angleClockwise(c,
                b) ? e.angleClockwise(a, b) && !e.angleClockwise(a, c) : !(!e.angleClockwise(a, b) && e.angleClockwise(a, c))
        },
        IsValueType(a, b) {
            return "number" === typeof a ? 0 === b : 1 === b
        },
        EvaluateExpression(a) {
            return !!a
        },
        PickByComparison(a, b, c, f) {
            if (!a) return !1;
            const h = this._GetForEachStack(),
                g = h.Push(),
                k = a.GetCurrentSol();
            e.shallowAssignArray(g, k.GetInstances());
            k.IsSelectAll() && e.clearArray(k._GetOwnElseInstances());
            const m = this._runtime.GetCurrentCondition();
            let r = 0;
            for (let w = 0, p = g.length; w < p; ++w) {
                const t = g[w];
                g[r] = t;
                b = m.ReevaluateParameter(1,
                    w);
                f = m.ReevaluateParameter(3, w);
                e.compare(b, c, f) ? ++r : k._PushElseInstance(t)
            }
            e.truncateArray(g, r);
            k.SetArrayPicked(g);
            b = !!g.length;
            e.clearArray(g);
            h.Pop();
            a.ApplySolToContainer();
            return b
        },
        PickByEvaluate(a, b) {
            if (!a) return !1;
            const c = this._GetForEachStack(),
                f = c.Push(),
                h = a.GetCurrentSol();
            e.shallowAssignArray(f, h.GetInstances());
            h.IsSelectAll() && e.clearArray(h._GetOwnElseInstances());
            const g = this._runtime.GetCurrentCondition();
            let k = 0;
            for (let m = 0, r = f.length; m < r; ++m) {
                const w = f[m];
                f[k] = w;
                (b = g.ReevaluateParameter(1,
                    m)) ? ++k: h._PushElseInstance(w)
            }
            e.truncateArray(f, k);
            h.SetArrayPicked(f);
            b = !!f.length;
            e.clearArray(f);
            c.Pop();
            a.ApplySolToContainer();
            return b
        },
        PickNth(a, b) {
            if (!a) return !1;
            const c = a.GetCurrentSol(),
                f = c.GetInstances();
            b = Math.floor(b);
            if (b >= f.length) return !1;
            c.PickOne(f[b]);
            a.ApplySolToContainer();
            return !0
        },
        PickRandom(a) {
            if (!a) return !1;
            const b = a.GetCurrentSol(),
                c = b.GetInstances(),
                f = Math.floor(this._runtime.Random() * c.length);
            if (f >= c.length) return !1;
            b.PickOne(c[f]);
            a.ApplySolToContainer();
            return !0
        },
        PickAll(a) {
            if (!a ||
                !a.GetInstanceCount()) return !1;
            a.GetCurrentSol()._SetSelectAll(!0);
            a.ApplySolToContainer();
            return !0
        },
        PickOverlappingPoint(a, b, c) {
            if (!a) return !1;
            const f = a.GetCurrentSol();
            var h = f.GetInstances();
            const g = this._runtime.GetCurrentEvent().IsOrBlock(),
                k = this._runtime.GetCurrentCondition().IsInverted();
            f.IsSelectAll() ? (e.shallowAssignArray(d, h), f.ClearArrays(), f._SetSelectAll(!1)) : g ? (e.shallowAssignArray(d, f._GetOwnElseInstances()), e.clearArray(f._GetOwnElseInstances())) : (e.shallowAssignArray(d, f._GetOwnInstances()),
                e.clearArray(f._GetOwnInstances()));
            for (let m = 0, r = d.length; m < r; ++m) h = d[m], e.xor(h.GetWorldInfo().ContainsPoint(b, c), k) ? f._PushInstance(h) : f._PushElseInstance(h);
            a.ApplySolToContainer();
            return e.xor(!!f._GetOwnInstances().length, k)
        },
        PickLastCreated(a) {
            if (!a) return !1;
            var b = a.IsFamily();
            let c = null;
            const f = this._runtime._GetInstancesPendingCreate();
            for (let h = f.length - 1; 0 <= h; --h) {
                const g = f[h];
                if (b) {
                    if (g.GetObjectClass().BelongsToFamily(a)) {
                        c = g;
                        break
                    }
                } else if (g.GetObjectClass() === a) {
                    c = g;
                    break
                }
            }
            c || (b = a.GetInstances(),
                b.length && (c = b.at(-1)));
            if (!c) return !1;
            a.GetCurrentSol().PickOne(c);
            a.ApplySolToContainer();
            return !0
        },
        Repeat(a) {
            return this._runtime.IsDebugging() ? this._DebugRepeat(a) : this._Repeat(a)
        },
        While() {
            return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
        },
        For(a, b, c) {
            return this._runtime.IsDebugging() ? this._DebugFor(a, b, c) : this._For(a, b, c)
        },
        ForEach(a) {
            return this._runtime.IsDebugging() ? this._DebugForEach(a) : this._ForEach(a)
        },
        ForEachOrdered(a, b, c) {
            return this._runtime.IsDebugging() ? this._DebugForEachOrdered(a,
                c) : this._ForEachOrdered(a, c)
        },
        LayerVisible(a) {
            return a ? a.IsVisible() : !1
        },
        LayerEmpty(a) {
            return a ? !a.GetInstanceCount() : !1
        },
        LayerCmpOpacity(a, b, c) {
            return a ? e.compare(100 * a.GetOpacity(), b, c) : !1
        },
        OnImageLoadingComplete() {
            return !0
        },
        IsLoadingImages() {
            return 0 < this._imagesLoadingTotal
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(g, k) {
        const m = g[0] - k[0];
        return 0 !== m ? m : g[1] - k[1]
    }

    function a(g, k) {
        return g[1] - k[1]
    }
    const b = [],
        c = [],
        f = e.New(e.Rect),
        h = e.New(e.Color);
    e.Plugins.System.Acts = {
        SetVar(g, k) {
            g.SetValue(k)
        },
        AddVar(g, k) {
            g.IsNumber() && "number" !== typeof k && (k = parseFloat(k));
            g.SetValue(g.GetValue() + k)
        },
        SubVar(g, k) {
            g.IsNumber() && g.SetValue(g.GetValue() - k)
        },
        SetBoolVar(g, k) {
            g.SetValue(!!k)
        },
        ToggleBoolVar(g) {
            g.SetValue(!g.GetValue())
        },
        ResetGlobals() {
            this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
        },
        CreateObject(g, k, m, r, w) {
            g && k && (m = this._runtime.CreateInstance(g, k, m, r, w)) && (w && k.SortAndAddInstancesByZIndex(m), k = this._runtime.GetEventSheetManager(), k.BlockFlushingInstances(!0), m._TriggerOnCreatedOnSelfAndRelated(), k.BlockFlushingInstances(!1), g.GetCurrentSol().SetSinglePicked(m), m.IsInContainer() && m.SetSiblingsSinglePicked())
        },
        CreateObjectByName(g, k, m, r, w) {
            g && k && (g = this._runtime.GetObjectClassByName(g)) && e.Plugins.System.Acts.CreateObject.call(this, g, k, m, r, w)
        },
        RecreateInitialObjects(g, k, m, r, w,
            p, t, u, q, x) {
            if (g) {
                var y = this._runtime.GetCurrentLayout();
                if (p && (y = this._runtime.GetLayoutManager().GetLayoutByName(p), !y)) return;
                p = null;
                if ("number" !== typeof t || 0 <= t)
                    if (p = y.GetLayer(t), !p) return;
                f.set(k, m, r, w);
                k = y.RecreateInitialObjects(g, f, p, u, q, x);
                g.GetCurrentSol().SetArrayPicked(k);
                g.ApplySolToContainer()
            }
        },
        StopLoop() {
            const g = this._loopStack;
            g.IsInLoop() && g.GetCurrent().Stop()
        },
        SetGroupActive(g, k) {
            (g = this._runtime.GetEventSheetManager().GetEventGroupByName(g)) && (0 === k ? g.SetGroupActive(!1) : 1 === k ?
                g.SetGroupActive(!0) : g.SetGroupActive(!g.IsGroupActive()))
        },
        SetTimescale(g) {
            this._runtime.SetTimeScale(g)
        },
        SetObjectTimescale(g, k) {
            0 > k && (k = 0);
            if (g) {
                g = g.GetCurrentSol().GetInstances();
                for (const m of g) m.SetTimeScale(k)
            }
        },
        RestoreObjectTimescale(g) {
            if (g) {
                g = g.GetCurrentSol().GetInstances();
                for (const k of g) k.RestoreTimeScale()
            }
        },
        Wait(g) {
            if (!(0 > g)) return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(g), !0
        },
        WaitForSignal(g) {
            this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(g);
            return !0
        },
        WaitForPreviousActions() {
            const g = this._runtime.GetEventSheetManager();
            g.AddScheduledWait().InitPromise(g.GetPromiseForAllAsyncActions());
            return !0
        },
        Signal(g) {
            g = g.toLowerCase();
            for (const k of this._runtime.GetEventSheetManager().scheduledWaits()) k.IsSignal() && k.GetSignalTag() === g && k.SetSignalled()
        },
        async SnapshotCanvas(g, k, m, r, w, p) {
            const t = this._runtime.GetCanvasManager();
            t && (this.UpdateRender(), await t.SnapshotCanvas(0 === g ? "image/png" : "image/jpeg", k / 100, m, r, w, p), await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnCanvasSnapshot,
                null))
        },
        SetCanvasSize(g, k) {
            if (!(0 >= g || 0 >= k)) {
                this._runtime.SetViewportSize(g, k);
                var m = this._runtime.GetCurrentLayout();
                m.BoundScrolling();
                for (const r of m.GetLayers()) r.UpdateViewport();
                if (m = this._runtime.GetCanvasManager()) "off" !== m.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(g, k), m.SetSize(m.GetLastWidth(), m.GetLastHeight(), !0), this._runtime.UpdateRender()
            }
        },
        SetFullscreenQuality(g) {
            const k = this._runtime.GetCanvasManager();
            k && "off" !== k.GetCurrentFullscreenMode() && (k.SetFullscreenScalingQuality(0 !==
                g ? "high" : "low"), k.SetSize(k.GetLastWidth(), k.GetLastHeight(), !0))
        },
        SaveState(g) {
            this._runtime.SaveToSlot(g)
        },
        LoadState(g) {
            this._runtime.LoadFromSlot(g)
        },
        LoadStateJSON(g) {
            this._runtime.LoadFromJsonString(g)
        },
        SetHalfFramerateMode(g) {},
        ResetPersisted() {
            for (const g of this._runtime.GetLayoutManager().GetAllLayouts()) g.ResetPersistData()
        },
        SetPixelRounding(g) {
            this._runtime.SetPixelRoundingEnabled(0 !== g)
        },
        SetMinimumFramerate(g) {
            this._runtime.SetMinimumFramerate(g)
        },
        SortZOrderByInstVar(g, k) {
            if (g) {
                var m = g.GetCurrentSol().GetInstances(),
                    r = this._runtime.GetCurrentLayout(),
                    w = g.IsFamily();
                g = g.GetFamilyIndex();
                for (let t = 0, u = m.length; t < u; ++t) {
                    var p = m[t];
                    const q = p.GetWorldInfo();
                    if (!q) continue;
                    let x;
                    x = w ? p.GetInstanceVariableValue(k + p.GetObjectClass().GetFamilyInstanceVariableOffset(g)) : p.GetInstanceVariableValue(k);
                    b.push([q.GetLayer().GetIndex(), q.GetZIndex()]);
                    c.push([p, x])
                }
                if (b.length) {
                    b.sort(d);
                    c.sort(a);
                    k = !1;
                    for (let t = 0, u = b.length; t < u; ++t) m = c[t][0], w = r.GetLayerByIndex(b[t][0]), g = b[t][1], p = w._GetInstances(), p[g] !== m && (p[g] = m, m.GetWorldInfo()._SetLayer(w),
                        w.SetZIndicesChanged(), k = !0);
                    k && this._runtime.UpdateRender();
                    e.clearArray(b);
                    e.clearArray(c)
                }
            }
        },
        GoToLayout(g) {
            if (!this._runtime.IsLoading()) {
                var k = this._runtime.GetLayoutManager();
                k.IsPendingChangeMainLayout() || k.ChangeMainLayout(g)
            }
        },
        GoToLayoutByName(g) {
            if (!this._runtime.IsLoading()) {
                var k = this._runtime.GetLayoutManager();
                k.IsPendingChangeMainLayout() || (g = k.GetLayoutByName(g)) && k.ChangeMainLayout(g)
            }
        },
        NextPrevLayout(g) {
            if (!this._runtime.IsLoading()) {
                var k = this._runtime.GetLayoutManager();
                if (!k.IsPendingChangeMainLayout()) {
                    var m =
                        k.GetAllLayouts(),
                        r = m.indexOf(k.GetMainRunningLayout());
                    g && 0 === r || (g || r !== m.length - 1) && k.ChangeMainLayout(m[r + (g ? -1 : 1)])
                }
            }
        },
        RestartLayout() {
            if (!this._runtime.IsLoading()) {
                var g = this._runtime.GetLayoutManager();
                g.IsPendingChangeMainLayout() || (g.ChangeMainLayout(g.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
            }
        },
        SetLayerVisible(g, k) {
            g && g.SetVisible(k)
        },
        SetLayerOpacity(g, k) {
            g && g.SetOpacity(k / 100)
        },
        SetLayerScale(g, k) {
            g && g.SetOwnScale(k)
        },
        SetLayerScaleRate(g,
            k) {
            g && g.SetScaleRate(k)
        },
        SetLayerAngle(g, k) {
            g && g.SetAngle(e.toRadians(+k))
        },
        SetLayerScroll(g, k, m) {
            g && (g.SetOwnScrollPositionEnabled(!0), g.SetScrollX(k), g.SetScrollY(m))
        },
        RestoreLayerScroll(g) {
            g && g.SetOwnScrollPositionEnabled(!1)
        },
        SetLayerParallax(g, k, m) {
            g && g.SetParallax(k / 100, m / 100)
        },
        SetLayerZElevation(g, k) {
            g && g.SetZElevation(+k)
        },
        SetLayerBackground(g, k) {
            g && (h.setFromRgbValue(k), h.clamp(), g = g.GetBackgroundColor(), g.equalsIgnoringAlpha(h) || (g.copyRgb(h), this.UpdateRender()))
        },
        SetLayerTransparent(g,
            k) {
            g && g.SetTransparent(k)
        },
        SetLayerBlendMode(g, k) {
            g && g.SetBlendMode(k)
        },
        SetLayerEffectEnabled(g, k, m) {
            g && (g = g.GetEffectList(), m = g.GetEffectTypeByName(m)) && (k = 1 === k, m.IsActive() !== k && (m.SetActive(k), g.UpdateActiveEffects(), this._runtime.UpdateRender()))
        },
        SetLayerEffectParam(g, k, m, r) {
            if (g && (g = g.GetEffectList(), k = g.GetEffectTypeByName(k))) {
                var w = k.GetIndex();
                g = g.GetEffectParametersForIndex(w);
                m = Math.floor(m);
                if (!(0 > m || m >= g.length)) {
                    w = k.GetShaderProgram().GetParameterType(m);
                    if ("color" === w) {
                        h.setFromRgbValue(r);
                        m = g[m];
                        if (h.equalsIgnoringAlpha(m)) return;
                        m.copyRgb(h)
                    } else {
                        "percent" === w && (r /= 100);
                        if (g[m] === r) return;
                        g[m] = r
                    }
                    k.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        SetLayerForceOwnTexture(g, k) {
            g && g.SetForceOwnTexture(k)
        },
        SetLayoutScale(g) {
            this._runtime.GetCurrentLayout().SetScale(+g)
        },
        SetLayoutAngle(g) {
            this._runtime.GetCurrentLayout().SetAngle(e.toRadians(+g))
        },
        SetLayoutEffectEnabled(g, k) {
            const m = this._runtime.GetCurrentLayout().GetEffectList();
            if (k = m.GetEffectTypeByName(k)) g = 1 === g, k.IsActive() !== g && (k.SetActive(g),
                m.UpdateActiveEffects(), this._runtime.UpdateRender())
        },
        SetLayoutEffectParam(g, k, m) {
            var r = this._runtime.GetCurrentLayout().GetEffectList();
            if (g = r.GetEffectTypeByName(g)) {
                var w = g.GetIndex();
                r = r.GetEffectParametersForIndex(w);
                k = Math.floor(k);
                if (!(0 > k || k >= r.length)) {
                    w = g.GetShaderProgram().GetParameterType(k);
                    if ("color" === w) {
                        h.setFromRgbValue(m);
                        k = r[k];
                        if (h.equalsIgnoringAlpha(k)) return;
                        k.copyRgb(h)
                    } else {
                        "percent" === w && (m /= 100);
                        if (r[k] === m) return;
                        r[k] = m
                    }
                    g.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        SetLayoutVanishingPoint(g,
            k) {
            this._runtime.GetCurrentLayout().SetVanishingPointXY(g / 100, k / 100)
        },
        SetLayoutProjection(g) {
            const k = this._runtime.GetCurrentLayout();
            0 === g ? k.SetPerspectiveProjection() : k.SetOrthographicProjection()
        },
        ScrollX(g) {
            this._runtime.GetCurrentLayout().SetScrollX(g)
        },
        ScrollY(g) {
            this._runtime.GetCurrentLayout().SetScrollY(g)
        },
        Scroll(g, k) {
            const m = this._runtime.GetCurrentLayout();
            m.SetScrollX(g);
            m.SetScrollY(k)
        },
        ScrollToObject(g) {
            if (g && (g = g.GetFirstPicked()) && (g = g.GetWorldInfo())) {
                var k = this._runtime.GetCurrentLayout();
                k.SetScrollX(g.GetX());
                k.SetScrollY(g.GetY())
            }
        },
        async LoadObjectTextures(g) {
            const k = this._runtime.GetMainRunningLayout();
            k && g && !this._runtime.IsLoading() && (g = g.IsFamily() ? g.GetFamilyMembers() : [g], await this._LoadTexturesForObjectClasses(k, g))
        },
        async LoadObjectTexturesByName(g) {
            await e.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(g))
        },
        UnloadObjectTextures(g) {
            const k = this._runtime.GetMainRunningLayout();
            k && g && (g = g.IsFamily() ? g.GetFamilyMembers() : [g], this._UnloadTexturesForObjectClasses(k,
                g))
        },
        UnloadObjectTexturesByName(g) {
            e.Plugins.System.Acts.UnloadObjectTexturesByName.call(this, this._runtime.GetObjectClassByName(g))
        },
        UnloadUnusedTextures() {
            const g = this._runtime.GetMainRunningLayout();
            if (g) {
                var k = g._GetTextureLoadedObjectTypes();
                this._UnloadTexturesForObjectClasses(g, k)
            }
        },
        async LoadLayoutTextures(g) {
            const k = this._runtime.GetMainRunningLayout();
            g && k && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(k, g._GetInitialObjectClasses())
        },
        async LoadLayoutTexturesByName(g) {
            const k =
                this._runtime.GetMainRunningLayout();
            (g = this._runtime.GetLayoutManager().GetLayoutByName(g)) && k && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(k, g._GetInitialObjectClasses())
        },
        SetFunctionReturnValue(g) {
            const k = this._eventStack.GetCurrentExpFuncStackFrame();
            if (k) switch (k.GetFunctionReturnType()) {
                case 1:
                    "number" === typeof g && k.SetFunctionReturnValue(g);
                    break;
                case 2:
                    "string" === typeof g && k.SetFunctionReturnValue(g);
                    break;
                case 3:
                    k.SetFunctionReturnValue(g)
            }
        },
        MapFunction(g, k, m) {
            var r =
                this._GetFunctionMap(g.toLowerCase(), !0);
            const w = r.strMap,
                p = k.toLowerCase();
            w.has(p) && console.warn(`[Construct 3] Function map '${g}' string '${k}' already in map; overwriting entry`);
            if (r = e.first(w.values()) || r.defaultFunc) {
                r = 0 !== r.GetReturnType();
                const t = 0 !== m.GetReturnType();
                if (r !== t) {
                    console.error(`[Construct 3] Function map '${g}' string '${k}' function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            w.set(p, m)
        },
        MapFunctionDefault(g, k) {
            const m = this._GetFunctionMap(g.toLowerCase(), !0);
            m.defaultFunc && console.warn(`[Construct 3] Function map '${g}' already has a default; overwriting entry`);
            var r = e.first(m.strMap.values()) || m.defaultFunc;
            if (r) {
                r = 0 !== r.GetReturnType();
                const w = 0 !== k.GetReturnType();
                if (r !== w) {
                    console.error(`[Construct 3] Function map '${g}' default: function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            m.defaultFunc = k
        },
        CallMappedFunction(g, k, m) {
            m = Math.floor(m);
            var r = this._GetFunctionMap(g.toLowerCase(), !1);
            if (r) {
                var w = r.strMap.get(k.toLowerCase());
                if (!w)
                    if (r.defaultFunc) w = r.defaultFunc, m = 0;
                    else {
                        console.warn(`[Construct 3] Call mapped function: no function associated with map '${g}' string '${k}'; call ignored (consider setting a default)`);
                        return
                    }
                if (w.IsEnabled())
                    if (0 !== w.GetReturnType()) console.warn(`[Construct 3] Call mapped function: map '${g}' string '${k}' has a return type so cannot be called`);
                    else {
                        g = this._runtime;
                        k = g.GetEventSheetManager();
                        var p = k.GetCurrentEvent();
                        r = p.GetSolModifiersIncludingParents();
                        var t = 0 < r.length;
                        t && k.PushCleanSol(r);
                        var u = [];
                        if (p = k.FindFirstFunctionBlockParent(p)) {
                            p = p.GetFunctionParameters();
                            for (let q = m, x = p.length; q < x; ++q) u.push(p[q].GetValue())
                        }
                        m = w.GetFunctionParameters();
                        for (let q = u.length, x = m.length; q < x; ++q) u.push(m[q].GetInitialValue());
                        return g.IsDebugging() ? this._DebugDoCallMappedFunction(k, w, u, t, r) : this._DoCallMappedFunction(k, w, u, t, r)
                    }
            } else console.warn(`[Construct 3] Call mapped function: map name '${g}' not found; call ignored`)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.System.Exps = {
        int: function(d) {
            "string" === typeof d && (d = parseInt(d, 10), isNaN(d) && (d = 0));
            return Math.floor(d)
        },
        float: function(d) {
            "string" === typeof d && (d = parseFloat(d), isNaN(d) && (d = 0));
            return d
        },
        str(d) {
            return d.toString()
        },
        len(d) {
            return "string" === typeof d ? d.length : 0
        },
        random(d, a) {
            return "undefined" === typeof a ? this._runtime.Random() * d : this._runtime.Random() * (a - d) + d
        },
        choose(...d) {
            const a = Math.floor(this._runtime.Random() * d.length);
            return d[a]
        },
        pi() {
            return Math.PI
        },
        infinity() {
            return Infinity
        },
        sqrt(d) {
            return Math.sqrt(d)
        },
        abs(d) {
            return Math.abs(d)
        },
        round(d) {
            return Math.round(d)
        },
        roundtodp(d, a) {
            a = Math.max(Math.floor(a), 0);
            a = Math.pow(10, a);
            return Math.round((d + Number.EPSILON) * a) / a
        },
        floor(d) {
            return Math.floor(d)
        },
        ceil(d) {
            return Math.ceil(d)
        },
        sign(d) {
            return Math.sign(d)
        },
        sin(d) {
            return Math.sin(e.toRadians(d))
        },
        cos(d) {
            return Math.cos(e.toRadians(d))
        },
        tan(d) {
            return Math.tan(e.toRadians(d))
        },
        asin(d) {
            return e.toDegrees(Math.asin(d))
        },
        acos(d) {
            return e.toDegrees(Math.acos(d))
        },
        atan(d) {
            return e.toDegrees(Math.atan(d))
        },
        exp(d) {
            return Math.exp(d)
        },
        ln(d) {
            return Math.log(d)
        },
        log10(d) {
            return Math.log(d) / Math.LN10
        },
        max(...d) {
            let a = d[0];
            "number" !== typeof a && (a = 0);
            for (let b = 1, c = d.length; b < c; ++b) {
                let f = d[b];
                "number" === typeof f && a < f && (a = f)
            }
            return a
        },
        min(...d) {
            let a = d[0];
            "number" !== typeof a && (a = 0);
            for (let b = 1, c = d.length; b < c; ++b) {
                let f = d[b];
                "number" === typeof f && a > f && (a = f)
            }
            return a
        },
        clamp(d, a, b) {
            return e.clamp(d, a, b)
        },
        distance(d, a, b, c) {
            return e.distanceTo(d, a, b, c)
        },
        angle(d, a, b, c) {
            return e.toDegrees(e.angleTo(d, a, b, c))
        },
        lerp(d,
            a, b) {
            return e.lerp(d, a, b)
        },
        unlerp(d, a, b) {
            return e.unlerp(d, a, b)
        },
        qarp(d, a, b, c) {
            return e.qarp(d, a, b, c)
        },
        cubic(d, a, b, c, f) {
            return e.cubic(d, a, b, c, f)
        },
        cosp(d, a, b) {
            return e.cosp(d, a, b)
        },
        anglediff(d, a) {
            return e.toDegrees(e.angleDiff(e.toRadians(d), e.toRadians(a)))
        },
        anglelerp(d, a, b) {
            return e.toDegrees(e.angleLerp(e.toRadians(d), e.toRadians(a), b))
        },
        anglerotate(d, a, b) {
            return e.toDegrees(e.angleRotate(e.toRadians(d), e.toRadians(a), e.toRadians(b)))
        },
        setbit(d, a, b) {
            a |= 0;
            return (d | 0) & ~(1 << a) | (0 !== b ? 1 : 0) << a
        },
        togglebit(d,
            a) {
            return (d | 0) ^ 1 << (a | 0)
        },
        getbit(d, a) {
            return (d | 0) & 1 << (a | 0) ? 1 : 0
        },
        newline() {
            return "\n"
        },
        uppercase(d) {
            return "string" === typeof d ? d.toUpperCase() : ""
        },
        lowercase(d) {
            return "string" === typeof d ? d.toLowerCase() : ""
        },
        left(d, a) {
            return "string" === typeof d ? d.substr(0, a) : ""
        },
        mid(d, a, b) {
            return "string" !== typeof d ? "" : 0 > b ? d.substr(a) : d.substr(a, b)
        },
        right(d, a) {
            return "string" === typeof d ? d.substr(d.length - a) : ""
        },
        trim(d) {
            return "string" === typeof d ? d.trim() : ""
        },
        tokenat(d, a, b) {
            if ("string" !== typeof d || "string" !== typeof b) return "";
            d = d.split(b);
            a = Math.floor(a);
            return 0 > a || a >= d.length ? "" : d[a]
        },
        tokencount(d, a) {
            return "string" === typeof d && "string" === typeof a && d.length ? d.split(a).length : 0
        },
        find(d, a) {
            return "string" === typeof d && "string" === typeof a ? d.search(new RegExp(e.EscapeRegex(a), "i")) : -1
        },
        findcase(d, a) {
            return "string" === typeof d && "string" === typeof a ? d.search(new RegExp(e.EscapeRegex(a), "")) : -1
        },
        replace(d, a, b) {
            return "string" === typeof d && "string" === typeof a && "string" === typeof b ? d.replace(new RegExp(e.EscapeRegex(a), "gi"), b) : "string" ===
                typeof d ? d : ""
        },
        regexsearch(d, a, b) {
            a = this.GetRegex(a, b);
            return d ? d.search(a) : -1
        },
        regexreplace(d, a, b, c) {
            a = this.GetRegex(a, b);
            return d ? d.replace(a, c) : ""
        },
        regexmatchcount(d, a, b) {
            return (d = this.GetRegexMatches(d.toString(), a, b)) ? d.length : 0
        },
        regexmatchat(d, a, b, c) {
            c = Math.floor(c);
            d = this.GetRegexMatches(d.toString(), a, b);
            return !d || 0 > c || c >= d.length ? "" : d[c]
        },
        zeropad(d, a) {
            let b = 0 > d ? "-" : "";
            0 > d && (d = -d);
            b += "0".repeat(Math.max(a - d.toString().length, 0));
            return b + d.toString()
        },
        urlencode(d) {
            return encodeURIComponent(d)
        },
        urldecode(d) {
            return decodeURIComponent(d)
        },
        dt() {
            return this._runtime._GetDtFast()
        },
        timescale() {
            return this._runtime.GetTimeScale()
        },
        wallclocktime() {
            return (Date.now() - this._runtime.GetStartTime()) / 1E3
        },
        unixtime() {
            return Date.now()
        },
        time() {
            return this._runtime.GetGameTime()
        },
        tickcount() {
            return this._runtime.GetTickCount()
        },
        objectcount() {
            return this._runtime.GetObjectCount()
        },
        fps() {
            return this._runtime.GetFPS()
        },
        cpuutilisation() {
            return this._runtime.GetMainThreadTime()
        },
        gpuutilisation() {
            return this._runtime.GetGPUUtilisation()
        },
        windowwidth() {
            return this._runtime.GetCanvasManager().GetDeviceWidth()
        },
        windowheight() {
            return this._runtime.GetCanvasManager().GetDeviceHeight()
        },
        originalwindowwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalwindowheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        originalviewportwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalviewportheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        scrollx() {
            return this._runtime.GetCurrentLayout().GetScrollX()
        },
        scrolly() {
            return this._runtime.GetCurrentLayout().GetScrollY()
        },
        layoutname() {
            return this._runtime.GetCurrentLayout().GetName()
        },
        layoutscale() {
            return this._runtime.GetCurrentLayout().GetScale()
        },
        layoutangle() {
            return e.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
        },
        layoutwidth() {
            return this._runtime.GetCurrentLayout().GetWidth()
        },
        layoutheight() {
            return this._runtime.GetCurrentLayout().GetHeight()
        },
        viewportleft(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetViewport3D().getLeft() :
                0
        },
        viewporttop(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetViewport3D().getTop() : 0
        },
        viewportright(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetViewport3D().getRight() : 0
        },
        viewportbottom(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetViewport3D().getBottom() : 0
        },
        viewportwidth(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetViewport3D().width() : 0
        },
        viewportheight(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetViewport3D().height() :
                0
        },
        canvastolayerx(d, a, b) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.CanvasCssToLayer(a, b)[0] : 0
        },
        canvastolayery(d, a, b) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.CanvasCssToLayer(a, b)[1] : 0
        },
        layertocanvasx(d, a, b) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.LayerToCanvasCss(a, b)[0] : 0
        },
        layertocanvasy(d, a, b) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.LayerToCanvasCss(a, b)[1] : 0
        },
        layerscale(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetOwnScale() :
                0
        },
        layerangle(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? e.toDegrees(d.GetOwnAngle()) : 0
        },
        layeropacity(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? 100 * d.GetOpacity() : 0
        },
        layerscalerate(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetScaleRate() : 0
        },
        layerscrollx(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetScrollX() : 0
        },
        layerscrolly(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetScrollY() : 0
        },
        layerparallaxx(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ?
                100 * d.GetParallaxX() : 0
        },
        layerparallaxy(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? 100 * d.GetParallaxY() : 0
        },
        layerzelevation(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetZElevation() : 0
        },
        layerindex(d) {
            return (d = this._runtime.GetCurrentLayout().GetLayer(d)) ? d.GetIndex() : -1
        },
        canvassnapshot() {
            const d = this._runtime.GetCanvasManager();
            return d ? d.GetCanvasSnapshotUrl() : ""
        },
        loopindex(d) {
            const a = this._loopStack;
            return a.IsInLoop() ? d ? (d = a.FindByName(d)) ? d.GetIndex() : 0 : a.GetCurrent().GetIndex() :
                0
        },
        savestatejson() {
            return this._runtime.GetLastSaveJsonString()
        },
        callmapped(d, a, ...b) {
            var c = this._GetFunctionMap(d.toLowerCase(), !1);
            if (!c) return console.warn(`[Construct 3] Call mapped function: map name '${d}' not found; returning 0`), 0;
            var f = c.strMap.get(a.toLowerCase());
            if (!f)
                if (c.defaultFunc) f = c.defaultFunc;
                else return console.warn(`[Construct 3] Call mapped function: no function associated with map '${d}' string '${a}'; returning 0 (consider setting a default)`), 0;
            c = f.GetReturnType();
            const h =
                f.GetDefaultReturnValue();
            if (0 === c) return console.warn(`[Construct 3] Call mapped function: map '${d}' string '${a}' has no return type so cannot be called from an expression; returning 0`), 0;
            if (!f.IsEnabled()) return h;
            d = this._runtime.GetEventSheetManager();
            a = d.GetCurrentEvent().GetSolModifiersIncludingParents();
            const g = 0 < a.length;
            g && d.PushCleanSol(a);
            const k = f.GetFunctionParameters();
            for (let m = b.length, r = k.length; m < r; ++m) b.push(k[m].GetInitialValue());
            f = f.GetEventBlock();
            b = f.RunAsExpressionFunctionCall(f.GetSolModifiersIncludingParents(),
                c, h, ...b);
            g && d.PopSol(a);
            return b
        },
        loadingprogress() {
            return this._runtime.GetAssetManager().GetLoadProgress()
        },
        imageloadingprogress() {
            return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
        },
        renderer() {
            return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl"
        },
        rendererdetail() {
            return this._runtime.GetWebGPURenderer() ? "<unavailable>" : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
        },
        imagememoryusage() {
            let d = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
            return Math.round(100 * d / 1048576) / 100
        },
        rgb(d, a, b) {
            return e.PackRGB(d, a, b)
        },
        rgbex(d, a, b) {
            return e.PackRGBEx(d / 100, a / 100, b / 100)
        },
        rgba(d, a, b, c) {
            return e.PackRGBAEx(d / 100, a / 100, b / 100, c / 100)
        },
        rgbex255(d, a, b) {
            return e.PackRGBEx(d / 255, a / 255, b / 255)
        },
        rgba255(d, a, b, c) {
            return e.PackRGBAEx(d / 255, a / 255, b / 255, c / 255)
        },
        projectname() {
            return this._runtime.GetProjectName()
        },
        projectversion() {
            return this._runtime.GetProjectVersion()
        },
        currenteventsheetname() {
            return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
        },
        currenteventnumber() {
            return this._runtime.GetCurrentEvent().GetDisplayNumber()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        LoadTextures(d) {}
        ReleaseTextures() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = [0, 0, 0],
        b = ["left", "center", "right"],
        c = ["top", "center", "bottom"],
        f = new e.Rect,
        h = new e.Quad,
        g = new e.Color;
    e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
        constructor(p, t) {
            super(p);
            this._text = "";
            this._enableBBcode = !0;
            this._faceName = "Arial";
            this._ptSize = 12;
            this._lineHeightOffset = 0;
            this._isItalic = this._isBold = !1;
            this._color = e.New(e.Color);
            this._verticalAlign = this._horizontalAlign = 0;
            this._wrapByWord = !0;
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._rendererText = e.New(e.Gfx.RendererText, this._runtime.GetRenderer(), {
                timeout: 5
            });
            this._rendererText.ontextureupdate = () => this._runtime.UpdateRender();
            this._rendererText.SetIsAsync(!1);
            t && (this._text = t[0], this._enableBBcode = !!t[1], this._faceName = t[2], this._ptSize = t[3], this._lineHeightOffset = t[4], this._isBold = !!t[5], this._isItalic = !!t[6], this._horizontalAlign = t[8], this._verticalAlign = t[9], this._wrapByWord = 0 === t[10], p = t[7], this._color.setRgb(p[0], p[1], p[2]), this.GetWorldInfo().SetVisible(t[11]));
            this._UpdateTextSettings()
        }
        Release() {
            this._CancelTypewriter();
            this._rendererText.Release();
            this._rendererText = null;
            super.Release()
        }
        _UpdateTextSettings() {
            const p = this._rendererText;
            p.SetText(this._text);
            p.SetBBCodeEnabled(this._enableBBcode);
            p.SetFontName(this._faceName);
            p.SetLineHeight(this._lineHeightOffset);
            p.SetBold(this._isBold);
            p.SetItalic(this._isItalic);
            p.SetColor(this._color);
            p.SetHorizontalAlignment(b[this._horizontalAlign]);
            p.SetVerticalAlignment(c[this._verticalAlign]);
            p.SetWordWrapMode(this._wrapByWord ?
                "word" : "character")
        }
        _UpdateTextSize() {
            const p = this.GetWorldInfo();
            this._rendererText.SetFontSize(this._ptSize);
            this._rendererText.SetFontSizeScale(p.GetSceneGraphScale());
            var t = p.GetLayer();
            t = t.GetRenderScale() * t.Get2DScaleFactorToZ(p.GetTotalZElevation());
            this._rendererText.SetSize(p.GetWidth(), p.GetHeight(), t)
        }
        Draw(p) {
            var t = this.GetWorldInfo();
            this._UpdateTextSize();
            const u = this._rendererText.GetTexture();
            if (u) {
                var q = t.GetLayer();
                if (0 === t.GetAngle() && 0 === q.GetAngle() && 0 === t.GetTotalZElevation() &&
                    !t.HasMesh() && q.RendersIn2DMode()) {
                    t = t.GetBoundingQuad();
                    const [x, y] = q.LayerToDrawSurface(t.getTlx(), t.getTly()), [B, F] = q.LayerToDrawSurface(t.getBrx(), t.getBry());
                    t = x - Math.round(x);
                    const H = y - Math.round(y);
                    f.set(x, y, B, F);
                    f.offset(-t, -H);
                    h.setFromRect(f);
                    const [K, C] = p.GetRenderTargetSize(p.GetRenderTarget());
                    this._runtime.GetCanvasManager().SetDeviceTransform(p, K, C);
                    p.SetTexture(u);
                    p.Quad3(h, this._rendererText.GetTexRect());
                    q._SetTransform(p)
                } else p.SetTexture(u), t.HasMesh() ? this._DrawMesh(t, p) : this._DrawStandard(t,
                    p)
            }
        }
        _DrawStandard(p, t) {
            p = p.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (p = this._PixelRoundQuad(p));
            t.Quad3(p, this._rendererText.GetTexRect())
        }
        _DrawMesh(p, t) {
            const u = p.GetTransformedMesh();
            if (p.IsMeshChanged()) {
                p.CalculateBbox(f, h, !1);
                let q = h;
                this._runtime.IsPixelRoundingEnabled() && (q = this._PixelRoundQuad(q));
                u.CalculateTransformedMesh(p.GetSourceMesh(), q, this._rendererText.GetTexRect());
                p.SetMeshChanged(!1)
            }
            u.Draw(t)
        }
        _PixelRoundQuad(p) {
            const t = p.getTlx() - Math.round(p.getTlx()),
                u = p.getTly() -
                Math.round(p.getTly());
            if (0 === t && 0 === u) return p;
            h.copy(p);
            h.offset(-t, -u);
            return h
        }
        SaveToJson() {
            const p = {
                t: this._text,
                c: this._color.toJSON(),
                fn: this._faceName,
                ps: this._ptSize
            };
            this._enableBBcode && (p.bbc = this._enableBBcode);
            0 !== this._horizontalAlign && (p.ha = this._horizontalAlign);
            0 !== this._verticalAlign && (p.va = this._verticalAlign);
            this._wrapByWord || (p.wr = this._wrapByWord);
            0 !== this._lineHeightOffset && (p.lho = this._lineHeightOffset);
            this._isBold && (p.b = this._isBold);
            this._isItalic && (p.i = this._isItalic); -
            1 !== this._typewriterEndTime && (p.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            });
            return p
        }
        LoadFromJson(p) {
            this._CancelTypewriter();
            this._text = p.t;
            this._color.setFromJSON(p.c);
            this._faceName = p.fn;
            this._ptSize = p.ps;
            this._enableBBcode = p.hasOwnProperty("bbc") ? p.bbc : !1;
            this._horizontalAlign = p.hasOwnProperty("ha") ? p.ha : 0;
            this._verticalAlign = p.hasOwnProperty("va") ? p.va : 0;
            this._wrapByWord = p.hasOwnProperty("wr") ? p.wr : !0;
            this._lineHeightOffset = p.hasOwnProperty("lho") ?
                p.lho : 0;
            this._isBold = p.hasOwnProperty("b") ? p.b : !1;
            this._isItalic = p.hasOwnProperty("i") ? p.i : !1;
            p.hasOwnProperty("tw") && (p = p.tw, this._typewriterStartTime = p.st, this._typewriterEndTime = p.en, this._typewriterLength = p.l);
            this._UpdateTextSettings(); - 1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(p) {
            switch (p) {
                case 0:
                    return this._text;
                case 1:
                    return this._enableBBcode;
                case 2:
                    return this._faceName;
                case 3:
                    return this._ptSize;
                case 4:
                    return this._lineHeightOffset;
                case 5:
                    return this._isBold;
                case 6:
                    return this._isItalic;
                case 7:
                    return a[0] = this._color.getR(), a[1] = this._color.getG(), a[2] = this._color.getB(), a;
                case 8:
                    return this._horizontalAlign;
                case 9:
                    return this._verticalAlign;
                case 10:
                    return this._wrapByWord ? 1 : 0
            }
        }
        SetPropertyValueByIndex(p, t) {
            switch (p) {
                case 0:
                    if (this._text === t) break;
                    this._text = t;
                    this._UpdateTextSettings();
                    break;
                case 1:
                    if (this._enableBBcode === !!t) break;
                    this._enableBBcode = !!t;
                    this._UpdateTextSettings();
                    break;
                case 2:
                    if (this._faceName === t) break;
                    this._faceName = t;
                    this._UpdateTextSettings();
                    break;
                case 3:
                    if (this._ptSize === t) break;
                    this._ptSize = t;
                    this._UpdateTextSettings();
                    break;
                case 4:
                    if (this._lineHeightOffset === t) break;
                    this._lineHeightOffset = t;
                    this._UpdateTextSettings();
                    break;
                case 5:
                    if (this._isBold === !!t) break;
                    this._isBold = !!t;
                    this._UpdateTextSettings();
                    break;
                case 6:
                    if (this._isItalic === !!t) break;
                    this._isItalic = !!t;
                    this._UpdateTextSettings();
                    break;
                case 7:
                    p = this._color;
                    if (p.getR() === t[0] && p.getG() === t[1] && p.getB() === t[2]) break;
                    this._color.setRgb(t[0], t[1], t[2]);
                    this._UpdateTextSettings();
                    break;
                case 8:
                    if (this._horizontalAlign === t) break;
                    this._horizontalAlign = t;
                    this._UpdateTextSettings();
                    break;
                case 9:
                    if (this._verticalAlign === t) break;
                    this._verticalAlign = t;
                    this._UpdateTextSettings();
                    break;
                case 10:
                    this._wrapByWord !== (0 === t) && (this._wrapByWord = 0 === t, this._UpdateTextSettings())
            }
        }
        SetPropertyColorOffsetValueByIndex(p, t, u, q) {
            if (0 !== t || 0 !== u || 0 !== q) switch (p) {
                case 7:
                    this._color.addRgb(t, u, q), this._UpdateTextSettings()
            }
        }
        _SetText(p) {
            this._text !== p && (this._text = p, this._rendererText.SetText(p), this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(p,
            t) {
            this._SetText(p);
            this._typewriterStartTime = this._runtime.GetWallTime();
            this._typewriterEndTime = this._typewriterStartTime + t / this.GetInstance().GetActiveTimeScale();
            this._typewriterLength = e.BBString.StripAnyTags(p).length;
            this._rendererText.SetDrawMaxCharacterCount(0);
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._rendererText.SetDrawMaxCharacterCount(-1);
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 !== this._typewriterEndTime &&
                (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
        }
        _SetFontFace(p) {
            this._faceName !== p && (this._faceName = p, this._rendererText.SetFontName(p), this._runtime.UpdateRender())
        }
        _GetFontFace() {
            return this._faceName
        }
        _SetBold(p) {
            p = !!p;
            this._isBold !== p && (this._isBold = p, this._rendererText.SetBold(p), this._runtime.UpdateRender())
        }
        _IsBold() {
            return this._isBold
        }
        _SetItalic(p) {
            p = !!p;
            this._isItalic !== p && (this._isItalic = p, this._rendererText.SetItalic(p),
                this._runtime.UpdateRender())
        }
        _IsItalic() {
            return this._isItalic
        }
        _SetFontSize(p) {
            this._ptSize !== p && (this._ptSize = p, this._runtime.UpdateRender())
        }
        _GetFontSize() {
            return this._ptSize
        }
        _SetFontColor(p) {
            this._color.equalsIgnoringAlpha(p) || (this._color.copyRgb(p), this._rendererText.SetColor(this._color), this._runtime.UpdateRender())
        }
        _GetFontColor() {
            return this._color
        }
        _SetLineHeight(p) {
            this._lineHeightOffset !== p && (this._lineHeightOffset = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeightOffset
        }
        _SetHAlign(p) {
            this._horizontalAlign !==
                p && (this._horizontalAlign = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(p) {
            this._verticalAlign !== p && (this._verticalAlign = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(p) {
            p = !!p;
            this._wrapByWord !== p && (this._wrapByWord = p, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        _GetTextWidth() {
            this._UpdateTextSize();
            return this._rendererText.GetTextWidth()
        }
        _GetTextHeight() {
            this._UpdateTextSize();
            return this._rendererText.GetTextHeight()
        }
        Tick() {
            var p = this._runtime.GetWallTime();
            p >= this._typewriterEndTime ? (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (p = e.relerp(this._typewriterStartTime, this._typewriterEndTime, p, 0, this._typewriterLength), p = Math.floor(p), p !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(p), this._runtime.UpdateRender()))
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.text.name",
                properties: [{
                    name: "plugins.text.properties.text.name",
                    value: this._text,
                    onedit: p => this._SetText(p)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInstance
        }
    };
    const k = new WeakMap,
        m = new Map([
            ["left", 0],
            ["center", 1],
            ["right", 2]
        ]),
        r = new Map([
            ["top", 0],
            ["center", 1],
            ["bottom", 2]
        ]),
        w = new Map([
            ["word", !0],
            ["character", !1]
        ]);
    self.ITextInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            k.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return k.get(this).GetText()
        }
        set text(p) {
            d.RequireString(p);
            const t = k.get(this);
            t._CancelTypewriter();
            t._SetText(p)
        }
        typewriterText(p, t) {
            d.RequireString(p);
            d.RequireFiniteNumber(t);
            const u = k.get(this);
            u._CancelTypewriter();
            u._StartTypewriter(p, t)
        }
        typewriterFinish() {
            k.get(this)._FinishTypewriter()
        }
        set fontFace(p) {
            d.RequireString(p);
            k.get(this)._SetFontFace(p)
        }
        get fontFace() {
            return k.get(this)._GetFontFace()
        }
        set isBold(p) {
            k.get(this)._SetBold(p)
        }
        get isBold() {
            return k.get(this)._IsBold()
        }
        set isItalic(p) {
            k.get(this)._SetItalic(p)
        }
        get isItalic() {
            return k.get(this)._IsItalic()
        }
        set sizePt(p) {
            d.RequireFiniteNumber(p);
            k.get(this)._SetFontSize(p)
        }
        get sizePt() {
            return k.get(this)._GetFontSize()
        }
        set fontColor(p) {
            d.RequireArray(p);
            if (3 > p.length) throw Error("expected 3 elements");
            g.setRgb(p[0], p[1], p[2]);
            k.get(this)._SetFontColor(g)
        }
        get fontColor() {
            const p = k.get(this)._GetFontColor();
            return [p.getR(), p.getG(), p.getB()]
        }
        set lineHeight(p) {
            d.RequireFiniteNumber(p);
            k.get(this)._SetLineHeight(p)
        }
        get lineHeight() {
            return k.get(this)._GetLineHeight()
        }
        set horizontalAlign(p) {
            d.RequireString(p);
            p = m.get(p);
            if ("undefined" === typeof p) throw Error("invalid mode");
            k.get(this)._SetHAlign(p)
        }
        get horizontalAlign() {
            return b[k.get(this)._GetHAlign()]
        }
        set verticalAlign(p) {
            d.RequireString(p);
            p = r.get(p);
            if ("undefined" === typeof p) throw Error("invalid mode");
            k.get(this)._SetVAlign(p)
        }
        get verticalAlign() {
            return c[k.get(this)._GetVAlign()]
        }
        set wordWrapMode(p) {
            d.RequireString(p);
            p = w.get(p);
            if ("undefined" === typeof p) throw Error("invalid mode");
            k.get(this)._SetWrapByWord(p)
        }
        get wordWrapMode() {
            return k.get(this)._IsWrapByWord() ? "word" : "character"
        }
        get textWidth() {
            return k.get(this)._GetTextWidth()
        }
        get textHeight() {
            return k.get(this)._GetTextHeight()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text.Cnds = {
        CompareText(d, a) {
            return a ? this._text === d : e.equalsNoCase(this._text, d)
        },
        IsRunningTypewriterText() {
            return -1 !== this._typewriterEndTime
        },
        OnTypewriterTextFinished() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.New(e.Color);
    e.Plugins.Text.Acts = {
        SetText(a) {
            this._CancelTypewriter();
            "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
            this._SetText(a.toString())
        },
        AppendText(a) {
            this._CancelTypewriter();
            "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
            (a = a.toString()) && this._SetText(this._text + a)
        },
        TypewriterText(a, b) {
            this._CancelTypewriter();
            "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
            this._StartTypewriter(a.toString(), b)
        },
        SetFontFace(a, b) {
            let c = !1,
                f = !1;
            switch (b) {
                case 1:
                    c = !0;
                    break;
                case 2:
                    f = !0;
                    break;
                case 3:
                    f = c = !0
            }
            if (a !== this._faceName || c !== this._isBold || f !== this._isItalic) this._SetFontFace(a), this._SetBold(c), this._SetItalic(f)
        },
        SetFontSize(a) {
            this._SetFontSize(a)
        },
        SetFontColor(a) {
            d.setFromRgbValue(a);
            d.clamp();
            this._SetFontColor(d)
        },
        SetWebFont(a, b) {
            console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
        },
        SetEffect(a) {
            this.GetWorldInfo().SetBlendMode(a);
            this._runtime.UpdateRender()
        },
        TypewriterFinish() {
            this._FinishTypewriter()
        },
        SetLineHeight(a) {
            this._SetLineHeight(a)
        },
        SetHAlign(a) {
            this._SetHAlign(a)
        },
        SetVAlign(a) {
            this._SetVAlign(a)
        },
        SetWrapping(a) {
            this._SetWrapByWord(0 === a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text.Exps = {
        Text() {
            return this._text
        },
        PlainText() {
            return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text
        },
        FaceName() {
            return this._faceName
        },
        FaceSize() {
            return this._ptSize
        },
        TextWidth() {
            return this._GetTextWidth()
        },
        TextHeight() {
            return this._GetTextHeight()
        },
        LineHeight() {
            return this._lineHeightOffset
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.TextBox = class extends e.SDKDOMPluginBase {
        constructor(d) {
            super(d, "text-input");
            this.AddElementMessageHandler("click", (a, b) => a._OnClick(b));
            this.AddElementMessageHandler("dblclick", (a, b) => a._OnDoubleClick(b));
            this.AddElementMessageHandler("change", (a, b) => a._OnChange(b))
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.TextBox.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = "text password email number tel url textarea search".split(" ");
    e.Plugins.TextBox.Instance = class extends e.SDKDOMInstanceBase {
        constructor(c, f) {
            super(c, "text-input");
            this._title = this._placeholder = this._text = "";
            this._isEnabled = !0;
            this._spellCheck = this._isReadOnly = !1;
            this._type = "text";
            this._autoFontSize = !0;
            this._maxLength = -1;
            this._id = "";
            f && (this._text = f[0], this._placeholder = f[1], this._title = f[2], this.GetWorldInfo().SetVisible(f[3]), this._isEnabled = f[4], this._isReadOnly =
                f[5], this._spellCheck = f[6], this._type = a[f[7]], this._autoFontSize = f[8], this._id = f[9]);
            this.CreateElement({
                type: this._type,
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                text: this._text,
                placeholder: this._placeholder,
                title: this._title,
                isEnabled: this._isEnabled,
                isReadOnly: this._isReadOnly,
                spellCheck: this._spellCheck,
                maxLength: this._maxLength
            }
        }
        async _OnClick(c) {
            this.GetScriptInterface().dispatchEvent(e.New(e.Event, "click", !0));
            await this.TriggerAsync(e.Plugins.TextBox.Cnds.OnClicked)
        }
        async _OnDoubleClick(c) {
            this.GetScriptInterface().dispatchEvent(e.New(e.Event,
                "dblclick", !0));
            await this.TriggerAsync(e.Plugins.TextBox.Cnds.OnDoubleClicked)
        }
        async _OnChange(c) {
            this._text = c.text;
            this.GetScriptInterface().dispatchEvent(e.New(e.Event, "change", !0));
            await this.TriggerAsync(e.Plugins.TextBox.Cnds.OnTextChanged)
        }
        _SetText(c) {
            this._text !== c && (this._text = c, this.UpdateElementState())
        }
        _GetText() {
            return this._text
        }
        _SetPlaceholder(c) {
            this._placeholder !== c && (this._placeholder = c, this.UpdateElementState())
        }
        _GetPlaceholder() {
            return this._placeholder
        }
        _SetTooltip(c) {
            this._title !==
                c && (this._title = c, this.UpdateElementState())
        }
        _GetTooltip() {
            return this._title
        }
        _SetEnabled(c) {
            c = !!c;
            this._isEnabled !== c && (this._isEnabled = c, this.UpdateElementState())
        }
        _IsEnabled() {
            return this._isEnabled
        }
        _SetReadOnly(c) {
            c = !!c;
            this._isReadOnly !== c && (this._isReadOnly = c, this.UpdateElementState())
        }
        _IsReadOnly() {
            return this._isReadOnly
        }
        _SetMaxLength(c) {
            c = Math.max(+c, -1);
            this._maxLength !== c && (this._maxLength = c, this.UpdateElementState())
        }
        _GetMaxLength() {
            return this._maxLength
        }
        _ScrollToBottom() {
            Promise.resolve().then(() =>
                this.PostToDOMElement("scroll-to-bottom"))
        }
        Draw(c) {}
        SaveToJson() {
            return {
                t: this._text,
                p: this._placeholder,
                ti: this._title,
                e: this._isEnabled,
                r: this._isReadOnly,
                sp: this._spellCheck,
                ml: this._maxLength,
                type: this._type,
                id: this._id
            }
        }
        LoadFromJson(c) {
            this._text = c.t;
            this._placeholder = c.p;
            this._title = c.ti;
            this._isEnabled = c.e;
            this._isReadOnly = c.r;
            this._spellCheck = c.sp;
            this._maxLength = c.hasOwnProperty("ml") ? c.ml : -1;
            this._type = c.type;
            this._id = c.id;
            this.UpdateElementState()
        }
        GetPropertyValueByIndex(c) {
            switch (c) {
                case 0:
                    return this._text;
                case 1:
                    return this._placeholder;
                case 2:
                    return this._title;
                case 4:
                    return this._isEnabled;
                case 5:
                    return this._isReadOnly;
                case 6:
                    return this._spellCheck;
                case 8:
                    return this._autoFontSize;
                case 9:
                    return this._id
            }
        }
        SetPropertyValueByIndex(c, f) {
            switch (c) {
                case 0:
                    if (this._text === f) break;
                    this._text = f;
                    this.UpdateElementState();
                    break;
                case 1:
                    if (this._placeholder === f) break;
                    this._placeholder = f;
                    this.UpdateElementState();
                    break;
                case 2:
                    if (this._title === f) break;
                    this._title = f;
                    this.UpdateElementState();
                    break;
                case 4:
                    if (this._isEnabled ===
                        !!f) break;
                    this._isEnabled = !!f;
                    this.UpdateElementState();
                    break;
                case 5:
                    if (this._isReadOnly === !!f) break;
                    this._isReadOnly = !!f;
                    this.UpdateElementState();
                    break;
                case 6:
                    if (this._spellCheck === !!f) break;
                    this._spellCheck = !!f;
                    this.UpdateElementState();
                    break;
                case 8:
                    this._autoFontSize = !!f;
                    break;
                case 9:
                    this._id !== f && (this._id = f, this.UpdateElementState())
            }
        }
        GetDebuggerProperties() {
            const c = e.Plugins.TextBox.Acts;
            return [{
                title: "plugins.textbox.name",
                properties: [{
                    name: "plugins.textbox.properties.text.name",
                    value: this._text,
                    onedit: f => this.CallAction(c.SetText, f)
                }, {
                    name: "plugins.textbox.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: f => this.CallAction(c.SetEnabled, f)
                }, {
                    name: "plugins.textbox.properties.read-only.name",
                    value: this._isReadOnly,
                    onedit: f => this.CallAction(c.SetReadOnly, f)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInputInstance
        }
    };
    const b = new WeakMap;
    self.ITextInputInstance = class extends self.IDOMInstance {
        constructor() {
            super();
            b.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set text(c) {
            d.RequireString(c);
            b.get(this)._SetText(c)
        }
        get text() {
            return b.get(this)._GetText()
        }
        set placeholder(c) {
            d.RequireString(c);
            b.get(this)._SetPlaceholder(c)
        }
        get placeholder() {
            return b.get(this)._GetPlaceholder()
        }
        set tooltip(c) {
            d.RequireString(c);
            b.get(this)._SetTooltip(c)
        }
        get tooltip() {
            return b.get(this)._GetTooltip()
        }
        set isEnabled(c) {
            b.get(this)._SetEnabled(c)
        }
        get isEnabled() {
            return b.get(this)._IsEnabled()
        }
        set isReadOnly(c) {
            b.get(this)._SetReadOnly(c)
        }
        get isReadOnly() {
            return b.get(this)._IsReadOnly()
        }
        set maxLength(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetMaxLength(c)
        }
        get maxLength() {
            return b.get(this)._GetMaxLength()
        }
        scrollToBottom() {
            b.get(this)._ScrollToBottom()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.TextBox.Cnds = {
        CompareText(d, a) {
            return 0 === a ? e.equalsNoCase(this._text, d) : this._text === d
        },
        OnTextChanged() {
            return !0
        },
        OnClicked() {
            return !0
        },
        OnDoubleClicked() {
            return !0
        }
    }
}
"use strict";
self.C3.Plugins.TextBox.Acts = {
    SetText(e) {
        this._SetText(e.toString())
    },
    AppendText(e) {
        "" !== e && this._SetText(this._GetText() + e)
    },
    SetPlaceholder(e) {
        this._SetPlaceholder(e)
    },
    SetTooltip(e) {
        this._SetTooltip(e)
    },
    SetReadOnly(e) {
        this._SetReadOnly(0 === e)
    },
    ScrollToBottom() {
        this._ScrollToBottom()
    },
    SetMaxLength(e) {
        this._SetMaxLength(e)
    }
};
"use strict";
self.C3.Plugins.TextBox.Exps = {
    Text() {
        return this._GetText()
    },
    MaxLength() {
        return this._GetMaxLength()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Spritefont2 = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Spritefont2.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d);
            this._spriteFont = e.New(self.SpriteFont)
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(d) {
            return this.GetImageInfo().LoadStaticTexture(d, {
                sampling: this._runtime.GetSampling()
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        UpdateSettings(d, a, b, c) {
            const f = this.GetImageInfo(),
                h = this._spriteFont;
            h.SetWidth(f.GetWidth());
            h.SetHeight(f.GetHeight());
            h.SetCharacterWidth(d);
            h.SetCharacterHeight(a);
            h.SetCharacterSet(b);
            h.SetSpacingData(c);
            h.UpdateCharacterMap()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = ["left", "center", "right"],
        b = ["top", "center", "bottom"];
    e.Plugins.Spritefont2.Instance = class extends e.SDKWorldInstanceBase {
        constructor(k, m) {
            super(k);
            this._text = "";
            this._enableBBcode = !0;
            this._characterHeight = this._characterWidth = 16;
            this._characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>";
            k = "";
            this._characterScale = 1;
            this._verticalAlign = this._horizontalAlign = this._lineHeight = this._characterSpacing =
                0;
            this._wrapByWord = !0;
            this._spriteFontText = null;
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            m && (this._text = m[0], this._enableBBcode = m[1], this._characterWidth = m[2], this._characterHeight = m[3], this._characterSet = m[4], k = m[5], this._characterScale = m[6], this._characterSpacing = m[7], this._lineHeight = m[8], this._horizontalAlign = m[9], this._verticalAlign = m[10], this._wrapByWord = 0 === m[11], this.GetWorldInfo().SetVisible(m[12]));
            this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight,
                this._characterSet, k);
            this._spriteFontText = e.New(self.SpriteFontText, this._sdkType.GetSpriteFont());
            m = this.GetWorldInfo();
            this._spriteFontText.SetSize(m.GetWidth(), m.GetHeight());
            this._UpdateSettings();
            this._inst.SetMustMitigateZFighting()
        }
        Release() {
            this._CancelTypewriter();
            this._spriteFontText.Release();
            this._spriteFontText = null;
            super.Release()
        }
        _UpdateSettings() {
            const k = this._spriteFontText;
            k && (k.SetBBCodeEnabled(this._enableBBcode), k.SetText(this._text), k.SetWordWrapMode(this._wrapByWord ? "word" :
                "character"), k.SetHorizontalAlign(a[this._horizontalAlign]), k.SetVerticalAlign(b[this._verticalAlign]), k.SetSpacing(this._characterSpacing), k.SetLineHeight(this._lineHeight))
        }
        Draw(k) {
            const m = this._objectClass.GetImageInfo();
            var r = m.GetTexture();
            if (r) {
                k.SetTexture(r);
                r = this.GetWorldInfo();
                var w = r.GetBoundingQuad(),
                    p = this._spriteFontText;
                p.SetScale(this._characterScale);
                p.SetSceneGraphScale(r.GetSceneGraphScale());
                this._runtime.IsPixelRoundingEnabled() && (w = r.PixelRoundQuad(w));
                p.SetSize(r.GetWidth(),
                    r.GetHeight());
                p.GetSpriteFont().SetTexRect(m.GetTexRect());
                p.SetColor(r.GetUnpremultipliedColor());
                p.Draw(k, w.getTlx(), w.getTly(), r.GetAngle())
            }
        }
        SaveToJson() {
            const k = {
                t: this._text,
                ebbc: this._enableBBcode,
                csc: this._characterScale,
                csp: this._characterSpacing,
                lh: this._lineHeight,
                ha: this._horizontalAlign,
                va: this._verticalAlign,
                w: this._wrapByWord,
                cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
                ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
                cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
                sd: this._sdkType.GetSpriteFont().GetSpacingData()
            }; - 1 !== this._typewriterEndTime && (k.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            });
            return k
        }
        LoadFromJson(k) {
            this._CancelTypewriter();
            this._text = k.t;
            this._enableBBcode = k.ebbc;
            this._characterScale = k.csc;
            this._characterSpacing = k.csp;
            this._lineHeight = k.lh;
            this._horizontalAlign = k.ha;
            this._verticalAlign = k.va;
            this._wrapByWord = k.w;
            if (k.hasOwnProperty("tw")) {
                var m = k.tw;
                this._typewriterStartTime = m.st;
                this._typewriterEndTime =
                    m.en;
                this._typewriterLength = k.l
            }
            m = this._sdkType.GetSpriteFont();
            m.SetCharacterWidth(k.cw);
            m.SetCharacterHeight(k.ch);
            m.SetCharacterSet(k.cs);
            m.SetSpacingData(k.sd);
            this._UpdateSettings(); - 1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(k) {
            switch (k) {
                case 0:
                    return this._text;
                case 1:
                    return this._enableBBcode;
                case 2:
                    return this._sdkType.GetSpriteFont().GetCharacterWidth();
                case 3:
                    return this._sdkType.GetSpriteFont().GetCharacterHeight();
                case 4:
                    return this._sdkType.GetSpriteFont().GetCharacterSet();
                case 5:
                    return this._sdkType.GetSpriteFont().GetSpacingData();
                case 6:
                    return this._characterScale;
                case 7:
                    return this._characterSpacing;
                case 8:
                    return this._lineHeight;
                case 9:
                    return this._horizontalAlign;
                case 10:
                    return this._verticalAlign;
                case 11:
                    return this._wrapByWord ? 1 : 0
            }
        }
        SetPropertyValueByIndex(k, m) {
            switch (k) {
                case 0:
                    if (this._text === m) break;
                    this._text = m;
                    this._UpdateSettings();
                    break;
                case 1:
                    if (this._enableBBcode === !!m) break;
                    this._enableBBcode = !!m;
                    this._UpdateSettings();
                    break;
                case 2:
                    this._sdkType.GetSpriteFont().SetCharacterWidth(m);
                    break;
                case 3:
                    this._sdkType.GetSpriteFont().SetCharacterHeight(m);
                    break;
                case 4:
                    this._sdkType.GetSpriteFont().SetCharacterSet(m);
                    break;
                case 5:
                    this._sdkType.GetSpriteFont().SetSpacingData(m);
                    break;
                case 6:
                    if (this._characterScale === m) break;
                    this._characterScale = m;
                    this._UpdateSettings();
                    break;
                case 7:
                    if (this._characterSpacing === m) break;
                    this._characterSpacing = m;
                    this._UpdateSettings();
                    break;
                case 8:
                    if (this._lineHeight === m) break;
                    this._lineHeight = m;
                    this._UpdateSettings();
                    break;
                case 9:
                    if (this._horizontalAlign ===
                        m) break;
                    this._horizontalAlign = m;
                    this._UpdateSettings();
                    break;
                case 10:
                    if (this._verticalAlign === m) break;
                    this._verticalAlign = m;
                    this._UpdateSettings();
                    break;
                case 11:
                    this._wrapByWord !== (0 === m) && (this._wrapByWord = 0 === m, this._UpdateSettings())
            }
        }
        _SetText(k) {
            this._text !== k && (this._text = k, this._spriteFontText.SetText(k), this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(k, m) {
            this._SetText(k);
            this._typewriterStartTime = this._runtime.GetWallTime();
            this._typewriterEndTime = this._typewriterStartTime +
                m / this.GetInstance().GetActiveTimeScale();
            this._typewriterLength = e.BBString.StripAnyTags(k).length;
            this._spriteFontText.SetDrawMaxCharacterCount(0);
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._spriteFontText.SetDrawMaxCharacterCount(-1);
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(e.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
        }
        _SetScale(k) {
            this._characterScale !==
                k && (this._characterScale = k, this._spriteFontText.SetScale(this._characterScale), this._runtime.UpdateRender())
        }
        _GetScale() {
            return this._characterScale
        }
        _SetCharacterSpacing(k) {
            this._characterSpacing !== k && (this._characterSpacing = k, this._spriteFontText.SetSpacing(this._characterSpacing), this._runtime.UpdateRender())
        }
        _GetCharacterSpacing() {
            return this._characterSpacing
        }
        _SetLineHeight(k) {
            this._lineHeight !== k && (this._lineHeight = k, this._spriteFontText.SetLineHeight(this._lineHeight), this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeight
        }
        _SetHAlign(k) {
            this._horizontalAlign !==
                k && (this._horizontalAlign = k, this._UpdateSettings(), this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(k) {
            this._verticalAlign !== k && (this._verticalAlign = k, this._UpdateSettings(), this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(k) {
            k = !!k;
            this._wrapByWord !== k && (this._wrapByWord = k, this._UpdateSettings(), this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        Tick() {
            var k = this._runtime.GetWallTime();
            k >= this._typewriterEndTime ?
                (this._CancelTypewriter(), this.Trigger(e.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (k = e.relerp(this._typewriterStartTime, this._typewriterEndTime, k, 0, this._typewriterLength), k = Math.floor(k), k !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(k), this._runtime.UpdateRender()))
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.spritefont2.name",
                properties: [{
                    name: "plugins.spritefont2.properties.text.name",
                    value: this._text,
                    onedit: k => this._SetText(k)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ISpriteFontInstance
        }
    };
    const c = new WeakMap,
        f = new Map([
            ["left", 0],
            ["center", 1],
            ["right", 2]
        ]),
        h = new Map([
            ["top", 0],
            ["center", 1],
            ["bottom", 2]
        ]),
        g = new Map([
            ["word", !0],
            ["character", !1]
        ]);
    self.ISpriteFontInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            c.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return c.get(this).GetText()
        }
        set text(k) {
            d.RequireString(k);
            const m = c.get(this);
            m._CancelTypewriter();
            m._SetText(k)
        }
        typewriterText(k, m) {
            d.RequireString(k);
            d.RequireFiniteNumber(m);
            const r = c.get(this);
            r._CancelTypewriter();
            r._StartTypewriter(k, m)
        }
        typewriterFinish() {
            c.get(this)._FinishTypewriter()
        }
        set characterScale(k) {
            d.RequireFiniteNumber(k);
            c.get(this)._SetScale(k)
        }
        get characterScale() {
            return c.get(this)._GetScale()
        }
        set characterSpacing(k) {
            d.RequireFiniteNumber(k);
            c.get(this)._SetCharacterSpacing(k)
        }
        get characterSpacing() {
            return c.get(this)._GetCharacterSpacing()
        }
        set lineHeight(k) {
            d.RequireFiniteNumber(k);
            c.get(this)._SetLineHeight(k)
        }
        get lineHeight() {
            return c.get(this)._GetLineHeight()
        }
        set horizontalAlign(k) {
            d.RequireString(k);
            k = f.get(k);
            if ("undefined" === typeof k) throw Error("invalid mode");
            c.get(this)._SetHAlign(k)
        }
        get horizontalAlign() {
            return a[c.get(this)._GetHAlign()]
        }
        set verticalAlign(k) {
            d.RequireString(k);
            k = h.get(k);
            if ("undefined" === typeof k) throw Error("invalid mode");
            c.get(this)._SetVAlign(k)
        }
        get verticalAlign() {
            return b[c.get(this)._GetVAlign()]
        }
        set wordWrapMode(k) {
            d.RequireString(k);
            k = g.get(k);
            if ("undefined" === typeof k) throw Error("invalid mode");
            c.get(this)._SetWrapByWord(k)
        }
        get wordWrapMode() {
            return c.get(this)._IsWrapByWord() ? "word" : "character"
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Spritefont2.Cnds = {
        CompareText(d, a) {
            return a ? this._text === d : e.equalsNoCase(this._text, d)
        },
        IsRunningTypewriterText() {
            return -1 !== this._typewriterEndTime
        },
        OnTypewriterTextFinished() {
            return !0
        }
    }
}
"use strict";
self.C3.Plugins.Spritefont2.Acts = {
    SetText(e) {
        this._CancelTypewriter();
        "number" === typeof e && 1E9 > e && (e = Math.round(1E10 * e) / 1E10);
        this._SetText(e.toString())
    },
    AppendText(e) {
        this._CancelTypewriter();
        "number" === typeof e && 1E9 > e && (e = Math.round(1E10 * e) / 1E10);
        (e = e.toString()) && this._SetText(this._text + e)
    },
    TypewriterText(e, d) {
        this._CancelTypewriter();
        "number" === typeof e && 1E9 > e && (e = Math.round(1E10 * e) / 1E10);
        this._StartTypewriter(e.toString(), d)
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetScale(e) {
        this._SetScale(e)
    },
    SetCharacterSpacing(e) {
        this._SetCharacterSpacing(e)
    },
    SetLineHeight(e) {
        this._SetLineHeight(e)
    },
    SetCharacterWidth(e, d) {
        let a = !1;
        const b = this._sdkType.GetSpriteFont();
        for (const c of e)
            if (" " === c) b.SetSpaceWidth(d), a = !0;
            else if (e = b.GetCharacter(c)) e.SetDisplayWidth(d), a = !0;
        a && b.SetCharacterWidthsChanged();
        this._runtime.UpdateRender()
    },
    SetEffect(e) {
        this.GetWorldInfo().SetBlendMode(e);
        this._runtime.UpdateRender()
    },
    SetHAlign(e) {
        this._SetHAlign(e)
    },
    SetVAlign(e) {
        this._SetVAlign(e)
    },
    SetWrapping(e) {
        this._SetWrapByWord(0 ===
            e)
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Spritefont2.Exps = {
        CharacterWidth(d) {
            return (d = this._sdkType.GetSpriteFont().GetCharacter(d)) ? d.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
        },
        CharacterHeight() {
            return this._characterHeight
        },
        CharacterScale() {
            return this._characterScale
        },
        CharacterSpacing() {
            return this._characterSpacing
        },
        LineHeight() {
            return this._lineHeight
        },
        Text() {
            return this._text
        },
        PlainText() {
            return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text
        },
        TextWidth() {
            const d =
                this.GetWorldInfo();
            this._spriteFontText.SetSize(d.GetWidth(), d.GetHeight());
            return this._spriteFontText.GetTextWidth()
        },
        TextHeight() {
            const d = this.GetWorldInfo();
            this._spriteFontText.SetSize(d.GetWidth(), d.GetHeight());
            return this._spriteFontText.GetTextHeight()
        }
    }
} {
    "use strict";
    const e = self.C3;
    self.SpriteFontCharacter = class {
        constructor(d, a, b, c) {
            let f = d.GetCharacterWidth(),
                h = d.GetCharacterHeight();
            this._spriteFont = d;
            this._char = a;
            this._pxRect = new e.Rect(b, c, b + f, c + h);
            this._texRect = new e.Rect;
            this._displayWidth = -1;
            this._UpdateTexRect()
        }
        Release() {
            this._texRect = this._pxRect = this._spriteFont = null
        }
        _UpdateTexRect() {
            let d = this._spriteFont.GetWidth(),
                a = this._spriteFont.GetHeight();
            this._texRect.copy(this._pxRect);
            this._texRect.divide(d, a);
            this._texRect.lerpInto(this._spriteFont.GetTexRect())
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        GetChar() {
            return this._char
        }
        GetTexRect() {
            return this._texRect
        }
        SetDisplayWidth(d) {
            this._displayWidth =
                d
        }
        GetDisplayWidth() {
            return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = new e.Rect,
        a = new e.Quad,
        b = new e.Color,
        c = new Set(["left", "center", "right"]),
        f = new Set(["top", "center", "bottom"]),
        h = new Set(["word", "character"]);
    self.SpriteFontText = class {
        constructor(g) {
            this._spriteFont = g;
            this._cssHeight = this._cssWidth = 0;
            this._text = "";
            this._isBBcodeEnabled = !1;
            this._bbString = null;
            this._wrappedText = e.New(e.WordWrap);
            this._wrapMode = "word";
            this._wrapChanged = !1;
            this._horizontalAlign = "left";
            this._verticalAlign = "top";
            this._sceneGraphScale = this._scale = 1;
            this._lineHeight =
                this._spacing = 0;
            this._color = e.New(e.Color);
            this._drawMaxCharCount = -1;
            this._drawCharCount = 0;
            this._measureTextCallback = (k, m) => this._MeasureText(k, m);
            this._spriteFont._AddSpriteFontText(this)
        }
        Release() {
            this._spriteFont._RemoveSpriteFontText(this);
            this._measureTextCallback = this._color = null;
            this._wrappedText.Clear();
            this._bbString = this._spriteFont = this._wrappedText = null
        }
        _MeasureText(g, k) {
            var m = this._GetStyleTag(k, "scale"),
                r = (m ? parseFloat(m.param) : this._scale) * this._sceneGraphScale;
            m = this._GetStyleTag(k,
                "scalex");
            m = (m ? parseFloat(m.param) : 1) * r;
            k = this._GetStyleTag(k, "scaley");
            k = (k ? parseFloat(k.param) : 1) * r;
            k = this._spriteFont.GetCharacterHeight() * k + this._lineHeight;
            const w = this.GetSpriteFont();
            r = w.GetCharacterWidth() * m;
            const p = this.GetSpacing();
            if (w.HasAnyCustomWidths()) {
                let u = 0,
                    q = 0;
                for (var t of g) {
                    g = r;
                    const x = w.GetCharacter(t);
                    x ? g = x.GetDisplayWidth() * m : " " === t && (g = w.GetSpaceWidth() * m);
                    q += g;
                    ++u
                }
                return {
                    width: q + u * p,
                    height: k
                }
            }
            t = [...g].length;
            return {
                width: r * t + Math.max(t, 0) * p,
                height: k
            }
        }
        _SetWrapChanged() {
            this._wrapChanged = !0;
            this._wrappedText.Clear()
        }
        SetSize(g, k) {
            0 >= g || 0 >= k || this._cssWidth === g && this._cssHeight === k || (this._cssWidth !== g && this._SetWrapChanged(), this._cssWidth = g, this._cssHeight = k)
        }
        SetDrawMaxCharacterCount(g) {
            this._drawMaxCharCount = Math.floor(g)
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(g, k) {
            for (let m = g.length - 1; 0 <= m; --m) {
                const r = g[m];
                if (r.tag === k) return r
            }
            return null
        }
        _HasStyleTag(g, k) {
            return !!this._GetStyleTag(g, k)
        }
        _MaybeWrapText() {
            if (this._wrapChanged) {
                !this._isBBcodeEnabled ||
                    this._bbString && this._bbString.toString() === this._text || (this._bbString = new e.BBString(this._text, {
                        noEscape: !0
                    }));
                var g = -this.GetSpacing();
                this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, g);
                this._wrapChanged = !1
            }
        }
        Draw(g, k, m, r) {
            this._MaybeWrapText();
            let w = this._drawCharCount = 0;
            const p = this._lineHeight,
                t = e.cloneArray(this._wrappedText.GetLines()),
                u = Math.sin(r);
            r = Math.cos(r);
            var q = t.reduce((x, y) => x + y.height,
                0) - p;
            "center" === this._verticalAlign ? w = Math.max(Math.floor(this._cssHeight / 2 - q / 2), 0) : "bottom" === this._verticalAlign && (w = Math.floor(this._cssHeight - q));
            for (let x = 0, y = t.length; x < y; ++x) {
                q = t[x];
                const B = q.height;
                if (0 < x && w > this._cssHeight - (B - p)) break;
                0 <= w && this._DrawLine(g, q, k, m, w, u, r);
                w += B
            }
        }
        _DrawLine(g, k, m, r, w, p, t) {
            const u = k.height;
            let q = 0;
            "center" === this._horizontalAlign ? q = Math.max(Math.floor((this._cssWidth - k.width) / 2), 0) : "right" === this._horizontalAlign && (q = Math.max(Math.floor(this._cssWidth - k.width),
                0));
            for (const x of k.fragments) this._DrawFragment(g, x, m, r, q, w, p, t, u), q += x.width
        }
        _DrawFragment(g, k, m, r, w, p, t, u, q) {
            var x = k.text,
                y = k.width,
                B = k.styles;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount) return;
                this._drawCharCount + x.length > this._drawMaxCharCount && (x = x.substr(0, this._drawMaxCharCount - this._drawCharCount), y = this._MeasureText(x, B).width);
                this._drawCharCount += x.length
            }
            var F = this._GetStyleTag(B, "background");
            if (!(e.IsStringAllWhitespace(x) && !F || this._HasStyleTag(B,
                    "hide"))) {
                k = this._GetStyleTag(B, "scale");
                var H = (k ? parseFloat(k.param) : this._scale) * this._sceneGraphScale;
                k = this._GetStyleTag(B, "scalex");
                k = (k ? parseFloat(k.param) : 1) * H;
                var K = this._GetStyleTag(B, "scaley");
                H *= K ? parseFloat(K.param) : 1;
                H *= this._spriteFont.GetCharacterHeight();
                p += q - this._lineHeight - H;
                q = this._GetStyleTag(B, "offsetx");
                w += q ? parseFloat(q.param) : 0;
                q = this._GetStyleTag(B, "offsety");
                p += q ? parseFloat(q.param) : 0;
                F && (g.SetColorFillMode(), b.parseString(F.param), b.setA(1), g.SetColor(b), d.set(w, p, w + y,
                    p + H), d.getRight() > this._cssWidth && d.setRight(this._cssWidth), a.setFromRotatedRectPrecalc(d, t, u), a.offset(m, r), g.Quad(a), g.SetTextureFillMode());
                (y = this._GetStyleTag(B, "color")) ? (b.parseString(y.param), b.setA(this._color.getA())) : b.copy(this._color);
                (y = this._GetStyleTag(B, "opacity")) && b.setA(b.getA() * parseFloat(y.param) / 100);
                b.premultiply();
                g.SetColor(b);
                y = this._spriteFont.GetCharacterWidth() * k;
                B = Math.abs(this.GetSpacing());
                for (const C of x)
                    if (x = this._spriteFont.GetCharacter(C)) {
                        F = x.GetDisplayWidth() *
                            k;
                        if (w + F > this._cssWidth + B + 1E-5) break;
                        d.set(w, p, w + y, p + H);
                        a.setFromRotatedRectPrecalc(d, t, u);
                        a.offset(m, r);
                        g.Quad3(a, x.GetTexRect());
                        w += F + this._spacing
                    } else w += this._spriteFont.GetSpaceWidth() * k + this._spacing
            }
        }
        GetSpriteFont() {
            return this._spriteFont
        }
        SetBBCodeEnabled(g) {
            g = !!g;
            this._isBBcodeEnabled !== g && (this._isBBcodeEnabled = g, this._SetWrapChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetText(g) {
            this._text !== g && (this._text = g, this._SetWrapChanged())
        }
        SetWordWrapMode(g) {
            if (!h.has(g)) throw Error("invalid word wrap mode");
            this._wrapMode !== g && (this._wrapMode = g, this._SetWrapChanged())
        }
        SetHorizontalAlign(g) {
            if (!c.has(g)) throw Error("invalid alignment");
            this._horizontalAlign = g
        }
        SetVerticalAlign(g) {
            if (!f.has(g)) throw Error("invalid alignment");
            this._verticalAlign = g
        }
        SetScale(g) {
            this._scale !== g && (this._scale = g, this._SetWrapChanged())
        }
        GetScale() {
            return this._scale
        }
        SetSceneGraphScale(g) {
            this._sceneGraphScale !== g && (this._sceneGraphScale = g, this._SetWrapChanged())
        }
        GetSceneGraphScale() {
            return this._sceneGraphScale
        }
        SetSpacing(g) {
            this._spacing !==
                g && (this._spacing = g, this._SetWrapChanged())
        }
        GetSpacing() {
            return this._spacing
        }
        SetLineHeight(g) {
            this._lineHeight = g;
            this._SetWrapChanged()
        }
        GetLineHeight() {
            return this._lineHeight
        }
        SetOpacity(g) {
            g = e.clamp(g, 0, 1);
            this._color.a = g
        }
        SetColor(g) {
            this._color.equals(g) || this._color.copy(g)
        }
        GetColor() {
            return this._color
        }
        GetTextWidth() {
            this._MaybeWrapText();
            return this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            var g = this._spriteFont.GetCharacterHeight() * this._scale;
            const k = this._lineHeight;
            g += k;
            return this._wrappedText.GetLineCount() * g - k
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = {
            width: 256,
            height: 256,
            characterWidth: 16,
            characterHeight: 16,
            characterSet: ""
        };
    self.SpriteFont = class {
        constructor(a) {
            a = Object.assign({}, d, a);
            if (0 >= a.width || 0 >= a.height || 0 >= a.characterWidth || 0 >= a.characterHeight) throw Error("invalid size");
            this._width = a.width;
            this._height = a.height;
            this._characterWidth = a.characterWidth;
            this._characterHeight = a.characterHeight;
            this._characterSet = a.characterSet;
            this._spacingData = "";
            this._spacingParsed = null;
            this._hasAnyCustomWidths = !1;
            this._spaceWidth = -1;
            this._texRect = new e.Rect(0, 0, 1, 1);
            this._characterMap = new Map;
            this._mapChanged = !0;
            this._allTexts = new Set
        }
        Release() {
            this._texRect = null;
            this._ReleaseCharacters();
            this._characterMap = null;
            this._allTexts && this._allTexts.clear();
            this._allTexts = null
        }
        _ReleaseCharacters() {
            for (let a of this._characterMap.values()) a.Release();
            this._characterMap.clear()
        }
        _AddSpriteFontText(a) {
            this._allTexts.add(a)
        }
        _RemoveSpriteFontText(a) {
            this._allTexts.delete(a)
        }
        UpdateCharacterMap() {
            if (this._mapChanged) {
                this._ReleaseCharacters();
                var a = [...this._characterSet],
                    b = Math.floor(this._width / this._characterWidth),
                    c = b * Math.floor(this._height / this._characterHeight);
                for (let f = 0, h = a.length; f < h && !(f >= c); ++f) {
                    let g = a[f];
                    this._characterMap.set(g, e.New(self.SpriteFontCharacter, this, g, f % b * this._characterWidth, Math.floor(f / b) * this._characterHeight))
                }
                this._hasAnyCustomWidths = !1;
                this._spaceWidth = -1;
                if (Array.isArray(this._spacingParsed))
                    for (let f of this._spacingParsed)
                        if (Array.isArray(f) && 2 === f.length && (a = f[0], b = f[1], "number" === typeof a && isFinite(a) &&
                                "string" === typeof b && a !== this._characterWidth))
                            for (let h of b)(b = this._characterMap.get(h)) ? (b.SetDisplayWidth(a), this._hasAnyCustomWidths = !0) : " " === h && (this._spaceWidth = a, this._hasAnyCustomWidths = !0);
                this._mapChanged = !1;
                for (let f of this._allTexts) f._SetWrapChanged()
            }
        }
        SetCharacterWidthsChanged() {
            this._hasAnyCustomWidths = !0;
            for (const a of this._allTexts) a._SetWrapChanged()
        }
        GetCharacter(a) {
            this.UpdateCharacterMap();
            return this._characterMap.get(a) || null
        }
        HasAnyCustomWidths() {
            return this._hasAnyCustomWidths
        }
        SetWidth(a) {
            a =
                Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._width !== a && (this._width = a, this._mapChanged = !0)
        }
        GetWidth() {
            return this._width
        }
        SetHeight(a) {
            a = Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._height !== a && (this._height = a, this._mapChanged = !0)
        }
        GetHeight() {
            return this._height
        }
        SetTexRect(a) {
            if (!this._texRect.equals(a)) {
                this._texRect.copy(a);
                for (const b of this._characterMap.values()) b._UpdateTexRect()
            }
        }
        GetTexRect() {
            return this._texRect
        }
        SetCharacterWidth(a) {
            a = Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._characterWidth !== a && (this._characterWidth = a, this._mapChanged = !0)
        }
        GetCharacterWidth() {
            return this._characterWidth
        }
        SetCharacterHeight(a) {
            a = Math.floor(a);
            if (0 >= a) throw Error("invalid size");
            this._characterHeight !== a && (this._characterHeight = a, this._mapChanged = !0)
        }
        GetCharacterHeight() {
            return this._characterHeight
        }
        SetCharacterSet(a) {
            this._characterSet !== a && (this._characterSet = a, this._mapChanged = !0)
        }
        GetCharacterSet() {
            return this._characterSet
        }
        SetSpacingData(a) {
            if (this._spacingData !== a && (this._spacingData =
                    a, this._mapChanged = !0, this._spacingParsed = null, this._spacingData.length)) try {
                this._spacingParsed = JSON.parse(this._spacingData)
            } catch (b) {
                this._spacingParsed = null
            }
        }
        GetSpacingData() {
            return this._spacingData
        }
        SetSpaceWidth(a) {
            0 > a && (a = -1);
            this._spaceWidth !== a && (this._spaceWidth = a, 0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
        }
        GetSpaceWidth() {
            return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d);
            this._animations = d.GetAnimations()
        }
        Release() {
            e.clearArray(this._animations);
            super.Release()
        }
        OnCreate() {
            for (const d of this._animations) d.LoadAllAssets(this._runtime)
        }
        LoadTextures(d) {
            const a = {
                sampling: this._runtime.GetSampling()
            };
            return Promise.all(this._animations.map(b => b.LoadAllTextures(d, a)))
        }
        ReleaseTextures() {
            for (const d of this._animations) d.ReleaseAllTextures()
        }
        OnDynamicTextureLoadComplete() {
            this._UpdateAllCurrentTexture()
        }
        _UpdateAllCurrentTexture() {
            for (const d of this._objectClass.instancesIncludingPendingCreate()) d.GetSdkInstance()._UpdateCurrentTexture()
        }
        FinishCondition(d) {
            e.Plugins.Sprite.FinishCollisionCondition(this,
                d)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = e.New(e.Rect),
        b = e.New(e.Quad),
        c = e.New(e.Vector2);
    e.Plugins.Sprite.Instance = class extends e.SDKWorldInstanceBase {
        constructor(g, k) {
            super(g);
            let m = !0,
                r = "",
                w = 0,
                p = !0;
            k && (m = !!k[0], r = k[1], w = k[2], p = k[3]);
            this._currentAnimation = this._objectClass.GetAnimationByName(r) || this._objectClass.GetAnimations()[0];
            this._currentFrameIndex = e.clamp(w, 0, this._currentAnimation.GetFrameCount() - 1);
            this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            k =
                this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = k.GetTexture();
            this._currentRcTex = k.GetTexRect();
            this._currentQuadTex = k.GetTexQuad();
            this.HandleWebGLContextLoss();
            g.SetFlag(2, !0);
            g.SetFlag(1, 0 <= this._currentAnimation.GetSpeed());
            this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
            this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
            this._animationTimer = e.New(e.KahanSum);
            this._animationRepeats = this._frameStartTime = 0;
            this._animTriggerName = "";
            this._changeAnimFrameIndex = -1;
            this._changeAnimationName = "";
            this._changeAnimationFrom = 0;
            g = this.GetWorldInfo();
            this._bquadRef = g.GetBoundingQuad();
            g.SetVisible(m);
            g.SetCollisionEnabled(p);
            g.SetOriginX(this._currentAnimationFrame.GetOriginX());
            g.SetOriginY(this._currentAnimationFrame.GetOriginY());
            g.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
            g.SetBboxChanged();
            1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking()
        }
        Release() {
            this._animationTimer =
                this._currentTexture = this._currentAnimationFrame = this._currentAnimation = null;
            super.Release()
        }
        GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo()
        }
        IsOriginalSizeKnown() {
            return !0
        }
        OnWebGLContextLost() {
            this._currentTexture = null
        }
        OnWebGLContextRestored() {
            this._UpdateCurrentTexture()
        }
        Draw(g) {
            var k = this._currentTexture;
            null !== k && (g.SetTexture(k), k = this.GetWorldInfo(), k.HasMesh() ? this._DrawMesh(k, g) : this._DrawStandard(k, g))
        }
        _DrawStandard(g, k) {
            let m = this._bquadRef;
            this._runtime.IsPixelRoundingEnabled() &&
                (m = g.PixelRoundQuad(m));
            k.Quad4(m, this._currentQuadTex)
        }
        _DrawMesh(g, k) {
            const m = g.GetTransformedMesh();
            if (g.IsMeshChanged()) {
                g.CalculateBbox(a, b, !1);
                let r = b;
                this._runtime.IsPixelRoundingEnabled() && (r = g.PixelRoundQuad(r));
                m.CalculateTransformedMesh(g.GetSourceMesh(), r, this._currentQuadTex);
                g.SetMeshChanged(!1)
            }
            m.Draw(k)
        }
        GetAnimationTime() {
            return this._animationTimer.Get()
        }
        IsAnimationPlaying() {
            return this._inst.GetFlag(2)
        }
        SetAnimationPlaying(g) {
            this._inst.SetFlag(2, g)
        }
        IsPlayingForwards() {
            return this._inst.GetFlag(1)
        }
        SetPlayingForwards(g) {
            this._inst.SetFlag(1,
                g)
        }
        IsInAnimationTrigger() {
            return this._inst.GetFlag(4)
        }
        SetInAnimationTrigger(g) {
            this._inst.SetFlag(4, g)
        }
        Tick() {
            this._changeAnimationName && this._DoChangeAnimation();
            0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
            const g = this._currentAnimationSpeed;
            if (this.IsAnimationPlaying() && 0 !== g) {
                var k = this._runtime.GetDt(this._inst);
                this._animationTimer.Add(k);
                k = this.GetAnimationTime();
                var m = this._currentAnimationFrame,
                    r = m.GetDuration() / g;
                if (!(k < this._frameStartTime + r)) {
                    var w = this._currentAnimation,
                        p = this._currentAnimationRepeatTo,
                        t = w.GetFrameCount(),
                        u = w.GetRepeatCount(),
                        q = w.IsLooping(),
                        x = w.IsPingPong();
                    this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--;
                    this._frameStartTime += r;
                    this._currentFrameIndex >= t && (x ? (this.SetPlayingForwards(!1), this._currentFrameIndex = t - 2) : q ? this._currentFrameIndex = p : (this._animationRepeats++, this._animationRepeats >= u ? this._FinishAnimation(!1) : this._currentFrameIndex = p));
                    0 > this._currentFrameIndex && (x ? (this._currentFrameIndex = 1, this.SetPlayingForwards(!0),
                        q || (this._animationRepeats++, this._animationRepeats >= u && this._FinishAnimation(!0))) : q ? this._currentFrameIndex = p : (this._animationRepeats++, this._animationRepeats >= u ? this._FinishAnimation(!0) : this._currentFrameIndex = p));
                    this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, t - 1);
                    r = w.GetFrameAt(this._currentFrameIndex);
                    k > this._frameStartTime + r.GetDuration() / g && (this._frameStartTime = k);
                    this._OnFrameChanged(m, r)
                }
            } else this._StopTicking()
        }
        _FinishAnimation(g) {
            this._currentFrameIndex = g ? 0 : this._currentAnimation.GetFrameCount() -
                1;
            this.SetAnimationPlaying(!1);
            this._animTriggerName = this._currentAnimation.GetName();
            this.SetInAnimationTrigger(!0);
            this.Trigger(e.Plugins.Sprite.Cnds.OnAnyAnimFinished);
            this.Trigger(e.Plugins.Sprite.Cnds.OnAnimFinished);
            this.SetInAnimationTrigger(!1);
            this._animationRepeats = 0
        }
        _OnFrameChanged(g, k) {
            if (g !== k) {
                var m = this.GetWorldInfo(),
                    r = g.GetImageInfo(),
                    w = k.GetImageInfo(),
                    p = r.GetWidth();
                r = r.GetHeight();
                var t = w.GetWidth(),
                    u = w.GetHeight();
                p !== t && m.SetWidth(m.GetWidth() * (t / p));
                r !== u && m.SetHeight(m.GetHeight() *
                    (u / r));
                m.SetOriginX(k.GetOriginX());
                m.SetOriginY(k.GetOriginY());
                m.SetSourceCollisionPoly(k.GetCollisionPoly());
                m.SetBboxChanged();
                this._currentAnimationFrame = k;
                this._currentTexture = w.GetTexture();
                this._currentRcTex = w.GetTexRect();
                this._currentQuadTex = w.GetTexQuad();
                m = this.GetInstance().GetBehaviorInstances();
                for (let q = 0, x = m.length; q < x; ++q) m[q].OnSpriteFrameChanged(g, k);
                this.Trigger(e.Plugins.Sprite.Cnds.OnFrameChanged);
                this._runtime.UpdateRender()
            }
        }
        _StartAnim(g) {
            this.SetAnimationPlaying(!0);
            this._frameStartTime =
                this.GetAnimationTime();
            1 === g && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
            this._StartTicking()
        }
        _SetAnim(g, k) {
            this._changeAnimationName = g;
            this._changeAnimationFrom = k;
            this._StartTicking();
            this.IsInAnimationTrigger() || this._DoChangeAnimation()
        }
        _GetCurrentAnimationName() {
            return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
        }
        _SetAnimFrame(g) {
            isFinite(g) && (this._changeAnimFrameIndex = g, this.IsInAnimationTrigger() ||
                this._DoChangeAnimFrame())
        }
        _GetAnimFrame() {
            return this._currentFrameIndex
        }
        _SetAnimSpeed(g) {
            this._currentAnimationSpeed = Math.abs(g);
            this.SetPlayingForwards(0 <= g);
            0 < this._currentAnimationSpeed && this._StartTicking()
        }
        _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
        }
        _SetAnimRepeatToFrame(g) {
            this._currentAnimationRepeatTo = g = e.clamp(Math.floor(g), 0, this._currentAnimation.GetFrameCount() - 1)
        }
        _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo
        }
        _DoChangeAnimation() {
            const g =
                this._currentAnimationFrame;
            var k = this._objectClass.GetAnimationByName(this._changeAnimationName);
            this._changeAnimationName = "";
            !k || k === this._currentAnimation && this.IsAnimationPlaying() || (this._currentAnimation = k, this.SetPlayingForwards(0 <= k.GetSpeed()), this._currentAnimationSpeed = Math.abs(k.GetSpeed()), this._currentAnimationRepeatTo = k.GetRepeatTo(), this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex =
                0), this.SetAnimationPlaying(!0), this._frameStartTime = this.GetAnimationTime(), k = this._currentAnimation.GetFrameAt(this._currentFrameIndex), this._OnFrameChanged(g, k))
        }
        _DoChangeAnimFrame() {
            const g = this._currentAnimationFrame;
            var k = this._currentFrameIndex;
            this._currentFrameIndex = e.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);
            this._changeAnimFrameIndex = -1;
            k !== this._currentFrameIndex && (k = this._currentAnimation.GetFrameAt(this._currentFrameIndex), this._OnFrameChanged(g,
                k), this._frameStartTime = this.GetAnimationTime())
        }
        _UpdateCurrentTexture() {
            const g = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = g.GetTexture();
            this._currentRcTex = g.GetTexRect();
            this._currentQuadTex = g.GetTexQuad();
            this.GetWorldInfo().SetMeshChanged(!0)
        }
        GetTexture() {
            return this._currentTexture
        }
        GetTexRect() {
            return this._currentRcTex
        }
        GetTexQuad() {
            return this._currentQuadTex
        }
        GetImagePointCount() {
            return this._currentAnimationFrame.GetImagePointCount()
        }
        GetImagePoint(g) {
            const k = this._currentAnimationFrame,
                m = this.GetWorldInfo();
            if ("string" === typeof g) g = k.GetImagePointByName(g);
            else if ("number" === typeof g) g = k.GetImagePointByIndex(g - 1);
            else throw new TypeError("expected string or number");
            if (!g) return [m.GetX(), m.GetY()];
            c.copy(g.GetVec2());
            if (m.HasMesh()) {
                const [r, w] = m.GetSourceMesh().TransformPoint(c.getX(), c.getY());
                c.set(r, w)
            }
            c.offset(-k.GetOriginX(), -k.GetOriginY());
            c.scale(m.GetWidth(), m.GetHeight());
            c.rotate(m.GetAngle());
            c.offset(m.GetX(), m.GetY());
            return [c.getX(), c.getY()]
        }
        GetCollisionPolyPointCount() {
            return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
        }
        GetCollisionPolyPoint(g) {
            g =
                Math.floor(g);
            const k = this.GetWorldInfo();
            var m = k.GetTransformedCollisionPoly();
            const r = m.pointCount();
            g === r && (g = 0);
            if (0 > g || g >= r) return [0, 0];
            m = m.pointsArr();
            return [m[2 * g] + k.GetX(), m[2 * g + 1] + k.GetY()]
        }
        GetDebuggerProperties() {
            const g = e.Plugins.Sprite.Acts;
            return [{
                title: "plugins.sprite.debugger.animation-properties.title",
                properties: [{
                    name: "plugins.sprite.debugger.animation-properties.current-animation",
                    value: this._currentAnimation.GetName(),
                    onedit: k => this.CallAction(g.SetAnim, k, 0)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.current-frame",
                    value: this._currentFrameIndex,
                    onedit: k => this.CallAction(g.SetAnimFrame, k)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.is-playing",
                    value: this.IsAnimationPlaying(),
                    onedit: k => k ? this.CallAction(g.StartAnim, 0) : this.CallAction(g.StopAnim)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.speed",
                    value: this._currentAnimationSpeed,
                    onedit: k => this.CallAction(g.SetAnimSpeed, k)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.repeats",
                    value: this._animationRepeats,
                    onedit: k => this._animationRepeats =
                        k
                }]
            }]
        }
        SaveToJson() {
            const g = {
                a: this._currentAnimation.GetSID()
            };
            0 !== this._frameStartTime && (g.fs = this._frameStartTime);
            var k = this.GetAnimationTime();
            0 !== k && (g.at = k);
            0 !== this._currentFrameIndex && (g.f = this._currentFrameIndex);
            0 !== this._currentAnimationSpeed && (g.cas = this._currentAnimationSpeed);
            1 !== this._animationRepeats && (g.ar = this._animationRepeats);
            0 !== this._currentAnimationRepeatTo && (g.rt = this._currentAnimationRepeatTo);
            this.IsAnimationPlaying() || (g.ap = this.IsAnimationPlaying());
            this.IsPlayingForwards() ||
                (g.af = this.IsPlayingForwards());
            k = this.GetWorldInfo();
            k.IsCollisionEnabled() && (g.ce = k.IsCollisionEnabled());
            return g
        }
        LoadFromJson(g) {
            var k = this.GetObjectClass().GetAnimationBySID(g.a);
            k && (this._currentAnimation = k);
            this._frameStartTime = g.hasOwnProperty("fs") ? g.fs : 0;
            this._animationTimer.Set(g.hasOwnProperty("at") ? g.at : 0);
            k = g.hasOwnProperty("f") ? g.f : 0;
            this._currentFrameIndex = e.clamp(k, 0, this._currentAnimation.GetFrameCount() - 1);
            this._currentAnimationSpeed = g.hasOwnProperty("cas") ? g.cas : 0;
            this._animationRepeats =
                g.hasOwnProperty("ar") ? g.ar : 1;
            k = g.hasOwnProperty("rt") ? g.rt : 0;
            this._currentAnimationRepeatTo = e.clamp(k, 0, this._currentAnimation.GetFrameCount() - 1);
            this.SetAnimationPlaying(g.hasOwnProperty("ap") ? !!g.ap : !0);
            this.SetPlayingForwards(g.hasOwnProperty("af") ? !!g.af : !0);
            this._currentAnimationFrame = k = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._UpdateCurrentTexture();
            const m = this.GetWorldInfo();
            m.SetOriginX(k.GetOriginX());
            m.SetOriginY(k.GetOriginY());
            m.SetSourceCollisionPoly(k.GetCollisionPoly());
            m.SetCollisionEnabled(!!g.ce)
        }
        GetPropertyValueByIndex(g) {
            const k = this.GetWorldInfo();
            switch (g) {
                case 3:
                    return k.IsCollisionEnabled();
                case 2:
                    return e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1)
            }
        }
        SetPropertyValueByIndex(g, k) {
            var m = this.GetWorldInfo();
            switch (g) {
                case 3:
                    m.SetCollisionEnabled(!!k);
                    break;
                case 2:
                    this.SetAnimationPlaying(!1);
                    g = this._currentAnimation.GetFrameCount() - 1;
                    m = k = e.clamp(k, 0, g);
                    k = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
                    const r = this._currentAnimation.GetFrameAt(m);
                    this._OnFrameChanged(k, r);
                    this._currentFrameIndex = e.clamp(m, 0, g)
            }
        }
        GetScriptInterfaceClass() {
            return self.ISpriteInstance
        }
    };
    const f = new WeakMap,
        h = new Map([
            ["current-frame", 0],
            ["beginning", 1]
        ]);
    self.ISpriteInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            f.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        getImagePointCount() {
            return f.get(this).GetImagePointCount()
        }
        getImagePointX(g) {
            if ("string" !== typeof g && "number" !== typeof g) throw new TypeError("expected string or number");
            return f.get(this).GetImagePoint(g)[0]
        }
        getImagePointY(g) {
            if ("string" !==
                typeof g && "number" !== typeof g) throw new TypeError("expected string or number");
            return f.get(this).GetImagePoint(g)[1]
        }
        getImagePoint(g) {
            if ("string" !== typeof g && "number" !== typeof g) throw new TypeError("expected string or number");
            return f.get(this).GetImagePoint(g)
        }
        getPolyPointCount() {
            return f.get(this).GetCollisionPolyPointCount()
        }
        getPolyPointX(g) {
            d.RequireFiniteNumber(g);
            return f.get(this).GetCollisionPolyPoint(g)[0]
        }
        getPolyPointY(g) {
            d.RequireFiniteNumber(g);
            return f.get(this).GetCollisionPolyPoint(g)[1]
        }
        getPolyPoint(g) {
            d.RequireFiniteNumber(g);
            return f.get(this).GetCollisionPolyPoint(g)
        }
        stopAnimation() {
            f.get(this).SetAnimationPlaying(!1)
        }
        startAnimation(g = "current-frame") {
            d.RequireString(g);
            g = h.get(g);
            if ("undefined" === typeof g) throw Error("invalid mode");
            f.get(this)._StartAnim(g)
        }
        setAnimation(g, k = "beginning") {
            d.RequireString(g);
            d.RequireString(k);
            k = h.get(k);
            if ("undefined" === typeof k) throw Error("invalid mode");
            f.get(this)._SetAnim(g, k)
        }
        get animationName() {
            return f.get(this)._GetCurrentAnimationName()
        }
        set animationFrame(g) {
            d.RequireFiniteNumber(g);
            f.get(this)._SetAnimFrame(g)
        }
        get animationFrame() {
            return f.get(this)._GetAnimFrame()
        }
        set animationSpeed(g) {
            d.RequireFiniteNumber(g);
            f.get(this)._SetAnimSpeed(g)
        }
        get animationSpeed() {
            return f.get(this)._GetAnimSpeed()
        }
        set animationRepeatToFrame(g) {
            d.RequireFiniteNumber(g);
            f.get(this)._SetAnimRepeatToFrame(g)
        }
        get animationRepeatToFrame() {
            return f.get(this)._GetAnimRepeatToFrame()
        }
        get imageWidth() {
            return f.get(this).GetCurrentImageInfo().GetWidth()
        }
        get imageHeight() {
            return f.get(this).GetCurrentImageInfo().GetHeight()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite.Cnds = {
        IsAnimPlaying(d) {
            return e.equalsNoCase(this._GetCurrentAnimationName(), d)
        },
        CompareFrame(d, a) {
            return e.compare(this._currentFrameIndex, d, a)
        },
        CompareAnimSpeed(d, a) {
            return e.compare(this._GetAnimSpeed(), d, a)
        },
        OnAnimFinished(d) {
            return e.equalsNoCase(this._animTriggerName, d)
        },
        OnAnyAnimFinished() {
            return !0
        },
        OnFrameChanged() {
            return !0
        },
        IsMirrored() {
            return 0 > this.GetWorldInfo().GetWidth()
        },
        IsFlipped() {
            return 0 > this.GetWorldInfo().GetHeight()
        },
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        },
        IsCollisionEnabled() {
            return this.GetWorldInfo().IsCollisionEnabled()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite.Acts = {
        Spawn(d, a, b, c) {
            if (d && a) {
                var [f, h] = this.GetImagePoint(b);
                if (b = this._runtime.CreateInstance(d, a, f, h, c)) {
                    c && a.SortAndAddInstancesByZIndex(b);
                    d.GetPlugin().IsRotatable() && (a = b.GetWorldInfo(), a.SetAngle(this.GetWorldInfo().GetAngle()), a.SetBboxChanged());
                    a = this._runtime.GetEventSheetManager();
                    a.BlockFlushingInstances(!0);
                    b._TriggerOnCreatedOnSelfAndRelated();
                    a.BlockFlushingInstances(!1);
                    c = this._runtime.GetCurrentAction().GetSavedDataMap();
                    a = !1;
                    if (!c.has("Spawn_LastExec") ||
                        c.get("Spawn_LastExec") < this._runtime.GetExecCount()) a = !0, c.set("Spawn_LastExec", this._runtime.GetExecCount());
                    if (d !== this.GetObjectClass() && (d = d.GetCurrentSol(), d._SetSelectAll(!1), d = d._GetOwnInstances(), a && e.clearArray(d), d.push(b), b.IsInContainer()))
                        for (const g of b.siblings()) b = g.GetObjectClass().GetCurrentSol(), a ? b.SetSinglePicked(g) : (b._SetSelectAll(!1), b._PushInstance(g))
                }
            }
        },
        StopAnim() {
            this.SetAnimationPlaying(!1)
        },
        StartAnim(d) {
            this._StartAnim(d)
        },
        SetAnim(d, a) {
            this._SetAnim(d, a)
        },
        SetAnimFrame(d) {
            this._SetAnimFrame(d)
        },
        SetAnimSpeed(d) {
            this._SetAnimSpeed(d)
        },
        SetAnimRepeatToFrame(d) {
            this._SetAnimRepeatToFrame(d)
        },
        SetMirrored(d) {
            const a = this.GetWorldInfo(),
                b = a.GetWidth();
            d = Math.abs(b) * (0 === d ? -1 : 1);
            b !== d && (a.SetWidth(d), a.SetBboxChanged())
        },
        SetFlipped(d) {
            const a = this.GetWorldInfo(),
                b = a.GetHeight();
            d = Math.abs(b) * (0 === d ? -1 : 1);
            b !== d && (a.SetHeight(d), a.SetBboxChanged())
        },
        SetScale(d) {
            const a = this._currentAnimationFrame.GetImageInfo(),
                b = this.GetWorldInfo();
            var c = 0 > b.GetWidth() ? -1 : 1;
            const f = 0 > b.GetHeight() ? -1 : 1;
            c *= a.GetWidth() *
                d;
            d = a.GetHeight() * d * f;
            if (b.GetWidth() !== c || b.GetHeight() !== d) b.SetSize(c, d), b.SetBboxChanged()
        },
        async LoadURL(d, a, b) {
            b = this._currentAnimationFrame.GetImageInfo();
            const c = this.GetWorldInfo(),
                f = this._runtime;
            if (b.GetURL() === d) 0 === a && (c.SetSize(b.GetWidth(), b.GetHeight()), c.SetBboxChanged()), this.Trigger(e.Plugins.Sprite.Cnds.OnURLLoaded);
            else {
                var h = e.New(e.ImageInfo);
                try {
                    await h.LoadDynamicAsset(f, d);
                    if (!h.IsLoaded()) throw Error("image failed to load");
                    await h.LoadStaticTexture(f.GetRenderer(), {
                        sampling: this._runtime.GetSampling()
                    })
                } catch (g) {
                    console.error("Load image from URL failed: ",
                        g);
                    this.Trigger(e.Plugins.Sprite.Cnds.OnURLFailed);
                    return
                }
                b.ReplaceWith(h);
                this._sdkType._UpdateAllCurrentTexture();
                this.WasReleased() || 0 !== a || (c.SetSize(b.GetWidth(), b.GetHeight()), c.SetBboxChanged());
                f.UpdateRender();
                this.WasReleased() || await this.TriggerAsync(e.Plugins.Sprite.Cnds.OnURLLoaded)
            }
        },
        SetCollisions(d) {
            this.GetWorldInfo().SetCollisionEnabled(d)
        },
        SetSolidCollisionFilter(d, a) {
            this.GetWorldInfo().SetSolidCollisionFilter(0 === d, a)
        },
        SetEffect(d) {
            this.GetWorldInfo().SetBlendMode(d);
            this._runtime.UpdateRender()
        }
    }
}
"use strict";
self.C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._currentFrameIndex
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(e) {
        return this.GetImagePoint(e)[0]
    },
    ImagePointY(e) {
        return this.GetImagePoint(e)[1]
    },
    ImagePointCount() {
        return this.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    PolyPointXAt(e) {
        return this.GetCollisionPolyPoint(e)[0]
    },
    PolyPointYAt(e) {
        return this.GetCollisionPolyPoint(e)[1]
    },
    PolyPointCount() {
        return this.GetCollisionPolyPointCount()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.List = class extends e.SDKDOMPluginBase {
        constructor(d) {
            super(d, "list");
            this.AddElementMessageHandler("click", (a, b) => a._OnClick(b));
            this.AddElementMessageHandler("dblclick", (a, b) => a._OnDoubleClick(b));
            this.AddElementMessageHandler("change", (a, b) => a._OnChange(b))
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.List.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.List.Instance = class extends e.SDKDOMInstanceBase {
        constructor(d, a) {
            super(d, "list");
            this._items = [];
            this._title = this._stringItems = "";
            this._isDropdown = this._isEnabled = !0;
            this._isMultiSelect = !1;
            this._autoFontSize = !0;
            this._id = "";
            this._selectedIndex = -1;
            this._selectedIndices = [];
            a && (this._items = (d = a[0]) ? d.split("\n") : [], this._stringItems = a[0], this._title = a[1], this.GetWorldInfo().SetVisible(!!a[2]), this._isEnabled = !!a[3], this._isDropdown = 1 === a[4], this._isMultiSelect = !!a[5], this._autoFontSize = !!a[6], this._id = a[7], this._isDropdown && (this._selectedIndex = 0));
            this.CreateElement({
                id: this._id,
                isDropdown: this._isDropdown,
                isMultiSelect: this._isMultiSelect,
                items: this._items
            })
        }
        Release() {
            e.clearArray(this._items);
            this._items = null;
            e.clearArray(this._selectedIndices);
            this._selectedIndices = null;
            super.Release()
        }
        GetElementState() {
            return {
                title: this._title,
                isEnabled: this._isEnabled,
                isMultiSelect: this._isMultiSelect
            }
        }
        _UpdateSelectedIndex() {
            this.PostToDOMElement("set-selected-index", {
                selectedIndex: this._selectedIndex
            })
        }
        _ReadSelectionState(d) {
            this._selectedIndex = d.selectedIndex;
            this._selectedIndices = d.selectedIndices
        }
        async _OnClick(d) {
            this._ReadSelectionState(d);
            await this.TriggerAsync(e.Plugins.List.Cnds.OnClicked)
        }
        async _OnDoubleClick(d) {
            this._ReadSelectionState(d);
            await this.TriggerAsync(e.Plugins.List.Cnds.OnDoubleClicked)
        }
        async _OnChange(d) {
            this._ReadSelectionState(d);
            await this.TriggerAsync(e.Plugins.List.Cnds.OnSelectionChanged)
        }
        Draw(d) {}
        SaveToJson() {
            return {
                title: this._title,
                isEnabled: this._isEnabled,
                id: this._id,
                items: e.cloneArray(this._items),
                selectedIndex: this._selectedIndex,
                selectedIndices: this._selectedIndices
            }
        }
        LoadFromJson(d) {
            this._title = d.title;
            this._isEnabled = d.isEnabled;
            this._id = d.id;
            this._items = e.cloneArray(d.items);
            this._stringItems = this._items.join("/n");
            this._selectedIndex = d.selectedIndex;
            this._selectedIndices = d.selectedIndices;
            this.UpdateElementState();
            this.PostToDOMElement("load-state", {
                items: this._items,
                selectedIndex: this._selectedIndex,
                selectedIndices: this._selectedIndices
            })
        }
        _SetEnabled(d) {
            d = !!d;
            this._isEnabled !== d && (this._isEnabled = d, this.UpdateElementState())
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(d) {
            switch (d) {
                case 0:
                    return this._stringItems;
                case 1:
                    return this._title;
                case 3:
                    return this._isEnabled;
                case 5:
                    return this._isMultiSelect;
                case 6:
                    return this._autoFontSize;
                case 7:
                    return this._id
            }
        }
        SetPropertyValueByIndex(d, a) {
            switch (d) {
                case 0:
                    if (this._stringItems === a) break;
                    this._items = a.split("\n");
                    this._stringItems = a;
                    this._selectedIndex = e.clamp(this._selectedIndex, 0, this._items.length -
                        1);
                    this.UpdateElementState();
                    this.PostToDOMElement("load-state", {
                        items: this._items,
                        selectedIndex: this._selectedIndex,
                        selectedIndices: this._selectedIndices
                    });
                    break;
                case 1:
                    if (this._title === a) break;
                    this._title = a;
                    this.UpdateElementState();
                    break;
                case 3:
                    if (this._isEnabled === !!a) break;
                    this._isEnabled = !!a;
                    this.UpdateElementState();
                    break;
                case 5:
                    if (this._isMultiSelect === !!a) break;
                    this._isMultiSelect = !!a;
                    this.UpdateElementState();
                    break;
                case 6:
                    if (this._autoFontSize === !!a) break;
                    this._autoFontSize = !!a;
                    this.UpdateElementState();
                    break;
                case 7:
                    this._id !== a && (this._id = a, this.UpdateElementState())
            }
        }
        GetDebuggerProperties() {
            const d = e.Plugins.List.Acts;
            return [{
                title: "plugins.list.name",
                properties: [{
                    name: "plugins.list.debugger.item-count",
                    value: this._items.length
                }, {
                    name: "plugins.list.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: a => this.CallAction(d.SetEnabled, a)
                }, {
                    name: "plugins.list.debugger.selected-index",
                    value: this._selectedIndex
                }]
            }, {
                title: "plugins.list.properties.items.name",
                properties: this._items.map((a, b) => ({
                    name: "$" +
                        b,
                    value: a,
                    onedit: c => this.CallAction(d.SetItemText, b, c)
                }))
            }]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.List.Cnds = {
        CompareSelection(d, a) {
            return e.compare(this._selectedIndex, d, a)
        },
        OnSelectionChanged() {
            return !0
        },
        OnClicked() {
            return !0
        },
        OnDoubleClicked() {
            return !0
        },
        CompareSelectedText(d, a) {
            var b = this._selectedIndex;
            if (0 > b || b >= this._items.length) return !1;
            b = this._items[b];
            return a ? b === d : e.equalsNoCase(b, d)
        },
        CompareTextAt(d, a, b) {
            d = Math.floor(d);
            if (0 > d || d >= this._items.length) return !1;
            d = this._items[d];
            return b ? d === a : e.equalsNoCase(d, a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.List.Acts = {
        Select(d) {
            d = Math.floor(d);
            0 > d && (d = -1);
            d >= this._items.length || this._selectedIndex === d || (this._selectedIndex = d, this._selectedIndices = [d], this._UpdateSelectedIndex())
        },
        SetTooltip(d) {
            this._title !== d && (this._title = d, this.UpdateElementState())
        },
        SetVisible(d) {
            const a = this.GetWorldInfo();
            d = 0 !== d;
            a.IsVisible() !== d && a.SetVisible(d)
        },
        AddItem(d) {
            this._items.push(d);
            this.PostToDOMElement("add-item", {
                text: d,
                index: -1
            })
        },
        AddItemAt(d, a) {
            d = Math.max(Math.floor(d), 0);
            if (d >= this._items.length) this._items.push(a), d = -1;
            else {
                this._items.splice(d, 0, a);
                this._selectedIndex >= d && this._selectedIndex++;
                for (let b = 0, c = this._selectedIndices.length; b < c; ++b) this._selectedIndices[b] >= d && this._selectedIndices[b]++
            }
            this.PostToDOMElement("add-item", {
                index: d,
                text: a
            })
        },
        Remove(d) {
            d = Math.floor(d);
            if (!(0 > d || d >= this._items.length)) {
                this._items.splice(d, 1);
                this._selectedIndex >= d && this._selectedIndex--;
                var a = this._selectedIndices.indexOf(d); - 1 !== a && this._selectedIndices.splice(a, 1);
                a = 0;
                for (let b = this._selectedIndices.length; a < b; ++a) this._selectedIndices[a] >= d && this._selectedIndices[a]--;
                this.PostToDOMElement("remove-item", {
                    index: d
                })
            }
        },
        SetItemText(d, a) {
            d = Math.floor(d);
            0 > d || d >= this._items.length || (this._items[d] = a, this.PostToDOMElement("set-item", {
                index: d,
                text: a
            }))
        },
        Clear() {
            e.clearArray(this._items);
            this._selectedIndex = -1;
            e.clearArray(this._selectedIndices);
            this.PostToDOMElement("clear")
        }
    }
}
"use strict";
self.C3.Plugins.List.Exps = {
    ItemCount() {
        return this._items.length
    },
    ItemTextAt(e) {
        e = Math.floor(e);
        return 0 > e || e >= this._items.length ? "" : this._items[e]
    },
    SelectedIndex() {
        return this._selectedIndex
    },
    SelectedText() {
        const e = this._selectedIndex;
        return 0 > e || e >= this._items.length ? "" : this._items[e]
    },
    SelectedCount() {
        return this._selectedIndices.length
    },
    SelectedIndexAt(e) {
        e = Math.floor(e);
        return 0 > e || e >= this._selectedIndices.length ? 0 : this._selectedIndices[e]
    },
    SelectedTextAt(e) {
        e = Math.floor(e);
        if (0 > e || e >= this._selectedIndices.length) return "";
        e = this._selectedIndices[e];
        return 0 > e || e >= this._items.length ? "" : this._items[e]
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Function = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Function.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    class d {
        constructor() {
            this.name = "";
            this.retVal = 0;
            this.params = []
        }
    }
    e.Plugins.Function.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a);
            this._isPreview = this._runtime.IsPreview();
            this._funcStackPtr = -1;
            this._funcStack = [];
            a = (c, f) => this._InvokeFromJS(c, f);
            self.c2_callFunction = a;
            self.c3_callFunction = a
        }
        Release() {
            super.Release()
        }
        Push() {
            const a = this._funcStack,
                b = ++this._funcStackPtr;
            b === a.length && a.push(new d);
            return a[b]
        }
        Pop() {
            --this._funcStackPtr
        }
        GetCurrent() {
            const a =
                this._funcStackPtr;
            return 0 > a ? null : this._funcStack[a]
        }
        GetOneAbove() {
            const a = this._funcStack;
            return a.length ? a[Math.min(this._funcStackPtr + 1, a.length - 1)] : null
        }
        _CallFunction(a, b) {
            const c = this.Push();
            c.name = a.toLowerCase();
            c.retVal = 0;
            e.shallowAssignArray(c.params, b);
            b = this.FastTrigger(e.Plugins.Function.Cnds.OnFunction, c.name);
            this._isPreview && !b && console.warn(`[Construct 3] Function object: called function '${a}' but no event was triggered. Is the function call spelt incorrectly or no longer used?`);
            this.Pop()
        }* _DebugCallFunction(a, b) {
            const c = this.Push();
            c.name = a.toLowerCase();
            c.retVal = 0;
            e.shallowAssignArray(c.params, b);
            b = yield* this.DebugFastTrigger(e.Plugins.Function.Cnds.OnFunction, c.name);
            this._isPreview && !b && console.warn(`[Construct 3] Function object: called function '${a}' but no event was triggered. Is the function call spelt incorrectly or no longer used?`);
            this.Pop()
        }
        _InvokeFromJS(a, b) {
            const c = this.Push();
            c.name = a.toLowerCase();
            c.retVal = 0;
            c.params = (b || []).map(f => "number" === typeof f ||
                "string" === typeof f ? f : "boolean" === typeof f ? f ? 1 : 0 : 0);
            this.FastTrigger(e.Plugins.Function.Cnds.OnFunction, c.name);
            this.Pop();
            return c.retVal
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Function.Cnds = {
        OnFunction(d) {
            return !0
        },
        CompareParam(d, a, b) {
            const c = this.GetCurrent();
            if (!c) return this._isPreview && console.warn("[Construct 3] Function object: used 'Compare parameter' condition when not in a function call"), !1;
            const f = c.params;
            d = Math.floor(d);
            let h = 0;
            0 > d || d >= f.length ? this._isPreview && console.warn(`[Construct 3] Function object: in function '${c.name}', compared parameter out of bounds (accessed index ${d} of ${f.length})`) : h = f[d];
            return e.compare(h,
                a, b)
        }
    }
}
"use strict";
self.C3.Plugins.Function.Acts = {
    CallFunction(e, d) {
        if (this._runtime.IsDebugging()) return this._DebugCallFunction(e, d);
        this._CallFunction(e, d)
    },
    SetReturnValue(e) {
        const d = this.GetCurrent();
        d ? d.retVal = e : this._isPreview && console.warn("[Construct 3] Function object: used 'Set return value' when not in a function call")
    },
    CallExpression(e) {}
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Function.Exps = {
        ReturnValue() {
            const d = this.GetOneAbove();
            return d ? d.retVal : 0
        },
        ParamCount() {
            const d = this.GetCurrent();
            if (d) return d.params.length;
            this._isPreview && console.warn("[Construct 3] Function object: used 'ParamCount' expression when not in a function call");
            return 0
        },
        Param(d) {
            d = Math.floor(d);
            const a = this.GetCurrent();
            if (a) {
                const b = a.params;
                if (0 <= d && d < b.length) return b[d];
                this._isPreview && console.warn(`[Construct 3] Function object: in function '${a.name}', accessed parameter out of bounds (accessed index ${d} of ${b.length})`);
                return 0
            }
            this._isPreview && console.warn("[Construct 3] Function object: used 'Param' expression when not in a function call");
            return 0
        },
        Call(d, ...a) {
            const b = this.Push();
            b.name = d.toLowerCase();
            b.retVal = 0;
            b.params = a;
            a = this.FastTrigger(e.Plugins.Function.Cnds.OnFunction, b.name);
            this._isPreview && !a && console.warn(`[Construct 3] Function object: expression Function.Call("${d}" ...) was used, but no event was triggered. Is the function call spelt incorrectly or no longer used?`);
            this.Pop();
            return b.retVal
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Touch = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X;
    e.Plugins.Touch.Type = class extends e.SDKTypeBase {
        constructor(c) {
            super(c)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.ITouchObjectType
        }
    };
    let a = null;

    function b() {
        return a.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.ITouchObjectType = class extends self.IObjectClass {
        constructor(c) {
            super(c);
            a = c;
            c.GetRuntime()._GetCommonScriptInterfaces().touch = this
        }
        requestPermission(c) {
            d.RequireString(c);
            const f = b();
            if ("orientation" === c) return f._RequestPermission(0);
            if ("motion" === c) return f._RequestPermission(1);
            throw Error("invalid type");
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Touch.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d, "touch");
            this._touches = new Map;
            this._isMouseDown = this._useMouseInput = !1;
            this._getTouchIndex = this._curTouchY = this._curTouchX = this._triggerPermission = this._triggerId = this._triggerIndex = this._accWithGZ = this._accWithGY = this._accWithGX = this._accZ = this._accY = this._accX = this._orientGamma = this._orientBeta = this._orientAlpha = this._orientCompassHeading = 0;
            this._permissionPromises = [];
            a && (this._useMouseInput =
                a[0]);
            this.AddDOMMessageHandler("permission-result", b => this._OnPermissionResult(b));
            d = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(d, "pointerdown", b => this._OnPointerDown(b.data)), e.Disposable.From(d, "pointermove", b => this._OnPointerMove(b.data)), e.Disposable.From(d, "pointerup", b => this._OnPointerUp(b.data, !1)), e.Disposable.From(d, "pointercancel", b => this._OnPointerUp(b.data, !0)), e.Disposable.From(d, "deviceorientation", b => this._OnDeviceOrientation(b.data)),
                e.Disposable.From(d, "deviceorientationabsolute", b => this._OnDeviceOrientationAbsolute(b.data)), e.Disposable.From(d, "devicemotion", b => this._OnDeviceMotion(b.data)), e.Disposable.From(d, "tick2", b => this._OnTick2()))
        }
        Release() {
            this._touches.clear();
            super.Release()
        }
        _OnPointerDown(d) {
            if ("mouse" === d.pointerType)
                if (this._useMouseInput) this._isMouseDown = !0;
                else return;
            const a = d.pointerId;
            if (!this._touches.has(a)) {
                var b = d.pageX - this._runtime.GetCanvasClientX();
                d = d.pageY - this._runtime.GetCanvasClientY();
                var c =
                    performance.now(),
                    f = this._touches.size;
                this._triggerIndex = f;
                this._triggerId = a;
                var h = e.New(e.Plugins.Touch.TouchInfo);
                h.Init(c, b, d, a, f);
                this._touches.set(a, h);
                this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchStart);
                this.Trigger(e.Plugins.Touch.Cnds.OnTouchStart);
                this._curTouchX = b;
                this._curTouchY = d;
                this.Trigger(e.Plugins.Touch.Cnds.OnTouchObject)
            }
        }
        _OnPointerMove(d) {
            if ("mouse" !== d.pointerType || this._isMouseDown) {
                var a = this._touches.get(d.pointerId);
                if (a) {
                    var b = performance.now();
                    if (!(2 > b - a.GetTime())) {
                        var c =
                            d.pageX - this._runtime.GetCanvasClientX(),
                            f = d.pageY - this._runtime.GetCanvasClientY();
                        a.Update(b, c, f, d.width, d.height, d.pressure)
                    }
                }
            }
        }
        _OnPointerUp(d, a) {
            if ("mouse" === d.pointerType)
                if (this._isMouseDown) this._isMouseDown = !1;
                else return;
            const b = performance.now();
            d = d.pointerId;
            const c = this._touches.get(d);
            c && (this._triggerIndex = c.GetStartIndex(), this._triggerId = c.GetId(), this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(e.Plugins.Touch.Cnds.OnTouchEnd), a || (a = c.ShouldTriggerTap(b), "single-tap" ===
                a ? (this.Trigger(e.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === a && (this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGestureObject))), c.Release(), this._touches.delete(d))
        }
        _RequestPermission(d) {
            this._PostToDOMMaybeSync("request-permission", {
                type: d
            });
            return new Promise((a, b) => {
                this._permissionPromises.push({
                    type: d,
                    resolve: a,
                    reject: b
                })
            })
        }
        _OnPermissionResult(d) {
            const a = d.result,
                b = d.type;
            this._triggerPermission = b;
            d = this._permissionPromises.filter(c => c.type === b);
            for (const c of d) c.resolve(a ? "granted" : "denied");
            this._permissionPromises = this._permissionPromises.filter(c => c.type !== b);
            a ? (this.Trigger(e.Plugins.Touch.Cnds.OnPermissionGranted), 0 === b ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(e.Plugins.Touch.Cnds.OnPermissionDenied)
        }
        _OnDeviceOrientation(d) {
            "number" ===
            typeof d.webkitCompassHeading ? this._orientCompassHeading = d.webkitCompassHeading : d.absolute && (this._orientCompassHeading = d.alpha);
            this._orientAlpha = d.alpha;
            this._orientBeta = d.beta;
            this._orientGamma = d.gamma
        }
        _OnDeviceOrientationAbsolute(d) {
            this._orientCompassHeading = d.alpha
        }
        _OnDeviceMotion(d) {
            const a = d.acceleration;
            a && (this._accX = a.x, this._accY = a.y, this._accZ = a.z);
            if (d = d.accelerationIncludingGravity) this._accWithGX = d.x, this._accWithGY = d.y, this._accWithGZ = d.z
        }
        _OnTick2() {
            const d = performance.now();
            let a =
                0;
            for (const b of this._touches.values()) b.GetTime() <= d - 50 && b._SetLastTime(d), b.ShouldTriggerHold(d) && (this._triggerIndex = b.GetStartIndex(), this._triggerId = b.GetId(), this._getTouchIndex = a, this.Trigger(e.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = b.GetX(), this._curTouchY = b.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++a
        }
        _GetTouchByIndex(d) {
            d = Math.floor(d);
            for (const a of this._touches.values()) {
                if (0 === d) return a;
                --d
            }
            return null
        }
        _IsClientPosOnCanvas(d, a) {
            return 0 <=
                d && 0 <= a && d < this._runtime.GetCanvasCssWidth() && a < this._runtime.GetCanvasCssHeight()
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.touch.debugger.touches",
                properties: [...this._touches.values()].map(d => ({
                    name: "$" + d.GetId(),
                    value: d.GetX() + ", " + d.GetY()
                }))
            }]
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [];
    e.Plugins.Touch.Cnds = {
        OnTouchStart() {
            return !0
        },
        OnTouchEnd() {
            return !0
        },
        IsInTouch() {
            return 0 < this._touches.size
        },
        OnTouchObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
        },
        IsTouchingObject(a) {
            if (!a) return !1;
            const b = a.GetCurrentSol();
            var c = b.GetInstances();
            for (const f of c) {
                c = f.GetWorldInfo();
                const h = c.GetLayer();
                for (const g of this._touches.values()) {
                    if (!this._IsClientPosOnCanvas(g.GetX(),
                            g.GetY())) continue;
                    const [k, m] = h.CanvasCssToLayer(g.GetX(), g.GetY(), c.GetTotalZElevation());
                    if (c.ContainsPoint(k, m)) {
                        d.push(f);
                        break
                    }
                }
            }
            return d.length ? (b.SetArrayPicked(d), a.ApplySolToContainer(), e.clearArray(d), !0) : !1
        },
        CompareTouchSpeed(a, b, c) {
            return (a = this._GetTouchByIndex(a)) ? e.compare(a.GetSpeed(), b, c) : !1
        },
        OrientationSupported() {
            return !0
        },
        MotionSupported() {
            return !0
        },
        CompareOrientation(a, b, c) {
            this._runtime.RequestDeviceOrientationEvent();
            return e.compare(0 === a ? this._orientAlpha : 1 === a ? this._orientBeta :
                this._orientGamma, b, c)
        },
        CompareAcceleration(a, b, c) {
            this._runtime.RequestDeviceMotionEvent();
            return e.compare(0 === a ? this._accWithGX : 1 === a ? this._accWithGY : 2 === a ? this._accWithGZ : 3 === a ? this._accX : 4 === a ? this._accY : this._accZ, b, c)
        },
        OnNthTouchStart(a) {
            a = Math.floor(a);
            return a === this._triggerIndex
        },
        OnNthTouchEnd(a) {
            a = Math.floor(a);
            return a === this._triggerIndex
        },
        HasNthTouch(a) {
            a = Math.floor(a);
            return this._touches.size >= a + 1
        },
        OnHoldGesture() {
            return !0
        },
        OnTapGesture() {
            return !0
        },
        OnDoubleTapGesture() {
            return !0
        },
        OnHoldGestureObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
        },
        OnTapGestureObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
        },
        OnDoubleTapGestureObject(a) {
            return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a,
                this._curTouchX, this._curTouchY, !1) : !1
        },
        OnPermissionGranted(a) {
            return this._triggerPermission === a
        },
        OnPermissionDenied(a) {
            return this._triggerPermission === a
        }
    }
}
"use strict";
self.C3.Plugins.Touch.Acts = {
    RequestPermission(e) {
        this._RequestPermission(e)
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Touch.Exps = {
        TouchCount() {
            return this._touches.size
        },
        X(d) {
            const a = this._GetTouchByIndex(this._getTouchIndex);
            return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), d, !0) : 0
        },
        Y(d) {
            const a = this._GetTouchByIndex(this._getTouchIndex);
            return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), d, !1) : 0
        },
        XAt(d, a) {
            return (d = this._GetTouchByIndex(d)) ? d.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
        },
        YAt(d, a) {
            return (d = this._GetTouchByIndex(d)) ?
                d.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
        },
        XForID(d, a) {
            return (d = this._touches.get(d)) ? d.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
        },
        YForID(d, a) {
            return (d = this._touches.get(d)) ? d.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
        },
        AbsoluteX() {
            const d = this._GetTouchByIndex(0);
            return d ? d.GetX() : 0
        },
        AbsoluteY() {
            const d = this._GetTouchByIndex(0);
            return d ? d.GetY() : 0
        },
        AbsoluteXAt(d) {
            return (d = this._GetTouchByIndex(d)) ? d.GetX() : 0
        },
        AbsoluteYAt(d) {
            return (d = this._GetTouchByIndex(d)) ?
                d.GetY() : 0
        },
        AbsoluteXForID(d) {
            return (d = this._touches.get(d)) ? d.GetX() : 0
        },
        AbsoluteYForID(d) {
            return (d = this._touches.get(d)) ? d.GetY() : 0
        },
        SpeedAt(d) {
            return (d = this._GetTouchByIndex(d)) ? d.GetSpeed() : 0
        },
        SpeedForID(d) {
            return (d = this._touches.get(d)) ? d.GetSpeed() : 0
        },
        AngleAt(d) {
            return (d = this._GetTouchByIndex(d)) ? e.toDegrees(d.GetAngle()) : 0
        },
        AngleForID(d) {
            return (d = this._touches.get(d)) ? e.toDegrees(d.GetAngle()) : 0
        },
        CompassHeading() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientCompassHeading
        },
        Alpha() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientAlpha
        },
        Beta() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientBeta
        },
        Gamma() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientGamma
        },
        AccelerationXWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGX
        },
        AccelerationYWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGY
        },
        AccelerationZWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGZ
        },
        AccelerationX() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accX
        },
        AccelerationY() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accY
        },
        AccelerationZ() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accZ
        },
        TouchIndex() {
            return this._triggerIndex
        },
        TouchID() {
            return this._triggerId
        },
        WidthForID(d) {
            return (d = this._touches.get(d)) ? d.GetWidth() : 0
        },
        HeightForID(d) {
            return (d = this._touches.get(d)) ? d.GetHeight() : 0
        },
        PressureForID(d) {
            return (d = this._touches.get(d)) ? d.GetPressure() : 0
        }
    }
} {
    "use strict";
    const e = self.C3;
    let d = -1E3,
        a = -1E3,
        b = -1E4;
    e.Plugins.Touch.TouchInfo = class extends e.DefendedBase {
        constructor() {
            super();
            this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0;
            this._isTooFarForHold = this._hasTriggeredHold = !1
        }
        Release() {}
        Init(c, f, h, g, k) {
            this._pointerId = g;
            this._startIndex = k;
            this._startTime = this._lastTime = this._time = c;
            this._startX = f;
            this._startY = h;
            this._x = f;
            this._y = h;
            this._lastX = f;
            this._lastY = h
        }
        Update(c, f, h, g, k, m) {
            this._lastTime = this._time;
            this._time = c;
            this._lastX = this._x;
            this._lastY = this._y;
            this._x = f;
            this._y = h;
            this._width = g;
            this._height = k;
            this._pressure = m;
            !this._isTooFarForHold && 15 <= e.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
        }
        GetId() {
            return this._pointerId
        }
        GetStartIndex() {
            return this._startIndex
        }
        GetTime() {
            return this._time
        }
        _SetLastTime(c) {
            this._lastTime = c
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSpeed() {
            const c =
                e.distanceTo(this._x, this._y, this._lastX, this._lastY),
                f = (this._time - this._lastTime) / 1E3;
            return 0 < f ? c / f : 0
        }
        GetAngle() {
            return e.angleTo(this._lastX, this._lastY, this._x, this._y)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetPressure() {
            return this._pressure
        }
        ShouldTriggerHold(c) {
            return this._hasTriggeredHold ? !1 : 500 <= c - this._startTime && !this._isTooFarForHold && 15 > e.distanceTo(this._startX, this._startY, this._x, this._y) ? this._hasTriggeredHold = !0 : !1
        }
        ShouldTriggerTap(c) {
            if (this._hasTriggeredHold) return "";
            if (333 >= c - this._startTime && !this._isTooFarForHold && 15 > e.distanceTo(this._startX, this._startY, this._x, this._y)) {
                if (666 >= c - b && 25 > e.distanceTo(d, a, this._x, this._y)) return a = d = -1E3, b = -1E4, "double-tap";
                d = this._x;
                a = this._y;
                b = c;
                return "single-tap"
            }
            return ""
        }
        GetPositionForLayer(c, f, h) {
            return "undefined" === typeof f ? c.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[h ? 0 : 1] : (c = c.GetLayer(f)) ? c.CanvasCssToLayer(this._x, this._y)[h ? 0 : 1] : 0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Browser = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Browser.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Browser.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d, "browser");
            this._initLocationStr = "";
            this._isOnline = !1;
            this._docTitle = this._referrer = "";
            this._isCookieEnabled = !1;
            this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
            this._isScirraArcade = !1;
            this.AddDOMMessageHandlers([
                ["online-state", b => this._OnOnlineStateChanged(b)],
                ["backbutton", () => this._OnBackButton()],
                ["sw-message", b => this._OnSWMessage(b)],
                ["hashchange",
                    b => this._OnHashChange(b)
                ]
            ]);
            d = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(d, "afterfirstlayoutstart", () => this._OnAfterFirstLayoutStart()), e.Disposable.From(d, "window-resize", () => this._OnWindowResize()), e.Disposable.From(d, "suspend", () => this._OnSuspend()), e.Disposable.From(d, "resume", () => this._OnResume()));
            this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state", {
                exportType: this._runtime.GetExportType()
            }).then(b => {
                this._initLocationStr = b.location;
                this._isOnline = b.isOnline;
                this._referrer = b.referrer;
                this._docTitle = b.title;
                this._isCookieEnabled = b.isCookieEnabled;
                this._screenWidth = b.screenWidth;
                this._screenHeight = b.screenHeight;
                this._windowOuterWidth = b.windowOuterWidth;
                this._windowOuterHeight = b.windowOuterHeight;
                this._isScirraArcade = b.isScirraArcade
            }))
        }
        Release() {
            super.Release()
        }
        _OnAfterFirstLayoutStart() {
            this.PostToDOM("ready-for-sw-messages")
        }
        async _OnOnlineStateChanged(d) {
            d = !!d.isOnline;
            this._isOnline !== d && ((this._isOnline = d) ? await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOnline) :
                await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOffline))
        }
        async _OnWindowResize() {
            await this.TriggerAsync(e.Plugins.Browser.Cnds.OnResize)
        }
        _OnSuspend() {
            this.Trigger(e.Plugins.Browser.Cnds.OnPageHidden)
        }
        _OnResume() {
            this.Trigger(e.Plugins.Browser.Cnds.OnPageVisible)
        }
        async _OnBackButton() {
            await this.TriggerAsync(e.Plugins.Browser.Cnds.OnBackButton)
        }
        _OnSWMessage(d) {
            d = d.type;
            "downloading-update" === d ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateFound) : "update-ready" === d || "update-pending" === d ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateReady) :
                "offline-ready" === d && this.Trigger(e.Plugins.Browser.Cnds.OnOfflineReady)
        }
        _OnHashChange(d) {
            this._initLocationStr = d.location;
            this.Trigger(e.Plugins.Browser.Cnds.OnHashChange)
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.browser.name",
                properties: [{
                    name: "plugins.browser.debugger.user-agent",
                    value: navigator.userAgent
                }, {
                    name: "plugins.browser.debugger.is-online",
                    value: this._isOnline
                }, {
                    name: "plugins.browser.debugger.is-fullscreen",
                    value: this._runtime.GetCanvasManager().IsDocumentFullscreen()
                }]
            }]
        }
    }
}
"use strict";
self.C3.Plugins.Browser.Cnds = {
    IsOnline() {
        return this._isOnline
    },
    OnOnline() {
        return !0
    },
    OnOffline() {
        return !0
    },
    OnResize() {
        return !0
    },
    CookiesEnabled() {
        return this._isCookieEnabled
    },
    IsFullscreen() {
        return this._runtime.GetCanvasManager().IsDocumentFullscreen()
    },
    OnBackButton() {
        return !0
    },
    IsPortraitLandscape(e) {
        const d = this._runtime.GetCanvasManager().GetLastWidth(),
            a = this._runtime.GetCanvasManager().GetLastHeight();
        return (d <= a ? 0 : 1) === e
    },
    OnUpdateFound() {
        return !0
    },
    OnUpdateReady() {
        return !0
    },
    OnOfflineReady() {
        return !0
    },
    OnHashChange() {
        return !0
    },
    PageVisible() {
        return !this._runtime.IsSuspended()
    },
    OnPageHidden() {
        return !0
    },
    OnPageVisible() {
        return !0
    },
    HasJava() {
        return !1
    },
    IsDownloadingUpdate() {
        return !1
    },
    OnMenuButton() {
        return !1
    },
    OnSearchButton() {
        return !1
    },
    IsMetered() {
        return !1
    },
    IsCharging() {
        return !0
    },
    SupportsFullscreen() {
        return !0
    }
}; {
    "use strict";
    const e = self.C3,
        d = "portrait landscape portrait-primary portrait-secondary landscape-primary landscape-secondary".split(" ");
    e.Plugins.Browser.Acts = {
        Alert(a) {
            this.PostToDOM("alert", {
                message: a.toString()
            })
        },
        Close() {
            this._isScirraArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM("close"))
        },
        Focus() {
            this.PostToDOM("set-focus", {
                isFocus: !0
            })
        },
        Blur() {
            this.PostToDOM("set-focus", {
                isFocus: !1
            })
        },
        GoBack() {
            this._isScirraArcade || this.PostToDOM("navigate", {
                type: "back"
            })
        },
        GoForward() {
            this._isScirraArcade || this.PostToDOM("navigate", {
                type: "forward"
            })
        },
        GoHome() {},
        Reload() {
            this._isScirraArcade || (this._runtime.IsDebug() ? this._runtime.PostToDebugger({
                type: "reload"
            }) : this.PostToDOM("navigate", {
                type: "reload"
            }))
        },
        GoToURL(a, b) {
            this._PostToDOMMaybeSync("navigate", {
                type: "url",
                url: a,
                target: b,
                exportType: this._runtime.GetExportType()
            })
        },
        GoToURLWindow(a, b) {
            this._PostToDOMMaybeSync("navigate", {
                type: "new-window",
                url: a,
                tag: b,
                exportType: this._runtime.GetExportType()
            })
        },
        RequestFullScreen(a,
            b) {
            2 <= a && (a += 1);
            6 === a && (a = 2);
            1 === a && (a = 0);
            a = e.CanvasManager._FullscreenModeNumberToString(a);
            this._runtime.GetCanvasManager().SetDocumentFullscreenMode(a);
            this._PostToDOMMaybeSync("request-fullscreen", {
                navUI: b
            })
        },
        CancelFullScreen() {
            this._PostToDOMMaybeSync("exit-fullscreen")
        },
        Vibrate(a) {
            a = a.split(",");
            for (let b = 0, c = a.length; b < c; ++b) a[b] = parseInt(a[b], 10);
            this._PostToDOMMaybeSync("vibrate", {
                pattern: a
            })
        },
        async InvokeDownload(a, b) {
            a && b && (a = await this._runtime.GetAssetManager().GetProjectFileUrl(a), this._runtime.InvokeDownload(a,
                b))
        },
        InvokeDownloadString(a, b, c) {
            c && (a = `data:${b},${encodeURIComponent(a)}`, this._runtime.InvokeDownload(a, c))
        },
        ConsoleLog(a, b) {
            b = b.toString();
            0 === a ? console.log(b) : 1 === a ? console.warn(b) : 2 === a && console.error(b)
        },
        ConsoleGroup(a) {
            console.group(a)
        },
        ConsoleGroupEnd() {
            console.groupEnd()
        },
        ExecJs(a) {
            try {
                eval(a)
            } catch (b) {
                console.error("Error executing JavaScript: ", b)
            }
        },
        LockOrientation(a) {
            a = Math.floor(a);
            0 > a || a >= d.length || this._PostToDOMMaybeSync("lock-orientation", {
                orientation: d[a]
            })
        },
        UnlockOrientation() {
            this._PostToDOMMaybeSync("unlock-orientation")
        },
        LoadStyleSheet(a) {
            this._runtime.GetAssetManager().LoadStyleSheet(a)
        },
        SetHash(a) {
            this.PostToDOM("set-hash", {
                hash: a
            })
        }
    }
}
"use strict";
self.C3.Plugins.Browser.Exps = {
    URL() {
        return this._runtime.IsInWorker() ? this._initLocationStr : location.toString()
    },
    Protocol() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).protocol : location.protocol
    },
    Domain() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hostname : location.hostname
    },
    Port() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).port : location.port
    },
    PathName() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).pathname :
            location.pathname
    },
    Hash() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).hash : location.hash
    },
    QueryString() {
        return this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search
    },
    QueryParam(e) {
        const d = this._runtime.IsInWorker() ? (new URL(this._initLocationStr)).search : location.search;
        return (e = RegExp("[?&]" + e + "=([^&]*)").exec(d)) ? decodeURIComponent(e[1].replace(/\+/g, " ")) : ""
    },
    Referrer() {
        return this._referrer
    },
    Title() {
        return this._docTitle
    },
    Language() {
        return navigator.language
    },
    Platform() {
        return navigator.platform
    },
    UserAgent() {
        return navigator.userAgent
    },
    ExecJS(e) {
        let d = 0;
        try {
            d = eval(e)
        } catch (a) {
            console.error("Error executing JavaScript: ", a)
        }
        return "number" === typeof d || "string" === typeof d ? d : "boolean" === typeof d ? d ? 1 : 0 : 0
    },
    Name() {
        return navigator.appName
    },
    Version() {
        return navigator.appVersion
    },
    Product() {
        return navigator.product
    },
    Vendor() {
        return navigator.vendor
    },
    BatteryLevel() {
        return 1
    },
    BatteryTimeLeft() {
        return Infinity
    },
    Bandwidth() {
        const e = navigator.connection;
        return e ? e.downlink ||
            e.downlinkMax || e.bandwidth || Infinity : Infinity
    },
    ConnectionType() {
        const e = navigator.connection;
        return e ? e.type || "unknown" : "unknown"
    },
    DevicePixelRatio() {
        return self.devicePixelRatio
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterWidth
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d);
            this._curTag = this._lastData = "";
            this._progress = 0;
            this._timeout = -1;
            this._nextRequestHeaders = new Map;
            this._nextReponseBinaryData = null;
            this._nextRequestOverrideMimeType = "";
            this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null;
            if (this._isNWjs = "nwjs" === this._runtime.GetExportType()) this._nwjsFs = require("fs"), this._nwjsPath = require("path"), this._nwjsAppFolder = this._nwjsPath.dirname((self.process ||
                nw.process).execPath) + "\\"
        }
        Release() {
            super.Release()
        }
        async _TriggerError(d, a, b) {
            console.error(`[Construct 3] AJAX request to '${a}' (tag '${d}') failed: `, b);
            this._curTag = d;
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyError);
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnError)
        }
        async _TriggerComplete(d) {
            this._curTag = d;
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyComplete);
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnComplete)
        }
        async _OnProgress(d, a) {
            a.lengthComputable && (this._progress = a.loaded /
                a.total, this._curTag = d, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnProgress))
        }
        _OnError(d, a, b) {
            if (this._isNWjs) {
                var c = this._nwjsFs,
                    f = this._nwjsAppFolder + a;
                c.existsSync(f) ? c.readFile(f, {
                    encoding: "utf8"
                }, (h, g) => {
                    h ? this._TriggerError(d, a, h) : (this._lastData = g.replace(/\r\n/g, "\n"), this._TriggerComplete(d))
                }) : this._TriggerError(d, a, b)
            } else this._TriggerError(d, a, b)
        }
        async _DoCordovaRequest(d, a) {
            const b = this._runtime.GetAssetManager(),
                c = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
                if (c) {
                    const f =
                        await b.CordovaFetchLocalFileAsArrayBuffer(a);
                    c.SetArrayBufferTransfer(f);
                    this._lastData = ""
                } else this._lastData = (await b.CordovaFetchLocalFileAsText(a)).replace(/\r\n/g, "\n");
                this._TriggerComplete(d)
            } catch (f) {
                this._TriggerError(d, a, f)
            }
        }
        _DoRequest(d, a, b, c) {
            return new Promise(f => {
                const h = k => {
                        this._OnError(d, a, k);
                        f()
                    },
                    g = this._nextReponseBinaryData;
                this._nextReponseBinaryData = null;
                try {
                    const k = new XMLHttpRequest;
                    k.onreadystatechange = () => {
                        if (4 === k.readyState) {
                            this._lastData = g ? "" : (k.responseText || "").replace(/\r\n/g,
                                "\n");
                            if (400 <= k.status) this._TriggerError(d, a, k.status + k.statusText);
                            else {
                                const m = this._lastData.length || g && k.response instanceof ArrayBuffer;
                                this._isNWjs && !m || !this._isNWjs && 0 === k.status && !m || (g && g.SetArrayBufferTransfer(k.response), this._TriggerComplete(d))
                            }
                            f()
                        }
                    };
                    k.onerror = h;
                    k.ontimeout = h;
                    k.onabort = h;
                    k.onprogress = m => this._OnProgress(d, m);
                    k.open(b, a);
                    0 <= this._timeout && "undefined" !== typeof k.timeout && (k.timeout = this._timeout);
                    k.responseType = g ? "arraybuffer" : "text";
                    c && !this._nextRequestHeaders.has("Content-Type") &&
                        ("string" !== typeof c ? k.setRequestHeader("Content-Type", "application/octet-stream") : k.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"));
                    for (const [m, r] of this._nextRequestHeaders) try {
                        k.setRequestHeader(m, r)
                    } catch (w) {
                        console.error(`[Construct 3] AJAX: Failed to set header '${m}: ${r}': `, w)
                    }
                    this._nextRequestHeaders.clear();
                    if (this._nextRequestOverrideMimeType) {
                        try {
                            k.overrideMimeType(this._nextRequestOverrideMimeType)
                        } catch (m) {
                            console.error("[Construct 3] AJAX: failed to override MIME type: ",
                                m)
                        }
                        this._nextRequestOverrideMimeType = ""
                    }
                    c ? k.send(c) : k.send()
                } catch (k) {
                    h(k)
                }
            })
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.ajax.debugger.title",
                properties: [{
                    name: "plugins.ajax.debugger.last-data",
                    value: this._lastData
                }]
            }]
        }
        SaveToJson() {
            return {
                lastData: this._lastData
            }
        }
        LoadFromJson(d) {
            this._lastData = d.lastData;
            this._curTag = "";
            this._progress = 0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Cnds = {
        OnComplete(d) {
            return e.equalsNoCase(this._curTag, d)
        },
        OnAnyComplete() {
            return !0
        },
        OnError(d) {
            return e.equalsNoCase(this._curTag, d)
        },
        OnAnyError() {
            return !0
        },
        OnProgress(d) {
            return e.equalsNoCase(this._curTag, d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Acts = {
        async Request(d, a) {
            this._runtime.IsCordova() && e.IsRelativeURL(a) && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(d, a) : this._runtime.IsPreview() && e.IsRelativeURL(a) ? (a = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a.toLowerCase()), await this._DoRequest(d, a, "GET", null)) : await this._DoRequest(d, a, "GET", null)
        },
        async RequestFile(d, a) {
            this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(d,
                a) : await this._DoRequest(d, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a), "GET", null)
        },
        async Post(d, a, b, c) {
            await this._DoRequest(d, a, c, b)
        },
        async PostBinary(d, a, b, c) {
            b && (b = b.GetFirstPicked(this._inst)) && (b = b.GetSdkInstance().GetArrayBufferReadOnly(), await this._DoRequest(d, a, c, b))
        },
        SetTimeout(d) {
            this._timeout = 1E3 * d
        },
        SetHeader(d, a) {
            this._nextRequestHeaders.set(d, a)
        },
        SetResponseBinary(d) {
            d && (d = d.GetFirstPicked(this._inst)) && (this._nextReponseBinaryData = d.GetSdkInstance())
        },
        OverrideMIMEType(d) {
            this._nextRequestOverrideMimeType =
                d
        }
    }
}
"use strict";
self.C3.Plugins.AJAX.Exps = {
    LastData() {
        return this._lastData
    },
    Progress() {
        return this._progress
    },
    Tag() {
        return this._curTag
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.LocalStorage = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.LocalStorage.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.LocalStorage.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d);
            this._lastValue = this._currentKey = "";
            this._keyNamesList = [];
            this._errorMessage = "";
            this._pendingSets = this._pendingGets = 0;
            this._storage = this._runtime._GetProjectStorage();
            this._debugCache = new Map;
            this._isLoadingDebugCache = !1
        }
        Release() {
            super.Release()
        }
        async _TriggerStorageError(d) {
            this._errorMessage = this._GetErrorString(d);
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnError)
        }
        _GetErrorString(d) {
            return d ?
                "string" === typeof d ? d : "string" === typeof d.message ? d.message : "string" === typeof d.name ? d.name : "string" === typeof d.data ? d.data : "unknown error" : "unknown error"
        }
        GetDebuggerProperties() {
            this._isLoadingDebugCache || this._DebugCacheStorage();
            return [{
                title: "plugins.localstorage.name",
                properties: [...this._debugCache.entries()].map(d => ({
                    name: "$" + d[0],
                    value: d[1],
                    onedit: a => this._storage.setItem(d[0], a)
                }))
            }]
        }
        async _DebugCacheStorage() {
            this._isLoadingDebugCache = !0;
            try {
                const d = await this._storage.keys();
                d.sort((b,
                    c) => {
                    b = b.toLowerCase();
                    c = c.toLowerCase();
                    return b < c ? -1 : c < b ? 1 : 0
                });
                const a = await Promise.all(d.map(b => this._storage.getItem(b)));
                this._debugCache.clear();
                for (let b = 0, c = d.length; b < c; ++b) this._debugCache.set(d[b], a[b])
            } catch (d) {
                console.warn("[C3 debugger] Error displaying local storage: ", d)
            } finally {
                this._isLoadingDebugCache = !1
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.LocalStorage.Cnds = {
        OnItemSet(d) {
            return this._currentKey === d
        },
        OnAnyItemSet() {
            return !0
        },
        OnItemGet(d) {
            return this._currentKey === d
        },
        OnAnyItemGet() {
            return !0
        },
        OnItemRemoved(d) {
            return this._currentKey === d
        },
        OnAnyItemRemoved() {
            return !0
        },
        OnCleared() {
            return !0
        },
        OnAllKeyNamesLoaded() {
            return !0
        },
        OnError() {
            return !0
        },
        OnItemExists(d) {
            return this._currentKey === d
        },
        OnItemMissing(d) {
            return this._currentKey === d
        },
        CompareKey(d, a) {
            return e.compare(this._currentKey, d, a)
        },
        CompareValue(d,
            a) {
            return e.compare(this._lastValue, d, a)
        },
        IsProcessingSets() {
            return 0 < this._pendingSets
        },
        IsProcessingGets() {
            return 0 < this._pendingGets
        },
        OnAllSetsComplete() {
            return !0
        },
        OnAllGetsComplete() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(a) {
        return "string" === typeof a || "number" === typeof a
    }
    e.Plugins.LocalStorage.Acts = {
        async SetItem(a, b) {
            this._pendingSets++;
            try {
                const c = await this._storage.setItem(a, b);
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    this._lastValue = c;
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemSet);
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemSet)
                })
            } catch (c) {
                await this._TriggerStorageError(c)
            } finally {
                this._pendingSets--, 0 === this._pendingSets &&
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllSetsComplete)
            }
        },
        async SetBinaryItem(a, b) {
            if (b && (b = b.GetFirstPicked(this._inst)) && (b = b.GetSdkInstance())) {
                b = b.GetArrayBufferReadOnly();
                this._pendingSets++;
                try {
                    await this._storage.setItem(a, b), await this.ScheduleTriggers(async () => {
                        this._currentKey = a;
                        this._lastValue = "";
                        await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemSet);
                        await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemSet)
                    })
                } catch (c) {
                    await this._TriggerStorageError(c)
                } finally {
                    this._pendingSets--,
                        0 === this._pendingSets && await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllSetsComplete)
                }
            }
        },
        async GetItem(a) {
            this._pendingGets++;
            try {
                const b = await this._storage.getItem(a);
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    this._lastValue = d(b) ? b : "";
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemGet);
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemGet)
                })
            } catch (b) {
                await this._TriggerStorageError(b)
            } finally {
                this._pendingGets--, 0 === this._pendingGets && await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllGetsComplete)
            }
        },
        async GetBinaryItem(a, b) {
            if (b && (b = b.GetFirstPicked(this._inst))) {
                var c = b.GetSdkInstance();
                this._pendingGets++;
                try {
                    let f = await this._storage.getItem(a);
                    f = f instanceof ArrayBuffer ? f : new ArrayBuffer(0);
                    await this.ScheduleTriggers(async () => {
                        this._lastValue = "";
                        this._currentKey = a;
                        c.SetArrayBufferTransfer(f);
                        await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemGet);
                        await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemGet)
                    })
                } catch (f) {
                    await this._TriggerStorageError(f)
                } finally {
                    this._pendingGets--,
                        0 === this._pendingGets && await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllGetsComplete)
                }
            }
        },
        async CheckItemExists(a) {
            try {
                const b = await this._storage.getItem(a);
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    "undefined" === typeof b || null === b ? (this._lastValue = "", await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemMissing)) : (this._lastValue = d(b) ? b : "", await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemExists))
                })
            } catch (b) {
                await this._TriggerStorageError(b)
            }
        },
        async RemoveItem(a) {
            try {
                await this._storage.removeItem(a),
                    await this.ScheduleTriggers(async () => {
                        this._currentKey = a;
                        this._lastValue = "";
                        await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemRemoved);
                        await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemRemoved)
                    })
            } catch (b) {
                await this._TriggerStorageError(b)
            }
        },
        async ClearStorage() {
            try {
                await this._storage.clear(), await this.ScheduleTriggers(async () => {
                    this._lastValue = this._currentKey = "";
                    e.clearArray(this._keyNamesList);
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnCleared)
                })
            } catch (a) {
                await this._TriggerStorageError(a)
            }
        },
        async GetAllKeyNames() {
            try {
                const a = await this._storage.keys();
                await this.ScheduleTriggers(async () => {
                    this._keyNamesList = a;
                    await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded)
                })
            } catch (a) {
                await this._TriggerStorageError(a)
            }
        }
    }
}
"use strict";
self.C3.Plugins.LocalStorage.Exps = {
    ItemValue() {
        return this._lastValue
    },
    Key() {
        return this._currentKey
    },
    KeyCount() {
        return this._keyNamesList.length
    },
    KeyAt(e) {
        e = Math.floor(e);
        return 0 > e || e >= this._keyNamesList.length ? "" : this._keyNamesList[e]
    },
    ErrorMessage() {
        return this._errorMessage
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Audio = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Audio.Type = class extends e.SDKTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IAudioObjectType
        }
    };

    function d() {
        if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
        throw Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
    }
    self.IAudioObjectType = class extends self.IObjectClass {
        constructor(a) {
            super(a)
        }
        get audioContext() {
            return d().GetAudioContext()
        }
        get destinationNode() {
            return d().GetDestinationNode()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = ["interactive", "balanced", "playback"];
    e.Plugins.Audio.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a, "audio");
            this._nextPlayTime = 0;
            this._triggerTag = "";
            this._saveLoadMode = this._timeScaleMode = 0;
            this._playInBackground = !1;
            this._distanceModel = this._panningModel = 1;
            this._listenerX = this._runtime.GetViewportWidth() / 2;
            this._listenerY = this._runtime.GetViewportHeight() / 2;
            this._listenerZ = -600;
            this._referenceDistance = 600;
            this._maxDistance = 1E4;
            this._rolloffFactor =
                1;
            this._listenerInst = null;
            this._loadListenerUid = -1;
            this._masterVolume = 1;
            this._isSilent = !1;
            this._sampleRate = 0;
            this._effectCount = new Map;
            this._preloadCount = this._preloadTotal = 0;
            this._remoteUrls = new Map;
            a = "interactive";
            b && (this._timeScaleMode = b[0], this._saveLoadMode = b[1], this._playInBackground = b[2], a = d[b[3]], this._panningModel = b[4], this._distanceModel = b[5], this._listenerZ = -b[6], this._referenceDistance = b[7], this._maxDistance = b[8], this._rolloffFactor = b[9]);
            this._lastAIState = [];
            this._lastFxState = [];
            this._lastAnalysersData = [];
            this.AddDOMMessageHandlers([
                ["state", c => this._OnUpdateState(c)],
                ["fxstate", c => this._OnUpdateFxState(c)],
                ["trigger", c => this._OnTrigger(c)]
            ]);
            b = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(b, "instancedestroy", c => this._OnInstanceDestroyed(c.instance)), e.Disposable.From(b, "afterload", () => this._OnAfterLoad()), e.Disposable.From(b, "suspend", () => this._OnSuspend()), e.Disposable.From(b, "resume", () => this._OnResume()));
            this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context", {
                preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(c => ({
                    originalUrl: c.originalUrl,
                    url: c.url,
                    type: c.type,
                    fileSize: c.fileSize
                })),
                isiOSCordova: this._runtime.IsiOSCordova(),
                timeScaleMode: this._timeScaleMode,
                latencyHint: a,
                panningModel: this._panningModel,
                distanceModel: this._distanceModel,
                refDistance: this._referenceDistance,
                maxDistance: this._maxDistance,
                rolloffFactor: this._rolloffFactor,
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ]
            }).then(c => {
                this._sampleRate = c.sampleRate
            }));
            this._StartTicking()
        }
        Release() {
            this._listenerInst = null;
            super.Release()
        }
        _OnInstanceDestroyed(a) {
            this._listenerInst === a && (this._listenerInst = null)
        }
        DbToLinearNoCap(a) {
            return Math.pow(10, a / 20)
        }
        DbToLinear(a) {
            a = this.DbToLinearNoCap(a);
            return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0
        }
        LinearToDbNoCap(a) {
            return Math.log(a) / Math.log(10) * 20
        }
        LinearToDb(a) {
            return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0))
        }
        _OnSuspend() {
            this._playInBackground || this.PostToDOM("set-suspended", {
                isSuspended: !0
            })
        }
        _OnResume() {
            this._playInBackground ||
                this.PostToDOM("set-suspended", {
                    isSuspended: !1
                })
        }
        _OnUpdateState(a) {
            const b = a.tickCount,
                c = this._lastAIState.filter(f => f.hasOwnProperty("placeholder") && (f.placeholder > b || -1 === f.placeholder));
            this._lastAIState = a.audioInstances;
            this._lastAnalysersData = a.analysers;
            0 < c.length && e.appendArray(this._lastAIState, c)
        }
        _OnUpdateFxState(a) {
            this._lastFxState = a.fxstate
        }
        _GetFirstAudioStateByTag(a) {
            for (const b of this._lastAIState)
                if (e.equalsNoCase(b.tag, a)) return b;
            return null
        }
        _IsTagPlaying(a) {
            return this._lastAIState.some(b =>
                e.equalsNoCase(a, b.tag) && b.isPlaying)
        }
        _MaybeMarkAsPlaying(a, b, c, f) {
            if (this._IsTagPlaying(a)) return null;
            a = {
                tag: a,
                duration: 0,
                volume: f,
                isPlaying: !0,
                playbackTime: 0,
                playbackRate: 1,
                uid: -1,
                bufferOriginalUrl: "",
                bufferUrl: "",
                bufferType: "",
                isMusic: b,
                isLooping: c,
                isMuted: !1,
                resumePosition: 0,
                pan: null,
                placeholder: -1
            };
            this._lastAIState.push(a);
            return a
        }
        async _OnTrigger(a) {
            const b = a.type;
            this._triggerTag = a.tag;
            a = a.aiid;
            if ("ended" === b) {
                for (const c of this._lastAIState)
                    if (c.aiid === a) {
                        c.isPlaying = !1;
                        break
                    }
                await this.TriggerAsync(e.Plugins.Audio.Cnds.OnEnded)
            } else "fade-ended" ===
                b && await this.TriggerAsync(e.Plugins.Audio.Cnds.OnFadeEnded)
        }
        Tick() {
            const a = {
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTimeRaw(),
                instPans: this.GetInstancePans(),
                tickCount: this._runtime.GetTickCountNoSave()
            };
            if (this._listenerInst) {
                const b = this._listenerInst.GetWorldInfo();
                this._listenerX = b.GetX();
                this._listenerY = b.GetY();
                a.listenerPos = [this._listenerX, this._listenerY, this._listenerZ]
            }
            this.PostToDOM("tick", a)
        }
        rotatePtAround(a, b, c, f, h) {
            if (0 === c) return [a, b];
            const g = Math.sin(c);
            c = Math.cos(c);
            a -= f;
            b -= h;
            const k = a * g;
            a = a * c - b * g;
            return [a + f, b * c + k + h]
        }
        GetInstancePans() {
            return this._lastAIState.filter(a => -1 !== a.uid).map(a => this._runtime.GetInstanceByUID(a.uid)).filter(a => a).map(a => {
                const b = a.GetWorldInfo(),
                    c = b.GetLayer().GetAngle(),
                    [f, h] = this.rotatePtAround(b.GetX(), b.GetY(), -c, this._listenerX, this._listenerY);
                return {
                    uid: a.GetUID(),
                    x: f,
                    y: h,
                    angle: b.GetAngle() - c
                }
            })
        }
        GetAnalyserData(a, b) {
            for (const c of this._lastAnalysersData)
                if (c.index === b && e.equalsNoCase(c.tag, a)) return c;
            return null
        }
        _IncrementEffectCount(a) {
            this._effectCount.set(a,
                (this._effectCount.get(a) || 0) + 1)
        }
        _ShouldSave(a) {
            return a.hasOwnProperty("placeholder") || 3 === this._saveLoadMode ? !1 : a.isMusic && 1 === this._saveLoadMode ? !1 : a.isMusic || 2 !== this._saveLoadMode ? !0 : !1
        }
        SaveToJson() {
            return {
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                listenerZ: this._listenerZ,
                listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
                remoteUrls: [...this._remoteUrls.entries()],
                playing: this._lastAIState.filter(a => this._ShouldSave(a)),
                effects: this._lastFxState,
                analysers: this._lastAnalysersData
            }
        }
        LoadFromJson(a) {
            this._isSilent =
                a.isSilent;
            this._masterVolume = a.masterVolume;
            this._listenerZ = a.listenerZ;
            this._listenerInst = null;
            this._loadListenerUid = a.listenerUid;
            this._remoteUrls.clear();
            if (a.remoteUrls)
                for (const [b, c] of a.remoteUrls) this._remoteUrls.set(b, c);
            this._lastAIState = a.playing;
            this._lastFxState = a.effects;
            this._lastAnalysersData = a.analysers
        }
        _OnAfterLoad() {
            if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid = -1, this._listenerInst)) {
                var a = this._listenerInst.GetWorldInfo();
                this._listenerX = a.GetX();
                this._listenerY = a.GetY()
            }
            for (var b of this._lastAIState)(a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b.bufferOriginalUrl)) ? (b.bufferUrl = a.url, b.bufferType = a.type) : b.bufferUrl = null;
            for (const c of Object.values(this._lastFxState))
                for (const f of c) f.hasOwnProperty("bufferOriginalUrl") && (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f.bufferOriginalUrl)) && (f.bufferUrl = b.url, f.bufferType = b.type);
            this.PostToDOM("load-state", {
                saveLoadMode: this._saveLoadMode,
                timeScale: this._runtime.GetTimeScale(),
                gameTime: this._runtime.GetGameTimeRaw(),
                listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
                isSilent: this._isSilent,
                masterVolume: this._masterVolume,
                playing: this._lastAIState.filter(c => null !== c.bufferUrl),
                effects: this._lastFxState
            })
        }
        GetDebuggerProperties() {
            const a = [];
            for (const [b, c] of Object.entries(this._lastFxState)) a.push({
                name: "$" + b,
                value: c.map(f => f.type).join(", ")
            });
            return [{
                title: "plugins.audio.debugger.tag-effects",
                properties: a
            }, {
                title: "plugins.audio.debugger.currently-playing",
                properties: [{
                    name: "plugins.audio.debugger.currently-playing-count",
                    value: this._lastAIState.length
                }, ...this._lastAIState.map((b, c) => ({
                    name: "$#" + c,
                    value: `${b.bufferOriginalUrl} ("${b.tag}") ${Math.round(10*b.playbackTime)/10} / ${Math.round(10*b.duration)/10}`
                }))]
            }]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Audio.Cnds = {
        OnEnded(d) {
            return e.equalsNoCase(this._triggerTag, d)
        },
        OnFadeEnded(d) {
            return e.equalsNoCase(this._triggerTag, d)
        },
        PreloadsComplete() {
            return this._preloadCount === this._preloadTotal
        },
        AdvancedAudioSupported() {
            return !0
        },
        IsSilent() {
            return this._isSilent
        },
        IsAnyPlaying() {
            for (const d of this._lastAIState)
                if (d.isPlaying) return !0;
            return !1
        },
        IsTagPlaying(d) {
            return this._IsTagPlaying(d)
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = "lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ");
    e.Plugins.Audio.Acts = {
        async Play(a, b, c, f) {
            if (!this._isSilent) {
                var h = a[1],
                    g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
                if (g) {
                    var k = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var m = this._MaybeMarkAsPlaying(f.toLowerCase(), h, 0 !== b, this.DbToLinear(c));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: a[0],
                            url: g.url,
                            type: g.type,
                            isMusic: h,
                            tag: f.toLowerCase(),
                            isLooping: 0 !== b,
                            vol: this.DbToLinear(c),
                            pos: 0,
                            off: k,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        })
                    } finally {
                        m && (m.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtPosition(a, b, c, f, h, g, k, m, r, w) {
            if (!this._isSilent) {
                var p = a[1],
                    t = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
                if (t) {
                    var u = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var q = this._MaybeMarkAsPlaying(w.toLowerCase(), p, 0 !== b, this.DbToLinear(c));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: a[0],
                            url: t.url,
                            type: t.type,
                            isMusic: p,
                            tag: w.toLowerCase(),
                            isLooping: 0 !==
                                b,
                            vol: this.DbToLinear(c),
                            pos: 0,
                            off: u,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: f,
                                y: h,
                                angle: e.toRadians(g),
                                innerAngle: e.toRadians(k),
                                outerAngle: e.toRadians(m),
                                outerGain: this.DbToLinear(r)
                            }
                        })
                    } finally {
                        q && (q.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtObject(a, b, c, f, h, g, k, m) {
            if (!this._isSilent && f && (f = f.GetFirstPicked()) && f.GetWorldInfo()) {
                var r = f.GetWorldInfo(),
                    w = r.GetLayer().GetAngle(),
                    [p, t] = this.rotatePtAround(r.GetX(), r.GetY(), -w, this._listenerX, this._listenerY),
                    u = a[1],
                    q = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
                if (q) {
                    var x = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var y = this._MaybeMarkAsPlaying(m.toLowerCase(), u, 0 !== b, this.DbToLinear(c));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: a[0],
                            url: q.url,
                            type: q.type,
                            isMusic: u,
                            tag: m.toLowerCase(),
                            isLooping: 0 !== b,
                            vol: this.DbToLinear(c),
                            pos: 0,
                            off: x,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: p,
                                y: t,
                                angle: r.GetAngle() - w,
                                innerAngle: e.toRadians(h),
                                outerAngle: e.toRadians(g),
                                outerGain: this.DbToLinear(k),
                                uid: f.GetUID()
                            }
                        })
                    } finally {
                        y && (y.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayByName(a, b, c, f, h) {
            if (!this._isSilent) {
                a = 1 === a;
                var g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
                if (g) {
                    var k = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var m = this._MaybeMarkAsPlaying(h.toLowerCase(), a, 0 !== c, this.DbToLinear(f));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: b,
                            url: g.url,
                            type: g.type,
                            isMusic: a,
                            tag: h.toLowerCase(),
                            isLooping: 0 !== c,
                            vol: this.DbToLinear(f),
                            pos: 0,
                            off: k,
                            trueClock: !!self.C3_GetAudioContextCurrentTime
                        })
                    } finally {
                        m && (m.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtPositionByName(a, b, c, f, h, g, k, m, r, w, p) {
            if (!this._isSilent) {
                a = 1 === a;
                var t = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
                if (t) {
                    var u = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var q = this._MaybeMarkAsPlaying(p.toLowerCase(), a, 0 !== c, this.DbToLinear(f));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: b,
                            url: t.url,
                            type: t.type,
                            isMusic: a,
                            tag: p.toLowerCase(),
                            isLooping: 0 !== c,
                            vol: this.DbToLinear(f),
                            pos: 0,
                            off: u,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: h,
                                y: g,
                                angle: e.toRadians(k),
                                innerAngle: e.toRadians(m),
                                outerAngle: e.toRadians(r),
                                outerGain: this.DbToLinear(w)
                            }
                        })
                    } finally {
                        q && (q.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        async PlayAtObjectByName(a, b, c, f, h, g, k, m, r) {
            if (!this._isSilent && !this._isSilent && h && (h = h.GetFirstPicked()) && h.GetWorldInfo()) {
                var w = h.GetWorldInfo(),
                    p = w.GetLayer().GetAngle(),
                    [t, u] = this.rotatePtAround(w.GetX(),
                        w.GetY(), -p, this._listenerX, this._listenerY);
                a = 1 === a;
                var q = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
                if (q) {
                    var x = this._nextPlayTime;
                    this._nextPlayTime = 0;
                    var y = this._MaybeMarkAsPlaying(r.toLowerCase(), a, 0 !== c, this.DbToLinear(f));
                    try {
                        await this.PostToDOMAsync("play", {
                            originalUrl: b,
                            url: q.url,
                            type: q.type,
                            isMusic: a,
                            tag: r.toLowerCase(),
                            isLooping: 0 !== c,
                            vol: this.DbToLinear(f),
                            pos: 0,
                            off: x,
                            trueClock: !!self.C3_GetAudioContextCurrentTime,
                            panning: {
                                x: t,
                                y: u,
                                angle: w.GetAngle() - p,
                                innerAngle: e.toRadians(g),
                                outerAngle: e.toRadians(k),
                                outerGain: this.DbToLinear(m),
                                uid: h.GetUID()
                            }
                        })
                    } finally {
                        y && (y.placeholder = this._runtime.GetTickCountNoSave())
                    }
                }
            }
        },
        SetLooping(a, b) {
            this.PostToDOM("set-looping", {
                tag: a.toLowerCase(),
                isLooping: 0 === b
            })
        },
        SetMuted(a, b) {
            this.PostToDOM("set-muted", {
                tag: a.toLowerCase(),
                isMuted: 0 === b
            })
        },
        SetVolume(a, b) {
            this.PostToDOM("set-volume", {
                tag: a.toLowerCase(),
                vol: this.DbToLinear(b)
            })
        },
        FadeVolume(a, b, c, f) {
            this.PostToDOM("fade-volume", {
                tag: a.toLowerCase(),
                vol: this.DbToLinear(b),
                duration: c,
                stopOnEnd: 0 === f
            })
        },
        async Preload(a) {
            const b = a[1],
                c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            c && (this._preloadTotal++, await this.PostToDOMAsync("preload", {
                originalUrl: a[0],
                url: c.url,
                type: c.type,
                isMusic: b
            }), this._preloadCount++)
        },
        async PreloadByName(a, b) {
            a = 1 === a;
            const c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            c && (this._preloadTotal++, await this.PostToDOMAsync("preload", {
                originalUrl: b,
                url: c.url,
                type: c.type,
                isMusic: a
            }), this._preloadCount++)
        },
        SetPlaybackRate(a, b) {
            this.PostToDOM("set-playback-rate", {
                tag: a.toLowerCase(),
                rate: Math.max(b, 0)
            })
        },
        Stop(a) {
            this.PostToDOM("stop", {
                tag: a.toLowerCase()
            })
        },
        StopAll() {
            this.PostToDOM("stop-all")
        },
        SetPaused(a, b) {
            this.PostToDOM("set-paused", {
                tag: a.toLowerCase(),
                paused: 0 === b
            })
        },
        Seek(a, b) {
            this.PostToDOM("seek", {
                tag: a.toLowerCase(),
                pos: b
            })
        },
        SetSilent(a) {
            2 === a && (a = this._isSilent ? 1 : 0);
            a = 0 === a;
            this._isSilent !== a && (this._isSilent = a, this.PostToDOM("set-silent", {
                isSilent: a
            }))
        },
        SetMasterVolume(a) {
            a = this.DbToLinear(a);
            this._masterVolume !== a && (this._masterVolume = a, this.PostToDOM("set-master-volume", {
                vol: a
            }))
        },
        AddFilterEffect(a, b, c, f, h, g, k) {
            a = a.toLowerCase();
            b = d[b];
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "filter",
                tag: a,
                params: [b, c, f, h, g, e.clamp(k / 100, 0, 1)]
            })
        },
        AddDelayEffect(a, b, c, f) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "delay",
                tag: a,
                params: [b, this.DbToLinear(c), e.clamp(f / 100, 0, 1)]
            })
        },
        AddFlangerEffect(a, b,
            c, f, h, g) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "flanger",
                tag: a,
                params: [b / 1E3, c / 1E3, f, h / 100, e.clamp(g / 100, 0, 1)]
            })
        },
        AddPhaserEffect(a, b, c, f, h, g, k) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "phaser",
                tag: a,
                params: [b, c, f, h, g, e.clamp(k / 100, 0, 1)]
            })
        },
        AddConvolutionEffect(a, b, c, f) {
            a = a.toLowerCase();
            const h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b[0]);
            h && (this._IncrementEffectCount(a), this.PostToDOM("add-effect", {
                type: "convolution",
                tag: a,
                bufferOriginalUrl: b[0],
                bufferUrl: h.url,
                bufferType: h.type,
                params: [0 === c, e.clamp(f / 100, 0, 1)]
            }))
        },
        AddGainEffect(a, b) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "gain",
                tag: a,
                params: [this.DbToLinear(b)]
            })
        },
        AddMuteEffect(a) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "gain",
                tag: a,
                params: [0]
            })
        },
        AddTremoloEffect(a, b, c) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "tremolo",
                tag: a,
                params: [b, e.clamp(c / 100, 0, 1)]
            })
        },
        AddRingModEffect(a, b, c) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "ringmod",
                tag: a,
                params: [b, e.clamp(c / 100, 0, 1)]
            })
        },
        AddDistortionEffect(a, b, c, f, h, g) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "distortion",
                tag: a,
                params: [this.DbToLinearNoCap(b), this.DbToLinearNoCap(c), f, this.DbToLinearNoCap(h), e.clamp(g / 100, 0, 1)]
            })
        },
        AddCompressorEffect(a, b, c, f, h, g) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "compressor",
                tag: a,
                params: [b, c, f, h / 1E3, g / 1E3]
            })
        },
        AddAnalyserEffect(a, b, c) {
            a = a.toLowerCase();
            this._IncrementEffectCount(a);
            this.PostToDOM("add-effect", {
                type: "analyser",
                tag: a,
                params: [b, c]
            })
        },
        RemoveEffects(a) {
            a = a.toLowerCase();
            this._effectCount.set(a, 0);
            this.PostToDOM("remove-effects", {
                tag: a
            });
            this._lastFxState = {}
        },
        SetEffectParameter(a, b, c, f, h, g) {
            this.PostToDOM("set-effect-param", {
                tag: a.toLowerCase(),
                index: Math.floor(b),
                param: c,
                value: f,
                ramp: h,
                time: g
            })
        },
        SetListenerObject(a) {
            a &&
                (a = a.GetFirstPicked()) && a.GetWorldInfo() && (this._listenerInst = a)
        },
        SetListenerZ(a) {
            this._listenerZ = a
        },
        ScheduleNextPlay(a) {
            this._nextPlayTime = Math.max(a, 0)
        },
        UnloadAudio(a) {
            const b = a[1];
            (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) && this.PostToDOM("unload", {
                url: a.url,
                type: a.type,
                isMusic: b
            })
        },
        UnloadAudioByName(a, b) {
            a = 1 === a;
            (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase())) && this.PostToDOM("unload", {
                url: b.url,
                type: b.type,
                isMusic: a
            })
        },
        UnloadAll() {
            this.PostToDOM("unload-all")
        },
        AddRemoteURL(a, b, c) {
            this._remoteUrls.set(c.toLowerCase(), {
                url: a,
                type: b
            })
        }
    }
}
"use strict";
self.C3.Plugins.Audio.Exps = {
    Duration(e) {
        return (e = this._GetFirstAudioStateByTag(e)) ? e.duration : 0
    },
    PlaybackTime(e) {
        return (e = this._GetFirstAudioStateByTag(e)) ? e.playbackTime : 0
    },
    PlaybackRate(e) {
        return (e = this._GetFirstAudioStateByTag(e)) ? e.playbackRate : 0
    },
    Volume(e) {
        return (e = this._GetFirstAudioStateByTag(e)) ? this.LinearToDb(e.volume) : 0
    },
    MasterVolume() {
        return this.LinearToDb(this._masterVolume)
    },
    EffectCount(e) {
        return this._effectCount.get(e.toLowerCase()) || 0
    },
    AnalyserFreqBinCount(e, d) {
        return (e = this.GetAnalyserData(e,
            Math.floor(d))) ? e.binCount : 0
    },
    AnalyserFreqBinAt(e, d, a) {
        e = this.GetAnalyserData(e, Math.floor(d));
        if (!e) return 0;
        a = Math.floor(a);
        return 0 > a || a >= e.binCount ? 0 : e.freqBins[a]
    },
    AnalyserPeakLevel(e, d) {
        return (e = this.GetAnalyserData(e, Math.floor(d))) ? e.peak : 0
    },
    AnalyserRMSLevel(e, d) {
        return (e = this.GetAnalyserData(e, Math.floor(d))) ? e.rms : 0
    },
    SampleRate() {
        return this._sampleRate
    },
    CurrentTime() {
        return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1E3
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse.Type = class extends e.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IMouseObjectType
        }
    };
    let d = null;

    function a() {
        return d.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IMouseObjectType = class extends self.IObjectClass {
        constructor(b) {
            super(b);
            d = b;
            b.GetRuntime()._GetCommonScriptInterfaces().mouse = this
        }
        getMouseX(b) {
            return a().GetMousePositionForLayer(b)[0]
        }
        getMouseY(b) {
            return a().GetMousePositionForLayer(b)[1]
        }
        getMousePosition(b) {
            return a().GetMousePositionForLayer(b)
        }
        isMouseButtonDown(b) {
            return a().IsMouseButtonDown(b)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d, "mouse");
            this._buttonMap = [!1, !1, !1];
            this._triggerDir = this._triggerType = this._triggerButton = this._mouseYcanvas = this._mouseXcanvas = 0;
            this._hasPointerLock = !1;
            this._movementY = this._movementX = 0;
            this.AddDOMMessageHandlers([
                ["pointer-lock-change", b => this._OnPointerLockChange(b)],
                ["pointer-lock-error", b => this._OnPointerLockError(b)]
            ]);
            d = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(d,
                "pointermove", b => this._OnPointerMove(b.data)), e.Disposable.From(d, "pointerdown", b => this._OnPointerDown(b.data)), e.Disposable.From(d, "pointerup", b => this._OnPointerUp(b.data)), e.Disposable.From(d, "dblclick", b => this._OnDoubleClick(b.data)), e.Disposable.From(d, "wheel", b => this._OnMouseWheel(b.data)), e.Disposable.From(d, "window-blur", () => this._OnWindowBlur()))
        }
        Release() {
            super.Release()
        }
        _OnPointerDown(d) {
            "mouse" === d.pointerType && (this._mouseXcanvas = d.pageX - this._runtime.GetCanvasClientX(), this._mouseYcanvas =
                d.pageY - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(d.lastButtons, d.buttons))
        }
        _OnPointerMove(d) {
            this._movementX = d.movementX;
            this._movementY = d.movementY;
            this.Trigger(e.Plugins.Mouse.Cnds.OnMovement);
            this._movementY = this._movementX = 0;
            "mouse" === d.pointerType && (this._mouseXcanvas = d.pageX - this._runtime.GetCanvasClientX(), this._mouseYcanvas = d.pageY - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(d.lastButtons, d.buttons))
        }
        _OnPointerUp(d) {
            "mouse" === d.pointerType && this._CheckButtonChanges(d.lastButtons,
                d.buttons)
        }
        _CheckButtonChanges(d, a) {
            this._CheckButtonChange(d, a, 1, 0);
            this._CheckButtonChange(d, a, 4, 1);
            this._CheckButtonChange(d, a, 2, 2)
        }
        _CheckButtonChange(d, a, b, c) {
            !(d & b) && a & b ? this._OnMouseDown(c) : d & b && !(a & b) && this._OnMouseUp(c)
        }
        _OnMouseDown(d) {
            this._buttonMap[d] = !0;
            this.Trigger(e.Plugins.Mouse.Cnds.OnAnyClick);
            this._triggerButton = d;
            this._triggerType = 0;
            this.Trigger(e.Plugins.Mouse.Cnds.OnClick);
            this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
        }
        _OnMouseUp(d) {
            this._buttonMap[d] && (this._buttonMap[d] = !1, this._triggerButton = d, this.Trigger(e.Plugins.Mouse.Cnds.OnRelease))
        }
        _OnDoubleClick(d) {
            this._triggerButton = d.button;
            this._triggerType = 1;
            this.Trigger(e.Plugins.Mouse.Cnds.OnClick);
            this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
        }
        _OnMouseWheel(d) {
            this._triggerDir = 0 > d.deltaY ? 1 : 0;
            this.Trigger(e.Plugins.Mouse.Cnds.OnWheel)
        }
        _OnWindowBlur() {
            for (let d = 0, a = this._buttonMap.length; d < a && this._buttonMap[d]; ++d) this._buttonMap[d] = !1, this._triggerButton = d, this.Trigger(e.Plugins.Mouse.Cnds.OnRelease)
        }
        GetMousePositionForLayer(d) {
            const a =
                this._runtime.GetMainRunningLayout(),
                b = this._mouseXcanvas,
                c = this._mouseYcanvas;
            return "undefined" === typeof d ? a.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(b, c) : (d = a.GetLayer(d)) ? d.CanvasCssToLayer(b, c) : [0, 0]
        }
        IsMouseButtonDown(d) {
            d = Math.floor(d);
            return !!this._buttonMap[d]
        }
        _IsMouseOverCanvas() {
            return 0 <= this._mouseXcanvas && 0 <= this._mouseYcanvas && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
        }
        _OnPointerLockChange(d) {
            this._UpdatePointerLockState(d["has-pointer-lock"])
        }
        _OnPointerLockError(d) {
            this._UpdatePointerLockState(d["has-pointer-lock"]);
            this.Trigger(e.Plugins.Mouse.Cnds.OnPointerLockError)
        }
        _UpdatePointerLockState(d) {
            this._hasPointerLock !== d && ((this._hasPointerLock = d) ? this.Trigger(e.Plugins.Mouse.Cnds.OnPointerLocked) : this.Trigger(e.Plugins.Mouse.Cnds.OnPointerUnlocked))
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.mouse.name",
                properties: [{
                    name: "plugins.mouse.debugger.absolute-position",
                    value: this._mouseXcanvas + "," + this._mouseYcanvas
                }, {
                    name: "plugins.mouse.debugger.left-button",
                    value: this._buttonMap[0]
                }, {
                    name: "plugins.mouse.debugger.middle-button",
                    value: this._buttonMap[1]
                }, {
                    name: "plugins.mouse.debugger.right-button",
                    value: this._buttonMap[2]
                }]
            }, {
                title: "plugins.mouse.debugger.position-on-each-layer",
                properties: this._runtime.GetMainRunningLayout().GetLayers().map(d => ({
                    name: "$" + d.GetName(),
                    value: d.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ")
                }))
            }]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse.Cnds = {
        OnClick(d, a) {
            return this._triggerButton === d && this._triggerType === a
        },
        OnAnyClick() {
            return !0
        },
        IsButtonDown(d) {
            return this._buttonMap[d]
        },
        OnRelease(d) {
            return this._triggerButton === d
        },
        IsOverObject(d) {
            if (!this._IsMouseOverCanvas()) return !1;
            const a = this._runtime.GetCurrentCondition().IsInverted(),
                b = this._mouseXcanvas,
                c = this._mouseYcanvas;
            return e.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(d, b, c, a), a)
        },
        OnObjectClicked(d, a, b) {
            if (d !==
                this._triggerButton || a !== this._triggerType || !this._IsMouseOverCanvas()) return !1;
            d = this._mouseXcanvas;
            a = this._mouseYcanvas;
            return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(b, d, a, !1)
        },
        OnWheel(d) {
            return this._triggerDir === d
        },
        OnPointerLocked() {
            return !0
        },
        OnPointerUnlocked() {
            return !0
        },
        OnPointerLockError() {
            return !0
        },
        HasPointerLock() {
            return this._hasPointerLock
        },
        OnMovement() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    let d = null;
    const a = "auto pointer text crosshair move help wait none".split(" ");
    e.Plugins.Mouse.Acts = {
        SetCursor(b) {
            b = a[b];
            d !== b && (d = b, this.PostToDOM("cursor", b))
        },
        SetCursorSprite(b) {
            if (!e.Platform.IsMobile && b && (b = b.GetFirstPicked())) {
                var c = b.GetWorldInfo(),
                    f = b.GetCurrentImageInfo();
                c && f && d !== f && (d = f, f.ExtractImageToCanvas().then(h => e.CanvasToBlob(h)).then(h => {
                    h = `url(${URL.createObjectURL(h)}) ${Math.round(c.GetOriginX()*f.GetWidth())} ${Math.round(c.GetOriginY()*f.GetHeight())}, auto`;
                    this.PostToDOM("cursor", "");
                    this.PostToDOM("cursor", h)
                }))
            }
        },
        RequestPointerLock() {
            this._PostToDOMMaybeSync("request-pointer-lock")
        },
        ReleasePointerLock() {
            this.PostToDOM("release-pointer-lock")
        }
    }
}
"use strict";
self.C3.Plugins.Mouse.Exps = {
    X(e) {
        return this.GetMousePositionForLayer(e)[0]
    },
    Y(e) {
        return this.GetMousePositionForLayer(e)[1]
    },
    AbsoluteX() {
        return this._mouseXcanvas
    },
    AbsoluteY() {
        return this._mouseYcanvas
    },
    MovementX() {
        return this._movementX
    },
    MovementY() {
        return this._movementY
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d, "platform-info");
            this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
            this._safeAreaInset = [0, 0, 0, 0];
            this._isWakeLockActive = this._supportsWakeLock = !1;
            this.AddDOMMessageHandlers([
                ["window-resize", b => this._OnWindowResize(b)],
                ["wake-lock-acquired", b => this._OnWakeLockAcquired(b)],
                ["wake-lock-error", b => this._OnWakeLockError(b)],
                ["wake-lock-released", b =>
                    this._OnWakeLockReleased(b)
                ]
            ]);
            navigator.connection && navigator.connection.addEventListener("change", () => this._OnNetworkChange());
            this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then(b => {
                this._screenWidth = b.screenWidth;
                this._screenHeight = b.screenHeight;
                this._windowOuterWidth = b.windowOuterWidth;
                this._windowOuterHeight = b.windowOuterHeight;
                this._safeAreaInset = b.safeAreaInset;
                this._supportsWakeLock = b.supportsWakeLock
            }))
        }
        Release() {
            super.Release()
        }
        _OnWindowResize(d) {
            this._windowOuterWidth =
                d.windowOuterWidth;
            this._windowOuterHeight = d.windowOuterHeight;
            this._safeAreaInset = d.safeAreaInset
        }
        async _OnNetworkChange() {
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange)
        }
        async _OnWakeLockAcquired() {
            this._isWakeLockActive = !0;
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired)
        }
        async _OnWakeLockError() {
            this._isWakeLockActive = !1;
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError)
        }
        async _OnWakeLockReleased() {
            this._isWakeLockActive = !1;
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo.Cnds = {
        IsOnMobile() {
            return e.Platform.IsMobile
        },
        IsOnWindows() {
            return "Windows" === e.Platform.OS
        },
        IsOnMacOS() {
            return "Mac OS X" === e.Platform.OS
        },
        IsOnLinux() {
            return "Linux" === e.Platform.OS
        },
        IsOnChromeOS() {
            return "Chrome OS" === e.Platform.OS
        },
        IsOnAndroid() {
            return "Android" === e.Platform.OS
        },
        IsOniOS() {
            return "iOS" === e.Platform.OS
        },
        IsWebExport() {
            const d = this._runtime.GetExportType();
            return "html5" === d || "scirra-arcade" === d || "preview" === d || "instant-games" === d
        },
        IsCordovaExport() {
            return this._runtime.IsCordova()
        },
        IsNWjsExport() {
            return "nwjs" === this._runtime.GetExportType()
        },
        IsWindowsUWPExport() {
            return "windows-uwp" === this._runtime.GetExportType()
        },
        IsWindowsWebView2Export() {
            return "windows-webview2" === this._runtime.GetExportType()
        },
        IsMacOSWKWebView2Export() {
            return "macos-wkwebview" === this._runtime.GetExportType()
        },
        OnNetworkChange() {
            return !0
        },
        OnWakeLockAcquired() {
            return !0
        },
        OnWakeLockError() {
            return !0
        },
        OnWakeLockReleased() {
            return !0
        },
        IsWakeLockActive() {
            return this._isWakeLockActive
        },
        IsWakeLockSupported() {
            return this._supportsWakeLock
        }
    }
}
"use strict";
self.C3.Plugins.PlatformInfo.Acts = {
    RequestWakeLock() {
        this._supportsWakeLock && this._PostToDOMMaybeSync("request-wake-lock")
    },
    ReleaseWakeLock() {
        this._supportsWakeLock && (this._isWakeLockActive = !1, this.PostToDOM("release-wake-lock"))
    }
};
"use strict";
self.C3.Plugins.PlatformInfo.Exps = {
    Renderer() {
        let e;
        e = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber();
        this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += "-software");
        return e
    },
    RendererDetail() {
        return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    DevicePixelRatio() {
        return self.devicePixelRatio
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterHeight
    },
    CanvasCssWidth() {
        return this._runtime.GetCanvasManager().GetCssWidth()
    },
    CanvasCssHeight() {
        return this._runtime.GetCanvasManager().GetCssHeight()
    },
    CanvasDeviceWidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    CanvasDeviceHeight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    Downlink() {
        return navigator.connection ?
            navigator.connection.downlink || 0 : 0
    },
    DownlinkMax() {
        return navigator.connection ? navigator.connection.downlinkMax || 0 : 0
    },
    ConnectionType() {
        return navigator.connection ? navigator.connection.type || "unknown" : "unknown"
    },
    ConnectionEffectiveType() {
        return navigator.connection ? navigator.connection.effectiveType || "unknown" : "unknown"
    },
    ConnectionRTT() {
        return navigator.connection ? navigator.connection.rtt || 0 : 0
    },
    HardwareConcurrency() {
        return navigator.hardwareConcurrency || 0
    },
    DeviceMemory() {
        return navigator.deviceMemory ||
            0
    },
    SafeAreaInsetTop() {
        return this._safeAreaInset[0]
    },
    SafeAreaInsetRight() {
        return this._safeAreaInset[1]
    },
    SafeAreaInsetBottom() {
        return this._safeAreaInset[2]
    },
    SafeAreaInsetLeft() {
        return this._safeAreaInset[3]
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Button = class extends e.SDKDOMPluginBase {
        constructor(d) {
            super(d, "button");
            this.AddElementMessageHandler("click", (a, b) => a._OnClick(b))
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Button.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X;
    e.Plugins.Button.Instance = class extends e.SDKDOMInstanceBase {
        constructor(b, c) {
            super(b, "button");
            this._text = "OK";
            this._isChecked = this._isCheckbox = !1;
            this._id = this._title = "";
            this._autoFontSize = this._isEnabled = !0;
            c && (this._isCheckbox = 1 === c[0], this._text = c[1], this._title = c[2], this.GetWorldInfo().SetVisible(c[3]), this._isEnabled = c[4], this._autoFontSize = c[5], this._isChecked = c[6], this._id = c[7]);
            this.CreateElement({
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                text: this._text,
                isCheckbox: this._isCheckbox,
                isChecked: this._isChecked,
                title: this._title,
                isVisible: this.GetWorldInfo().IsVisible(),
                isEnabled: this._isEnabled
            }
        }
        async _OnClick(b) {
            this._isChecked = b.isChecked;
            this.GetScriptInterface().dispatchEvent(e.New(e.Event, "click", !0));
            await this.TriggerAsync(e.Plugins.Button.Cnds.OnClicked)
        }
        _SetText(b) {
            this._text !== b && (this._text = b, this.UpdateElementState())
        }
        _GetText() {
            return this._text
        }
        _SetTooltip(b) {
            this._title !== b && (this._title = b, this.UpdateElementState())
        }
        _GetTooltip() {
            return this._title
        }
        _SetEnabled(b) {
            b = !!b;
            this._isEnabled !== b && (this._isEnabled = b, this.UpdateElementState())
        }
        _IsEnabled() {
            return this._isEnabled
        }
        _SetChecked(b) {
            this._isCheckbox && (b = !!b, this._isChecked !== b && (this._isChecked = b, this.UpdateElementState()))
        }
        _IsChecked() {
            return this._isChecked
        }
        Draw(b) {}
        SaveToJson() {
            return {
                text: this._text,
                checked: this._isChecked,
                title: this._title,
                enabled: this._isEnabled
            }
        }
        LoadFromJson(b) {
            this._text = b.text;
            this._isChecked = b.checked;
            this._title = b.title;
            this._isEnabled = b.enabled;
            this.UpdateElementState()
        }
        GetPropertyValueByIndex(b) {
            switch (b) {
                case 1:
                    return this._text;
                case 2:
                    return this._title;
                case 4:
                    return this._isEnabled;
                case 5:
                    return this._autoFontSize;
                case 6:
                    return this._isChecked;
                case 7:
                    return this._id
            }
        }
        SetPropertyValueByIndex(b, c) {
            switch (b) {
                case 1:
                    if (this._text === c) break;
                    this._text = c;
                    this.UpdateElementState();
                    break;
                case 2:
                    if (this._title === c) break;
                    this._title = c;
                    this.UpdateElementState();
                    break;
                case 4:
                    if (this._isEnabled === !!c) break;
                    this._isEnabled = !!c;
                    this.UpdateElementState();
                    break;
                case 5:
                    this._autoFontSize = !!c;
                    break;
                case 6:
                    if (this._isChecked === !!c) break;
                    this._isChecked = !!c;
                    this.UpdateElementState();
                    break;
                case 7:
                    this._id !== !!c && (this._id = c, this.UpdateElementState())
            }
        }
        GetDebuggerProperties() {
            const b = e.Plugins.Button.Acts;
            return [{
                title: "plugins.button.name",
                properties: [{
                    name: "plugins.button.properties.text.name",
                    value: this._text,
                    onedit: c => this.CallAction(b.SetText, c)
                }, {
                    name: "plugins.button.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: c => this.CallAction(b.SetEnabled, c)
                }, {
                    name: "plugins.button.properties.checked.name",
                    value: this._isChecked,
                    onedit: c => this.CallAction(b.SetChecked,
                        c)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.IButtonInstance
        }
    };
    const a = new WeakMap;
    self.IButtonInstance = class extends self.IDOMInstance {
        constructor() {
            super();
            a.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set text(b) {
            d.RequireString(b);
            a.get(this)._SetText(b)
        }
        get text() {
            return a.get(this)._GetText()
        }
        set tooltip(b) {
            d.RequireString(b);
            a.get(this)._SetTooltip(b)
        }
        get tooltip() {
            return a.get(this)._GetTooltip()
        }
        set isEnabled(b) {
            a.get(this)._SetEnabled(b)
        }
        get isEnabled() {
            return a.get(this)._IsEnabled()
        }
        set isChecked(b) {
            a.get(this)._SetChecked(b)
        }
        get isChecked() {
            return a.get(this)._IsChecked()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Button.Cnds = {
        OnClicked() {
            return !0
        },
        IsChecked() {
            return this._isChecked
        },
        CompareText(d, a) {
            return a ? this._text === d : e.equalsNoCase(this._text, d)
        }
    }
}
"use strict";
self.C3.Plugins.Button.Acts = {
    SetText(e) {
        this._SetText(e)
    },
    SetTooltip(e) {
        this._SetTooltip(e)
    },
    SetChecked(e) {
        this._SetChecked(0 !== e)
    },
    ToggleChecked() {
        this._isCheckbox && (this._isChecked = !this._isChecked, this.UpdateElementState())
    }
};
"use strict";
self.C3.Plugins.Button.Exps = {
    Text() {
        return this._text
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Keyboard = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Keyboard.Type = class extends e.SDKTypeBase {
        constructor(b) {
            super(b)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IKeyboardObjectType
        }
    };
    let d = null;

    function a() {
        return d.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IKeyboardObjectType = class extends self.IObjectClass {
        constructor(b) {
            super(b);
            d = b;
            b.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
        }
        isKeyDown(b) {
            const c = a();
            if ("string" === typeof b) return c.IsKeyDown(b);
            if ("number" ===
                typeof b) return c.IsKeyCodeDown(b);
            throw new TypeError("expected string or number");
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Keyboard.Instance = class extends e.SDKInstanceBase {
        constructor(d, a) {
            super(d);
            this._keysDownByString = new Set;
            this._keysDownByWhich = new Set;
            this._triggerWhich = 0;
            this._triggerTypedKey = this._triggerString = "";
            d = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(d, "keydown", b => this._OnKeyDown(b.data)), e.Disposable.From(d, "keyup", b => this._OnKeyUp(b.data)), e.Disposable.From(d, "window-blur", () => this._OnWindowOrKeyboardBlur()),
                e.Disposable.From(d, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))
        }
        Release() {
            super.Release()
        }
        _OnKeyDown(d) {
            const a = d.which,
                b = d.code || a.toString();
            d = d.key;
            this._keysDownByString.has(b) || (this._keysDownByString.add(b), this._keysDownByWhich.add(a), this._triggerString = b, this._triggerWhich = a, this._triggerTypedKey = d, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(e.Plugins.Keyboard.Cnds.OnKey), this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCode))
        }
        _OnKeyUp(d) {
            const a =
                d.which,
                b = d.code || a.toString();
            d = d.key;
            this._keysDownByString.delete(b);
            this._keysDownByWhich.delete(a);
            this._triggerString = b;
            this._triggerWhich = a;
            this._triggerTypedKey = d;
            this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
            this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased);
            this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
            this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
        }
        _OnWindowOrKeyboardBlur() {
            for (const d of this._keysDownByWhich) this._keysDownByWhich.delete(d), this._triggerWhich =
                d, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
            this._keysDownByString.clear()
        }
        IsKeyDown(d) {
            return this._keysDownByString.has(d)
        }
        IsKeyCodeDown(d) {
            return this._keysDownByWhich.has(d)
        }
        SaveToJson() {
            return {
                tk: this._triggerWhich,
                tkk: this._triggerTypedKey
            }
        }
        LoadFromJson(d) {
            this._triggerWhich = d.tk;
            d.hasOwnProperty("tkk") && (this._triggerTypedKey = d.tkk)
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.keyboard.name",
                properties: [{
                    name: "plugins.keyboard.debugger.last-key-code",
                    value: this._triggerWhich
                }, {
                    name: "plugins.keyboard.debugger.last-key-string",
                    value: e.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
                }, {
                    name: "plugins.keyboard.debugger.last-typed-key",
                    value: this._triggerTypedKey
                }]
            }]
        }
    }
} {
    "use strict";
    const e = "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(" ");
    self.C3.Plugins.Keyboard.Cnds = {
        IsKeyDown(d) {
            return this._keysDownByWhich.has(d)
        },
        OnKey(d) {
            return this._triggerWhich === d
        },
        OnAnyKey() {
            return !0
        },
        OnAnyKeyReleased() {
            return !0
        },
        OnKeyReleased(d) {
            return this._triggerWhich === d
        },
        IsKeyCodeDown(d) {
            d = Math.floor(d);
            return this._keysDownByWhich.has(d)
        },
        OnKeyCode(d) {
            return this._triggerWhich === d
        },
        OnKeyCodeReleased(d) {
            return this._triggerWhich === d
        },
        OnLeftRightKeyPressed(d) {
            return this._triggerString === e[d]
        },
        OnLeftRightKeyReleased(d) {
            return this._triggerString === e[d]
        },
        IsLeftRightKeyDown(d) {
            return this._keysDownByString.has(e[d])
        }
    }
}
"use strict";
self.C3.Plugins.Keyboard.Acts = {}; {
    "use strict";

    function e(d) {
        d = Math.floor(d);
        switch (d) {
            case 8:
                return "backspace";
            case 9:
                return "tab";
            case 13:
                return "enter";
            case 16:
                return "shift";
            case 17:
                return "control";
            case 18:
                return "alt";
            case 19:
                return "pause";
            case 20:
                return "capslock";
            case 27:
                return "esc";
            case 33:
                return "pageup";
            case 34:
                return "pagedown";
            case 35:
                return "end";
            case 36:
                return "home";
            case 37:
                return "\u2190";
            case 38:
                return "\u2191";
            case 39:
                return "\u2192";
            case 40:
                return "\u2193";
            case 45:
                return "insert";
            case 46:
                return "del";
            case 91:
                return "left window key";
            case 92:
                return "right window key";
            case 93:
                return "select";
            case 96:
                return "numpad 0";
            case 97:
                return "numpad 1";
            case 98:
                return "numpad 2";
            case 99:
                return "numpad 3";
            case 100:
                return "numpad 4";
            case 101:
                return "numpad 5";
            case 102:
                return "numpad 6";
            case 103:
                return "numpad 7";
            case 104:
                return "numpad 8";
            case 105:
                return "numpad 9";
            case 106:
                return "numpad *";
            case 107:
                return "numpad +";
            case 109:
                return "numpad -";
            case 110:
                return "numpad .";
            case 111:
                return "numpad /";
            case 112:
                return "F1";
            case 113:
                return "F2";
            case 114:
                return "F3";
            case 115:
                return "F4";
            case 116:
                return "F5";
            case 117:
                return "F6";
            case 118:
                return "F7";
            case 119:
                return "F8";
            case 120:
                return "F9";
            case 121:
                return "F10";
            case 122:
                return "F11";
            case 123:
                return "F12";
            case 144:
                return "numlock";
            case 145:
                return "scroll lock";
            case 186:
                return ";";
            case 187:
                return "=";
            case 188:
                return ",";
            case 189:
                return "-";
            case 190:
                return ".";
            case 191:
                return "/";
            case 192:
                return "'";
            case 219:
                return "[";
            case 220:
                return "\\";
            case 221:
                return "]";
            case 222:
                return "#";
            case 223:
                return "`";
            default:
                return String.fromCharCode(d)
        }
    }
    self.C3.Plugins.Keyboard.Exps = {
        LastKeyCode() {
            return this._triggerWhich
        },
        StringFromKeyCode(d) {
            return e(d)
        },
        TypedKey() {
            return this._triggerTypedKey
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.DrawingCanvas = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.DrawingCanvas.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = e.New(e.Color),
        b = e.New(e.Rect),
        c = e.New(e.Quad);
    let f = 0;
    e.Plugins.DrawingCanvas.Instance = class extends e.SDKWorldInstanceBase {
        constructor(g, k) {
            super(g);
            this._renderTarget = null;
            this._rcTex = e.New(e.Rect);
            this._multisampling = 0;
            this._texRenderTarget = null;
            this._drawCommands = [];
            this._currentPoly = [];
            this._drawBlendMode = 0;
            this._texScale = this._drawScale = 1;
            this._lineDashTexture = null;
            this._savedImageUrl = "";
            this._snapshot = null;
            this._tempRect = e.New(e.Rect);
            this._deviceQuadUnrotated =
                e.New(e.Quad);
            this._deviceQuadRotated = e.New(e.Quad);
            k && (this.GetWorldInfo().SetVisible(!!k[0]), this._multisampling = [0, 2, 4, 8][k[2]]);
            g = this._runtime.GetRenderer();
            this._SetDrawingBlendMode(0);
            g.IsWebGL() && 2 > g.GetWebGLVersionNumber() && (this._multisampling = 0);
            this._StartTicking2()
        }
        Release() {
            this._renderTarget && (this._renderTarget.GetRenderer().DeleteRenderTarget(this._renderTarget), this._renderTarget = null);
            this._texRenderTarget && (this._texRenderTarget.GetRenderer().DeleteRenderTarget(this._texRenderTarget),
                this._texRenderTarget = null);
            e.clearArray(this._drawCommands);
            super.Release()
        }
        _ClonePoly() {
            return this._currentPoly.map(g => g.slice(0))
        }
        _GetLineDashTexture() {
            this._MaybeCreateLineDashTexture();
            return this._lineDashTexture
        }
        _MaybeCreateLineDashTexture() {
            if (!this._lineDashTexture) {
                var g = e.CreateCanvas(512, 8),
                    k = g.getContext("2d");
                k.clearRect(0, 0, 512, 8);
                k.fillStyle = "white";
                k.fillRect(0, 0, 256, 8);
                this._lineDashTexture = this._runtime.GetRenderer().CreateStaticTexture(g, {
                    wrapX: "repeat",
                    sampling: this._runtime.GetSampling()
                })
            }
        }
        _SetDrawingBlendMode(g) {
            this._drawBlendMode =
                g
        }
        _ApplyCurrentDrawingBlendMode(g) {
            g.SetBlendMode(this._drawBlendMode)
        }
        _AddDrawCommand(g) {
            this._drawCommands.push(g);
            this._runtime.UpdateRender()
        }
        _UpdateRenderTargetSize(g, k, m) {
            this._renderTarget && g.DeleteRenderTarget(this._renderTarget);
            this._renderTarget = g.CreateRenderTarget({
                width: k,
                height: m,
                sampling: this._runtime.GetSampling(),
                isSampled: 0 === this._multisampling,
                canReadPixels: 0 === this._multisampling,
                multisampling: this._multisampling
            });
            0 < this._multisampling && (this._texRenderTarget && g.DeleteRenderTarget(this._texRenderTarget),
                this._texRenderTarget = g.CreateRenderTarget({
                    width: k,
                    height: m,
                    sampling: this._runtime.GetSampling(),
                    isSampled: !0,
                    canReadPixels: !0
                }));
            g.SetTexture(null)
        }
        _GetRenderTarget() {
            return this._renderTarget
        }
        _GetTexRenderTarget() {
            return this._texRenderTarget
        }
        GetMultisampling() {
            return this._multisampling
        }
        _SetRenderTargetDeviceTransform(g) {
            this._runtime.GetCanvasManager().SetDeviceTransform(g, this._renderTarget.GetWidth(), this._renderTarget.GetHeight(), !1)
        }
        HasAnyDrawingCommandInQueue() {
            return this._drawCommands.some(g =>
                !(g instanceof e.Plugins.DrawingCanvas.DrawCommand.SaveImage))
        }
        _CalculateUnrotatedDeviceCoords(g, k) {
            const m = this.GetWorldInfo(),
                r = m.GetLayer(),
                w = r.GetLayout(),
                p = m.GetAngle(),
                t = r.GetOwnAngle(),
                u = w.GetAngle();
            if (0 !== p || 0 !== t || 0 !== u) w.SetAngle(0), r.SetAngle(0), m.SetAngle(0), m.SetBboxChanged();
            var q = m.GetBoundingQuad();
            const [x, y] = r.LayerToDrawSurface(q.getTlx(), q.getTly()), [B, F] = r.LayerToDrawSurface(q.getBrx(), q.getBry());
            q = x - Math.round(x);
            const H = y - Math.round(y);
            g.set(x, y, B, F);
            g.offset(-q, -H);
            g.normalize();
            k.setFromRect(g);
            if (0 !== p || 0 !== t || 0 !== u) w.SetAngle(u), r.SetAngle(t), m.SetAngle(p), m.SetBboxChanged()
        }
        _CalculateRotatedDeviceCoords(g) {
            var k = this.GetWorldInfo();
            const m = k.GetLayer(),
                r = m.GetLayout(),
                w = m.GetOwnAngle(),
                p = r.GetAngle();
            if (0 !== w || 0 !== p) r.SetAngle(0), m.SetAngle(0);
            k = k.GetBoundingQuad();
            const [t, u] = m.LayerToDrawSurface(k.getTlx(), k.getTly()), [q, x] = m.LayerToDrawSurface(k.getTrx(), k.getTry()), [y, B] = m.LayerToDrawSurface(k.getBrx(), k.getBry()), [F, H] = m.LayerToDrawSurface(k.getBlx(), k.getBly());
            k = t - Math.round(t);
            const K = u - Math.round(u);
            g.set(t, u, q, x, y, B, F, H);
            g.offset(k, K);
            if (0 !== w || 0 !== p) r.SetAngle(p), m.SetAngle(w)
        }
        _CalculateSurfaceDeviceSize() {
            var g = this._runtime.GetRenderer(),
                k = this._tempRect;
            this._CalculateUnrotatedDeviceCoords(k, this._deviceQuadUnrotated);
            this._CalculateRotatedDeviceCoords(this._deviceQuadRotated);
            let m = Math.ceil(k.width() + .001),
                r = Math.ceil(k.height() + .001);
            g.IsWebGL() ? this._rcTex.set(0, 1, k.width() / m, 1 - k.height() / r) : this._rcTex.set(0, 0, k.width() / m, k.height() / r);
            g = g.GetMaxTextureSize();
            k = Math.max(m, r);
            k > g ? (this._texScale = g / k, m = Math.round(m * this._texScale), r = Math.round(r * this._texScale)) : this._texScale = 1;
            return [m, r]
        }
        _MaybeCreateRenderTarget() {
            if (!this._renderTarget) {
                var [g, k] = this._CalculateSurfaceDeviceSize();
                0 >= g || 0 >= k || (this._drawScale = b.width() / this.GetWorldInfo().GetWidth(), this._UpdateRenderTargetSize(this._runtime.GetRenderer(), g, k), this.Trigger(e.Plugins.DrawingCanvas.Cnds.OnResolutionChanged))
            }
        }
        Tick2() {
            const g = this._runtime.GetRenderer();
            var k = this.GetWorldInfo(),
                m = this._tempRect;
            ++f;
            const [r, w] = this._CalculateSurfaceDeviceSize();
            if (!(0 >= r || 0 >= w) && (this._drawScale = m.width() / k.GetWidth(), k = this._drawScale * this._texScale, (m = !this._renderTarget || this._renderTarget.GetWidth() !== r || this._renderTarget.GetHeight() !== w) && this.Trigger(e.Plugins.DrawingCanvas.Cnds.OnResolutionChanged), 0 < this._drawCommands.length || !this._renderTarget)) {
                (!this._renderTarget || m && this.HasAnyDrawingCommandInQueue()) && this._UpdateRenderTargetSize(g, r, w);
                g.SetRenderTarget(this._renderTarget);
                this._SetRenderTargetDeviceTransform(g);
                this._ApplyCurrentDrawingBlendMode(g);
                for (const p of this._drawCommands) p.Do(g, k, this);
                e.clearArray(this._drawCommands);
                g.SetAlphaBlend();
                0 < this._multisampling && (g.SetRenderTarget(this._texRenderTarget), g.CopyRenderTarget(this._renderTarget, "crop"))
            }--f
        }
        Draw(g) {
            const k = this.GetWorldInfo(),
                m = k.GetLayer(),
                r = this._runtime.GetCanvasManager(),
                w = g.GetRenderTarget();
            let p = this._deviceQuadUnrotated;
            if (this._renderTarget) {
                g.IsWebGPU() && g._MaybeDoPendingClearRenderPass(this._renderTarget);
                0 === this._multisampling ?
                    g.SetTexture(this._renderTarget.GetTexture()) : g.SetTexture(this._texRenderTarget.GetTexture());
                var t = !1;
                0 < f ? (r.SetDeviceTransform(g, w.GetWidth(), w.GetHeight(), !1), t = !0, p = this._deviceQuadRotated) : 0 === k.GetAngle() && 0 === m.GetAngle() && !k.HasMesh() && m.RendersIn2DMode() ? (r.SetDeviceTransform(g), t = !0) : p = k.GetBoundingQuad();
                k.HasMesh() ? this._DrawMesh(g, k) : g.Quad3(p, this._rcTex);
                t && m._SetTransform(g, !1);
                g.SetTexture(null)
            }
        }
        _DrawMesh(g, k) {
            const m = k.GetTransformedMesh();
            k.IsMeshChanged() && (k.CalculateBbox(b,
                c, !1), m.CalculateTransformedMesh(k.GetSourceMesh(), c, this._rcTex), k.SetMeshChanged(!1));
            m.Draw(g)
        }
        GetSnapshotPixel(g, k) {
            if (!this._snapshot) return [0, 0, 0, 0];
            var m = this._snapshot.width,
                r = this._snapshot.height;
            g = Math.floor(g);
            k = this._runtime.GetRenderer().IsWebGL() ? r - 1 - Math.floor(k) : Math.floor(k);
            if (0 > g || 0 > k || g >= m || k >= r) return [0, 0, 0, 0];
            r = this._snapshot.data;
            const w = k * m * 4 + 4 * g;
            g = r[w] / 255;
            k = r[w + 1] / 255;
            m = r[w + 2] / 255;
            r = r[w + 3] / 255;
            0 !== r && (g /= r, k /= r, m /= r);
            return [100 * g, 100 * k, 100 * m, 100 * r]
        }
        SetSnapshotPixel(g, k,
            m) {
            if (!this._snapshot) return [0, 0, 0, 0];
            a.setFromRgbValue(m);
            a.premultiply();
            m = this._snapshot.width;
            var r = this._snapshot.height;
            g = Math.floor(g);
            k = r - 1 - Math.floor(k);
            0 > g || 0 > k || g >= m || k >= r || (r = this._snapshot.data, g = k * m * 4 + 4 * g, r[g] = Math.floor(255 * a.getR()), r[g + 1] = Math.floor(255 * a.getG()), r[g + 2] = Math.floor(255 * a.getB()), r[g + 3] = Math.floor(255 * a.getA()))
        }
        GetImagePixelData() {
            return new Promise(g => {
                this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.SaveImage(async k => {
                    var m = k.data.buffer;
                    const r = k.width;
                    k = k.height;
                    m = await this._runtime.AddJob("ProcessImageData", {
                        buffer: m,
                        width: r,
                        height: k,
                        unpremultiply: !0,
                        flipY: !0
                    }, [m]);
                    g(new ImageData(new Uint8ClampedArray(m), r, k))
                }))
            })
        }
        LoadImagePixelData(g, k, m) {
            this._MaybeCreateRenderTarget();
            if (!this._renderTarget) throw Error("invalid canvas size");
            if (g.width !== this._renderTarget.GetWidth() || g.height !== this._renderTarget.GetHeight()) throw Error(`wrong size ImageData: expected ${this._renderTarget.GetWidth()} x ${this._renderTarget.GetHeight()}, got ${g.width} x ${g.height}`);
            e.clearArray(this._drawCommands);
            const r = this._runtime.GetRenderer();
            if (this._texRenderTarget) {
                var w = r.GetRenderTarget();
                const p = this._texRenderTarget.GetTexture();
                r.UpdateTexture(g, p, {
                    premultiplyAlpha: !!k,
                    flipY: !!m
                });
                r.SetRenderTarget(this._renderTarget);
                r.CopyRenderTarget(this._texRenderTarget, "crop");
                r.SetRenderTarget(w)
            } else w = this._renderTarget.GetTexture(), r.UpdateTexture(g, w, {
                premultiplyAlpha: !!k,
                flipY: !!m
            });
            this._runtime.UpdateRender()
        }
        GetScriptInterfaceClass() {
            return self.IDrawingCanvasInstance
        }
    };
    const h = new WeakMap;
    self.IDrawingCanvasInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            h.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        getImagePixelData() {
            return h.get(this).GetImagePixelData()
        }
        loadImagePixelData(g, k = !1) {
            d.RequireInstanceOf(g, ImageData);
            h.get(this).LoadImagePixelData(g, k, !0)
        }
        get surfaceDeviceWidth() {
            var g = h.get(this);
            g._MaybeCreateRenderTarget();
            g = g._GetRenderTarget();
            if (!g) throw Error("invalid canvas size");
            return g.GetWidth()
        }
        get surfaceDeviceHeight() {
            var g =
                h.get(this);
            g._MaybeCreateRenderTarget();
            g = g._GetRenderTarget();
            if (!g) throw Error("invalid canvas size");
            return g.GetHeight()
        }
    }
}
"use strict";
self.C3.Plugins.DrawingCanvas.Cnds = {
    OnSavedImage() {
        return !0
    },
    OnSnapshot() {
        return !0
    },
    OnResolutionChanged() {
        return !0
    }
}; {
    "use strict";
    const e = self.C3;

    function d(a, b) {
        return a.GetWorldInfo().GetZIndex() - b.GetWorldInfo().GetZIndex()
    }
    e.Plugins.DrawingCanvas.Acts = {
        SetEffect(a) {
            this.GetWorldInfo().SetBlendMode(a);
            this._runtime.UpdateRender()
        },
        ClearCanvas(a) {
            e.clearArray(this._drawCommands);
            this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.ClearCanvas(a))
        },
        ClearRect(a, b, c, f, h) {
            a !== c && b !== f && this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.ClearRect(a, b, c, f, h))
        },
        FillRect(a, b, c, f, h) {
            a !== c && b !== f && this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.FillRect(a,
                b, c, f, h))
        },
        FillLinearGradient(a, b, c, f, h, g, k) {
            a !== c && b !== f && this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.FillLinearGradient(a, b, c, f, h, g, k))
        },
        FillEllipse(a, b, c, f, h, g) {
            0 >= c || 0 >= f || this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.FillEllipse(a, b, c, f, h, 0 !== g))
        },
        OutlineEllipse(a, b, c, f, h, g, k) {
            0 >= c || 0 >= f || 0 >= g || this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.OutlineEllipse(a, b, c, f, h, g, 0 !== k))
        },
        OutlineRect(a, b, c, f, h, g) {
            a === c || b === f || 0 >= g || this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.OutlineRect(a,
                b, c, f, h, g))
        },
        Line(a, b, c, f, h, g, k) {
            a === c && b === f || 0 >= g || this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.Line(a, b, c, f, h, g, 0 === k ? "butt" : "square"))
        },
        LineDashed(a, b, c, f, h, g, k, m) {
            if (!(a === c && b === f || 0 >= g || 0 >= k)) {
                m = 0 === m ? "butt" : "square";
                var r = this._GetLineDashTexture();
                this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.LineDashed(a, b, c, f, h, g, k, r, m))
            }
        },
        AddPolyPoint(a, b) {
            this._currentPoly.push([a, b])
        },
        ResetPoly() {
            e.clearArray(this._currentPoly)
        },
        LinePoly(a, b, c) {
            2 > this._currentPoly.length ||
                0 >= b || (c = 0 === c ? "butt" : "square", this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.LinePoly(this._ClonePoly(), a, b, c)))
        },
        LineDashedPoly(a, b, c, f) {
            if (!(2 > this._currentPoly.length || 0 >= b || 0 >= c)) {
                f = 0 === f ? "butt" : "square";
                var h = this._GetLineDashTexture();
                this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.LineDashedPoly(this._ClonePoly(), a, b, c, h, f))
            }
        },
        FillPoly(a) {
            3 > this._currentPoly.length || this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.FillPoly(this._ClonePoly(), a))
        },
        SetDrawBlend(a) {
            2 <=
                a && a++;
            this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.SetDrawBlend(a))
        },
        PasteObject(a, b) {
            if (a) {
                var c = this.GetWorldInfo(),
                    f = c.GetBoundingBox(),
                    h = c.GetBoundingQuad();
                a = a.GetCurrentSol().GetInstances().filter(g => (g = g.GetWorldInfo()) && f.intersectsRect(g.GetBoundingBox()) && (0 === c.GetAngle() || h.intersectsQuad(g.GetBoundingQuad())));
                0 !== a.length && (a.sort(d), this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.DrawInstances(a, 0 !== b, c)))
            }
        },
        SaveImage(a, b, c, f, h, g) {
            const k = 0 === a ? "image/png" :
                "image/jpeg";
            b /= 100;
            const m = e.New(e.Rect);
            m.setWH(c, f, h, g);
            return new Promise(r => {
                this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.SaveImage(async w => {
                    var p = w.data.buffer,
                        t = w.width;
                    w = w.height;
                    const u = this._runtime.GetRenderer().IsWebGL();
                    p = await this._runtime.AddJob("ProcessImageData", {
                        buffer: p,
                        width: t,
                        height: w,
                        unpremultiply: !0,
                        flipY: u && !e.Supports.ImageBitmapOptions
                    }, [p]);
                    w = new ImageData(new Uint8ClampedArray(p), t, w);
                    e.Supports.ImageBitmapOptions ? (t = await createImageBitmap(w, {
                        premultiplyAlpha: "none",
                        imageOrientation: u ? "flipY" : "none"
                    }), t = await e.DrawableToBlob(t, k, b)) : t = await e.ImageDataToBlob(w, k, b);
                    this._savedImageUrl && URL.revokeObjectURL(this._savedImageUrl);
                    this._savedImageUrl = URL.createObjectURL(t);
                    this.Trigger(e.Plugins.DrawingCanvas.Cnds.OnSavedImage);
                    r()
                }, m))
            })
        },
        SaveSnapshot() {
            return new Promise(a => {
                this._AddDrawCommand(new e.Plugins.DrawingCanvas.DrawCommand.SaveImage(b => {
                    this._snapshot = b;
                    this.Trigger(e.Plugins.DrawingCanvas.Cnds.OnSnapshot);
                    a()
                }))
            })
        },
        ClearSnapshot() {
            this._snapshot = null
        },
        SnapshotSetPixel(a, b, c) {
            this.SetSnapshotPixel(a, b, c)
        },
        LoadSnapshot() {
            this._snapshot && this._renderTarget && this._snapshot.width === this._renderTarget.GetWidth() && this._snapshot.height === this._renderTarget.GetHeight() && this.LoadImagePixelData(this._snapshot, !1)
        }
    }
}
"use strict";
self.C3.Plugins.DrawingCanvas.Exps = {
    SavedImageURL() {
        return this._savedImageUrl
    },
    SnapshotRedAt(e, d) {
        return this.GetSnapshotPixel(e, d)[0]
    },
    SnapshotGreenAt(e, d) {
        return this.GetSnapshotPixel(e, d)[1]
    },
    SnapshotBlueAt(e, d) {
        return this.GetSnapshotPixel(e, d)[2]
    },
    SnapshotAlphaAt(e, d) {
        return this.GetSnapshotPixel(e, d)[3]
    },
    SnapshotWidth() {
        return this._snapshot ? this._snapshot.width : 0
    },
    SnapshotHeight() {
        return this._snapshot ? this._snapshot.height : 0
    },
    PixelScale() {
        return 1 / (this._drawScale * this._texScale)
    },
    SurfaceDeviceWidth() {
        const e =
            this._GetRenderTarget();
        return e ? e.GetWidth() : 0
    },
    SurfaceDeviceHeight() {
        const e = this._GetRenderTarget();
        return e ? e.GetHeight() : 0
    }
}; {
    "use strict";
    const e = self.C3,
        d = e.New(e.Quad),
        a = e.New(e.Quad),
        b = e.New(e.Vector2);
    e.Plugins.DrawingCanvas.DrawCommand = class {
        constructor() {}
        Do(f) {
            throw Error("required override");
        }
    };
    const c = e.Plugins.DrawingCanvas.DrawCommand;
    c.SaveImage = class extends c {
        constructor(f, h) {
            super();
            this._callback = f;
            this._areaRect = h
        }
        Do(f, h, g) {
            h = f.GetRenderTarget();
            0 < h.GetMultisampling() && (g = g._GetTexRenderTarget(), f.SetRenderTarget(g), f.CopyRenderTarget(h, "crop"), f.SetRenderTarget(h), h = g);
            f.ReadBackRenderTargetToImageData(h, !1, this._areaRect).then(this._callback)
        }
    };
    c.ClearCanvas = class extends c {
        constructor(f) {
            super();
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(f);
            this._color.premultiply()
        }
        Do(f) {
            f.Clear(this._color)
        }
    };
    c.ClearRect = class extends c {
        constructor(f, h, g, k, m) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f, h, g, k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply()
        }
        Do(f, h, g) {
            const k = g._GetRenderTarget().GetHeight();
            this._rect.multiply(h, h);
            this._rect.shuntY(k);
            f.SetColorFillMode();
            f.SetColor(this._color);
            f.SetBlendMode(3);
            f.Rect(this._rect);
            g._ApplyCurrentDrawingBlendMode(f)
        }
    };
    c.FillRect = class extends c {
        constructor(f, h, g, k, m) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f, h, g, k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply()
        }
        Do(f, h) {
            f.SetColorFillMode();
            f.SetColor(this._color);
            this._rect.multiply(h, h);
            f.Rect(this._rect)
        }
    };
    c.FillLinearGradient = class extends c {
        constructor(f, h, g, k, m, r, w) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f,
                h, g, k);
            this._color1 = e.New(e.Color);
            this._color1.setFromRgbValue(m);
            this._color2 = e.New(e.Color);
            this._color2.setFromRgbValue(r);
            this._dir = w
        }
        Do(f, h) {
            f.SetLinearGradientFillMode();
            f.SetColor(this._color1);
            f.SetGradientColor(this._color2);
            this._rect.multiply(h, h);
            d.setFromRect(this._rect);
            0 === this._dir ? a.set(0, 0, 1, 0, 1, 1, 0, 1) : a.set(0, 1, 0, 0, 1, 0, 1, 1);
            f.Quad4(d, a)
        }
    };
    c.FillEllipse = class extends c {
        constructor(f, h, g, k, m, r) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f - g, h - k, f + g, h + k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply();
            this._isSmooth = r
        }
        Do(f, h) {
            this._rect.multiply(h, h);
            this._isSmooth ? (f.SetSmoothEllipseFillMode(), f.SetColor(this._color), this._rect.inflate(.5, .5), f.SetEllipseParams(1 / this._rect.width(), 1 / this._rect.height())) : (f.SetHardEllipseFillMode(), f.SetColor(this._color));
            f.Rect(this._rect)
        }
    };
    c.OutlineEllipse = class extends c {
        constructor(f, h, g, k, m, r, w) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f - g, h - k, f + g, h + k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply();
            this._thickness = r;
            this._isSmooth = w
        }
        Do(f, h) {
            this._rect.multiply(h, h);
            this._isSmooth ? (f.SetSmoothEllipseOutlineMode(), f.SetColor(this._color), this._rect.inflate(.5, .5), f.SetEllipseParams(1 / this._rect.width(), 1 / this._rect.height(), this._thickness * h)) : (f.SetHardEllipseOutlineMode(), f.SetEllipseParams(1 / this._rect.width(), 1 / this._rect.height(), this._thickness * h), f.SetColor(this._color));
            f.Rect(this._rect)
        }
    };
    c.OutlineRect = class extends c {
        constructor(f, h, g, k, m, r) {
            super();
            this._rect =
                e.New(e.Rect);
            this._rect.set(f, h, g, k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply();
            this._thickness = r
        }
        Do(f, h) {
            f.SetColorFillMode();
            f.SetColor(this._color);
            f.PushLineCapZag();
            f.PushLineWidth(this._thickness * h);
            this._rect.multiply(h, h);
            f.LineRect2(this._rect);
            f.PopLineCap();
            f.PopLineWidth()
        }
    };
    c.Line = class extends c {
        constructor(f, h, g, k, m, r, w) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f, h, g, k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply();
            this._thickness = r;
            this._cap = w
        }
        Do(f, h) {
            f.SetColorFillMode();
            f.SetColor(this._color);
            f.PushLineCap(this._cap);
            f.PushLineWidth(this._thickness * h);
            const g = this._rect;
            g.multiply(h, h);
            f.Line(g.getLeft(), g.getTop(), g.getRight(), g.getBottom());
            f.PopLineCap();
            f.PopLineWidth()
        }
    };
    c.LinePoly = class extends c {
        constructor(f, h, g, k) {
            super();
            this._poly = f;
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(h);
            this._color.premultiply();
            this._thickness = g;
            this._cap = k
        }
        Do(f, h) {
            f.SetColorFillMode();
            f.SetColor(this._color);
            f.PushLineCap(this._cap);
            f.PushLineWidth(this._thickness * h);
            const g = this._poly;
            for (let k = 0, m = g.length; k < m; ++k) {
                const r = (k + 1) % m;
                f.Line(g[k][0] * h, g[k][1] * h, g[r][0] * h, g[r][1] * h)
            }
            f.PopLineCap();
            f.PopLineWidth()
        }
    };
    c.LineDashed = class extends c {
        constructor(f, h, g, k, m, r, w, p, t) {
            super();
            this._rect = e.New(e.Rect);
            this._rect.set(f, h, g, k);
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(m);
            this._color.premultiply();
            this._thickness = r;
            this._dashLength = w;
            this._dashTex = p;
            this._cap = t
        }
        Do(f, h) {
            f.SetTextureFillMode();
            f.SetTexture(this._dashTex);
            f.SetColor(this._color);
            f.PushLineCap(this._cap);
            f.PushLineWidth(this._thickness * h);
            const g = this._rect,
                k = e.distanceTo(g.getLeft(), g.getTop(), g.getRight(), g.getBottom()) / (2 * this._dashLength);
            g.multiply(h, h);
            f.TexturedLine(g.getLeft(), g.getTop(), g.getRight(), g.getBottom(), 0, k);
            f.PopLineCap();
            f.PopLineWidth()
        }
    };
    c.LineDashedPoly = class extends c {
        constructor(f, h, g, k, m, r) {
            super();
            this._poly = f;
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(h);
            this._color.premultiply();
            this._thickness = g;
            this._dashLength = k;
            this._dashTex = m;
            this._cap = r
        }
        Do(f, h) {
            f.SetTextureFillMode();
            f.SetTexture(this._dashTex);
            f.SetColor(this._color);
            f.PushLineCap(this._cap);
            f.PushLineWidth(this._thickness * h);
            let g = 0;
            const k = this._poly;
            for (let r = 0, w = k.length; r < w; ++r) {
                var m = (r + 1) % w;
                const p = k[r][0],
                    t = k[r][1],
                    u = k[m][0];
                m = k[m][1];
                const q = g + e.distanceTo(p, t, u, m) / (2 * this._dashLength);
                f.TexturedLine(p * h, t * h, u * h, m * h, g, q);
                g = q - Math.floor(q)
            }
            f.PopLineCap();
            f.PopLineWidth()
        }
    };
    c.FillPoly = class extends c {
        constructor(f,
            h) {
            super();
            this._poly = f;
            this._color = e.New(e.Color);
            this._color.setFromRgbValue(h);
            this._color.premultiply()
        }
        Do(f, h) {
            f.SetColorFillMode();
            f.SetColor(this._color);
            var g = this._poly;
            for (let k = 0, m = g.length; k < m; ++k) {
                const r = g[k];
                r[0] *= h;
                r[1] *= h
            }
            h = self.polyDecomp;
            if (h.isSimple(g)) {
                h.makeCCW(g);
                h.removeCollinearPoints(g, e.toRadians(.1));
                g = h.quickDecomp(g);
                for (const k of g) f.ConvexPoly(k.flat())
            }
        }
    };
    c.SetDrawBlend = class extends c {
        constructor(f) {
            super();
            this._blendIndex = f
        }
        Do(f, h, g) {
            g._SetDrawingBlendMode(this._blendIndex);
            g._ApplyCurrentDrawingBlendMode(f)
        }
    };
    c.DrawInstances = class extends c {
        constructor(f, h, g) {
            super();
            const k = g.GetLayer();
            this._includeFx = h;
            this._layoutTransform = k.GetLayout().SaveTransform();
            this._layerTransforms = new Map;
            this._layerTransforms.set(k, k.SaveTransform());
            this._instances = f.map(m => this._SaveInstanceState(m, g))
        }
        _SaveInstanceState(f, h) {
            const g = h.GetAngle();
            var k = h.GetLayer();
            const m = f.GetWorldInfo();
            var r = m.GetLayer();
            const w = m.GetX(),
                p = m.GetY(),
                t = m.GetWidth(),
                u = m.GetHeight(),
                q = m.GetAngle();
            this._layerTransforms.has(r) || this._layerTransforms.set(r, r.SaveTransform());
            const x = k.IsTransformCompatibleWith(r);
            if (!x) {
                const [B, F] = r.LayerToDrawSurface(w, p), [H, K] = k.DrawSurfaceToLayer(B, F);
                m.SetXY(H, K);
                var y = r.GetNormalScale() / k.GetNormalScale();
                m.SetSize(t * y, u * y);
                k = k.GetOwnAngle() - r.GetOwnAngle();
                m.OffsetAngle(k)
            }
            0 !== g && (r = h.GetBoundingQuad(), k = r.midX(), r = r.midY(), y = -h.GetSinAngle(), h = h.GetCosAngle(), b.set(w, p), b.offset(-k, -r), b.rotatePrecalc(y, h), b.offset(k, r), m.SetXY(b.getX(), b.getY()), m.OffsetAngle(-g));
            0 === g && x || m.SetBboxChanged();
            f = [f, f.SaveToJson("visual-state")];
            0 === g && x || (m.SetXY(w, p), m.SetSize(t, u), m.SetAngle(q), m.SetBboxChanged());
            return f
        }
        Do(f, h, g) {
            h = g.GetRuntime().GetCanvasManager();
            const k = g.GetWorldInfo().GetLayer(),
                m = k.GetLayout();
            var r = k.GetViewport(),
                w = g.GetWorldInfo().GetBoundingBox();
            const p = g._GetRenderTarget(),
                t = 0 < g.GetMultisampling(),
                u = this._includeFx,
                q = m.SaveTransform();
            m.RestoreTransform(this._layoutTransform);
            const x = new Map;
            for (const [G, J] of this._layerTransforms) x.set(G, G.SaveTransform()),
                G.RestoreTransform(J);
            h.SetIsPastingToDrawingCanvas(!0);
            var y = (r.width() - w.width()) / -2,
                B = (r.height() - w.height()) / -2;
            const [F, H] = k.LayerToDrawSurface(w.getLeft(), w.getTop());
            h.SetDeviceTransformOffset(F, H);
            var K = w.getLeft() - r.getLeft();
            r = w.getTop() - r.getTop();
            const C = y + K,
                A = B + r;
            y = p.GetHeight();
            k._SetTransform(f, !1, C, A, y);
            for (let G = 0, J = this._instances.length; G < J; ++G) {
                K = this._instances[G];
                B = K[0];
                K = K[1];
                if (B.IsDestroyed()) continue;
                r = B.GetWorldInfo();
                w = r.GetBoundingBox();
                const M = B.SaveToJson("visual-state");
                B.LoadFromJson(K, "visual-state");
                r.GetBoundingBox();
                !u || !r.HasAnyActiveEffect() || t && r.GetInstanceEffectList().HasAnyActiveBackgroundBlendingEffect() ? k._DrawInstance(B, r, f) : (w.offset(-C, -A), k._DrawInstanceWithEffects(B, r, f, p, {
                    preTransform: () => k._SetTransform(f, !1, C, A)
                }) && k._SetTransform(f, !1, C, A, y), r.SetBboxChanged(), r.GetBoundingBox());
                B.LoadFromJson(M, "visual-state")
            }
            h.SetDeviceTransformOffset(0, 0);
            h.SetIsPastingToDrawingCanvas(!1);
            g._SetRenderTargetDeviceTransform(f);
            g._ApplyCurrentDrawingBlendMode(f);
            m.RestoreTransform(q);
            for (const [G, J] of x) G.RestoreTransform(J)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Particles = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Particles.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {
            this.GetImageInfo().LoadAsset(this._runtime)
        }
        LoadTextures(d) {
            return this.GetImageInfo().LoadStaticTexture(d, {
                sampling: this._runtime.GetSampling()
            })
        }
        ReleaseTextures() {
            this.GetImageInfo().ReleaseTexture()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.New(e.Rect);
    e.Plugins.Particles.Instance = class extends e.SDKWorldInstanceBase {
        constructor(a, b) {
            super(a);
            this._isFirstTick = !0;
            this._particleEngine = a = e.New(self.ParticleEngine);
            a.ononeshotfinish = () => this._OnOneShotFinish();
            this._spawnObjectClass = null;
            this._particleUpdateCallback = (f, h, g, k, m, r) => this._OnParticleUpdate(f, h, g, k, m, r);
            this._particleDestroyCallback = f => this._OnParticleDestroy(f);
            this._hasAnyDefaultParticle = !0;
            b && (a.SetRate(b[0]), a.SetSprayCone(e.toRadians(b[1])),
                a.SetSprayType(b[2] ? "one-shot" : "continuous-spray"), this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(b[3])), a.SetInitSpeed(b[4]), a.SetInitSize(b[5]), a.SetInitOpacity(b[6] / 100), a.SetGrowRate(b[7]), a.SetInitXRandom(b[8]), a.SetInitYRandom(b[9]), a.SetInitSpeedRandom(b[10]), a.SetInitSizeRandom(b[11]), a.SetGrowRandom(b[12]), a.SetAcceleration(b[13]), a.SetGravity(b[14]), a.SetLifeAngleRandom(b[15]), a.SetLifeSpeedRandom(b[16]), a.SetLifeOpacityRandom(b[17]), a.SetDestroyModeIndex(b[18]), a.SetTimeout(b[19]));
            this._UpdateEngineParameters();
            this._spawnObjectClass && (this._hasAnyDefaultParticle = !1);
            "one-shot" === a.GetSprayType() ? a.CreateOneShotSpray() : a.SetSpraying(!0);
            const c = this.GetWorldInfo();
            c.SetBboxChangeEventEnabled(!0);
            this._inst.Dispatcher().addEventListener("bboxchange", () => {
                c.OverwriteBoundingBox(this._particleEngine.GetBoundingBox())
            });
            this.GetRuntime().GetRenderer().IsWebGPU() && c.SetUsePointsShaderProgram();
            this._StartTicking()
        }
        Release() {
            this._particleEngine.Release();
            this._particleDestroyCallback =
                this._particleUpdateCallback = this._particleEngine = null;
            super.Release()
        }
        _SetParticleObjectClass(a) {
            a === this.GetObjectClass() && (a = null);
            this._spawnObjectClass = a;
            this._particleEngine.onparticlecreate = a ? b => this._OnParticleCreate(b) : null;
            this._spawnObjectClass || (this._hasAnyDefaultParticle = !0)
        }
        _UpdateEngineParameters() {
            const a = this._particleEngine,
                b = this.GetWorldInfo();
            a.SetMasterOpacity(b.GetOpacity());
            a.SetPixelRounding(this._runtime.IsPixelRoundingEnabled());
            a.SetSpawnX(b.GetX());
            a.SetSpawnY(b.GetY());
            a.SetSpawnAngle(b.GetAngle());
            a.SetInitSizeScale(b.GetSceneGraphScale())
        }
        _OnOneShotFinish() {
            this._runtime.DestroyInstance(this._inst)
        }
        Draw(a) {
            if (this._hasAnyDefaultParticle) {
                var b = this._objectClass.GetImageInfo(),
                    c = b.GetTexture();
                if (c) {
                    var f = this.GetWorldInfo(),
                        h = f.GetLayer();
                    this._runtime.GetCanvasManager().IsPastingToDrawingCanvas() ? d.set(-Infinity, -Infinity, Infinity, Infinity) : h.Has3DCamera() ? h.CalculateViewport3D(f.GetTotalZElevation(), d) : h.GetViewportForZ(f.GetTotalZElevation(), d);
                    a.SetTexture(c);
                    c = h.Get2DScaleFactorToZ(f.GetTotalZElevation());
                    this._particleEngine.SetParticleScale(h.GetRenderScale() * c);
                    this._particleEngine.Draw(a, b.GetTexRect(), d, h.Has3DCamera())
                }
            }
        }
        SaveToJson() {
            const a = this._particleEngine;
            return {
                r: a.GetRate(),
                sc: a.GetSprayCone(),
                st: a.GetSprayType(),
                isp: a.GetInitSpeed(),
                isz: a.GetInitSize(),
                io: a.GetInitOpacity(),
                gr: a.GetGrowRate(),
                xr: a.GetInitXRandom(),
                yr: a.GetInitYRandom(),
                spr: a.GetInitSpeedRandom(),
                szr: a.GetInitSizeRandom(),
                grnd: a.GetGrowRandom(),
                acc: a.GetAcceleration(),
                g: a.GetGravity(),
                lar: a.GetLifeAngleRandom(),
                lsr: a.GetLifeSpeedRandom(),
                lor: a.GetLifeOpacityRandom(),
                dm: a.GetDestroyModeIndex(),
                to: a.GetTimeout(),
                s: a.IsSpraying(),
                pcc: a._GetCreateCounter(),
                ft: this._isFirstTick,
                p: a.GetParticles().map(b => b.toJSON())
            }
        }
        LoadFromJson(a) {
            var b = this._particleEngine;
            b.SetRate(a.r);
            b.SetSprayCone(a.sc);
            b.SetSprayType(a.st);
            b.SetInitSpeed(a.isp);
            b.SetInitSize(a.isz);
            b.SetInitOpacity(a.io);
            b.SetGrowRate(a.gr);
            b.SetInitXRandom(a.xr);
            b.SetInitYRandom(a.yr);
            b.SetInitSpeedRandom(a.spr);
            b.SetInitSizeRandom(a.szr);
            b.SetGrowRandom(a.grnd);
            b.SetAcceleration(a.acc);
            b.SetGravity(a.g);
            b.SetLifeAngleRandom(a.lar);
            b.SetLifeSpeedRandom(a.lsr);
            b.SetLifeOpacityRandom(a.lor);
            b.SetDestroyModeIndex(a.dm);
            b.SetTimeout(a.to);
            b.SetSpraying(a.s);
            b._SetCreateCounter(a.pcc);
            this._isFirstTick = a.ft;
            a = a.p;
            b.SetParticleCount(a.length);
            b = b.GetParticles();
            for (let c = 0, f = b.length; c < f; ++c) b[c].setFromJSON(a[c])
        }
        Tick() {
            const a = this._runtime.GetDt(this._inst);
            this._UpdateEngineParameters();
            this._isFirstTick &&
                "one-shot" === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles();
            this._particleEngine.Tick(a);
            this._particleEngine.IsSpraying() && this._runtime.UpdateRender();
            this.GetWorldInfo().SetBboxChanged();
            this._isFirstTick = !1
        }
        _OnParticleCreate(a) {
            const b = this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), a.GetX(), a.GetY()),
                c = b.GetWorldInfo();
            c.SetSize(a.GetSize(), a.GetSize());
            c.SetAngle(a.GetAngle());
            c.SetOpacity(a.GetOpacity());
            c.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor());
            c.SetBboxChanged();
            c.ZOrderMoveAdjacentToInstance(this.GetInstance(), !0);
            b._TriggerOnCreated();
            a.SetUpdateCallback(this._particleUpdateCallback);
            a.SetDestroyCallback(this._particleDestroyCallback);
            return b
        }
        _OnParticleUpdate(a, b, c, f, h, g) {
            a.IsDestroyed() || (a = a.GetWorldInfo(), a.OffsetXY(b, c), a.SetSize(a.GetWidth() + f, a.GetHeight() + f), a.SetAngle(a.GetAngle() + h), a.SetOpacity(a.GetOpacity() + g), a.SetBboxChanged())
        }
        _OnParticleDestroy(a) {
            a.IsDestroyed() || this._runtime.DestroyInstance(a)
        }
        GetPropertyValueByIndex(a) {
            const b =
                this._particleEngine;
            switch (a) {
                case 0:
                    return b.GetRate();
                case 1:
                    return e.toDegrees(b.GetSprayCone());
                case 2:
                    return "one-shot" === b.GetSprayType() ? 1 : 0;
                case 4:
                    return b.GetInitSpeed();
                case 5:
                    return b.GetInitSize();
                case 6:
                    return 100 * b.GetInitOpacity();
                case 7:
                    return b.GetGrowRate();
                case 8:
                    return b.GetInitXRandom();
                case 9:
                    return b.GetInitYRandom();
                case 10:
                    return b.GetInitSpeedRandom();
                case 11:
                    return b.GetInitSizeRandom();
                case 12:
                    return b.GetGrowRandom();
                case 13:
                    return b.GetAcceleration();
                case 14:
                    return b.GetGravity();
                case 15:
                    return b.GetLifeAngleRandom();
                case 16:
                    return b.GetLifeSpeedRandom();
                case 17:
                    return b.GetLifeOpacityRandom();
                case 18:
                    return b.GetDestroyModeIndex();
                case 19:
                    return b.GetTimeout()
            }
        }
        SetPropertyValueByIndex(a, b) {
            const c = this._particleEngine;
            switch (a) {
                case 0:
                    c.SetRate(b);
                    break;
                case 1:
                    c.SetSprayCone(e.toRadians(b));
                    break;
                case 2:
                    c.SetSprayType(b ? "one-shot" : "continuous-spray");
                    break;
                case 4:
                    c.SetInitSpeed(b);
                    break;
                case 5:
                    c.SetInitSize(b);
                    break;
                case 6:
                    c.SetInitOpacity(b / 100);
                    break;
                case 7:
                    c.SetGrowRate(b);
                    break;
                case 8:
                    c.SetInitXRandom(b);
                    break;
                case 9:
                    c.SetInitYRandom(b);
                    break;
                case 10:
                    c.SetInitSpeedRandom(b);
                    break;
                case 11:
                    c.SetInitSizeRandom(b);
                    break;
                case 12:
                    c.SetGrowRandom(b);
                    break;
                case 13:
                    c.SetAcceleration(b);
                    break;
                case 14:
                    c.SetGravity(b);
                    break;
                case 15:
                    c.SetLifeAngleRandom(b);
                    break;
                case 16:
                    c.SetLifeSpeedRandom(b);
                    break;
                case 17:
                    c.SetLifeOpacityRandom(b);
                    break;
                case 18:
                    c.SetDestroyModeIndex(b);
                    break;
                case 19:
                    c.SetTimeout(b)
            }
        }
        GetDebuggerProperties() {
            const a = this._particleEngine;
            return [{
                title: "plugins.particles.name",
                properties: [{
                        name: "plugins.particles.debugger.particle-count",
                        value: a.GetParticleCount()
                    }, {
                        name: "plugins.particles.properties.type.name",
                        value: ["plugins.particles.properties.type.items." + a.GetSprayType()]
                    }, {
                        name: "plugins.particles.debugger.is-spraying",
                        value: a.IsSpraying(),
                        onedit: b => a.SetSpraying(b)
                    }, {
                        name: "plugins.particles.properties.rate.name",
                        value: a.GetRate(),
                        onedit: b => a.SetRate(b)
                    }, {
                        name: "plugins.particles.properties.spray-cone.name",
                        value: e.toDegrees(a.GetSprayCone()),
                        onedit: b => a.SetSprayCone(e.toRadians(b))
                    },
                    {
                        name: "plugins.particles.properties.speed.name",
                        value: a.GetInitSpeed(),
                        onedit: b => a.SetInitSpeed(b)
                    }, {
                        name: "plugins.particles.properties.size.name",
                        value: a.GetInitSize(),
                        onedit: b => a.SetInitSize(b)
                    }, {
                        name: "plugins.particles.properties.opacity.name",
                        value: a.GetInitOpacity(),
                        onedit: b => a.SetInitOpacity(b)
                    }, {
                        name: "plugins.particles.properties.grow-rate.name",
                        value: a.GetGrowRate(),
                        onedit: b => a.SetGrowRate(b)
                    }, {
                        name: "plugins.particles.properties.x-randomiser.name",
                        value: a.GetInitXRandom(),
                        onedit: b => a.SetInitXRandom(b)
                    },
                    {
                        name: "plugins.particles.properties.y-randomiser.name",
                        value: a.GetInitYRandom(),
                        onedit: b => a.SetInitYRandom(b)
                    }, {
                        name: "plugins.particles.properties.initial-speed-randomiser.name",
                        value: a.GetInitSpeedRandom(),
                        onedit: b => a.SetInitSpeedRandom(b)
                    }, {
                        name: "plugins.particles.properties.size-randomiser.name",
                        value: a.GetInitSizeRandom(),
                        onedit: b => a.SetInitSizeRandom(b)
                    }, {
                        name: "plugins.particles.properties.grow-rate-randomiser.name",
                        value: a.GetGrowRandom(),
                        onedit: b => a.SetGrowRandom(b)
                    }, {
                        name: "plugins.particles.properties.acceleration.name",
                        value: a.GetAcceleration(),
                        onedit: b => a.SetAcceleration(b)
                    }, {
                        name: "plugins.particles.properties.gravity.name",
                        value: a.GetGravity(),
                        onedit: b => a.SetGravity(b)
                    }, {
                        name: "plugins.particles.properties.angle-randomiser.name",
                        value: a.GetLifeAngleRandom(),
                        onedit: b => a.SetLifeAngleRandom(b)
                    }, {
                        name: "plugins.particles.properties.life-speed-randomiser.name",
                        value: a.GetLifeSpeedRandom(),
                        onedit: b => a.SetLifeSpeedRandom(b)
                    }, {
                        name: "plugins.particles.properties.opacity-randomiser.name",
                        value: a.GetLifeOpacityRandom(),
                        onedit: b =>
                            a.SetLifeOpacityRandom(b)
                    }, {
                        name: "plugins.particles.properties.timeout.name",
                        value: a.GetTimeout(),
                        onedit: b => a.SetTimeout(b)
                    }
                ]
            }]
        }
    }
}
"use strict";
self.C3.Plugins.Particles.Cnds = {
    IsSpraying() {
        return this._particleEngine.IsSpraying()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Particles.Acts = {
        SetSpraying(d) {
            this._particleEngine.SetSpraying(0 !== d)
        },
        SetRate(d) {
            this._particleEngine.SetRate(d);
            "one-shot" === this._particleEngine.GetSprayType() && this._isFirstTick && this._particleEngine.SetParticleCount(d)
        },
        SetParticleObject(d) {
            this._SetParticleObjectClass(d)
        },
        UnsetParticleObject() {
            this._SetParticleObjectClass(null)
        },
        SetSprayCone(d) {
            this._particleEngine.SetSprayCone(e.toRadians(d))
        },
        SetInitSpeed(d) {
            this._particleEngine.SetInitSpeed(d)
        },
        SetInitSize(d) {
            this._particleEngine.SetInitSize(d)
        },
        SetInitOpacity(d) {
            this._particleEngine.SetInitOpacity(d / 100)
        },
        SetGrowRate(d) {
            this._particleEngine.SetGrowRate(d)
        },
        SetXRandomiser(d) {
            this._particleEngine.SetInitXRandom(d)
        },
        SetYRandomiser(d) {
            this._particleEngine.SetInitYRandom(d)
        },
        SetSpeedRandomiser(d) {
            this._particleEngine.SetInitSpeedRandom(d)
        },
        SetSizeRandomiser(d) {
            this._particleEngine.SetInitSizeRandom(d)
        },
        SetGrowRateRandomiser(d) {
            this._particleEngine.SetGrowRandom(d)
        },
        SetParticleAcc(d) {
            this._particleEngine.SetAcceleration(d)
        },
        SetGravity(d) {
            this._particleEngine.SetGravity(d)
        },
        SetAngleRandomiser(d) {
            this._particleEngine.SetLifeAngleRandom(d)
        },
        SetLifeSpeedRandomiser(d) {
            this._particleEngine.SetLifeSpeedRandom(d)
        },
        SetOpacityRandomiser(d) {
            this._particleEngine.SetLifeOpacityRandom(d)
        },
        SetTimeout(d) {
            this._particleEngine.SetTimeout(d)
        },
        SetEffect(d) {
            this.GetWorldInfo().SetBlendMode(d);
            this._runtime.UpdateRender()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Particles.Exps = {
        ParticleCount() {
            return this._particleEngine.GetParticleCount()
        },
        Rate() {
            return this._particleEngine.GetRate()
        },
        SprayCone() {
            return e.toDegrees(this._particleEngine.GetSprayCone())
        },
        InitSpeed() {
            return this._particleEngine.GetInitSpeed()
        },
        InitSize() {
            return this._particleEngine.GetInitSize()
        },
        InitOpacity() {
            return 100 * this._particleEngine.GetInitOpacity()
        },
        InitGrowRate() {
            return this._particleEngine.GetGrowRate()
        },
        XRandom() {
            return this._particleEngine.GetInitXRandom()
        },
        YRandom() {
            return this._particleEngine.GetInitYRandom()
        },
        InitSizeRandom() {
            return this._particleEngine.GetInitSizeRandom()
        },
        InitSpeedRandom() {
            return this._particleEngine.GetInitSpeedRandom()
        },
        InitGrowRandom() {
            return this._particleEngine.GetGrowRandom()
        },
        ParticleAcceleration() {
            return this._particleEngine.GetAcceleration()
        },
        Gravity() {
            return this._particleEngine.GetGravity()
        },
        ParticleAngleRandom() {
            return this._particleEngine.GetLifeAngleRandom()
        },
        ParticleSpeedRandom() {
            return this._particleEngine.GetLifeSpeedRandom()
        },
        ParticleOpacityRandom() {
            return this._particleEngine.GetLifeOpacityRandom()
        },
        Timeout() {
            return this._particleEngine.GetTimeout()
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = [],
        a = new Set(["continuous-spray", "one-shot"]),
        b = ["fade-to-invisible", "timeout-expired", "particle-stopped"];
    self.ParticleEngine = class {
        constructor() {
            this._sprayCone = this._rate = 0;
            this._sprayType = "continuous-spray";
            this._isSpraying = !1;
            this._masterOpacity = 0;
            this._isPixelRounding = !1;
            this._initSize = this._initSpeed = this._spawnAngle = this._spawnY = this._spawnX = 0;
            this._initSizeScale = 1;
            this._createCounter = this._timeout = this._destroyMode = this._lifeOpacityRandom = this._lifeSpeedRandom =
                this._lifeAngleRandom = this._gravity = this._acceleration = this._growRandom = this._initSizeRandom = this._initSpeedRandom = this._yRandom = this._xRandom = this._growRate = this._initOpacity = 0;
            this._particleScale = 1;
            this.onparticlecreate = this.ononeshotfinish = null;
            this._particles = [];
            this._boundingBox = new e.Rect;
            this._color = new e.Color
        }
        Release() {
            this.Cancel();
            e.clearArray(this._particles);
            this._color = this._boundingBox = this.onparticlecreate = this.ononeshotfinish = this._particles = null
        }
        Cancel() {
            const c = this._particles;
            for (let f = 0, h = c.length; f < h; ++f) c[f].Destroy();
            e.appendArray(d, c);
            e.clearArray(c);
            1E3 < d.length && e.truncateArray(d, 1E3);
            this._isSpraying = !1
        }
        CreateOneShotSpray() {
            for (let c = 0, f = this._rate; c < f; ++c) this._CreateParticle();
            this._particles.length && (this._isSpraying = !0)
        }
        _CreateParticle() {
            let c;
            d.length ? (c = d.pop(), c.SetEngine(this)) : c = e.New(self.Particle, this);
            this._particles.push(c);
            c.Init(this.onparticlecreate);
            return c
        }
        ReInitAllParticles() {
            const c = this._particles,
                f = this.onparticlecreate;
            for (let h = 0, g = c.length; h <
                g; ++h) c[h].Init(f)
        }
        SetParticleCount(c) {
            var f = this._particles;
            if (c < f.length) {
                c = f.length - c;
                for (let h = 0; h < c; ++h) {
                    const g = f.pop();
                    g.Destroy();
                    d.push(g)
                }
                1E3 < d.length && e.truncateArray(d, 1E3)
            } else if (c > f.length)
                for (f = c - f.length, c = 0; c < f; ++c) this._CreateParticle()
        }
        GetParticles() {
            return this._particles
        }
        GetParticleCount() {
            return this._particles.length
        }
        Tick(c) {
            this._SpawnContinuous(c);
            this._TickParticles(c);
            this._MaybeFinishOneShot()
        }
        _SpawnContinuous(c) {
            if ("continuous-spray" === this._sprayType && this._isSpraying) {
                this._createCounter +=
                    c * this._rate;
                c = Math.floor(this._createCounter);
                this._createCounter -= c;
                for (let f = 0; f < c; ++f) this._CreateParticle()
            }
        }
        _SetCreateCounter(c) {
            this._createCounter = c
        }
        _GetCreateCounter() {
            return this._createCounter
        }
        _TickParticles(c) {
            const f = this._boundingBox;
            f.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY);
            const h = this._particles;
            let g = 0;
            for (let k = 0, m = h.length; k < m; ++k) {
                const r = h[k];
                h[g] = r;
                r.Tick(c);
                r.IsActive() ? (++g, f.expandToContain(r.GetBoundingBox())) : (r.Destroy(), d.push(r))
            }
            e.truncateArray(h, g);
            1E3 < d.length && e.truncateArray(d, 1E3)
        }
        _MaybeFinishOneShot() {
            if ("one-shot" === this._sprayType && 0 === this._particles.length && this._isSpraying) {
                if (this.ononeshotfinish) this.ononeshotfinish();
                this._isSpraying = !1
            }
        }
        Draw(c, f, h, g) {
            c.StartRenderingPoints(f);
            this._color.copy(c.GetColor());
            const k = this._particles;
            for (let m = 0, r = k.length; m < r; ++m) {
                const w = k[m];
                h.intersectsRect(w.GetBoundingBox()) && w.Draw(c, f, g)
            }
            c.FinishRenderingPoints()
        }
        GetColor() {
            return this._color
        }
        SetRate(c) {
            this._rate = +c
        }
        GetRate() {
            return this._rate
        }
        SetSprayCone(c) {
            this._sprayCone = +c
        }
        GetSprayCone() {
            return this._sprayCone
        }
        SetSprayType(c) {
            if (!a.has(c)) throw Error("invalid spray type");
            this._sprayType = c
        }
        GetSprayType() {
            return this._sprayType
        }
        SetSpraying(c) {
            this._isSpraying = !!c
        }
        IsSpraying() {
            return this._isSpraying
        }
        SetMasterOpacity(c) {
            this._masterOpacity = +c
        }
        GetMasterOpacity() {
            return this._masterOpacity
        }
        SetPixelRounding(c) {
            this._isPixelRounding = !!c
        }
        IsPixelRounding() {
            return this._isPixelRounding
        }
        SetSpawnX(c) {
            this._spawnX = +c
        }
        GetSpawnX() {
            return this._spawnX
        }
        SetSpawnY(c) {
            this._spawnY = +c
        }
        GetSpawnY() {
            return this._spawnY
        }
        SetSpawnAngle(c) {
            this._spawnAngle = +c
        }
        GetInitAngle() {
            return this._spawnAngle
        }
        SetInitSpeed(c) {
            this._initSpeed = +c
        }
        GetInitSpeed() {
            return this._initSpeed
        }
        SetInitSize(c) {
            this._initSize = +c
        }
        GetInitSize() {
            return this._initSize
        }
        SetInitSizeScale(c) {
            this._initSizeScale = +c
        }
        GetInitSizeScale() {
            return this._initSizeScale
        }
        SetInitOpacity(c) {
            this._initOpacity = +c
        }
        GetInitOpacity() {
            return this._initOpacity
        }
        SetGrowRate(c) {
            this._growRate = +c
        }
        GetGrowRate() {
            return this._growRate
        }
        SetInitXRandom(c) {
            this._xRandom = +c
        }
        GetInitXRandom() {
            return this._xRandom
        }
        SetInitYRandom(c) {
            this._yRandom = +c
        }
        GetInitYRandom() {
            return this._yRandom
        }
        SetInitSpeedRandom(c) {
            this._initSpeedRandom = +c
        }
        GetInitSpeedRandom() {
            return this._initSpeedRandom
        }
        SetInitSizeRandom(c) {
            this._initSizeRandom = +c
        }
        GetInitSizeRandom() {
            return this._initSizeRandom
        }
        SetGrowRandom(c) {
            this._growRandom = +c
        }
        GetGrowRandom() {
            return this._growRandom
        }
        SetAcceleration(c) {
            this._acceleration = +c
        }
        GetAcceleration() {
            return this._acceleration
        }
        SetGravity(c) {
            this._gravity = +c
        }
        GetGravity() {
            return this._gravity
        }
        SetLifeAngleRandom(c) {
            this._lifeAngleRandom = +c
        }
        GetLifeAngleRandom() {
            return this._lifeAngleRandom
        }
        SetLifeSpeedRandom(c) {
            this._lifeSpeedRandom = +c
        }
        GetLifeSpeedRandom() {
            return this._lifeSpeedRandom
        }
        SetLifeOpacityRandom(c) {
            this._lifeOpacityRandom = +c
        }
        GetLifeOpacityRandom() {
            return this._lifeOpacityRandom
        }
        SetDestroyMode(c) {
            c = b.indexOf(c);
            if (-1 === c) throw Error("invalid destroy mode");
            this._destroyMode = c
        }
        SetDestroyModeIndex(c) {
            this.SetDestroyMode(b[c])
        }
        GetDestroyMode() {
            return b[this._destroyMode]
        }
        GetDestroyModeIndex() {
            return this._destroyMode
        }
        SetTimeout(c) {
            this._timeout = +c
        }
        GetTimeout() {
            return this._timeout
        }
        SetParticleScale(c) {
            this._particleScale = +c
        }
        GetParticleScale() {
            return this._particleScale
        }
        GetBoundingBox() {
            return this._boundingBox
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(h) {
        return Math.random() * h - h / 2
    }
    const a = new e.Quad,
        b = new e.Color,
        c = self.devicePixelRatio || 1;
    let f = !1;
    self.Particle = class {
        constructor(h) {
            this._engine = h;
            this._isActive = !1;
            this._angle = this._speed = this._y = this._x = 0;
            this._opacity = 1;
            this._age = this._gs = this._halfSize = this._size = this._grow = this._lastOpacity = 0;
            this._bbox = new e.Rect;
            this._destroyCallback = this._updateCallback = this._userData = null
        }
        SetEngine(h) {
            this._engine = h
        }
        Init(h) {
            const g = this._engine;
            this._isActive = !0;
            this._x = g.GetSpawnX() + d(g.GetInitXRandom());
            this._y = g.GetSpawnY() + d(g.GetInitYRandom());
            this._speed = g.GetInitSpeed() + d(g.GetInitSpeedRandom());
            this._angle = g.GetInitAngle() + d(g.GetSprayCone());
            this._lastOpacity = this._opacity = g.GetInitOpacity();
            this._size = (g.GetInitSize() + d(g.GetInitSizeRandom())) * g.GetInitSizeScale();
            this._halfSize = this._size / 2;
            this._grow = g.GetGrowRate() + d(g.GetGrowRandom());
            this._age = this._gs = 0;
            this._UpdateBoundingBox();
            h ? this._userData || (this._userData = h(this)) : this._destroyCallback =
                this._updateCallback = this._userData = null
        }
        SetUpdateCallback(h) {
            this._updateCallback = h
        }
        SetDestroyCallback(h) {
            this._destroyCallback = h
        }
        Destroy() {
            const h = this._destroyCallback;
            h && h(this._userData);
            this._destroyCallback = this._updateCallback = this._userData = null
        }
        toJSON() {
            return [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age]
        }
        setFromJSON(h) {
            this._x = h[0];
            this._y = h[1];
            this._speed = h[2];
            this._angle = h[3];
            this._opacity = h[4];
            this._grow = h[5];
            this._size = h[6];
            this._gs =
                h[7];
            this._age = h[8];
            this._halfSize = this._size / 2;
            this._UpdateBoundingBox()
        }
        Tick(h) {
            var g = this._engine,
                k = this._speed * h,
                m = this._angle;
            const r = Math.cos(m) * k;
            k = Math.sin(m) * k + this._gs * h;
            this._x += r;
            this._y += k;
            m = this._grow * h;
            this._size += m;
            this._halfSize = this._size / 2;
            this._speed += g.GetAcceleration() * h;
            this._gs += g.GetGravity() * h;
            this._age += h;
            this._UpdateBoundingBox();
            var w = g.GetLifeAngleRandom(),
                p = g.GetLifeSpeedRandom();
            const t = g.GetLifeOpacityRandom();
            let u = 0;
            0 !== w && (u = d(w * h), this._angle += u);
            0 !== p && (this._speed +=
                d(p * h));
            0 !== t && (this._opacity = e.clamp(this._opacity + d(t * h), 0, 1));
            h = 1 <= this._size && (2 === g.GetDestroyModeIndex() ? 0 < this._speed : this._age < g.GetTimeout());
            (w = this._updateCallback) && h && (p = g.GetMasterOpacity() * this._opacity, 0 === g.GetDestroyModeIndex() && (p *= 1 - this._age / g.GetTimeout()), g = p - this._lastOpacity, this._lastOpacity = p, w(this._userData, r, k, m, u, g));
            this._isActive = h
        }
        IsActive() {
            return this._isActive
        }
        GetBoundingBox() {
            return this._bbox
        }
        _UpdateBoundingBox() {
            const h = this._x,
                g = this._y,
                k = this._halfSize;
            this._bbox.set(h -
                k, g - k, h + k, g + k)
        }
        Draw(h, g, k) {
            if (!this._userData) {
                var m = this._engine,
                    r = m.GetMasterOpacity() * this._opacity;
                0 === m.GetDestroyModeIndex() && (r *= 1 - this._age / m.GetTimeout());
                if (!(0 >= r)) {
                    var w = this._size,
                        p = w * m.GetParticleScale() * c;
                    if (!(1 > p)) {
                        var t = this._x,
                            u = this._y;
                        m.IsPixelRounding() && (t = t + .5 | 0, u = u + .5 | 0);
                        h.IsWebGPU() ? h.Point(t, u, w, r) : k || p > h.GetMaxPointSize() || p < h.GetMinPointSize() ? (b.copy(m.GetColor()), b.multiplyAlpha(r), h.SetColor(b), f = !0, a.setFromRect(this._bbox), h.Quad3(a, g)) : (f && (h.SetColor(m.GetColor()),
                            f = !1), h.Point(t, u, p, r))
                    }
                }
            }
        }
        GetUserData() {
            return this._userData
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSize() {
            return this._size
        }
        GetAngle() {
            return this._angle
        }
        GetOpacity() {
            return this._opacity
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Arr = class extends e.SDKPluginBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Arr.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = self.IInstance;

    function b(f, h, g) {
        if (h < f.length) e.truncateArray(f, h);
        else if (h > f.length)
            if ("function" === typeof g)
                for (var k = f.length; k < h; ++k) f.push(g());
            else
                for (k = f.length; k < h; ++k) f.push(g)
    }
    e.Plugins.Arr.Instance = class extends e.SDKInstanceBase {
        constructor(f, h) {
            super(f);
            this._cx = 10;
            this._cz = this._cy = 1;
            this._arr = null;
            this._forX = [];
            this._forY = [];
            this._forZ = [];
            this._forDepth = -1;
            h && (this._cx = h[0], this._cy = h[1], this._cz = h[2]);
            this._arr = e.MakeFilledArray(this._cx,
                () => e.MakeFilledArray(this._cy, () => e.MakeFilledArray(this._cz, 0)))
        }
        Release() {
            this._arr = null;
            super.Release()
        }
        At(f, h, g) {
            f = Math.floor(f);
            h = Math.floor(h);
            g = Math.floor(g);
            return 0 <= f && f < this._cx && 0 <= h && h < this._cy && 0 <= g && g < this._cz ? this._arr[f][h][g] : 0
        }
        Set(f, h, g, k) {
            f = Math.floor(f);
            h = Math.floor(h);
            g = Math.floor(g);
            0 <= f && f < this._cx && 0 <= h && h < this._cy && 0 <= g && g < this._cz && (this._arr[f][h][g] = k)
        }
        SetSize(f, h, g) {
            f = Math.floor(f);
            h = Math.floor(h);
            g = Math.floor(g);
            0 > f && (f = 0);
            0 > h && (h = 0);
            0 > g && (g = 0);
            if (this._cx !== f || this._cy !==
                h || this._cz !== g) {
                this._cx = f;
                this._cy = h;
                this._cz = g;
                var k = this._arr;
                b(k, f, () => e.MakeFilledArray(h, () => e.MakeFilledArray(g, 0)));
                for (let m = 0; m < f; ++m) {
                    b(k[m], h, () => e.MakeFilledArray(g, 0));
                    for (let r = 0; r < h; ++r) b(k[m][r], g, 0)
                }
            }
        }
        GetWidth() {
            return this._cx
        }
        GetHeight() {
            return this._cy
        }
        GetDepth() {
            return this._cz
        }
        GetDebuggerProperties() {
            const f = [{
                    title: "plugins.arr.debugger.array-properties.title",
                    properties: [{
                            name: "plugins.arr.properties.width.name",
                            value: this._cx,
                            onedit: g => this.SetSize(g, this._cy, this._cz)
                        },
                        {
                            name: "plugins.arr.properties.height.name",
                            value: this._cy,
                            onedit: g => this.SetSize(this._cx, g, this._cz)
                        }, {
                            name: "plugins.arr.properties.depth.name",
                            value: this._cz,
                            onedit: g => this.SetSize(this._cx, this._cy, g)
                        }, {
                            name: "plugins.arr.properties.elements.name",
                            value: this._cx * this._cy * this._cz
                        }
                    ]
                }],
                h = [];
            if (1 === this._cy && 1 === this._cz)
                for (let g = 0; g < this._cx; ++g) h.push({
                    name: "$" + g,
                    value: this._arr[g][0][0],
                    onedit: k => this._arr[g][0][0] = k
                });
            else
                for (let g = 0; g < this._cx; ++g) h.push({
                    name: "$" + g,
                    value: this._arr[g].toString()
                });
            h.length && f.push({
                title: "plugins.arr.debugger.array-data.title",
                properties: h
            });
            return f
        }
        GetAsJsonString() {
            return JSON.stringify({
                c2array: !0,
                size: [this._cx, this._cy, this._cz],
                data: this._arr
            })
        }
        SaveToJson() {
            return {
                size: [this._cx, this._cy, this._cz],
                data: this._arr
            }
        }
        LoadFromJson(f) {
            const h = f.size;
            this._cx = h[0];
            this._cy = h[1];
            this._cz = h[2];
            this._arr = f.data
        }
        _GetForX() {
            return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0
        }
        _GetForY() {
            return 0 <= this._forDepth && this._forDepth <
                this._forY.length ? this._forY[this._forDepth] : 0
        }
        _GetForZ() {
            return 0 <= this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0
        }
        GetScriptInterfaceClass() {
            return self.IArrayInstance
        }
    };
    const c = new WeakMap;
    self.IArrayInstance = class extends a {
        constructor() {
            super();
            c.set(this, a._GetInitInst().GetSdkInstance())
        }
        get width() {
            return c.get(this).GetWidth()
        }
        get height() {
            return c.get(this).GetHeight()
        }
        get depth() {
            return c.get(this).GetDepth()
        }
        setSize(f, h = 1, g = 1) {
            d.RequireFiniteNumber(f);
            d.RequireFiniteNumber(h);
            d.RequireFiniteNumber(g);
            c.get(this).SetSize(f, h, g)
        }
        getAt(f, h = 0, g = 0) {
            d.RequireFiniteNumber(f);
            d.RequireFiniteNumber(h);
            d.RequireFiniteNumber(g);
            return c.get(this).At(f, h, g)
        }
        setAt(f, h, g = 0, k = 0) {
            d.RequireFiniteNumber(h);
            d.RequireFiniteNumber(g);
            d.RequireFiniteNumber(k);
            if ("number" !== typeof f && "string" !== typeof f) throw new TypeError("invalid type");
            c.get(this).Set(h, g, k, f)
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(a, b, c, f, h) {
        a.PushCopySol(c);
        b.Retrigger(f, h);
        a.PopSol(c)
    }
    e.Plugins.Arr.Cnds = {
        CompareX(a, b, c) {
            return e.compare(this.At(a, 0, 0), b, c)
        },
        CompareXY(a, b, c, f) {
            return e.compare(this.At(a, b, 0), c, f)
        },
        CompareXYZ(a, b, c, f, h) {
            return e.compare(this.At(a, b, c), f, h)
        },
        ArrForEach(a) {
            const b = this._runtime,
                c = b.GetEventSheetManager(),
                f = b.GetCurrentEvent(),
                h = f.GetSolModifiers(),
                g = b.GetEventStack(),
                k = g.GetCurrentStackFrame(),
                m = g.Push(f),
                r = ++this._forDepth,
                w = this._forX;
            var p = this._forY,
                t = this._forZ;
            const u = this._cx,
                q = this._cy;
            var x = this._cz;
            r === this._forX.length ? (w.push(0), p.push(0), t.push(0)) : (w[r] = 0, p[r] = 0, t[r] = 0);
            b.SetDebuggingEnabled(!1);
            if (0 === a)
                for (a = 0; a < u; ++a)
                    for (let y = 0; y < q; ++y)
                        for (let B = 0; B < x; ++B) w[r] = a, p[r] = y, t[r] = B, d(c, f, h, k, m);
            else if (1 === a)
                for (t = 0; t < u; ++t)
                    for (x = 0; x < q; ++x) w[r] = t, p[r] = x, d(c, f, h, k, m);
            else
                for (p = 0; p < u; ++p) w[r] = p, d(c, f, h, k, m);
            b.SetDebuggingEnabled(!0);
            this._forDepth--;
            g.Pop();
            return !1
        },
        CompareCurrent(a, b) {
            return e.compare(this.At(this._GetForX(), this._GetForY(),
                this._GetForZ()), a, b)
        },
        Contains(a) {
            const b = this._cx,
                c = this._cy,
                f = this._cz,
                h = this._arr;
            for (let g = 0; g < b; ++g)
                for (let k = 0; k < c; ++k)
                    for (let m = 0; m < f; ++m)
                        if (h[g][k][m] === a) return !0;
            return !1
        },
        IsEmpty() {
            return 0 === this._cx || 0 === this._cy || 0 === this._cz
        },
        CompareSize(a, b, c) {
            let f = 0;
            switch (a) {
                case 0:
                    f = this._cx;
                    break;
                case 1:
                    f = this._cy;
                    break;
                case 2:
                    f = this._cz
            }
            return e.compare(f, b, c)
        }
    }
} {
    "use strict";
    const e = self.C3;

    function d(a, b) {
        if ("number" === typeof a && "number" === typeof b) return a - b;
        a = a.toString();
        b = b.toString();
        return a < b ? -1 : a > b ? 1 : 0
    }
    e.Plugins.Arr.Acts = {
        Clear(a) {
            const b = this._cx,
                c = this._cy,
                f = this._cz,
                h = this._arr;
            for (let g = 0; g < b; ++g)
                for (let k = 0; k < c; ++k)
                    for (let m = 0; m < f; ++m) h[g][k][m] = a
        },
        SetSize(a, b, c) {
            this.SetSize(a, b, c)
        },
        SetX(a, b) {
            this.Set(a, 0, 0, b)
        },
        SetXY(a, b, c) {
            this.Set(a, b, 0, c)
        },
        SetXYZ(a, b, c, f) {
            this.Set(a, b, c, f)
        },
        Push(a, b, c) {
            var f = this._cx,
                h = this._cy;
            const g = this._cz,
                k = this._arr;
            if (0 === c) f = e.MakeFilledArray(h, () => e.MakeFilledArray(g, b)), 0 === a ? k.push(f) : k.unshift(f), this._cx++;
            else if (1 === c) {
                for (h = 0; h < f; ++h) c = e.MakeFilledArray(g, b), 0 === a ? k[h].push(c) : k[h].unshift(c);
                this._cy++
            } else {
                for (c = 0; c < f; ++c)
                    for (let m = 0; m < h; ++m) 0 === a ? k[c][m].push(b) : k[c][m].unshift(b);
                this._cz++
            }
        },
        Pop(a, b) {
            const c = this._cx;
            var f = this._cy,
                h = this._cz;
            const g = this._arr;
            if (0 === b) 0 !== c && (0 === a ? g.pop() : g.shift(), this._cx--);
            else if (1 === b) {
                if (0 !== f) {
                    for (f = 0; f < c; ++f) 0 === a ? g[f].pop() : g[f].shift();
                    this._cy--
                }
            } else if (0 !==
                h) {
                for (b = 0; b < c; ++b)
                    for (h = 0; h < f; ++h) 0 === a ? g[b][h].pop() : g[b][h].shift();
                this._cz--
            }
        },
        Reverse(a) {
            const b = this._cx;
            var c = this._cy,
                f = this._cz;
            const h = this._arr;
            if (0 !== b && 0 !== c && 0 !== f)
                if (0 === a) h.reverse();
                else if (1 === a)
                for (c = 0; c < b; ++c) h[c].reverse();
            else
                for (a = 0; a < b; ++a)
                    for (f = 0; f < c; ++f) h[a][f].reverse()
        },
        Sort(a) {
            const b = this._cx;
            var c = this._cy,
                f = this._cz;
            const h = this._arr;
            if (0 !== b && 0 !== c && 0 !== f)
                if (0 === a) h.sort((g, k) => d(g[0][0], k[0][0]));
                else if (1 === a)
                for (c = 0; c < b; ++c) h[c].sort((g, k) => d(g[0], k[0]));
            else
                for (a =
                    0; a < b; ++a)
                    for (f = 0; f < c; ++f) h[a][f].sort(d)
        },
        Delete(a, b) {
            a = Math.floor(a);
            if (!(0 > a)) {
                var c = this._cx,
                    f = this._cy,
                    h = this._cz,
                    g = this._arr;
                if (0 === b) a >= c || (g.splice(a, 1), this._cx--);
                else if (1 === b) {
                    if (!(a >= f)) {
                        for (f = 0; f < c; ++f) g[f].splice(a, 1);
                        this._cy--
                    }
                } else if (!(a >= h)) {
                    for (b = 0; b < c; ++b)
                        for (h = 0; h < f; ++h) g[b][h].splice(a, 1);
                    this._cz--
                }
            }
        },
        Insert(a, b, c) {
            b = Math.floor(b);
            if (!(0 > b)) {
                var f = this._cx,
                    h = this._cy,
                    g = this._cz,
                    k = this._arr;
                if (0 === c) b > f || (k.splice(b, 0, e.MakeFilledArray(h, () => e.MakeFilledArray(g, a))), this._cx++);
                else if (1 === c) {
                    if (!(b > h)) {
                        for (h = 0; h < f; ++h) k[h].splice(b, 0, e.MakeFilledArray(g, a));
                        this._cy++
                    }
                } else if (!(b > g)) {
                    for (c = 0; c < f; ++c)
                        for (let m = 0; m < h; ++m) k[c][m].splice(b, 0, a);
                    this._cz++
                }
            }
        },
        JSONLoad(a) {
            let b = null;
            try {
                b = JSON.parse(a)
            } catch (c) {
                console.error("[Construct 3] Failed to parse JSON: ", c);
                return
            }
            b.c2array && (a = b.size, this._cx = a[0], this._cy = a[1], this._cz = a[2], this._arr = b.data)
        },
        JSONDownload(a) {
            const b = URL.createObjectURL(new Blob([this.GetAsJsonString()], {
                type: "application/json"
            }));
            this._runtime.InvokeDownload(b,
                a)
        }
    }
}
"use strict";
self.C3.Plugins.Arr.Exps = {
    At(e, d, a) {
        return this.At(e, d || 0, a || 0)
    },
    Width() {
        return this._cx
    },
    Height() {
        return this._cy
    },
    Depth() {
        return this._cz
    },
    CurX() {
        return this._GetForX()
    },
    CurY() {
        return this._GetForY()
    },
    CurZ() {
        return this._GetForZ()
    },
    CurValue() {
        return this.At(this._GetForX(), this._GetForY(), this._GetForZ())
    },
    Front() {
        return this.At(0, 0, 0)
    },
    Back() {
        return this.At(this._cx - 1, 0, 0)
    },
    IndexOf(e) {
        const d = this._arr;
        for (let a = 0, b = this._cx; a < b; ++a)
            if (d[a][0][0] === e) return a;
        return -1
    },
    LastIndexOf(e) {
        const d = this._arr;
        for (let a = this._cx - 1; 0 <= a; --a)
            if (d[a][0][0] === e) return a;
        return -1
    },
    AsJSON() {
        return this.GetAsJsonString()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Pin = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Pin.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Pin.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._pinInst = null;
            this._pinUid = -1;
            this._mode = "";
            this._propSet = new Set;
            this._lastKnownAngle = this._dz = this._dAngle = this._dHeight = this._dWidth = this._dy = this._dx = this._pinImagePoint = this._pinAngle = this._pinDist = 0;
            this._destroy = !1;
            a && (this._destroy = a[0]);
            d = this._runtime.Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(d, "instancedestroy", b => this._OnInstanceDestroyed(b.instance)),
                e.Disposable.From(d, "afterload", b => this._OnAfterLoad()))
        }
        Release() {
            this._pinInst = null;
            super.Release()
        }
        _SetPinInst(d) {
            d ? (this._pinInst = d, this._StartTicking2()) : (this._pinInst = null, this._StopTicking2())
        }
        _Pin(d, a, b) {
            if (d && (d = d.GetFirstPicked(this._inst)))
                if (this._mode = a, this._SetPinInst(d), a = this._inst.GetWorldInfo(), d = d.GetWorldInfo(), "properties" === this._mode) {
                    const c = this._propSet;
                    c.clear();
                    for (const f of b) c.add(f);
                    this._dx = a.GetX() - d.GetX();
                    this._dy = a.GetY() - d.GetY();
                    this._dAngle = a.GetAngle() - d.GetAngle();
                    this._lastKnownAngle = a.GetAngle();
                    this._dz = a.GetZElevation() - d.GetZElevation();
                    c.has("x") && c.has("y") && (this._pinAngle = e.angleTo(d.GetX(), d.GetY(), a.GetX(), a.GetY()) - d.GetAngle(), this._pinDist = e.distanceTo(d.GetX(), d.GetY(), a.GetX(), a.GetY()));
                    c.has("width-abs") ? this._dWidth = a.GetWidth() - d.GetWidth() : c.has("width-scale") && (this._dWidth = a.GetWidth() / d.GetWidth());
                    c.has("height-abs") ? this._dHeight = a.GetHeight() - d.GetHeight() : c.has("height-scale") && (this._dHeight = a.GetHeight() / d.GetHeight())
                } else this._pinDist =
                    e.distanceTo(d.GetX(), d.GetY(), a.GetX(), a.GetY())
        }
        SaveToJson() {
            const d = this._propSet,
                a = this._mode,
                b = {
                    uid: this._pinInst ? this._pinInst.GetUID() : -1,
                    m: a
                };
            if ("rope" === a || "bar" === a) b.pd = this._pinDist;
            else if ("properties" === a) {
                b.ps = [...this._propSet];
                d.has("imagepoint") ? b.ip = this._pinImagePoint : d.has("x") && d.has("y") ? (b.pa = this._pinAngle, b.pd = this._pinDist) : (d.has("x") && (b.dx = this._dx), d.has("y") && (b.dy = this._dy));
                d.has("angle") && (b.da = this._dAngle, b.lka = this._lastKnownAngle);
                if (d.has("width-abs") || d.has("width-scale")) b.dw =
                    this._dWidth;
                if (d.has("height-abs") || d.has("height-scale")) b.dh = this._dHeight;
                d.has("z") && (b.dz = this._dz)
            }
            return b
        }
        LoadFromJson(d) {
            const a = d.m,
                b = this._propSet;
            b.clear();
            this._pinUid = d.uid;
            if ("number" === typeof a) this._LoadFromJson_Legacy(d);
            else if (this._mode = a, "rope" === a || "bar" === a) this._pinDist = d.pd;
            else if ("properties" === a) {
                for (const c of d.ps) b.add(c);
                b.has("imagepoint") ? this._pinImagePoint = d.ip : b.has("x") && b.has("y") ? (this._pinAngle = d.pa, this._pinDist = d.pd) : (b.has("x") && (this._dx = d.dx), b.has("y") &&
                    (this._dy = d.dy));
                b.has("angle") && (this._dAngle = d.da, this._lastKnownAngle = d.lka || 0);
                if (b.has("width-abs") || b.has("width-scale")) this._dWidth = d.dw;
                if (b.has("height-abs") || b.has("height-scale")) this._dHeight = d.dh;
                b.has("z") && (this._dz = d.dz)
            }
        }
        _LoadFromJson_Legacy(d) {
            const a = this._propSet,
                b = d.msa,
                c = d.tsa,
                f = d.pa,
                h = d.pd;
            switch (d.m) {
                case 0:
                    this._mode = "properties";
                    a.add("x").add("y").add("angle");
                    this._pinAngle = f;
                    this._pinDist = h;
                    this._dAngle = b - c;
                    this._lastKnownAngle = d.lka;
                    break;
                case 1:
                    this._mode = "properties";
                    a.add("x").add("y");
                    this._pinAngle = f;
                    this._pinDist = h;
                    break;
                case 2:
                    this._mode = "properties";
                    a.add("angle");
                    this._dAngle = b - c;
                    this._lastKnownAngle = d.lka;
                    break;
                case 3:
                    this._mode = "rope";
                    this._pinDist = d.pd;
                    break;
                case 4:
                    this._mode = "bar", this._pinDist = d.pd
            }
        }
        _OnAfterLoad() {
            -1 === this._pinUid ? this._SetPinInst(null) : (this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid)), this._pinUid = -1)
        }
        _OnInstanceDestroyed(d) {
            this._pinInst === d && (this._SetPinInst(null), this._destroy && this._runtime.DestroyInstance(this._inst))
        }
        Tick2() {
            var d =
                this._pinInst;
            if (d) {
                var a = d.GetWorldInfo(),
                    b = this._inst.GetWorldInfo(),
                    c = this._mode,
                    f = !1;
                if ("rope" === c || "bar" === c) {
                    if (d = e.distanceTo(b.GetX(), b.GetY(), a.GetX(), a.GetY()), d > this._pinDist || "bar" === c && d < this._pinDist) f = e.angleTo(a.GetX(), a.GetY(), b.GetX(), b.GetY()), b.SetXY(a.GetX() + Math.cos(f) * this._pinDist, a.GetY() + Math.sin(f) * this._pinDist), f = !0
                } else {
                    c = this._propSet;
                    if (c.has("imagepoint")) {
                        const [h, g] = d.GetImagePoint(this._pinImagePoint);
                        b.EqualsXY(h, g) || (b.SetXY(h, g), f = !0)
                    } else if (c.has("x") && c.has("y")) {
                        d =
                            a.GetX() + Math.cos(a.GetAngle() + this._pinAngle) * this._pinDist;
                        const h = a.GetY() + Math.sin(a.GetAngle() + this._pinAngle) * this._pinDist;
                        b.EqualsXY(d, h) || (b.SetXY(d, h), f = !0)
                    } else d = a.GetX() + this._dx, c.has("x") && d !== b.GetX() && (b.SetX(d), f = !0), d = a.GetY() + this._dy, c.has("y") && d !== b.GetY() && (b.SetY(d), f = !0);
                    c.has("angle") && (this._lastKnownAngle !== b.GetAngle() && (this._dAngle = e.clampAngle(this._dAngle + (b.GetAngle() - this._lastKnownAngle))), d = e.clampAngle(a.GetAngle() + this._dAngle), d !== b.GetAngle() && (b.SetAngle(d),
                        f = !0), this._lastKnownAngle = b.GetAngle());
                    c.has("width-abs") && (d = a.GetWidth() + this._dWidth, d !== b.GetWidth() && (b.SetWidth(d), f = !0));
                    c.has("width-scale") && (d = a.GetWidth() * this._dWidth, d !== b.GetWidth() && (b.SetWidth(d), f = !0));
                    c.has("height-abs") && (d = a.GetHeight() + this._dHeight, d !== b.GetHeight() && (b.SetHeight(d), f = !0));
                    c.has("height-scale") && (d = a.GetHeight() * this._dHeight, d !== b.GetHeight() && (b.SetHeight(d), f = !0));
                    c.has("z") && (d = a.GetZElevation() + this._dz, d !== b.GetZElevation() && (b.SetZElevation(d), this._runtime.UpdateRender()))
                }
                f &&
                    b.SetBboxChanged()
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.pin.debugger.is-pinned",
                    value: !!this._pinInst
                }, {
                    name: "behaviors.pin.debugger.pinned-uid",
                    value: this._pinInst ? this._pinInst.GetUID() : 0
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Pin.Cnds = {
    IsPinned() {
        return !!this._pinInst
    },
    WillDestroy() {
        return this._destroy
    }
};
"use strict";
self.C3.Behaviors.Pin.Acts = {
    PinByDistance(e, d) {
        this._Pin(e, 0 === d ? "rope" : "bar")
    },
    PinByProperties(e, d, a, b, c, f, h) {
        const g = [];
        d && g.push("x");
        a && g.push("y");
        b && g.push("angle");
        h && g.push("z");
        1 === c ? g.push("width-abs") : 2 === c && g.push("width-scale");
        1 === f ? g.push("height-abs") : 2 === f && g.push("height-scale");
        0 !== g.length && this._Pin(e, "properties", g)
    },
    PinByImagePoint(e, d, a, b, c, f) {
        const h = ["imagepoint"];
        a && h.push("angle");
        f && h.push("z");
        1 === b ? h.push("width-abs") : 2 === b && h.push("width-scale");
        1 === c ? h.push("height-abs") :
            2 === c && h.push("height-scale");
        this._pinImagePoint = d;
        this._Pin(e, "properties", h)
    },
    SetPinDistance(e) {
        if ("rope" === this._mode || "bar" === this._mode) this._pinDist = Math.max(e, 0)
    },
    SetDestroy(e) {
        this._destroy = e
    },
    Unpin() {
        this._SetPinInst(null);
        this._mode = "";
        this._propSet.clear();
        this._pinImagePoint = ""
    },
    Pin(e, d) {
        switch (d) {
            case 0:
                this._Pin(e, "properties", ["x", "y", "angle"]);
                break;
            case 1:
                this._Pin(e, "properties", ["x", "y"]);
                break;
            case 2:
                this._Pin(e, "properties", ["angle"]);
                break;
            case 3:
                this._Pin(e, "rope");
                break;
            case 4:
                this._Pin(e,
                    "bar")
        }
    }
};
"use strict";
self.C3.Behaviors.Pin.Exps = {
    PinnedUID() {
        return this._pinInst ? this._pinInst.GetUID() : -1
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Flash = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Flash.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Flash.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._timeLeft = this._stageTimeLeft = this._stage = this._offTime = this._onTime = 0;
            this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                on: this._onTime,
                off: this._offTime,
                s: this._stage,
                stl: this._stageTimeLeft,
                tl: this._timeLeft
            }
        }
        LoadFromJson(d) {
            this._onTime = d.on;
            this._offTime = d.off;
            this._stage = d.s;
            this._stageTimeLeft = d.stl;
            this._timeLeft = null === d.tl ? Infinity : d.tl
        }
        Tick() {
            if (!(0 >=
                    this._timeLeft)) {
                var d = this._runtime.GetDt(this._inst);
                this._timeLeft -= d;
                if (0 >= this._timeLeft) return this._timeLeft = 0, this._inst.GetWorldInfo().SetVisible(!0), this._runtime.UpdateRender(), this.DebugTrigger(e.Behaviors.Flash.Cnds.OnFlashEnded);
                this._stageTimeLeft -= d;
                0 >= this._stageTimeLeft && (0 === this._stage ? (this._inst.GetWorldInfo().SetVisible(!1), this._stage = 1, this._stageTimeLeft += this._offTime) : (this._inst.GetWorldInfo().SetVisible(!0), this._stage = 0, this._stageTimeLeft += this._onTime), this._runtime.UpdateRender())
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" +
                    this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.flash.debugger.on-time",
                    value: this._onTime,
                    onedit: d => this._onTime = d
                }, {
                    name: "behaviors.flash.debugger.off-time",
                    value: this._offTime,
                    onedit: d => this._offTime = d
                }, {
                    name: "behaviors.flash.debugger.is-flashing",
                    value: 0 < this._timeLeft
                }, {
                    name: "behaviors.flash.debugger.time-left",
                    value: this._timeLeft
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Flash.Cnds = {
    IsFlashing() {
        return 0 < this._timeLeft
    },
    OnFlashEnded() {
        return !0
    }
};
"use strict";
self.C3.Behaviors.Flash.Acts = {
    Flash(e, d, a) {
        this._onTime = e;
        this._offTime = d;
        this._stage = 1;
        this._stageTimeLeft = d;
        this._timeLeft = a;
        this._inst.GetWorldInfo().SetVisible(!1);
        this._runtime.UpdateRender()
    },
    StopFlashing() {
        this._timeLeft = 0;
        this._inst.GetWorldInfo().SetVisible(!0);
        this._runtime.UpdateRender()
    }
};
"use strict";
self.C3.Behaviors.Flash.Exps = {}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Timer = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Timer.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Timer.SingleTimer = class {
        constructor(d, a, b, c) {
            this._current = e.New(e.KahanSum);
            this._current.Set(d || 0);
            this._total = e.New(e.KahanSum);
            this._total.Set(a || 0);
            this._duration = b || 0;
            this._isRegular = !!c;
            this._isPaused = !1
        }
        GetCurrentTime() {
            return this._current.Get()
        }
        GetTotalTime() {
            return this._total.Get()
        }
        GetDuration() {
            return this._duration
        }
        SetPaused(d) {
            this._isPaused = !!d
        }
        IsPaused() {
            return this._isPaused
        }
        Add(d) {
            this._current.Add(d);
            this._total.Add(d)
        }
        HasFinished() {
            return this._current.Get() >=
                this._duration
        }
        Update() {
            if (this.HasFinished())
                if (this._isRegular) this._current.Subtract(this._duration);
                else return !0;
            return !1
        }
        SaveToJson() {
            return {
                c: this._current.Get(),
                t: this._total.Get(),
                d: this._duration,
                r: this._isRegular,
                p: this._isPaused
            }
        }
        LoadFromJson(d) {
            this._current.Set(d.c);
            this._total.Set(d.t);
            this._duration = d.d;
            this._isRegular = !!d.r;
            this._isPaused = !!d.p
        }
    };
    e.Behaviors.Timer.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._timers = new Map
        }
        Release() {
            this._timers.clear();
            super.Release()
        }
        _UpdateTickState() {
            0 < this._timers.size ? (this._StartTicking(), this._StartTicking2()) : (this._StopTicking(), this._StopTicking2())
        }
        SaveToJson() {
            const d = {};
            for (const [a, b] of this._timers.entries()) d[a] = b.SaveToJson();
            return d
        }
        LoadFromJson(d) {
            this._timers.clear();
            for (const [a, b] of Object.entries(d)) d = new e.Behaviors.Timer.SingleTimer, d.LoadFromJson(b), this._timers.set(a, d);
            this._UpdateTickState()
        }
        Tick() {
            const d = this._runtime.GetDt(this._inst);
            for (const a of this._timers.values()) a.IsPaused() ||
                a.Add(d)
        }
        Tick2() {
            for (const [d, a] of this._timers.entries()) a.Update() && this._timers.delete(d)
        }
        GetDebuggerProperties() {
            return [{
                title: "behaviors.timer.debugger.timers",
                properties: [...this._timers.entries()].map(d => ({
                    name: "$" + d[0],
                    value: `${Math.round(10*d[1].GetCurrentTime())/10} / ${Math.round(10*d[1].GetDuration())/10}`
                }))
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Timer.Cnds = {
    OnTimer(e) {
        return (e = this._timers.get(e.toLowerCase())) ? e.HasFinished() : !1
    },
    IsTimerRunning(e) {
        return this._timers.has(e.toLowerCase())
    },
    IsTimerPaused(e) {
        return (e = this._timers.get(e.toLowerCase())) && e.IsPaused()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Timer.Acts = {
        StartTimer(d, a, b) {
            d = new e.Behaviors.Timer.SingleTimer(0, 0, d, 1 === a);
            this._timers.set(b.toLowerCase(), d);
            this._UpdateTickState()
        },
        StopTimer(d) {
            this._timers.delete(d.toLowerCase());
            this._UpdateTickState()
        },
        PauseResumeTimer(d, a) {
            (d = this._timers.get(d.toLowerCase())) && d.SetPaused(0 === a)
        }
    }
}
"use strict";
self.C3.Behaviors.Timer.Exps = {
    CurrentTime(e) {
        return (e = this._timers.get(e.toLowerCase())) ? e.GetCurrentTime() : 0
    },
    TotalTime(e) {
        return (e = this._timers.get(e.toLowerCase())) ? e.GetTotalTime() : 0
    },
    Duration(e) {
        return (e = this._timers.get(e.toLowerCase())) ? e.GetDuration() : 0
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Fade = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Fade.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Fade.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._fadeOutTime = this._waitTime = this._fadeInTime = 0;
            this._activeAtStart = this._destroy = !0;
            this._setMaxOpacity = !1;
            this._stage = 0;
            this._stageTime = e.New(e.KahanSum);
            this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1;
            a && (this._fadeInTime = a[0], this._waitTime = a[1], this._fadeOutTime = a[2], this._destroy = !!a[3], this._stage = (this._activeAtStart = !!a[4]) ? 0 : 3);
            this._activeAtStart && (0 ===
                this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender()));
            this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                fit: this._fadeInTime,
                wt: this._waitTime,
                fot: this._fadeOutTime,
                d: this._destroy,
                s: this._stage,
                st: this._stageTime.Get(),
                mo: this._maxOpacity
            }
        }
        LoadFromJson(d) {
            this._fadeInTime = d.fit;
            this._waitTime = d.wt;
            this._fadeOutTime = d.fot;
            this._destroy = d.d;
            this._stage = d.s;
            this._stageTime.Set(d.st);
            this._maxOpacity =
                d.mo
        }
        Tick() {
            var d = this._runtime.GetDt(this._inst);
            this._stageTime.Add(d);
            d = this._inst.GetWorldInfo();
            0 === this._stage && (d.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity), this._runtime.UpdateRender(), d.GetOpacity() >= this._maxOpacity && (d.SetOpacity(this._maxOpacity), this._stage = 1, this._stageTime.Reset(), this.Trigger(e.Behaviors.Fade.Cnds.OnFadeInEnd)));
            1 === this._stage && this._stageTime.Get() >= this._waitTime && (this._stage = 2, this._stageTime.Reset(), this.Trigger(e.Behaviors.Fade.Cnds.OnWaitEnd));
            2 === this._stage && 0 !== this._fadeOutTime && (d.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity), this._runtime.UpdateRender(), 0 >= d.GetOpacity() && (this._stage = 3, this._stageTime.Reset(), this.Trigger(e.Behaviors.Fade.Cnds.OnFadeOutEnd), this._destroy && this._runtime.DestroyInstance(this._inst)))
        }
        Start() {
            this._stage = 0;
            this._stageTime.Reset();
            0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender())
        }
        GetPropertyValueByIndex(d) {
            switch (d) {
                case 0:
                    return this._fadeInTime;
                case 1:
                    return this._waitTime;
                case 2:
                    return this._fadeOutTime;
                case 3:
                    return this._destroy
            }
        }
        SetPropertyValueByIndex(d, a) {
            switch (d) {
                case 0:
                    this._fadeInTime = a;
                    break;
                case 1:
                    this._waitTime = a;
                    break;
                case 2:
                    this._fadeOutTime = a;
                    break;
                case 3:
                    this._destroy = !!a
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.fade.properties.fade-in-time.name",
                    value: this._fadeInTime,
                    onedit: d => this._fadeInTime = d
                }, {
                    name: "behaviors.fade.properties.wait-time.name",
                    value: this._waitTime,
                    onedit: d => this._waitTime = d
                }, {
                    name: "behaviors.fade.properties.fade-out-time.name",
                    value: this._fadeOutTime,
                    onedit: d => this._fadeOutTime = d
                }, {
                    name: "behaviors.fade.debugger.stage",
                    value: ["behaviors.fade.debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]]
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Fade.Cnds = {
    OnFadeOutEnd() {
        return !0
    },
    OnFadeInEnd() {
        return !0
    },
    OnWaitEnd() {
        return !0
    }
};
"use strict";
self.C3.Behaviors.Fade.Acts = {
    StartFade() {
        this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, this._setMaxOpacity = !0);
        3 === this._stage && this.Start()
    },
    RestartFade() {
        this.Start()
    },
    SetFadeInTime(e) {
        0 > e && (e = 0);
        this._fadeInTime = e
    },
    SetWaitTime(e) {
        0 > e && (e = 0);
        this._waitTime = e
    },
    SetFadeOutTime(e) {
        0 > e && (e = 0);
        this._fadeOutTime = e
    }
};
"use strict";
self.C3.Behaviors.Fade.Exps = {
    FadeInTime() {
        return this._fadeInTime
    },
    WaitTime() {
        return this._waitTime
    },
    FadeOutTime() {
        return this._fadeOutTime
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Sin = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Sin.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = self.IBehaviorInstance,
        b = 2 * Math.PI,
        c = Math.PI / 2,
        f = 3 * Math.PI / 2,
        h = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
    e.Behaviors.Sin.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(r, w) {
            super(r);
            this._mag = this._period = this._wave = this._movement = this._i = 0;
            this._isEnabled = !0;
            this._ratio = this._lastKnownValue2 = this._lastKnownValue = this._initialValue2 = this._initialValue = this._magnitudeRandom = this._periodOffsetRandom = this._periodRandom = this._baseMag = this._basePeriodOffset = this._basePeriod =
                0;
            w && (this._movement = h[w[0]], this._wave = w[1], this._periodRandom = this._runtime.Random() * w[3], this._basePeriod = w[2], this._period = w[2], this._period += this._periodRandom, this._basePeriodOffset = w[4], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * w[5], this._i = w[4] / this._period * b, this._i += this._periodOffsetRandom / this._period * b), this._magnitudeRandom = this._runtime.Random() * w[7], this._baseMag = w[6], this._mag = w[6], this._mag += this._magnitudeRandom, this._isEnabled = !!w[8]);
            5 === this._movement &&
                (this._mag = e.toRadians(this._mag));
            this.Init();
            this._isEnabled && this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                i: this._i,
                e: this._isEnabled,
                mv: this._movement,
                w: this._wave,
                p: this._period,
                mag: this._mag,
                iv: this._initialValue,
                iv2: this._initialValue2,
                r: this._ratio,
                lkv: this._lastKnownValue,
                lkv2: this._lastKnownValue2
            }
        }
        LoadFromJson(r) {
            this._i = r.i;
            this._SetEnabled(r.e);
            this._movement = r.mv;
            this._wave = r.w;
            this._period = r.p;
            this._mag = r.mag;
            this._initialValue = r.iv;
            this._initialValue2 = r.iv2;
            this._ratio =
                r.r;
            this._lastKnownValue = r.lkv;
            this._lastKnownValue2 = r.lkv2
        }
        Init() {
            const r = this._inst.GetWorldInfo();
            switch (this._movement) {
                case 0:
                    this._initialValue = r.GetX();
                    break;
                case 1:
                    this._initialValue = r.GetY();
                    break;
                case 2:
                    this._initialValue = r.GetWidth();
                    this._ratio = r.GetHeight() / r.GetWidth();
                    break;
                case 3:
                    this._initialValue = r.GetWidth();
                    break;
                case 4:
                    this._initialValue = r.GetHeight();
                    break;
                case 5:
                    this._initialValue = r.GetAngle();
                    break;
                case 6:
                    this._initialValue = r.GetOpacity();
                    break;
                case 7:
                    this._initialValue = 0;
                    break;
                case 8:
                    this._initialValue = r.GetX();
                    this._initialValue2 = r.GetY();
                    break;
                case 9:
                    this._initialValue = r.GetZElevation()
            }
            this._lastKnownValue = this._initialValue;
            this._lastKnownValue2 = this._initialValue2
        }
        WaveFunc(r) {
            r %= b;
            switch (this._wave) {
                case 0:
                    return Math.sin(r);
                case 1:
                    return r <= c ? r / c : r <= f ? 1 - 2 * (r - c) / Math.PI : (r - f) / c - 1;
                case 2:
                    return 2 * r / b - 1;
                case 3:
                    return -2 * r / b + 1;
                case 4:
                    return r < Math.PI ? -1 : 1
            }
            return 0
        }
        Tick() {
            const r = this._runtime.GetDt(this._inst);
            this._isEnabled && 0 !== r && (this._i = 0 === this._period ? 0 :
                (this._i + r / this._period * b) % b, this._UpdateFromPhase())
        }
        _UpdateFromPhase() {
            const r = this._inst.GetWorldInfo();
            switch (this._movement) {
                case 0:
                    r.GetX() !== this._lastKnownValue && (this._initialValue += r.GetX() - this._lastKnownValue);
                    r.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    this._lastKnownValue = r.GetX();
                    break;
                case 1:
                    r.GetY() !== this._lastKnownValue && (this._initialValue += r.GetY() - this._lastKnownValue);
                    r.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    this._lastKnownValue = r.GetY();
                    break;
                case 2:
                    r.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    r.SetHeight(r.GetWidth() * this._ratio);
                    break;
                case 3:
                    r.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    break;
                case 4:
                    r.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    break;
                case 5:
                    r.GetAngle() !== this._lastKnownValue && (this._initialValue = e.clampAngle(this._initialValue + (r.GetAngle() - this._lastKnownValue)));
                    r.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag);
                    this._lastKnownValue = r.GetAngle();
                    break;
                case 6:
                    r.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
                    break;
                case 8:
                    r.GetX() !== this._lastKnownValue && (this._initialValue += r.GetX() - this._lastKnownValue);
                    r.GetY() !== this._lastKnownValue2 && (this._initialValue2 += r.GetY() - this._lastKnownValue2);
                    r.SetX(this._initialValue + Math.cos(r.GetAngle()) * this.WaveFunc(this._i) * this._mag);
                    r.SetY(this._initialValue2 + Math.sin(r.GetAngle()) * this.WaveFunc(this._i) * this._mag);
                    this._lastKnownValue = r.GetX();
                    this._lastKnownValue2 = r.GetY();
                    break;
                case 9:
                    r.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag)
            }
            r.SetBboxChanged()
        }
        _OnSpriteFrameChanged(r, w) {}
        _SetPeriod(r) {
            this._period = r
        }
        _GetPeriod() {
            return this._period
        }
        _SetMagnitude(r) {
            this._mag = r
        }
        _SetMagnitude_ConvertAngle(r) {
            5 === this._movement && (r = e.toRadians(r));
            this._SetMagnitude(r)
        }
        _GetMagnitude() {
            return this._mag
        }
        _GetMagnitude_ConvertAngle() {
            let r = this._GetMagnitude();
            5 === this._movement && (r = e.toDegrees(r));
            return r
        }
        _SetMovement(r) {
            5 === this._movement && 5 !== r && (this._mag = e.toDegrees(this._mag));
            this._movement = r;
            this.Init()
        }
        _GetMovement() {
            return this._movement
        }
        _SetWave(r) {
            this._wave = r
        }
        _GetWave() {
            return this._wave
        }
        _SetPhase(r) {
            this._i = e.clamp(r, 0, 2 * Math.PI);
            this._UpdateFromPhase()
        }
        _GetPhase() {
            return this._i
        }
        _SetEnabled(r) {
            (this._isEnabled = !!r) ? this._StartTicking(): this._StopTicking()
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(r) {
            switch (r) {
                case 0:
                    return this._movement;
                case 1:
                    return this._wave;
                case 2:
                    return this._basePeriod;
                case 6:
                    return this._baseMag;
                case 8:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(r,
            w) {
            switch (r) {
                case 0:
                    this._movement = h[w];
                    this.Init();
                    break;
                case 1:
                    this._wave = w;
                    break;
                case 2:
                    this._basePeriod = w;
                    this._period = this._basePeriod + this._periodRandom;
                    this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * b, this._i += this._periodOffsetRandom / this._period * b) : this._i = 0);
                    break;
                case 6:
                    this._baseMag = w;
                    this._mag = this._baseMag + this._magnitudeRandom;
                    5 === this._movement && (this._mag = e.toRadians(this._mag));
                    break;
                case 8:
                    this._isEnabled = !!w
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" +
                    this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.sin.properties.enabled.name",
                    value: this._IsEnabled(),
                    onedit: r => this._SetEnabled(r)
                }, {
                    name: "behaviors.sin.properties.period.name",
                    value: this._GetPeriod(),
                    onedit: r => this._SetPeriod(r)
                }, {
                    name: "behaviors.sin.properties.magnitude.name",
                    value: this._GetMagnitude_ConvertAngle(),
                    onedit: r => this._SetMagnitude_ConvertAngle(r)
                }, {
                    name: "behaviors.sin.debugger.value",
                    value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ISineBehaviorInstance
        }
    };
    const g = new WeakMap,
        k = "horizontal vertical size width height angle opacity value-only forwards-backwards z-elevation".split(" "),
        m = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
    self.ISineBehaviorInstance = class extends a {
        constructor() {
            super();
            g.set(this, a._GetInitInst().GetSdkInstance())
        }
        set period(r) {
            d.RequireFiniteNumber(r);
            g.get(this)._SetPeriod(r)
        }
        get period() {
            return g.get(this)._GetPeriod()
        }
        set magnitude(r) {
            d.RequireFiniteNumber(r);
            g.get(this)._SetMagnitude(r)
        }
        get magnitude() {
            return g.get(this)._GetMagnitude()
        }
        set phase(r) {
            g.get(this)._SetPhase(r)
        }
        get phase() {
            return g.get(this)._GetPhase()
        }
        set movement(r) {
            d.RequireString(r);
            r = k.indexOf(r);
            if (-1 === r) throw Error("invalid movement");
            g.get(this)._SetMovement(r)
        }
        get movement() {
            return k[g.get(this)._GetMovement()]
        }
        set wave(r) {
            d.RequireString(r);
            r = m.indexOf(r);
            if (-1 === r) throw Error("invalid wave");
            g.get(this)._SetWave(r)
        }
        get wave() {
            return m[g.get(this)._GetWave()]
        }
        get value() {
            const r = g.get(this);
            return r.WaveFunc(r._GetPhase()) * r._GetMagnitude()
        }
        updateInitialState() {
            g.get(this).Init()
        }
        set isEnabled(r) {
            g.get(this)._SetEnabled(!!r)
        }
        get isEnabled() {
            return g.get(this)._IsEnabled()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Sin.Cnds = {
        IsEnabled() {
            return this._IsEnabled()
        },
        CompareMovement(d) {
            return this._GetMovement() === d
        },
        ComparePeriod(d, a) {
            return e.compare(this._GetPeriod(), d, a)
        },
        CompareMagnitude(d, a) {
            return e.compare(this._GetMagnitude_ConvertAngle(), d, a)
        },
        CompareWave(d) {
            return this._GetWave() === d
        }
    }
}
"use strict";
self.C3.Behaviors.Sin.Acts = {
    SetEnabled(e) {
        this._SetEnabled(0 !== e)
    },
    SetPeriod(e) {
        this._SetPeriod(e)
    },
    SetMagnitude(e) {
        this._SetMagnitude_ConvertAngle(e)
    },
    SetMovement(e) {
        this._SetMovement(e)
    },
    SetWave(e) {
        this._wave = e
    },
    SetPhase(e) {
        const d = 2 * Math.PI;
        this._SetPhase(e * d % d)
    },
    UpdateInitialState() {
        this.Init()
    }
};
"use strict";
self.C3.Behaviors.Sin.Exps = {
    CyclePosition() {
        return this._GetPhase() / (2 * Math.PI)
    },
    Period() {
        return this._GetPeriod()
    },
    Magnitude() {
        return this._GetMagnitude_ConvertAngle()
    },
    Value() {
        return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.DragnDrop = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d);
            d = this._runtime.Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(d, "pointerdown", a => this._OnPointerDown(a.data)), e.Disposable.From(d, "pointermove", a => this._OnPointerMove(a.data)), e.Disposable.From(d, "pointerup", a => this._OnPointerUp(a.data, !1)), e.Disposable.From(d, "pointercancel", a => this._OnPointerUp(a.data, !0)))
        }
        Release() {
            this._disposables.Release();
            this._disposables =
                null;
            super.Release()
        }
        _OnPointerDown(d) {
            "mouse" === d.pointerType && 0 !== d.button || this._OnInputDown(d.pointerId.toString(), d.pageX - this._runtime.GetCanvasClientX(), d.pageY - this._runtime.GetCanvasClientY())
        }
        _OnPointerMove(d) {
            0 !== (d.lastButtons & 1) && 0 === (d.buttons & 1) ? this._OnInputUp(d.pointerId.toString()) : this._OnInputMove(d.pointerId.toString(), d.pageX - this._runtime.GetCanvasClientX(), d.pageY - this._runtime.GetCanvasClientY())
        }
        _OnPointerUp(d, a) {
            "mouse" === d.pointerType && 0 !== d.button || this._OnInputUp(d.pointerId.toString())
        }
        async _OnInputDown(d,
            a, b) {
            var c = this.GetInstances();
            let f = null,
                h = null,
                g = 0,
                k = 0;
            for (const m of c) {
                c = m.GetBehaviorSdkInstanceFromCtor(e.Behaviors.DragnDrop);
                if (!c.IsEnabled() || c.IsDragging()) continue;
                const r = m.GetWorldInfo(),
                    w = r.GetLayer(),
                    [p, t] = w.CanvasCssToLayer(a, b, r.GetTotalZElevation());
                if (!r.ContainsPoint(p, t)) continue;
                if (!f) {
                    f = m;
                    h = c;
                    g = p;
                    k = t;
                    continue
                }
                const u = f.GetWorldInfo();
                if (w.GetIndex() > u.GetLayer().GetIndex() || w.GetIndex() === u.GetLayer().GetIndex() && r.GetZIndex() > u.GetZIndex()) f = m, h = c, g = p, k = t
            }
            f && await h._OnDown(d,
                g, k)
        }
        _OnInputMove(d, a, b) {
            var c = this.GetInstances();
            for (const f of c) {
                c = f.GetBehaviorSdkInstanceFromCtor(e.Behaviors.DragnDrop);
                if (!c.IsEnabled() || !c.IsDragging() || c.IsDragging() && c.GetDragSource() !== d) continue;
                const h = f.GetWorldInfo(),
                    g = h.GetLayer(),
                    [k, m] = g.CanvasCssToLayer(a, b, h.GetTotalZElevation());
                c._OnMove(k, m)
            }
        }
        async _OnInputUp(d) {
            var a = this.GetInstances();
            for (const b of a) a = b.GetBehaviorSdkInstanceFromCtor(e.Behaviors.DragnDrop), a.IsDragging() && a.GetDragSource() === d && await a._OnUp()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.DragnDrop.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.DragnDrop.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._isDragging = !1;
            this._dy = this._dx = 0;
            this._dragSource = "<none>";
            this._axes = 0;
            this._isEnabled = !0;
            a && (this._axes = a[0], this._isEnabled = a[1])
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                a: this._axes,
                e: this._isEnabled
            }
        }
        LoadFromJson(d) {
            this._axes = d.a;
            this._isEnabled = d.e;
            this._isDragging = !1
        }
        IsEnabled() {
            return this._isEnabled
        }
        IsDragging() {
            return this._isDragging
        }
        GetDragSource() {
            return this._dragSource
        }
        async _OnDown(d,
            a, b) {
            const c = this.GetWorldInfo();
            this._dx = a - c.GetX();
            this._dy = b - c.GetY();
            this._isDragging = !0;
            this._dragSource = d;
            await this.TriggerAsync(e.Behaviors.DragnDrop.Cnds.OnDragStart)
        }
        _OnMove(d, a) {
            const b = this.GetWorldInfo();
            d -= this._dx;
            a -= this._dy;
            if (0 === this._axes) {
                if (b.GetX() !== d || b.GetY() !== a) b.SetXY(d, a), b.SetBboxChanged()
            } else 1 === this._axes ? b.GetX() !== d && (b.SetX(d), b.SetBboxChanged()) : 2 === this._axes && b.GetY() !== a && (b.SetY(a), b.SetBboxChanged())
        }
        async _OnUp() {
            this._isDragging = !1;
            await this.TriggerAsync(e.Behaviors.DragnDrop.Cnds.OnDrop)
        }
        GetPropertyValueByIndex(d) {
            switch (d) {
                case 0:
                    return this._axes;
                case 1:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(d, a) {
            switch (d) {
                case 0:
                    this._axes = a;
                    break;
                case 1:
                    this._isEnabled = !!a
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.dragndrop.debugger.is-dragging",
                    value: this._isDragging
                }, {
                    name: "behaviors.dragndrop.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: d => this._isEnabled = d
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.DragnDrop.Cnds = {
    IsDragging() {
        return this._isDragging
    },
    OnDragStart() {
        return !0
    },
    OnDrop() {
        return !0
    },
    IsEnabled() {
        return this._isEnabled
    }
};
"use strict";
self.C3.Behaviors.DragnDrop.Acts = {
    SetEnabled(e) {
        this._isEnabled = !!e;
        this._isEnabled || (this._isDragging = !1)
    },
    SetAxes(e) {
        this._axes = e
    },
    Drop() {
        this._isDragging && this._OnUp()
    }
};
"use strict";
self.C3.Behaviors.DragnDrop.Exps = {}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Tween = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Tween.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = e.Behaviors.Tween;
    d.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(a, b) {
            super(a);
            this._allowMultiple = !1;
            this._enabled = !0;
            b && (this._allowMultiple = !1, this._enabled = !!b[0]);
            this._activeTweens = new Map;
            this._disabledTweens = [];
            this._waitingForReleaseTweens = new Map;
            this._waitingForReleaseTweensJson = this._disabledTweensJson = this._activeTweensJson = this._finishingTween = null;
            this._finishingTweenName = "";
            this._enabled && this._StartTicking2();
            this._afterLoad = c => this._OnAfterLoad(c);
            this.GetRuntime().Dispatcher().addEventListener("afterload", this._afterLoad)
        }
        Release() {
            this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);
            this._afterLoad = null;
            this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null);
            this.ReleaseAndCompleteTweens();
            this._tweens = null;
            this.ClearDisabledList();
            this._disabledTweens = null;
            this._ReleaseWaitingTweens();
            this._waitingForReleaseTweens = null;
            super.Release()
        }
        SetEnabled(a) {
            (this._enabled = a) ?
            this._StartTicking2(): this._StopTicking2()
        }
        GetEnabled() {
            return this._enabled
        }
        AddToDisabledList(a) {
            this._disabledTweens.push(a)
        }
        IsInDisabledList(a) {
            return this._disabledTweens.includes(a)
        }
        ClearDisabledList() {
            e.clearArray(this._disabledTweens)
        }
        GetFinishingTween() {
            return this._finishingTween
        }
        IsInstanceValid() {
            const a = this.GetObjectInstance();
            return a ? !a.IsDestroyed() : !1
        }
        GetTween(a, b, c = !1) {
            if ((b = b ? this.PropertyTweens(b, c) : this.AllTweens(c)) && b.length)
                for (const f of b)
                    if (f.HasTags(a)) return f
        }
        GetTweenIncludingWaitingForRelease(a,
            b) {
            return this.GetTween(a, b, !0)
        }* GetTweens(a, b, c = !1) {
            if ((b = b ? this.PropertyTweens(b, c) : this.AllTweens(c)) && b.length)
                for (const f of b) f.HasTags(a) && (yield f)
        }* GetTweensIncludingWaitingForRelease(a, b) {
            yield* this.GetTweens(a, b, !0)
        }
        PropertyTweens(a, b) {
            if (b) return b = this._activeTweens.get(a), a = this._waitingForReleaseTweens.get(a), b || (b = []), a || (a = []), b.concat(a).filter(c => c);
            (a = this._activeTweens.get(a)) || (a = []);
            return a.filter(c => c)
        }
        AllTweens(a) {
            if (a) {
                a = [...this._activeTweens.values()].flat();
                const b = [...this._waitingForReleaseTweens.values()].flat();
                return a.concat(b).filter(c => c)
            }
            return [...this._activeTweens.values()].flat().filter(b => b)
        }
        AllTweensIncludingWaitingForRelease() {
            return this.AllTweens(!0)
        }
        SaveToJson() {
            return {
                s: !1,
                e: !!this._enabled,
                at: this._SaveActiveTweensToJson(),
                dt: this._SaveDisabledTweensToJson(),
                wt: this._SaveWaitingForReleaseTweensToJson(),
                ft: this._SaveFinishingTweenToJson()
            }
        }
        LoadFromJson(a) {
            a && (this._activeTweensJson = a.at, this._disabledTweensJson = a.dt, this._waitingForReleaseTweensJson = a.wt, this._finishingTweenName = a.ft, this._allowMultiple = !1, this._enabled = !!a.e)
        }
        _OnAfterLoad(a) {
            a = this.GetRuntime().GetTimelineManager();
            this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, a);
            if (this._disabledTweensJson) {
                e.clearArray(this._disabledTweens);
                for (const b of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, b, a)
            }
            this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, a);
            this._finishingTween = this._GetTween(this._finishingTweenName, a);
            this._enabled ? this._StartTicking2() : this._StopTicking2()
        }
        _PopulateTweenMap(a,
            b, c) {
            if (a)
                for (const h in a) {
                    let g = b.get(h);
                    g ? e.clearArray(g) : g = [];
                    var f = a[h];
                    for (const k of f) this._PopulateTweenArray(g, k.name, c) ? this._LoadTweenFromJson(k.name, k, c) : (f = e.Tween.Build({
                        runtime: this.GetRuntime(),
                        json: k
                    }), f.AddCompletedCallback(m => this._FinishTriggers(m)), c.AddScheduledTimeline(f), this._PopulateTweenArray(g, f, c));
                    b.set(h, g)
                }
        }
        _GetTween(a, b) {
            return b.GetScheduledOrPlayingTimelineByName(a)
        }
        _PopulateTweenArray(a, b, c) {
            if ("string" === typeof b) {
                if (b = this._GetTween(b, c)) return !!a.push(b)
            } else return !!a.push(b);
            return !1
        }
        _LoadTweenFromJson(a, b, c) {
            "string" === typeof a ? (a = this._GetTween(a, c)) && a._LoadFromJson(b) : a._LoadFromJson(b)
        }
        _SaveActiveTweensToJson() {
            const a = {};
            for (const [b, c] of this._activeTweens) a[b] = c.map(f => f._SaveToJson());
            return a
        }
        _SaveDisabledTweensToJson() {
            return this._disabledTweens.map(a => a.GetName())
        }
        _SaveWaitingForReleaseTweensToJson() {
            const a = {};
            for (const [b, c] of this._waitingForReleaseTweens) a[b] = c.map(f => f._SaveToJson());
            return a
        }
        _SaveFinishingTweenToJson() {
            return this._finishingTween ? this._finishingTween.GetName() :
                ""
        }
        Tick2() {
            this._ReleaseWaitingTweens()
        }
        CreateTween(a) {
            var b = d.Config.GetPropertyTracksConfig(a.property, a.startValue, a.endValue, a.ease, a.resultMode, this.GetObjectInstance());
            const c = d.Maps.GetPropertyFromIndex(a.property);
            d.Maps.IsValueId(c) || this.ReleaseTweens(a.property);
            b = e.Tween.Build({
                runtime: this.GetRuntime(),
                id: c,
                tags: a.tags,
                time: a.time,
                instance: this.GetObjectInstance(),
                releaseOnComplete: !!a.releaseOnComplete,
                loop: !!a.loop,
                pingPong: !!a.pingPong,
                initialValueMode: a.initialValueMode,
                propertyTracksConfig: b
            });
            b.AddCompletedCallback(f => this._FinishTriggers(f));
            this._AddTween(b, a.property);
            return b
        }
        ReleaseTween(a, b = !1) {
            var c = a.GetId();
            if (this._activeTweens.has(c) && (c = this._activeTweens.get(c))) {
                const f = c.indexOf(a); - 1 !== f && c.splice(f, 1)
            }
            a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(b), this._AddToWaitingList(a))
        }
        ReleaseTweens(a, b = !1) {
            if (e.IsFiniteNumber(a)) {
                var c = d.Maps.GetPropertyFromIndex(a);
                if (this._activeTweens.has(c)) {
                    c = this._activeTweens.get(c);
                    var f = this.GetFinishingTween();
                    for (var h of c) h ===
                        f || h.IsReleased() || this._IsInWaitingList(h) || (h.Stop(b), h.Release());
                    e.clearArray(c)
                }
            } else {
                h = this.GetFinishingTween();
                for (c of this.AllTweens()) c === h || c.IsReleased() || this._IsInWaitingList(c) || (c.Stop(b), c.Release());
                for (f of this._activeTweens.keys()) e.clearArray(this._activeTweens.get(f)), this._activeTweens.delete(f);
                this._activeTweens.clear()
            }
        }
        ReleaseAndCompleteTween(a) {
            this.ReleaseTween(a, !0)
        }
        ReleaseAndCompleteTweens() {
            this.ReleaseTweens(NaN, !0)
        }
        GetPropertyValueByIndex(a) {
            switch (a) {
                case 0:
                    return this._enabled
            }
        }
        SetPropertyValueByIndex(a,
            b) {
            switch (a) {
                case 0:
                    this._enabled = !!b
            }
        }
        _GetBehaviorType(a) {
            a = a.GetInstance().GetBehaviorInstances();
            for (const b of a)
                if (a = b.GetBehaviorType(), a.GetInstanceSdkCtor() === this.constructor) return a
        }
        Trigger(a, b, c, f) {
            return this._runtime ? super.Trigger(a) : b.Trigger(a, c, f)
        }
        _FinishTriggers(a) {
            this._finishingTween = a;
            d.Cnds.SetFinishingTween(a);
            let b, c;
            if (this.GetRuntime()) b = this._inst, c = this._runtime, this.Trigger(d.Cnds.OnTweensFinished), this.Trigger(d.Cnds.OnAnyTweensFinished), this.ReleaseTween(a);
            else {
                b = a.GetInstance();
                if (!b || b && b.IsDestroyed()) return;
                c = b.GetRuntime();
                const f = this._GetBehaviorType(a);
                this.Trigger(d.Cnds.OnTweensFinished, c, b, f);
                this.Trigger(d.Cnds.OnAnyTweensFinished, c, b, f);
                a.Stop()
            }
            this._finishingTween = null;
            d.Cnds.SetFinishingTween(null);
            a.GetDestroyInstanceOnComplete() && c.DestroyInstance(b)
        }
        _AddTween(a, b) {
            b = d.Maps.GetPropertyFromIndex(b);
            this._activeTweens.has(b) || this._activeTweens.set(b, []);
            this._activeTweens.get(b).push(a)
        }
        _AddToWaitingList(a) {
            const b = a.GetId();
            this._waitingForReleaseTweens.has(b) ||
                this._waitingForReleaseTweens.set(b, []);
            this._waitingForReleaseTweens.get(b).push(a)
        }
        _IsInWaitingList(a) {
            const b = a.GetId();
            return this._waitingForReleaseTweens.has(b) ? this._waitingForReleaseTweens.get(b).includes(a) : !1
        }
        _ReleaseWaitingTweens() {
            if (this._waitingForReleaseTweens.size) {
                for (const a of this._waitingForReleaseTweens.values()) {
                    for (const b of a) b.IsReleased() || b.Release();
                    e.clearArray(a)
                }
                this._waitingForReleaseTweens.clear()
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    let d = null;
    e.Behaviors.Tween.Cnds = {
        SetFinishingTween(a) {
            d = a
        },
        OnTweensFinished(a) {
            return d.HasTags(a)
        },
        OnAnyTweensFinished() {
            return !0
        },
        IsPlaying(a) {
            return (a = [...this.GetTweensIncludingWaitingForRelease(a)], a.length) ? a.some(e.Tween.IsPlaying) : !1
        },
        IsAnyPlaying() {
            const a = [...this.AllTweensIncludingWaitingForRelease()];
            return a && a.length ? a.some(e.Tween.IsPlaying) : !1
        },
        IsPaused(a) {
            return (a = [...this.GetTweensIncludingWaitingForRelease(a)], a.length) ? a.some(e.Tween.IsPaused) : !1
        },
        IsAnyPaused() {
            const a = [...this.AllTweensIncludingWaitingForRelease()];
            return a && a.length ? a.some(e.Tween.IsPaused) : !1
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = self.Ease,
        a = e.Behaviors.Tween;
    a.Acts = {
        SetEnabled(b) {
            this.SetEnabled(!!b);
            for (const c of this.AllTweens()) b ? this.IsInDisabledList(c) && c.Resume() : ((c.IsPlaying() || c.IsScheduled()) && this.AddToDisabledList(c), c.Stop());
            b && this.ClearDisabledList()
        },
        async TweenOneProperty(...b) {
            this.GetEnabled() && this.IsInstanceValid() && (b = this.CreateTween(a.TweenArguments.OneProperty(this, ...b)), b.Play() && await b.GetPlayPromise())
        },
        async TweenTwoProperties(...b) {
            this.GetEnabled() && this.IsInstanceValid() &&
                (b = this.CreateTween(a.TweenArguments.TwoProperties(this, ...b)), b.Play() && await b.GetPlayPromise())
        },
        async TweenValue(...b) {
            this.GetEnabled() && this.IsInstanceValid() && (b = this.CreateTween(a.TweenArguments.ValueProperty(this, ...b)), b.Play() && await b.GetPlayPromise())
        },
        PauseTweens(b) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const c of this.GetTweens(b)) c.Stop()
        },
        PauseAllTweens() {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const b of this.AllTweens()) b.Stop()
        },
        ResumeTweens(b) {
            if (this.GetEnabled() &&
                this.IsInstanceValid())
                for (const c of this.GetTweens(b)) c.Resume()
        },
        ResumeAllTweens() {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const b of this.AllTweens()) b.Resume()
        },
        StopTweens(b) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const c of this.GetTweens(b)) this.ReleaseTween(c)
        },
        StopAllTweens() {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const b of this.AllTweens()) this.ReleaseTween(b)
        },
        SetOnePropertyTweensEndValue(b, c, f) {
            if (this.GetEnabled() && this.IsInstanceValid()) {
                c = e.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(c);
                for (const h of this.GetTweens(b)) h.BeforeSetEndValues([c]), h.SetEndValue(f, c)
            }
        },
        SetTwoPropertiesTweensEndValue(b, c, f, h) {
            if (this.GetEnabled() && this.IsInstanceValid()) {
                c = e.Behaviors.Tween.Maps.GetRealProperties(c);
                for (const g of this.GetTweens(b)) g.BeforeSetEndValues(c), g.SetEndValue(f, c[0]), g.SetEndValue(h, c[1])
            }
        },
        SetValuePropertyTweensStartValue(b, c) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const f of this.GetTweens(b, "value")) f.SetStartValue(c, "value")
        },
        SetValuePropertyTweensEndValue(b, c) {
            if (this.GetEnabled() &&
                this.IsInstanceValid())
                for (const f of this.GetTweens(b, "value")) f.BeforeSetEndValues(["value"]), f.SetEndValue(c, "value")
        },
        SetTweensEase(b, c) {
            if (this.GetEnabled() && this.IsInstanceValid()) {
                c = d.GetEaseFromIndex(c);
                for (const f of this.GetTweens(b)) f.SetEase(c)
            }
        },
        SetAllTweensEase(b) {
            if (this.GetEnabled() && this.IsInstanceValid()) {
                b = d.GetEaseFromIndex(b);
                for (const c of this.AllTweens()) c.SetEase(b)
            }
        },
        SetTweensTime(b, c) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const f of this.GetTweens(b)) f.SetTime(c)
        },
        SetAllTweensTime(b) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const c of this.AllTweens()) c.SetTime(b)
        },
        SetTweensPlaybackRate(b, c) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const f of this.GetTweens(b)) f.SetPlaybackRate(c)
        },
        SetAllTweensPlaybackRate(b) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const c of this.AllTweens()) c.SetPlaybackRate(b)
        },
        SetTweensDestroyOnComplete(b, c) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const f of this.GetTweens(b)) f.SetDestroyInstanceOnComplete(!!c)
        },
        SetAllTweensDestroyOnComplete(b) {
            if (this.GetEnabled() && this.IsInstanceValid())
                for (const c of this.AllTweens()) c.SetDestroyInstanceOnComplete(!!b)
        }
    }
}
"use strict";
self.C3.Behaviors.Tween.Exps = {
    Time(e) {
        return (e = this.GetTweenIncludingWaitingForRelease(e)) ? e.GetTime() : 0
    },
    Progress(e) {
        return (e = this.GetTweenIncludingWaitingForRelease(e)) ? e.GetTime() / e.GetTotalTime() : 0
    },
    Value(e) {
        return (e = this.GetTweenIncludingWaitingForRelease(e, "value")) ? e.GetPropertyTrack("value").GetSourceAdapterValue() : 0
    },
    Tags() {
        return this.GetFinishingTween() ? this.GetFinishingTween().GetStringTags() : ""
    }
}; {
    "use strict";
    const e = self.C3,
        d = self.Ease,
        a = ["position", "size", "scale"],
        b = "offsetX offsetY offsetWidth offsetHeight offsetAngle offsetOpacity offsetColor offsetZElevation offsetScaleX offsetScaleY".split(" "),
        c = ["value"],
        f = [].concat(a).concat(b).concat(c),
        h = {
            position: ["offsetX", "offsetY"],
            size: ["offsetWidth", "offsetHeight"],
            scale: ["offsetScaleX", "offsetScaleY"]
        },
        g = Object.assign({}, f.reduce((k, m) => Object.assign({}, k, {
            [m]: [m]
        }), {}), h);
    e.Behaviors.Tween.Maps = class {
        constructor() {}
        static GetEases() {
            return [...d.GetRuntimeEaseNames()]
        }
        static GetEaseFromIndex(k) {
            return [...d.GetRuntimeEaseNames()][k]
        }
        static GetPropertyFromIndex(k) {
            return f[k]
        }
        static GetPropertyIndexFromName(k) {
            return f.indexOf(k)
        }
        static GetPairPropertyFromIndex(k) {
            return a[k]
        }
        static GetSinglePropertyFromIndex(k) {
            return b[k]
        }
        static GetValuePropertyFromIndex(k) {
            return c[k]
        }
        static GetPairProperties(k) {
            return h[k]
        }
        static GetRealProperties(k) {
            return e.IsString(k) ?
                g[k] : g[f[k]]
        }
        static IsPairId(k) {
            return !!h[k]
        }
        static IsColorId(k) {
            return "offsetColor" === k
        }
        static IsAngleId(k) {
            return "offsetAngle" === k
        }
        static IsOpacityId(k) {
            return "offsetOpacity" === k
        }
        static IsValueId(k) {
            return "value" === k
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.Behaviors.Tween,
        a = new Map;
    d.Config = class {
        constructor() {}
        static GetPropertyTracksConfig(b, c, f, h, g, k) {
            0 === a.size && this._CreateConfigObjects();
            var m = d.PropertyTypes.Pick(b);
            m = a.get(m);
            e.IsFiniteNumber(b) && (b = d.Maps.GetPropertyFromIndex(b));
            return this._GetConfig(m, b, c, f, h, g, k)
        }
        static TransformValue(b, c) {
            return e.Behaviors.Tween.GetPropertyTracksConfig(b).valueGetter(c)
        }
        static _CreateConfigObjects() {
            const b = d.PropertyTypes,
                c = d.ValueGetters;
            this._AddConfigObject(b.PAIR,
                this._GetPairConfig, c._GetPropertyValue);
            this._AddConfigObject(b.COLOR, this._GetColorConfig, c._GetColorPropertyValue);
            this._AddConfigObject(b.ANGLE, this._GetAngleConfig, c._GetPropertyAngleValue);
            this._AddConfigObject(b.VALUE, this._GetValueConfig, c._GetPropertyValue);
            this._AddConfigObject(b.OTHER, this._GetCommonConfig, c._GetPropertyValue)
        }
        static _AddConfigObject(b, c, f) {
            a.set(b, this._CreateConfigObject(b, c, f))
        }
        static _CreateConfigObject(b, c, f) {
            return {
                name: b,
                configFunc: c,
                valueGetter: f
            }
        }
        static _GetConfig(b,
            c, f, h, g, k, m) {
            return b.configFunc(c, b.valueGetter(f), b.valueGetter(h), g, k, m)
        }
        static _GetPairConfig(b, c, f, h, g, k) {
            return d.Maps.GetPairProperties(b).map((m, r) => ({
                sourceId: "world-instance",
                property: m,
                type: "float",
                valueType: "numeric",
                startValue: c[r],
                endValue: f[r],
                ease: d.Maps.GetEaseFromIndex(h),
                resultMode: g
            }))
        }
        static _GetColorConfig(b, c, f, h, g, k) {
            return e.Plugins.Text && k.GetPlugin() instanceof e.Plugins.Text ? {
                sourceId: "plugin",
                sourceArgs: [7],
                property: "color",
                type: "color",
                valueType: "color",
                startValue: c,
                endValue: f,
                ease: d.Maps.GetEaseFromIndex(h),
                resultMode: g
            } : {
                sourceId: "world-instance",
                property: b,
                type: "color",
                valueType: "color",
                startValue: c,
                endValue: f,
                ease: d.Maps.GetEaseFromIndex(h),
                resultMode: g
            }
        }
        static _GetAngleConfig(b, c, f, h, g, k) {
            return {
                sourceId: "world-instance",
                property: b,
                type: "angle",
                valueType: "angle",
                startValue: c,
                endValue: f,
                ease: d.Maps.GetEaseFromIndex(h),
                resultMode: g
            }
        }
        static _GetCommonConfig(b, c, f, h, g, k) {
            return {
                sourceId: "world-instance",
                property: b,
                type: "float",
                valueType: "numeric",
                startValue: c,
                endValue: f,
                ease: d.Maps.GetEaseFromIndex(h),
                resultMode: g
            }
        }
        static _GetValueConfig(b, c, f, h, g, k) {
            return {
                sourceId: "value",
                property: b,
                type: "float",
                valueType: "numeric",
                startValue: c,
                endValue: f,
                ease: d.Maps.GetEaseFromIndex(h),
                resultMode: g
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        d = e.Behaviors.Tween,
        a = Object.assign({}, {
            resultMode: "absolute"
        }, {
            tags: "",
            property: "",
            time: 0,
            ease: 0,
            releaseOnComplete: 0,
            loop: !1,
            pingPong: !1
        }),
        b = Object.assign({}, a, {
            initialValueMode: "current-state",
            startValue: 0,
            endValue: 0
        }),
        c = Object.assign({}, a, {
            initialValueMode: "current-state",
            startValue: [0, 0],
            endValue: [0, 0]
        }),
        f = Object.assign({}, a, {
            initialValueMode: "current-state",
            startValue: [0, 0, 0],
            endValue: [0, 0, 0]
        }),
        h = Object.assign({}, b, {
            initialValueMode: "start-value"
        });
    d.TweenArguments =
        class {
            constructor() {}
            static _SetCommonProperties(g, k, m, r, w, p, t) {
                g.tags = k;
                g.time = m;
                g.ease = r;
                g.releaseOnComplete = w;
                g.loop = p;
                g.pingPong = t
            }
            static OneProperty(g, k, m, r, w, p, t, u, q) {
                g = d.Maps.GetSinglePropertyFromIndex(m);
                m = d.Maps.IsColorId(g) ? f : b;
                this._SetCommonProperties(m, k, w, p, t, u, q);
                d.Maps.IsColorId(g) ? (f.endValue[0] = e.GetRValue(r), f.endValue[1] = e.GetGValue(r), f.endValue[2] = e.GetBValue(r), f.property = d.Maps.GetPropertyIndexFromName(g)) : d.Maps.IsOpacityId(g) ? b.endValue = r / 100 : b.endValue = r;
                m.property = d.Maps.GetPropertyIndexFromName(g);
                return m
            }
            static TwoProperties(g, k, m, r, w, p, t, u, q, x) {
                this._SetCommonProperties(c, k, p, t, u, q, x);
                g = d.Maps.GetPairPropertyFromIndex(m);
                c.endValue[0] = r;
                c.endValue[1] = w;
                c.property = d.Maps.GetPropertyIndexFromName(g);
                return c
            }
            static ValueProperty(g, k, m, r, w, p, t, u, q) {
                this._SetCommonProperties(h, k, w, p, t, u, q);
                h.startValue = m;
                h.endValue = r;
                h.property = d.Maps.GetPropertyIndexFromName("value");
                return h
            }
        }
} {
    "use strict";
    const e = self.C3,
        d = e.Behaviors.Tween,
        a = [];
    d.PropertyTypes = class {
        constructor() {}
        static Pick(b) {
            0 === a.length && (a.push({
                checkFunc: d.Maps.IsPairId,
                result: this.PAIR
            }), a.push({
                checkFunc: d.Maps.IsColorId,
                result: this.COLOR
            }), a.push({
                checkFunc: d.Maps.IsAngleId,
                result: this.ANGLE
            }), a.push({
                checkFunc: d.Maps.IsValueId,
                result: this.VALUE
            }), a.push({
                checkFunc: () => !0,
                result: this.OTHER
            }));
            e.IsFiniteNumber(b) && (b = e.Behaviors.Tween.Maps.GetPropertyFromIndex(b));
            for (const c of a)
                if (c.checkFunc(b)) return c.result
        }
        static get PAIR() {
            return "pair"
        }
        static get COLOR() {
            return "color"
        }
        static get ANGLE() {
            return "angle"
        }
        static get VALUE() {
            return "value"
        }
        static get OTHER() {
            return "other"
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Tween.ValueGetters = class {
        constructor() {}
        static _GetPropertyAngleValue(d) {
            d = e.toRadians(parseFloat(d));
            return e.clampAngle(d)
        }
        static _GetColorPropertyValue(d) {
            return d.slice(0)
        }
        static _GetPropertyValue(d) {
            return d
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Persist = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Persist.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Persist.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
}
"use strict";
self.C3.Behaviors.Persist.Cnds = {};
"use strict";
self.C3.Behaviors.Persist.Acts = {};
"use strict";
self.C3.Behaviors.Persist.Exps = {}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.scrollto = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d);
            this._shakeMode = this._shakeEnd = this._shakeStart = this._shakeMag = 0
        }
        Release() {
            super.Release()
        }
        SetShakeMagnitude(d) {
            this._shakeMag = d
        }
        GetShakeMagnitude() {
            return this._shakeMag
        }
        SetShakeStart(d) {
            this._shakeStart = d
        }
        GetShakeStart() {
            return this._shakeStart
        }
        SetShakeEnd(d) {
            this._shakeEnd = d
        }
        GetShakeEnd() {
            return this._shakeEnd
        }
        SetShakeMode(d) {
            this._shakeMode = d
        }
        GetShakeMode() {
            return this._shakeMode
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.scrollto.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.scrollto.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._isEnabled = !0;
            a && (this._isEnabled = a[0]);
            this._isEnabled && this._StartTicking2()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            const d = this.GetBehavior();
            return {
                e: this._isEnabled,
                smg: d.GetShakeMagnitude(),
                ss: d.GetShakeStart(),
                se: d.GetShakeEnd(),
                smd: d.GetShakeMode()
            }
        }
        LoadFromJson(d) {
            const a = this.GetBehavior();
            a.SetShakeMagnitude(d.smg);
            a.SetShakeStart(d.ss);
            a.SetShakeEnd(d.se);
            a.SetShakeMode(d.smd);
            (this._isEnabled = d.e) ? this._StartTicking2(): this._StopTicking2()
        }
        IsEnabled() {
            return this._isEnabled
        }
        Tick2() {
            if (this.IsEnabled()) {
                this._runtime.GetDt(this._inst);
                var d = this.GetBehavior(),
                    a = d.GetInstances(),
                    b = 0,
                    c = 0,
                    f = 0;
                for (var h of a)(a = h.GetBehaviorInstanceFromCtor(e.Behaviors.scrollto)) && a.GetSdkInstance().IsEnabled() && (a = h.GetWorldInfo(), b += a.GetX(), c += a.GetY(), ++f);
                h = this._inst.GetWorldInfo().GetLayout();
                var g = this._runtime.GetGameTime(),
                    k = a = 0;
                g >= d.GetShakeStart() && g < d.GetShakeEnd() &&
                    (a = d.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1), 0 === d.GetShakeMode() && (a *= 1 - (g - d.GetShakeStart()) / (d.GetShakeEnd() - d.GetShakeStart())), d = this._runtime.Random() * Math.PI * 2, g = this._runtime.Random() * a, a = Math.cos(d) * g, k = Math.sin(d) * g);
                h.SetScrollX(b / f + a);
                h.SetScrollY(c / f + k)
            }
        }
        GetPropertyValueByIndex(d) {
            switch (d) {
                case 0:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(d, a) {
            switch (d) {
                case 0:
                    (this._isEnabled = !!a) ? this._StartTicking2(): this._StopTicking2()
            }
        }
    }
}
"use strict";
self.C3.Behaviors.scrollto.Cnds = {
    IsEnabled() {
        return this._isEnabled
    }
};
"use strict";
self.C3.Behaviors.scrollto.Acts = {
    Shake(e, d, a) {
        const b = this.GetBehavior();
        b.SetShakeMagnitude(e);
        b.SetShakeStart(this._runtime.GetGameTime());
        b.SetShakeEnd(this._runtime.GetGameTime() + d);
        b.SetShakeMode(a)
    },
    SetEnabled(e) {
        (this._isEnabled = 0 !== e) ? this._StartTicking2(): this._StopTicking2()
    }
};
"use strict";
self.C3.Behaviors.scrollto.Exps = {}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.MoveTo = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.MoveTo.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        d = self.C3X,
        a = self.IBehaviorInstance;
    e.Behaviors.MoveTo.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(c, f) {
            super(c);
            this._maxSpeed = 200;
            this._dec = this._acc = 600;
            this._rotateSpeed = 0;
            this._setAngle = !0;
            this._stopOnSolids = !1;
            this._isEnabled = !0;
            this._speed = 0;
            this._movingAngle = this.GetWorldInfo().GetAngle();
            this._waypoints = [];
            f && (this._maxSpeed = f[0], this._acc = f[1], this._dec = f[2], this._rotateSpeed = e.toRadians(f[3]), this._setAngle = f[4], this._stopOnSolids = f[5], this._isEnabled =
                f[6])
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                rs: this._rotateSpeed,
                sa: this._setAngle,
                sos: this._stopOnSolids,
                s: this._speed,
                ma: this._movingAngle,
                wp: this._waypoints.map(c => ({
                    x: c.x,
                    y: c.y
                })),
                e: this._isEnabled
            }
        }
        LoadFromJson(c) {
            this._maxSpeed = c.ms;
            this._acc = c.acc;
            this._dec = c.dec;
            this._rotateSpeed = c.rs;
            this._setAngle = c.sa;
            this._stopOnSolids = c.sos;
            this._speed = c.s;
            this._movingAngle = c.ma;
            this._waypoints = c.wp.map(f => ({
                x: f.x,
                y: f.y
            }));
            this._SetEnabled(c.e);
            this._isEnabled &&
                0 < this._waypoints.length && this._StartTicking()
        }
        _AddWaypoint(c, f, h) {
            h && e.clearArray(this._waypoints);
            this._waypoints.push({
                x: c,
                y: f
            });
            this._isEnabled && this._StartTicking()
        }
        _GetWaypointCount() {
            return this._waypoints.length
        }
        _GetWaypointXAt(c) {
            c = Math.floor(c);
            return 0 > c || c >= this._waypoints.length ? 0 : this._waypoints[c].x
        }
        _GetWaypointYAt(c) {
            c = Math.floor(c);
            return 0 > c || c >= this._waypoints.length ? 0 : this._waypoints[c].y
        }
        _IsMoving() {
            return 0 < this._waypoints.length
        }
        _Stop() {
            e.clearArray(this._waypoints);
            this._speed =
                0;
            this._StopTicking()
        }
        _GetTargetX() {
            return 0 < this._waypoints.length ? this._waypoints[0].x : 0
        }
        _GetTargetY() {
            return 0 < this._waypoints.length ? this._waypoints[0].y : 0
        }
        _SetSpeed(c) {
            this._IsMoving() && (this._speed = Math.min(c, this._maxSpeed))
        }
        _GetSpeed() {
            return this._speed
        }
        _SetMaxSpeed(c) {
            this._maxSpeed = Math.max(c, 0);
            this._SetSpeed(this._speed)
        }
        _GetMaxSpeed() {
            return this._maxSpeed
        }
        _IsRotationEnabled() {
            return 0 !== this._rotateSpeed
        }
        Tick() {
            if (this._isEnabled && this._IsMoving()) {
                var c = this._runtime.GetDt(this._inst),
                    f = this._inst.GetWorldInfo(),
                    h = f.GetX(),
                    g = f.GetY(),
                    k = f.GetAngle(),
                    m = this._speed,
                    r = this._maxSpeed,
                    w = this._acc,
                    p = this._dec,
                    t = this._GetTargetX(),
                    u = this._GetTargetY(),
                    q = e.angleTo(h, g, t, u),
                    x = !1;
                0 < p && 1 === this._waypoints.length && (x = .5 * m * m / p * 1.0001, x = e.distanceSquared(h, g, t, u) <= x * x) && (r = e.distanceTo(h, g, t, u), this._speed = r = m = Math.sqrt(2 * p * r));
                if (this._IsRotationEnabled()) {
                    var y = e.angleDiff(this._movingAngle, q);
                    if (y > Number.EPSILON) {
                        const B = y / this._rotateSpeed;
                        y *= e.distanceTo(f.GetX(), f.GetY(), t, u) / (2 * Math.sin(y));
                        r = Math.min(r, e.clamp(y / B, 0, this._maxSpeed))
                    }
                }
                m = Math.min(m * c + .5 * (x ? -p : w) * c * c, r * c);
                if (x) {
                    if (0 < p && (this._speed = Math.max(this._speed - p * c, 0), 0 === this._speed)) {
                        this._OnArrived(f, t, u);
                        return
                    }
                } else this._speed = 0 === w ? r : Math.min(this._speed + w * c, r);
                e.distanceSquared(f.GetX(), f.GetY(), t, u) <= m * m ? this._OnArrived(f, t, u) : (this._IsRotationEnabled() ? this._movingAngle = e.angleRotate(this._movingAngle, q, this._rotateSpeed * c) : this._movingAngle = q, f.OffsetXY(Math.cos(this._movingAngle) * m, Math.sin(this._movingAngle) * m), this._setAngle &&
                    f.SetAngle(this._movingAngle), f.SetBboxChanged(), this._CheckSolidCollision(h, g, k))
            }
        }
        _OnArrived(c, f, h) {
            c.SetXY(f, h);
            c.SetBboxChanged();
            this._waypoints.shift();
            0 === this._waypoints.length && (this._speed = 0, this._StopTicking());
            this.GetScriptInterface().dispatchEvent(e.New(e.Event, "arrived"));
            this.Trigger(e.Behaviors.MoveTo.Cnds.OnArrived)
        }
        _CheckSolidCollision(c, f, h) {
            const g = this._runtime.GetCollisionEngine();
            if (this._stopOnSolids && g.TestOverlapSolid(this._inst)) {
                this._Stop();
                const m = this._inst.GetWorldInfo();
                var k = m.GetX();
                const r = m.GetY(),
                    w = e.angleTo(k, r, c, f);
                k = e.distanceTo(k, r, c, f);
                g.PushOutSolid(this._inst, Math.cos(w), Math.sin(w), Math.max(k, 1)) || (m.SetXY(c, f), m.SetAngle(h), m.SetBboxChanged());
                this.GetScriptInterface().dispatchEvent(e.New(e.Event, "hitsolid"));
                this.Trigger(e.Behaviors.MoveTo.Cnds.OnHitSolid)
            }
        }
        _IsSetAngle() {
            return this._setAngle
        }
        _SetSetAngle(c) {
            this._setAngle = !!c
        }
        _SetAngleOfMotion(c) {
            this._movingAngle = c;
            this._isEnabled && this._setAngle && !this._IsMoving() && (c = this.GetWorldInfo(), c.SetAngle(this._movingAngle),
                c.SetBboxChanged())
        }
        _GetAngleOfMotion() {
            return this._movingAngle
        }
        _SetAcceleration(c) {
            this._acc = Math.max(c, 0)
        }
        _GetAcceleration() {
            return this._acc
        }
        _SetDeceleration(c) {
            this._dec = Math.max(c, 0)
        }
        _GetDeceleration() {
            return this._dec
        }
        _SetRotateSpeed(c) {
            this._rotateSpeed = Math.max(c, 0)
        }
        _GetRotateSpeed() {
            return this._rotateSpeed
        }
        _SetStopOnSolids(c) {
            this._stopOnSolids = !!c
        }
        _IsStopOnSolids() {
            return this._stopOnSolids
        }
        _SetEnabled(c) {
            c = !!c;
            this._isEnabled !== c && ((this._isEnabled = c) && this._IsMoving() ? this._StartTicking() :
                this._StopTicking())
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(c) {
            switch (c) {
                case 0:
                    return this._GetMaxSpeed();
                case 1:
                    return this._GetAcceleration();
                case 2:
                    return this._GetDeceleration();
                case 3:
                    return e.toDegrees(this._GetRotateSpeed());
                case 4:
                    return this._IsSetAngle();
                case 5:
                    return this._IsStopOnSolids();
                case 6:
                    return this._IsEnabled()
            }
        }
        SetPropertyValueByIndex(c, f) {
            switch (c) {
                case 0:
                    this._SetMaxSpeed(f);
                    break;
                case 1:
                    this._SetAcceleration(f);
                    break;
                case 2:
                    this._SetDeceleration(f);
                    break;
                case 3:
                    this._SetRotateSpeed(e.toRadians(f));
                    break;
                case 4:
                    this._SetSetAngle(f);
                    break;
                case 5:
                    this._SetStopOnSolids(f);
                    break;
                case 6:
                    this._SetEnabled(f)
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                        name: "behaviors.moveto.debugger.speed",
                        value: this._GetSpeed(),
                        onedit: c => this._SetSpeed(c)
                    }, {
                        name: "behaviors.moveto.debugger.angle-of-motion",
                        value: e.toDegrees(this._GetAngleOfMotion()),
                        onedit: c => this._movingAngle = e.toRadians(c)
                    }, {
                        name: "behaviors.moveto.debugger.target-x",
                        value: this._GetTargetX()
                    }, {
                        name: "behaviors.moveto.debugger.target-y",
                        value: this._GetTargetY()
                    }, {
                        name: "behaviors.moveto.debugger.waypoint-count",
                        value: this._GetWaypointCount()
                    }, {
                        name: "behaviors.moveto.properties.max-speed.name",
                        value: this._GetMaxSpeed(),
                        onedit: c => this._SetMaxSpeed(c)
                    }, {
                        name: "behaviors.moveto.properties.acceleration.name",
                        value: this._GetAcceleration(),
                        onedit: c => this._SetAcceleration(c)
                    }, {
                        name: "behaviors.moveto.properties.deceleration.name",
                        value: this._GetDeceleration(),
                        onedit: c => this._SetDeceleration(c)
                    },
                    {
                        name: "behaviors.moveto.properties.rotate-speed.name",
                        value: e.toDegrees(this._GetRotateSpeed()),
                        onedit: c => this._SetRotateSpeed(e.toRadians(c))
                    }, {
                        name: "behaviors.moveto.properties.enabled.name",
                        value: this._IsEnabled(),
                        onedit: c => this._SetEnabled(c)
                    }
                ]
            }]
        }
        GetScriptInterfaceClass() {
            return self.IMoveToBehaviorInstance
        }
    };
    const b = new WeakMap;
    self.IMoveToBehaviorInstance = class extends a {
        constructor() {
            super();
            b.set(this, a._GetInitInst().GetSdkInstance())
        }
        moveToPosition(c, f, h = !0) {
            d.RequireFiniteNumber(c);
            d.RequireFiniteNumber(f);
            b.get(this)._AddWaypoint(c, f, !!h)
        }
        getTargetX() {
            return b.get(this)._GetTargetX()
        }
        getTargetY() {
            return b.get(this)._GetTargetY()
        }
        getTargetPosition() {
            const c = b.get(this);
            return [c._GetTargetX(), c._GetTargetY()]
        }
        getWaypointCount() {
            return b.get(this)._GetWaypointCount()
        }
        getWaypointX(c) {
            d.RequireFiniteNumber(c);
            return b.get(this)._GetWaypointXAt(c)
        }
        getWaypointY(c) {
            d.RequireFiniteNumber(c);
            return b.get(this)._GetWaypointYAt(c)
        }
        getWaypoint(c) {
            d.RequireFiniteNumber(c);
            const f = b.get(this);
            return [f._GetWaypointXAt(c),
                f._GetWaypointYAt(c)
            ]
        }
        stop() {
            b.get(this)._Stop()
        }
        get isMoving() {
            return b.get(this)._IsMoving()
        }
        get speed() {
            return b.get(this)._GetSpeed()
        }
        set speed(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetSpeed(c)
        }
        get maxSpeed() {
            return b.get(this)._GetMaxSpeed()
        }
        set maxSpeed(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetMaxSpeed(c)
        }
        get acceleration() {
            return b.get(this)._GetAcceleration()
        }
        set acceleration(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetAcceleration(c)
        }
        get deceleration() {
            return b.get(this)._GetDeceleration()
        }
        set deceleration(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetDeceleration(c)
        }
        get angleOfMotion() {
            return b.get(this)._GetAngleOfMotion()
        }
        set angleOfMotion(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetAngleOfMotion(c)
        }
        get rotateSpeed() {
            return b.get(this)._GetRotateSpeed()
        }
        set rotateSpeed(c) {
            d.RequireFiniteNumber(c);
            b.get(this)._SetRotateSpeed(c)
        }
        get isStopOnSolids() {
            return b.get(this)._IsStopOnSolids()
        }
        set isStopOnSolids(c) {
            b.get(this)._SetStopOnSolids(c)
        }
        get isEnabled() {
            return b.get(this)._IsEnabled()
        }
        set isEnabled(c) {
            b.get(this)._SetEnabled(c)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.MoveTo.Cnds = {
        IsMoving() {
            return this._IsMoving()
        },
        CompareSpeed(d, a) {
            return e.compare(this._GetSpeed(), d, a)
        },
        IsEnabled() {
            return this._IsEnabled()
        },
        OnArrived() {
            return !0
        },
        OnHitSolid() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.MoveTo.Acts = {
        MoveToPosition(d, a, b) {
            this._AddWaypoint(d, a, 0 === b)
        },
        MoveToObject(d, a, b) {
            if (d && (d = d.GetPairedInstance(this._inst)) && d.GetWorldInfo()) {
                var [c, f] = d.GetImagePoint(a);
                this._AddWaypoint(c, f, 0 === b)
            }
        },
        MoveAlongPathfindingPath(d) {
            var a = this._inst.GetBehaviorSdkInstanceFromCtor(e.Behaviors.Pathfinding);
            if (a && (a = a._GetPath(), 0 !== a.length))
                for (let b = 0, c = a.length; b < c; ++b) {
                    const f = a[b];
                    this._AddWaypoint(f.x, f.y, 0 === b && 0 === d)
                }
        },
        MoveAlongTimeline(d, a, b) {
            if (a =
                a ? d.GetTrackById(a) : e.first(d.GetTracks()))
                if (d = a.GetPropertyTrack("offsetX"), a = a.GetPropertyTrack("offsetY"), d && a) {
                    var c = [...d.GetPropertyKeyframeValues()],
                        f = [...a.GetPropertyKeyframeValues()];
                    if (0 !== c.length && 0 !== f.length) {
                        var h = 0,
                            g = 0,
                            k = this._inst.GetWorldInfo();
                        "relative" === d.GetResultMode() && (h = k.GetX());
                        "relative" === a.GetResultMode() && (g = k.GetY());
                        for (let m = 0, r = Math.min(c.length, f.length); m < r; ++m) this._AddWaypoint(c[m] + h, f[m] + g, 0 === m && 0 === b)
                    }
                }
        },
        MoveAlongTimelineByName(d, a, b) {
            (d = this._runtime.GetTimelineManager().GetTimelineByName(d)) &&
            e.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, d, a, b)
        },
        Stop() {
            this._Stop()
        },
        SetMovingAngle(d) {
            this._SetAngleOfMotion(e.toRadians(d))
        },
        SetSpeed(d) {
            this._SetSpeed(d)
        },
        SetMaxSpeed(d) {
            this._SetMaxSpeed(d)
        },
        SetAcceleration(d) {
            this._SetAcceleration(d)
        },
        SetDeceleration(d) {
            this._SetDeceleration(d)
        },
        SetRotateSpeed(d) {
            this._SetRotateSpeed(e.toRadians(d))
        },
        SetStopOnSolids(d) {
            this._SetStopOnSolids(d)
        },
        SetEnabled(d) {
            this._SetEnabled(d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.MoveTo.Exps = {
        Speed() {
            return this._GetSpeed()
        },
        MaxSpeed() {
            return this._GetMaxSpeed()
        },
        Acceleration() {
            return this._GetAcceleration()
        },
        Deceleration() {
            return this._GetDeceleration()
        },
        MovingAngle() {
            return e.toDegrees(this._GetAngleOfMotion())
        },
        RotateSpeed() {
            return e.toDegrees(this._GetRotateSpeed())
        },
        TargetX() {
            return this._GetTargetX()
        },
        TargetY() {
            return this._GetTargetY()
        },
        WaypointCount() {
            return this._GetWaypointCount()
        },
        WaypointXAt(d) {
            return this._GetWaypointXAt(d)
        },
        WaypointYAt(d) {
            return this._GetWaypointYAt(d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Rotate = class extends e.SDKBehaviorBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Rotate.Type = class extends e.SDKBehaviorTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Rotate.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(d, a) {
            super(d);
            this._acceleration = this._speed = 0;
            this._isEnabled = !0;
            a && (this._speed = e.toRadians(a[0]), this._acceleration = e.toRadians(a[1]), this._isEnabled = a[2]);
            this._isEnabled && this._StartTicking()
        }
        Release() {
            super.Release()
        }
        SaveToJson() {
            return {
                s: this._speed,
                a: this._acceleration,
                e: this._isEnabled
            }
        }
        LoadFromJson(d) {
            this._speed = d.s;
            this._acceleration = d.a;
            this._SetEnabled(d.e)
        }
        Tick() {
            if (this._isEnabled) {
                var d =
                    this._runtime.GetDt(this._inst);
                if (0 !== d && (0 !== this._acceleration && (this._speed += this._acceleration * d), 0 !== this._speed)) {
                    const a = this._inst.GetWorldInfo();
                    a.SetAngle(a.GetAngle() + this._speed * d);
                    a.SetBboxChanged()
                }
            }
        }
        GetPropertyValueByIndex(d) {
            switch (d) {
                case 0:
                    return e.toDegrees(this._speed);
                case 1:
                    return e.toDegrees(this._acceleration);
                case 2:
                    return this._isEnabled
            }
        }
        SetPropertyValueByIndex(d, a) {
            switch (d) {
                case 0:
                    this._speed = e.toRadians(a);
                    break;
                case 1:
                    this._acceleration = e.toRadians(a);
                    break;
                case 2:
                    this._SetEnabled(a)
            }
        }
        _SetEnabled(d) {
            (this._isEnabled = !!d) ? this._StartTicking(): this._StopTicking()
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.rotate.properties.speed.name",
                    value: e.toDegrees(this._speed),
                    onedit: d => this._speed = e.toRadians(d)
                }, {
                    name: "behaviors.rotate.properties.acceleration.name",
                    value: e.toDegrees(this._acceleration),
                    onedit: d => this._acceleration = e.toRadians(d)
                }, {
                    name: "behaviors.rotate.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: d => this._SetEnabled(d)
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.Rotate.Cnds = {
    IsEnabled() {
        return this._isEnabled
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Rotate.Acts = {
        SetSpeed(d) {
            this._speed = e.toRadians(d)
        },
        SetAcceleration(d) {
            this._acceleration = e.toRadians(d)
        },
        SetEnabled(d) {
            this._SetEnabled(d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Rotate.Exps = {
        Speed() {
            return e.toDegrees(this._speed)
        },
        Acceleration() {
            return e.toDegrees(this._acceleration)
        }
    }
} {
    const e = self.C3;
    self.C3_GetObjectRefTable = function() {
        return [e.Plugins.Text, e.Plugins.TextBox, e.Plugins.Spritefont2, e.Behaviors.Pin, e.Behaviors.Flash, e.Behaviors.Timer, e.Behaviors.Fade, e.Behaviors.Sin, e.Plugins.Sprite, e.Plugins.List, e.Plugins.Function, e.Plugins.Touch, e.Plugins.Browser, e.Plugins.AJAX, e.Plugins.LocalStorage, e.Plugins.Audio, e.Plugins.Mouse, e.Plugins.PlatformInfo, e.Plugins.Button, e.Plugins.Keyboard, e.Plugins.DrawingCanvas, e.Behaviors.DragnDrop, e.Behaviors.Tween, e.Behaviors.Persist, e.Plugins.Particles,
            e.Behaviors.scrollto, e.Behaviors.MoveTo, e.Plugins.Arr, e.Behaviors.Rotate, e.Behaviors.Fade.Cnds.OnFadeOutEnd, e.Plugins.Spritefont2.Cnds.CompareInstanceVar, e.Plugins.Spritefont2.Acts.SetText, e.Plugins.Spritefont2.Acts.AddInstanceVar, e.Behaviors.Fade.Acts.RestartFade, e.Plugins.System.Cnds.Else, e.Plugins.System.Acts.GoToLayout, e.Plugins.Touch.Cnds.OnTapGestureObject, e.Plugins.LocalStorage.Acts.SetItem, e.Plugins.Function.Acts.CallFunction, e.Plugins.System.Cnds.OnLayoutStart, e.Plugins.System.Acts.SetVar,
            e.Plugins.System.Cnds.PickByEvaluate, e.Plugins.Text.Acts.SetText, e.Plugins.System.Cnds.CompareVar, e.Plugins.System.Cnds.TriggerOnce, e.Plugins.Sprite.Acts.SetVisible, e.Plugins.System.Acts.SetTimescale, e.Behaviors.Sin.Acts.SetEnabled, e.Plugins.System.Acts.AddVar, e.Plugins.Browser.Acts.ExecJs, e.Plugins.System.Cnds.OnLoadFinished, e.Plugins.System.Acts.SetBoolVar, e.Plugins.System.Cnds.EveryTick, e.Plugins.System.Exps.loadingprogress, e.Plugins.Audio.Acts.SetSilent, e.Plugins.System.Acts.ResetGlobals, e.Plugins.LocalStorage.Acts.CheckItemExists,
            e.Plugins.Text.Acts.Destroy, e.Plugins.Sprite.Acts.Destroy, e.Plugins.Sprite.Acts.SetX, e.Plugins.AJAX.Acts.RequestFile, e.Plugins.AJAX.Cnds.OnComplete, e.Plugins.Arr.Acts.JSONLoad, e.Plugins.AJAX.Exps.LastData, e.Plugins.System.Acts.SubVar, e.Plugins.System.Exps.tokencount, e.Plugins.Sprite.Acts.SetY, e.Plugins.Sprite.Cnds.CompareInstanceVar, e.Plugins.System.Cnds.PickAll, e.Plugins.System.Acts.Wait, e.Plugins.Sprite.Acts.ToggleBoolInstanceVar, e.Plugins.Sprite.Acts.SetAnimFrame, e.Plugins.System.Exps.int, e.Plugins.LocalStorage.Cnds.OnItemExists,
            e.Plugins.LocalStorage.Exps.ItemValue, e.Plugins.Sprite.Acts.SetBoolInstanceVar, e.Plugins.System.Acts.SetLayerOpacity, e.Plugins.Sprite.Cnds.OnURLLoaded, e.Plugins.System.Acts.SetLayerVisible, e.Plugins.Function.Cnds.OnFunction, e.Plugins.Function.Exps.Param, e.Plugins.System.Exps.random, e.Plugins.Sprite.Acts.LoadURL, e.Plugins.System.Cnds.IsGroupActive, e.Plugins.Button.Cnds.OnClicked, e.Plugins.Sprite.Exps.AnimationFrame, e.Plugins.System.Exps.layoutname, e.Plugins.Particles.Acts.SetSpraying, e.Behaviors.Pin.Acts.PinByProperties,
            e.Plugins.System.Exps.replace, e.Plugins.System.Exps.tokenat, e.Plugins.System.Cnds.ForEachOrdered, e.Plugins.System.Exps.loopindex, e.Plugins.Sprite.Cnds.IsOnScreen, e.Plugins.Sprite.Acts.SetPosToObject, e.Plugins.Sprite.Acts.MoveToLayer, e.Plugins.Sprite.Exps.LayerNumber, e.Plugins.System.Cnds.Compare, e.Plugins.Sprite.Exps.Count, e.Plugins.System.Cnds.For, e.Plugins.System.Acts.CreateObject, e.Plugins.Sprite.Acts.SetInstanceVar, e.Plugins.Sprite.Acts.SetSize, e.Plugins.Sprite.Acts.SetAngle, e.Behaviors.Sin.Acts.SetMovement,
            e.Behaviors.Sin.Acts.SetPeriod, e.Behaviors.Sin.Acts.SetMagnitude, e.Plugins.System.Exps.float, e.Plugins.System.Cnds.CompareBoolVar, e.Plugins.Text.Acts.SetVAlign, e.Plugins.Sprite.Cnds.OnCreated, e.Plugins.Sprite.Cnds.IsOverlapping, e.Behaviors.Pin.Acts.Unpin, e.Plugins.Sprite.Cnds.IsBoolInstanceVarSet, e.Behaviors.Tween.Acts.TweenOneProperty, e.Plugins.System.Exps.len, e.Plugins.Text.Acts.SetVisible, e.Plugins.Text.Acts.TypewriterText, e.Plugins.System.Exps.uppercase, e.Plugins.Text.Acts.SetFontSize, e.Behaviors.Fade.Acts.StartFade,
            e.Plugins.Text.Acts.SetInstanceVar, e.Plugins.System.Exps.layoutwidth, e.Plugins.Sprite.Exps.UID, e.Plugins.Audio.Acts.StopAll, e.Plugins.Browser.Acts.ConsoleLog, e.Plugins.Text.Acts.SetHeight, e.Plugins.Text.Exps.Height, e.Plugins.Function.Cnds.CompareParam, e.Plugins.Arr.Exps.At, e.Plugins.System.Exps.viewporttop, e.Plugins.System.Exps.viewportheight, e.Behaviors.Tween.Cnds.OnTweensFinished, e.Plugins.System.Acts.SetObjectTimescale, e.Plugins.Touch.Cnds.OnTapGesture, e.Plugins.System.Cnds.LayerVisible, e.Plugins.Touch.Cnds.IsTouchingObject,
            e.Plugins.Mouse.Cnds.IsButtonDown, e.Plugins.Arr.Acts.SetSize, e.Plugins.Arr.Acts.SetXY, e.Plugins.Touch.Exps.X, e.Plugins.Touch.Exps.Y, e.Plugins.Sprite.Exps.PickedCount, e.Plugins.Sprite.Cnds.IsOnLayer, e.Plugins.System.Cnds.PickNth, e.Behaviors.Tween.Acts.TweenTwoProperties, e.Plugins.Sprite.Exps.X, e.Plugins.Sprite.Exps.Y, e.Plugins.System.Cnds.Repeat, e.Plugins.Arr.Exps.Width, e.Plugins.Sprite.Acts.SetAnim, e.Behaviors.Fade.Acts.SetFadeOutTime, e.Plugins.Sprite.Acts.SetScale, e.Behaviors.DragnDrop.Cnds.IsDragging,
            e.Plugins.Sprite.Acts.SetPos, e.Behaviors.DragnDrop.Cnds.OnDrop, e.Plugins.Mouse.Cnds.OnRelease, e.Plugins.System.Cnds.OnCanvasSnapshot, e.Plugins.System.Exps.canvassnapshot, e.Plugins.System.Exps.layoutheight, e.Plugins.Touch.Cnds.OnHoldGesture, e.Plugins.Mouse.Cnds.OnClick, e.Plugins.System.Acts.SnapshotCanvas, e.Plugins.Touch.Cnds.OnTouchStart, e.Plugins.PlatformInfo.Cnds.IsOnMobile, e.Plugins.Text.Cnds.IsRunningTypewriterText, e.Plugins.Sprite.Acts.SetOpacity, e.Plugins.System.Cnds.ForEach, e.Plugins.Sprite.Acts.Spawn,
            e.Plugins.Particles.Acts.SetRate, e.Plugins.Particles.Acts.SetSprayCone, e.Plugins.Particles.Acts.SetGravity, e.Plugins.Particles.Acts.SetInitSpeed, e.Behaviors.Pin.Acts.SetDestroy, e.Plugins.Text.Exps.Text, e.Plugins.System.Exps.find, e.Plugins.System.Acts.GoToLayoutByName, e.Plugins.Keyboard.Cnds.OnKey, e.Plugins.System.Acts.SetGroupActive, e.Behaviors.Pin.Acts.Pin, e.Plugins.Text.Acts.SetPosToObject, e.Plugins.System.Exps.max, e.Plugins.System.Exps.viewportwidth, e.Behaviors.MoveTo.Cnds.IsMoving, e.Plugins.Text.Acts.SetOpacity,
            e.Plugins.Browser.Cnds.IsPortraitLandscape, e.Plugins.Sprite.Cnds.IsVisible, e.Behaviors.MoveTo.Acts.MoveToPosition, e.Plugins.Mouse.Cnds.OnWheel, e.Plugins.Keyboard.Cnds.IsKeyDown, e.Plugins.Sprite.Cnds.CompareX, e.Plugins.Touch.Cnds.IsInTouch, e.Plugins.Mouse.Cnds.IsOverObject, e.Plugins.System.Exps.min, e.Plugins.Sprite.Exps.Height, e.Plugins.Sprite.Exps.AnimationFrameCount, e.Plugins.System.Exps.viewportleft, e.Plugins.System.Acts.SetLayerAngle, e.Plugins.System.Exps.viewportright, e.Plugins.Sprite.Exps.Width,
            e.Plugins.System.Exps.viewportbottom, e.Behaviors.Fade.Acts.SetFadeInTime, e.Plugins.Sprite.Exps.LayerName, e.Plugins.Browser.Cnds.IsFullscreen, e.Plugins.Function.Exps.ParamCount, e.Plugins.LocalStorage.Cnds.OnItemMissing, e.Plugins.Mouse.Acts.SetCursor, e.Plugins.System.Exps.layerindex, e.Plugins.Browser.Acts.GoToURLWindow, e.Behaviors.Pin.Exps.PinnedUID, e.Plugins.Browser.Acts.RequestFullScreen, e.Plugins.Browser.Acts.CancelFullScreen, e.Plugins.LocalStorage.Acts.ClearStorage, e.Plugins.Browser.Cnds.SupportsFullscreen,
            e.Plugins.Browser.Acts.GoToURL, e.Behaviors.Fade.Cnds.OnFadeInEnd, e.Plugins.Function.Acts.SetReturnValue, e.Plugins.System.Exps.regexreplace, e.Plugins.Audio.Cnds.IsTagPlaying, e.Plugins.Audio.Acts.Play, e.Plugins.Audio.Acts.SetMuted, e.Plugins.Audio.Acts.Stop, e.Plugins.Audio.Acts.PlayByName, e.Plugins.System.Acts.StopLoop, e.Plugins.Audio.Acts.SetLooping, e.Plugins.System.Acts.SetCanvasSize, e.Plugins.System.Acts.Scroll, e.Plugins.DrawingCanvas.Acts.SaveSnapshot
        ]
    };
    self.C3_JsPropNameTable = [{
            InvalidDimText: 0
        },
        {
            Text: 0
        }, {
            Text2: 0
        }, {
            TextBox: 0
        }, {
            AltAcrossTextBox: 0
        }, {
            AltDownTextBox: 0
        }, {
            species: 0
        }, {
            id: 0
        }, {
            Pin: 0
        }, {
            Flash: 0
        }, {
            Timer: 0
        }, {
            Fade: 0
        }, {
            SpriteFontOLD: 0
        }, {
            type: 0
        }, {
            panel: 0
        }, {
            Sine: 0
        }, {
            mainText: 0
        }, {
            cupsWon: 0
        }, {
            subClass: 0
        }, {
            hudFont: 0
        }, {
            group: 0
        }, {
            TextX: 0
        }, {
            hudText: 0
        }, {
            font_lik: 0
        }, {
            teamNames: 0
        }, {
            SpriteFontOLD2: 0
        }, {
            class: 0
        }, {
            picked: 0
        }, {
            res: 0
        }, {
            touchEnabled: 0
        }, {
            button: 0
        }, {
            List: 0
        }, {
            Function: 0
        }, {
            Touch: 0
        }, {
            Browser: 0
        }, {
            AJAX: 0
        }, {
            LocalStorage: 0
        }, {
            Audio: 0
        }, {
            Mouse: 0
        }, {
            PlatformInfo: 0
        }, {
            change: 0
        }, {
            ButtonX: 0
        }, {
            Keyboard: 0
        },
        {
            DrawingCanvas: 0
        }, {
            buttonLoad: 0
        }, {
            ButtonFakeShuffle: 0
        }, {
            buttonDesno: 0
        }, {
            ButtonMenuAlt: 0
        }, {
            ButtonPhoto: 0
        }, {
            buttonLevo: 0
        }, {
            ButtonShuffle: 0
        }, {
            buttonRestart: 0
        }, {
            dragging: 0
        }, {
            DragDrop: 0
        }, {
            Lupa: 0
        }, {
            bigImage: 0
        }, {
            saveButton: 0
        }, {
            Sprite2: 0
        }, {
            zoomMask: 0
        }, {
            bubble: 0
        }, {
            personNameBackground: 0
        }, {
            levelBackground: 0
        }, {
            Tween: 0
        }, {
            actionCountDown: 0
        }, {
            pointid: 0
        }, {
            Sine0: 0
        }, {
            Sine2: 0
        }, {
            hand: 0
        }, {
            taskNum: 0
        }, {
            Persist: 0
        }, {
            node: 0
        }, {
            itemToFind: 0
        }, {
            fadeAfterTouch: 0
        }, {
            tweenXRel: 0
        }, {
            tweenYRel: 0
        }, {
            touched: 0
        }, {
            movingObject: 0
        }, {
            checkmark: 0
        },
        {
            itemHOGhost: 0
        }, {
            particleTaskCompleted: 0
        }, {
            miniHOCheckmark: 0
        }, {
            particleWrongClick: 0
        }, {
            prevTouchY: 0
        }, {
            curTouchY: 0
        }, {
            DiffY: 0
        }, {
            upperLimitY: 0
        }, {
            lowerLimitY: 0
        }, {
            mouseRollDeltaY: 0
        }, {
            prevTouchX: 0
        }, {
            curTouchX: 0
        }, {
            DiffX: 0
        }, {
            upperLimitX: 0
        }, {
            lowerLimitX: 0
        }, {
            mouseRollDeltaX: 0
        }, {
            currentPage: 0
        }, {
            ScrollTo: 0
        }, {
            MoveTo: 0
        }, {
            scroller: 0
        }, {
            level: 0
        }, {
            subId: 0
        }, {
            levelButtonStarMap: 0
        }, {
            thumbURL: 0
        }, {
            levelButton: 0
        }, {
            initX: 0
        }, {
            initY: 0
        }, {
            uniPanel: 0
        }, {
            thumbFrame: 0
        }, {
            levelIntroImage: 0
        }, {
            arenabutton: 0
        }, {
            arenaselectioncircle: 0
        },
        {
            mapBackground: 0
        }, {
            map_indicator: 0
        }, {
            levelIcon: 0
        }, {
            myLogo: 0
        }, {
            mainMenuBackground: 0
        }, {
            transitionMask: 0
        }, {
            regularMask: 0
        }, {
            partnerLogo: 0
        }, {
            gametitle: 0
        }, {
            upgrade_checkmark: 0
        }, {
            glavniLik: 0
        }, {
            googleplaybadge: 0
        }, {
            changeorientationsheet: 0
        }, {
            timesNStarsArr: 0
        }, {
            crossPromoArr: 0
        }, {
            gameText: 0
        }, {
            teamsArr: 0
        }, {
            arrCup: 0
        }, {
            arrCupTemp: 0
        }, {
            trajectoryPointsArr: 0
        }, {
            trajectoryShadowsArr: 0
        }, {
            checkmarkPositions: 0
        }, {
            x1: 0
        }, {
            y1: 0
        }, {
            z1: 0
        }, {
            x2: 0
        }, {
            y2: 0
        }, {
            z2: 0
        }, {
            segmentObject: 0
        }, {
            speechbubble2: 0
        }, {
            Rotate: 0
        }, {
            hourglass: 0
        }, {
            soundoff: 0
        },
        {
            Sprite3: 0
        }, {
            Sprite: 0
        }, {
            snapshotTestButton: 0
        }, {
            senka_dugmeta: 0
        }, {
            defaultButtons: 0
        }, {
            introCounter: 0
        }, {
            loading_complete: 0
        }, {
            loading_complete2: 0
        }, {
            SHOW_INIT_PLAY_BUTTON: 0
        }, {
            initCounter: 0
        }, {
            ALL_MUTED: 0
        }, {
            allLevelsData: 0
        }, {
            SKIP_INTRO: 0
        }, {
            imagePath: 0
        }, {
            frameToSet: 0
        }, {
            rewardAdGoingOn: 0
        }, {
            questionNumber: 0
        }, {
            maxQuestions: 0
        }, {
            timeOnLevel: 0
        }, {
            hoModeExists: 0
        }, {
            levelSuccess: 0
        }, {
            numOfMovingObjects: 0
        }, {
            postojeMrakObjekti: 0
        }, {
            UPGRADES_ENABLED: 0
        }, {
            rewardAdPrize: 0
        }, {
            clickCoolDown: 0
        }, {
            skipButtonReminderTimer: 0
        }, {
            reminderTimerInit: 0
        },
        {
            tutorialShown: 0
        }, {
            FDmod: 0
        }, {
            currentLevelData: 0
        }, {
            currentTaskData: 0
        }, {
            currentTaskFull: 0
        }, {
            currentTaskShort: 0
        }, {
            currentTaskConclusion: 0
        }, {
            currentTaskPersonsNames: 0
        }, {
            actionText: 0
        }, {
            speechBubbles: 0
        }, {
            numOfPersonsOnStage: 0
        }, {
            itemToFindFrames: 0
        }, {
            sumaFrejmovaItemToFind: 0
        }, {
            nodesDescription: 0
        }, {
            movingObjectsDescription: 0
        }, {
            observedMovingObject: 0
        }, {
            observedNode: 0
        }, {
            nodeLayer: 0
        }, {
            personsComment: 0
        }, {
            accuWaitTimeString: 0
        }, {
            accuDelay: 0
        }, {
            delayTime: 0
        }, {
            typeWriterTime: 0
        }, {
            failTextIndex: 0
        }, {
            onlyAnswerNodesPresent: 0
        },
        {
            numOfOrdinaryNodes: 0
        }, {
            numOfAnswerNodes: 0
        }, {
            checkmarkX: 0
        }, {
            checkmarkY: 0
        }, {
            findDifferencesMode: 0
        }, {
            goodClick: 0
        }, {
            frontObjectTouched: 0
        }, {
            touchedMovingObjTaskNum: 0
        }, {
            correctNodeID: 0
        }, {
            ignoreClick: 0
        }, {
            correctClick: 0
        }, {
            touchOffset: 0
        }, {
            magnScale: 0
        }, {
            s: 0
        }, {
            AFTER_AD_LAYOUT: 0
        }, {
            ImageFrame: 0
        }, {
            levelOfDifficulty: 0
        }, {
            lastSelectedSize: 0
        }, {
            LANGUAGE_ID: 0
        }, {
            OLD_OR_NEW_GAME: 0
        }, {
            SOUND_STATUS: 0
        }, {
            MUSIC_STATUS: 0
        }, {
            MYPLACE: 0
        }, {
            GOOGLE_PLAY: 0
        }, {
            LICENSING_PAGE: 0
        }, {
            imagesURLPrefix: 0
        }, {
            partnerURL: 0
        }, {
            ANDROID: 0
        }, {
            ANDROID_INTER_STATUS: 0
        },
        {
            LINKS_ALLOWED: 0
        }, {
            SHOW_CROSS_PROMO: 0
        }, {
            CRAZYGAMES_ENABLED: 0
        }, {
            LAGGED_ENABLED: 0
        }, {
            POKI_ENABLED: 0
        }, {
            GAMEDISTRIBUTION_ENABLED: 0
        }, {
            GAMEDISTRIBUTION_LOADED_OK: 0
        }, {
            localGameStorage: 0
        }, {
            money: 0
        }, {
            ROUND_NAMES: 0
        }, {
            levelPicked: 0
        }, {
            ANY_ORIENTATIONS_ALLOWED: 0
        }, {
            SHOW_LEVEL_INTRO: 0
        }, {
            SCROLLING_ALLOWED: 0
        }, {
            SHOW_LEVEL_NUMBERS: 0
        }, {
            RECTANGLE_POSITIONING_BUTTONS: 0
        }, {
            SCROLLER_INITIAL_MOVE: 0
        }, {
            levelSets: 0
        }, {
            levelUnlocked: 0
        }, {
            levelsNum: 0
        }, {
            fiksnaSirina: 0
        }, {
            fiksnaVisina: 0
        }, {
            UCITAVANJE_THUMBOVA: 0
        }, {
            poslednjiUcitan: 0
        }, {
            thumbsXnum: 0
        },
        {
            xOffset: 0
        }, {
            offsetScroll: 0
        }, {
            indIndex2: 0
        }, {
            touchedIndicatorID: 0
        }, {
            currentIndicatorID: 0
        }, {
            minutes: 0
        }, {
            seconds: 0
        }, {
            temp: 0
        }, {
            buttonsRows: 0
        }, {
            buttonsColumns: 0
        }, {
            thumbsYnum: 0
        }, {
            xFactor: 0
        }, {
            yFactor: 0
        }, {
            buttonsPerPage: 0
        }, {
            totalCounter: 0
        }, {
            indOffset: 0
        }, {
            pocCoordinate: 0
        }, {
            indIndex: 0
        }, {
            desiredIndicatorID: 0
        }, {
            nextLayoutName: 0
        }, {
            pokiEvent: 0
        }, {
            result: 0
        }, {
            buttonClass: 0
        }, {
            soundTagsList: 0
        }, {
            soundFilesList: 0
        }, {
            soundTag: 0
        }, {
            soundVolume: 0
        }, {
            soundLooping: 0
        }, {
            soundFile: 0
        }, {
            orient: 0
        }
    ]
} {
    function e(b, c) {
        return "number" === typeof b && "number" === typeof c
    }

    function d(b, c) {
        return "string" === typeof b || "string" === typeof c ? ("number" === typeof b ? (Math.round(1E10 * b) / 1E10).toString() : b) + ("number" === typeof c ? (Math.round(1E10 * c) / 1E10).toString() : c) : b && c ? 1 : 0
    }

    function a(b, c) {
        return e(b, c) ? b || c ? 1 : 0 : b
    }
    self.C3_ExpressionFuncs = [() => 0, () => "OR...WAS IT WORLD WAR 4?", () => 1, b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "skipIntro"
        }, () => "YES", () => "startIt", b => {
            const c = b._GetNode(0).GetVar();
            return () =>
                c.GetValue() + "introshown"
        }, b => {
            const c = b._GetNode(0);
            return () => 1 >= c.ExpInstVar() ? 1 : 0
        }, () => "", b => {
            const c = b._GetNode(0);
            return () => 0 === c.ExpInstVar() ? 1 : 0
        }, () => "HI HONEY, WANNA GO FOR A RIDE?", b => {
            const c = b._GetNode(0);
            return () => 1 === c.ExpInstVar() ? 1 : 0
        }, () => "ARE YOU NUTS? ROADS ARE FULL OF GIANT ZOMBIES AND WILD SELF-DRIVING CARS!", () => 2, () => "C'MON, IT WILL BE FUN!", () => 3, () => "HMMM...", () => 4, () => "OK, LET ME GET MY ROCKET LAUNCHER", () => 5, () => "LOADING...", () => "PokiSDK.gameLoadingStart();", () => "crazyInit();",
        () => "yes", () => "100%", () => "PokiSDK.gameLoadingFinished();", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => d(Math.round(100 * c()), "%")
        }, () => "no", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => d("PokiSDK.gameLoadingProgress({percentageDone:", c()) + "});"
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "allMuted"
        }, () => -500, () => "gameText", () => "timesNstars", () => "levelData", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c()
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), "---") - 2
        },
        b => {
            const c = b._GetNode(0);
            return () => "go" === c.ExpInstVar() ? 1 : 0
        }, () => 225, b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "soundStatus"
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue().toString()
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "musicStatus"
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue()
        }, () => "NO", () => "go", () => .5, () => "skipIntro", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => 32 + c(f.ExpInstVar())
        },
        b => {
            const c = b._GetNode(0);
            return () => c.ExpInstVar() ? "YES" : "NO"
        }, () => "muteSounds", b => {
            const c = b._GetNode(0);
            return () => "skipIntro" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => 32 + ("YES" === c.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0);
            return () => "muteSounds" === c.ExpInstVar() ? 1 : 0
        }, () => 100, () => "Mask", () => "loadBackground", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c(0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod();
            return () => d(c.GetValue() +
                "level_images/backgrounds/" + f.GetValue().toString() + ".jpg?r=", Math.floor(h(999999)))
        }, () => "Test dugmad", b => {
            const c = b._GetNode(0);
            return () => c.ExpObject() + 1
        },
        b => {
            const c = b._GetNode(0);
            return () => c.ExpObject() - 1
        },
        b => {
            const c = b._GetNode(0);
            return () => c.ExpObject()
        }, () => "Zooming", () => "initActionLayout", b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "gamevars"
        },
        b => {
            const c = b._GetNode(0);
            return () => "levelIntro" === c.ExpInstVar() ? 1 : 0
        }, () => "prepareLevel", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetVar();
            return () => c(f(h.GetValue(), g.GetValue(), "---"), "\n", "")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetVar();
            return () => c(f.GetValue(), h.GetValue(), "//")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 0, "#"), ";")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetVar();
            return () => c(f(h.GetValue(), 0, "#"), g.GetValue(), ";")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetVar();
            return () => c(f(h.GetValue(), 1, "#"), g.GetValue(), ";")
        },
        b => {
            const c = b._GetNode(0);
            return () => "text_levelIntro" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), "|", "\n")
        },
        b => {
            const c = b._GetNode(0);
            return () => "text_actionPanel" === c.ExpInstVar() ?
                1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 3, "#")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 4, "#")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), ";")
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1),
                h = b._GetNode(2).GetVar();
            return () => d("persons" === c.ExpInstVar() ? 1 : 0, f.ExpInstVar() >= h.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpInstVar() >= f.GetValue() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "speech" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "personName" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => c.ExpInstVar()
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod();
            return () => c(f.GetValue(), h(), ";")
        },
        b => {
            const c = b._GetNode(0);
            return () => "persons" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1),
                h = b._GetNode(2);
            return () =>
                a(a(-10 === c.ExpInstVar() ? 1 : 0, -99 === f.ExpInstVar() ? 1 : 0), 999 < h.ExpInstVar() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 7, "#")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3).GetVar(),
                k = b._GetNode(4).GetBoundMethod();
            return () => c(f(h(g.GetValue(), k(), ";"), 1, ","))
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => c.ExpInstVar() === f.ExpInstVar() ? 1 : 0
        }, () => "checkmark", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3).GetVar();
            return () => c(f(h(g.GetValue(), 8, "#"), 1, ";"))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 5, "#")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 6, "#")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), ";") - 1
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 1, ",")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 2, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 3, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 12, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 7, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 8, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 14, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 13, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 4, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 5, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 6, ","))
        }, () => 999, b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(),
                11, ",")
        }, () => "Angle", () => "Vertical", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 9, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 10, ","))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), ",")
        }, () => 8, b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(),
                8, ",")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar();
            return () => c(f(h.GetValue(), 1, ","))
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() - 1
        },
        b => {
            const c = b._GetNode(0);
            return () => "actionPanel" === c.ExpInstVar() ? 1 : 0
        }, () => "initAndShowIntro", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => c.ExpObject() === f.ExpObject() - 1 ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "title_levelIntro" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => d("CASE: ", c.GetValue() + 1)
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => d("TASK ", c.GetValue() + 1) + ":"
        }, () => "FINAL TASK:", () => "YOUR TASK:", () => 60, () => "showIntroPanel", () => "intro", b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(2 === c.GetValue() ? 1 : 0, 1 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(4 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(6 === c.GetValue() ?
                1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(7 === c.GetValue() ? 1 : 0, 2 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(9 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(13 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(15 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c =
                b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(34 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(37 === c.GetValue() ? 1 : 0, 1 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(27 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(40 === c.GetValue() ? 1 : 0, 0 === f.GetValue() ? 1 : 0)
        }, () => "tweenZoomInfoPanel", () => 520, () => 600, () =>
        "restart_levelOver", () => "initGameVars", () => "stopAllSounds", () => "layoutTransition", () => "Ad", () => "forward_levelOver", () => "levelOverButton", () => "showIntro", () => "PokiSDK.gameplayStop();", () => "close_questionSuccess", () => "Map", () => "close_levelIntroPanel", () => 30, () => .7, b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2);
            return () => c(f.GetValue(), h.ExpInstVar(), ";")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => 1.2 * (c(f.GetValue()) / 30)
        },
        b => {
            const c =
                b._GetNode(0).GetVar();
            return () => c.GetValue() + .5
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => d(c.GetValue() + ";", f.GetValue() + 0)
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3);
            return () => c(f(h.GetValue(), g.ExpInstVar(), ";"))
        }, () => 65, () => 13, () => "speechCompleted", () => "showRewardOffer", b => {
            const c = b._GetNode(0);
            return () => "rewardAdOffer" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => .5 * c()
        }, () => "paused", () => "accept_close_rewardAdOffer", () => "showRewardAd();", () => "rewardAdFinishedOk", () => "C3: reward Ad finished OK", () => "unpause", () => "taskSuccess", () => "rewardAdError", () => "C3: reward Ad Error", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => -.5 * c()
        }, () => "updateGameVars", () => "levelSuccess", () => "SUCCESS!", b => {
            const c = b._GetNode(0);
            return () => .7 * c.ExpObject()
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3).GetVar(),
                k = b._GetNode(4).GetVar();
            return () => c(f(h(g.GetValue(), 2, "#"), k.GetValue(), ";"), "|", "\n")
        }, () => "YOU HAVE COMPLETED THE GAME.\nCONGRATS!", b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "levelUnlocked"
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "questionNumber"
        },
        b => {
            const c = b._GetNode(0);
            return () => "pause" === c.ExpInstVar() ? 1 : 0
        }, () => "PokiSDK.happyTime(0.5);", () => 9, () => 14, () => "success",
        () => "panelBackToInitPosition", () => "levelFail", b => {
            const c = b._GetNode(0);
            return () => "title_levelOver" === c.ExpInstVar() ? 1 : 0
        }, () => "time", () => 17, () => 16, b => {
            const c = b._GetNode(0);
            return () => "text_levelOver" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2),
                g = b._GetNode(3).GetVar();
            return () => c(f(h.ExpObject(g.GetValue()), "|", "\n"))
        },
        b => {
            const c = b._GetNode(0);
            return () => "levelOver" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c("HUD") + .5 * f("HUD")
        },
        b => {
            const c = b._GetNode(0);
            return () => "close_levelIntroPanel" === c.ExpInstVar() ? 1 : 0
        }, () => "TEST DETECTIVE", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpInstVar() === f.GetValue() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => 0 <= c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpInstVar_InstExpr(f())
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpInstVar_InstExpr(f() +
                1)
        },
        b => {
            const c = b._GetNode(0);
            return () => 0 > c.ExpInstVar() ? 1 : 0
        }, () => "frontObjects", () => -1, () => "correctNodeClicked", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => c.ExpObject() + f.ExpInstVar()
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpInstVar() === f.GetValue() + 1E3 ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 1, ";")
        }, () => "soundPlay", () => "wrongclick", () => "wrongAnswerText", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 4, ";")
        }, () => "UI2", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpObject(f(), 0)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpObject(f(), 1)
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() ? "correct" : "wrong"
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() ? 0 : 1
        }, () => .6, b => {
            const c = b._GetNode(0);
            return () => "showRewardOffer" === c.ExpInstVar() ? 1 : 0
        }, () => "Skip button reminder", () => "ZUMIRANJE", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c() - f.GetValue()
        }, () => "zumelementi", () => .2, b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetBoundMethod();
            return () => d(d(c.GetValue() + "level_images/backgrounds/", 0) + ".jpg?r=", Math.floor(f(999999)))
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.GetValue() * f()
        }, () => 75, b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => -c.ExpObject() * (f.GetValue() - 1)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1),
                h = b._GetNode(2);
            return () =>
                800 < c.ExpObject() ? 800 : 0 > f.ExpObject() ? 0 : h.ExpObject()
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1),
                h = b._GetNode(2);
            return () => 450 < c.ExpObject() ? 450 : 0 > f.ExpObject() ? 0 : h.ExpObject()
        }, () => "-!-", () => "blip-clock", () => -20, b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2),
                g = b._GetNode(3).GetVar();
            return () => d(c.ExpInstVar() === f.GetValue() ? 1 : 0, h.ExpInstVar() === g.GetValue() ? 1 : 0)
        }, () => "ok1", () => "particles", () => 360, () => 20, b => {
            const c = b._GetNode(0).GetVar();
            return () => Math.ceil(.5 * c.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetVar();
            return () => c(f(h.GetValue(), 0, ";"), "##", g.GetValue().toString())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2),
                g = b._GetNode(3).GetVar();
            return () => c(f(h.ExpObject(), "%%", 1 < g.GetValue() ? "s" : ""))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2);
            return () => c(f(h.ExpObject(), "clue", "item"))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 2, ";")
        },
        b => {
            const c = b._GetNode(0);
            return () => -99 === c.ExpInstVar() ? 1 : 0
        }, () => 50, () => "THAT'S IT!", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c(f(), "action")
        }, () => 300, () => "task_completed", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 5, ";")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(),
                6, ";")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 3, ";")
        },
        b => {
            const c = b._GetNode(0);
            return () => "zoomInfo" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "text_zoomInfo" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue(), 7, ";")
        }, () => "preRoll layout started", () => "showAd();", () => "afterAd", () => "Ad finished or not loaded", () => "ADS", () => "adFinished", () => "Ad finished", () => "adRequested",
        () => "Ad requested", () => "adError", () => "Ad error", () => "gameFinished", () => "Game Finished", () => "GAMEDISTRIBUTION", () => "LAGGED", b => {
            const c = b._GetNode(0);
            return () => "gamecomplete_forward" === c.ExpInstVar() ? 1 : 0
        }, () => "gamecomplete_forward", () => "mainMenu", () => "detectiveAction", b => {
            const c = b._GetNode(0);
            return () => "play" === c.ExpInstVar() ? 1 : 0
        }, () => "forward", () => "play", () => -400, b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => a("forward" === c.ExpInstVar() ? 1 : 0, "play" === f.ExpInstVar() ? 1 : 0)
        }, () => "forwardOrPlay",
        () => "init_text", () => "TouchScroll", b => {
            const c = b._GetNode(0);
            return () => "scroll" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => .4 * c.GetValue()
        }, () => "level buttons", () => -1E3, b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1),
                h = b._GetNode(2).GetBoundMethod();
            return () => d(c.GetValue() + "level_images/thumbs/" + f.ExpInstVar().toString() + ".jpg?r=", Math.floor(h(999999)))
        }, () => "thumbFrames", () => "levelIcon", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpInstVar() >= f.GetValue() -
                1 ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1),
                h = b._GetNode(2),
                g = b._GetNode(3).GetBoundMethod(),
                k = b._GetNode(4).GetBoundMethod(),
                m = b._GetNode(5).GetBoundMethod();
            return () => Math.ceil(c(f.ExpObject(), h.ExpObject()) / g(k("basicHUD"), m("basicHUD")))
        }, () => "map UI", b => {
            const c = b._GetNode(0);
            return () => "levelIntroPanel" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => d("levelIntroPanel" === c.ExpInstVar() ? 1 : 0, 1 === f.ExpInstVar() ? 1 : 0)
        }, () => "FIRING IS AUTOMATIC", () =>
        "updateMapIndicator", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHUD")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetBoundMethod();
            return () => c(f("basicHUD"), h("basicHUD"))
        }, () => "scroll", () => "next", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpObject() - f.GetValue()
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpObject() + f.GetValue()
        }, () => "jumpToPage", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => d("next" === c.ExpInstVar() ? 1 : 0, "scroll" === f.ExpInstVar() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => d("previous" === c.ExpInstVar() ? 1 : 0, "scroll" === f.ExpInstVar() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => Math.abs(c.ExpInstVar() - f.ExpInstVar())
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpObject() - f("basicHUD")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3);
            return () => c(f.ExpObject() +
                h("basicHUD"), g.ExpInstVar())
        }, () => "button_click", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c("basicHud") + .5 * f("basicHud")
        }, () => "levelStart", () => "closeIntro", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => c("basicHud") - 2 * f.ExpObject()
        }, () => "play_levelIntroPanel", () => "thumbsSetUp", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar();
            return () => c.ExpInstVar() === f.GetValue() - 1 ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1),
                h = b._GetNode(2).GetBoundMethod();
            return () => -c("basicHUD") * Math.floor(f.ExpObject() / h("basicHUD") - 1)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => d("scroll" === c.ExpInstVar() ? 1 : 0, "previous" === f.ExpInstVar() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => d("scroll" === c.ExpInstVar() ? 1 : 0, "next" === f.ExpInstVar() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetBoundMethod();
            return () => d(c.GetValue() + "level_images/thumbs/" + f().toString() + ".jpg?r=",
                Math.floor(h(999999)))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1),
                h = b._GetNode(2).GetBoundMethod();
            return () => c(f.ExpObject(h(), 0))
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => Math.floor(c.GetValue() / 60)
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => c.GetValue() - 60 * f.GetValue()
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod();
            return () => c() <= f.GetValue() ? (h() + 1).toString() : ""
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c() + 1
        }, () => "levelIntroPanel", b => {
            const c = b._GetNode(0);
            return () => "play_levelIntroPanel" === c.ExpInstVar() ? 1 : 0
        }, () => "levelButtonsPrepak", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => Math.floor(c("basicHud") / (1.35 * f.GetValue()))
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => Math.ceil(c.GetValue() / f.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetVar(),
                k = b._GetNode(4).GetVar();
            return () => c(f.GetValue() * h.GetValue(), Math.round(g.GetValue() / k.GetValue()))
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => Math.round(c.GetValue() / f.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => 800 === c("basicHud") ? .195 : .23
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => 800 === c("basicHud") ? .23 : .195
        }, () => "i", () => "j", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3).GetBoundMethod(),
                k = b._GetNode(4).GetVar(),
                m = b._GetNode(5).GetVar(),
                r = b._GetNode(6).GetBoundMethod(),
                w = b._GetNode(7).GetVar(),
                p = b._GetNode(8).GetVar();
            return () => c("basicHud") + f.GetValue() * h("basicHud") + 1.2 * (g("j") % k.GetValue()) * m.GetValue() + r("basicHud") * Math.floor(w.GetValue() / p.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3).GetVar(),
                k = b._GetNode(4).GetBoundMethod(),
                m = b._GetNode(5).GetVar();
            return () => c("basicHud") + f.GetValue() * h("basicHud") +
                1.2 * g.GetValue() * Math.floor(k("j") / m.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1).GetVar();
            return () => (1 - c.GetValue()) * f.GetValue()
        }, () => 90, b => {
            const c = b._GetNode(0);
            return () => "next" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHud") + 150
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHud") - 20
        },
        b => {
            const c = b._GetNode(0);
            return () => "previous" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHud") -
                150
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHud") + 20
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1),
                h = b._GetNode(2).GetVar();
            return () => .5 * (c.GetValue() - 1) * (f.ExpObject() + h.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod(),
                g = b._GetNode(3).GetBoundMethod(),
                k = b._GetNode(4),
                m = b._GetNode(5).GetVar();
            return () => c("basicHUD") - f.GetValue() + .5 * h("basicHUD") + g() * (k.ExpObject() + m.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2),
                g = b._GetNode(3).GetVar();
            return () => c("basicHUD") + .5 * f("basicHUD") - h.ExpObject() + g.GetValue() + 550
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetBoundMethod(),
                k = b._GetNode(4),
                m = b._GetNode(5).GetVar();
            return () => c("basicHUD") + .5 * f("basicHUD") - h.GetValue() + g() * (k.ExpObject() + m.GetValue())
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => c("basicHUD") - f.ExpObject()
        },
        b => {
            const c = b._GetNode(0).GetVar(),
                f = b._GetNode(1),
                h = b._GetNode(2).GetVar();
            return () => Math.round((c.GetValue() - f.ExpObject()) / h.GetValue())
        },
        b => {
            const c = b._GetNode(0);
            return () => 1 === c.ExpObject() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetVar(),
                g = b._GetNode(3).GetVar();
            return () => c.ExpObject() + (f.GetValue() - h.GetValue()) * g.GetValue()
        }, () => "Init", b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "tutorialShown"
        }, () => "actionProto", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1),
                h = b._GetNode(2);
            return () => -1 !== c(f.ExpInstVar(), h.ExpInstVar()) ? 1 : 0
        }, () => "creditsPanel", b => {
            const c = b._GetNode(0);
            return () => "creditsPanel" === c.ExpObject() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "our_partners" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "more_games" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "dotcom" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "fullScreen" === c.ExpInstVar() ? 1 : 0
        }, () => 28, () => 27, b => {
            const c = b._GetNode(0);
            return () =>
                "text_creditsPanel" === c.ExpInstVar() ? 1 : 0
        }, () => "DEVELOPER:\nDPARROTINT@GMAIL.COM", b => {
            const c = b._GetNode(0);
            return () => 2 === c.ExpInstVar() ? 1 : 0
        }, () => "MUSIC: SPY GLASS BY KEVIN MACLEOD   \nLINK: HTTPS://FILMMUSIC.IO/SONG/4410-SPY-GLASS  \nLICENSE: HTTPS://FILMMUSIC.IO/STANDARD-LICENSE", () => "soundCheck", () => .1, b => {
            const c = b._GetNode(0).GetVar();
            return () => d("poki event defined: ", c.GetValue())
        }, () => "PokiSDK.gameplayStart();", () => "LOCAL STORAGE", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c(f())
        }, () => "CURSOR LOOKS", () => "BUTTONS", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpObject() < f("Mask") ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => c.GetValue() + "_logo"
        }, () => "_blank", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => c(f.ExpInstVar(), "close")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => c(f.ExpInstVar(), "confirm")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => c(f.ExpInstVar(),
                "menu")
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => c.ExpObject() === f.ExpBehavior() ? 1 : 0
        }, () => "menu", () => "map", () => "sound", b => {
            const c = b._GetNode(0).GetVar();
            return () => 1 - c.GetValue()
        }, () => "music", () => "trash", b => {
            const c = b._GetNode(0);
            return () => "rUSurePanel" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c() / 2
        },
        b => {
            const c = b._GetNode(0);
            return () => "pausePanel" === c.ExpInstVar() ? 1 : 0
        }, () => "pause", () => "fullScreen", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => 28 - c(f.ExpInstVar())
        }, () => "confirm_bigReset", () => "close_rUSurePanel", () => 1E3, () => "more_games", () => "credits", b => {
            const c = b._GetNode(0);
            return () => "creditsPanel" === c.ExpInstVar() ? 1 : 0
        }, () => "close_creditsPanel", () => "LAYOUT TRANSITIONS", () => "OTHER", () => "commaSep", b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => Math.round(c(0))
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar();
            return () => c(f.GetValue().toString(), "\\d{1,3}(?=(\\d{3})+(?!\\d))", "g", "$&,")
        }, () => "1st ad", () =>
        "titlesCount", b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => c.ExpObject() === f(0) ? 1 : 0
        }, () => "SPACE", () => "closePanel", () => "GASENJE PANELA", b => {
            const c = b._GetNode(0);
            return () => "sound" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => 21 + c.GetValue()
        },
        b => {
            const c = b._GetNode(0);
            return () => "music" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetVar();
            return () => 34 + c.GetValue()
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () =>
                c(f(), "intro")
        }, () => "soundtrack", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetVar(),
                h = b._GetNode(2).GetBoundMethod();
            return () => c(f.GetValue(), h(), ",")
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c(1)
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c(2)
        }, () => "looping", () => 450, () => 800, () => "buttonsRepositioning", () => "portrait", () => .8, () => "landscape", b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1);
            return () => c("basicHud") - f.ExpObject()
        },
        b => {
            const c = b._GetNode(0);
            return () => "nextPlayer" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0);
            return () => "left" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c("basicHud") + .05 * f("basicHud")
        },
        b => {
            const c = b._GetNode(0);
            return () => "right" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod(),
                f = b._GetNode(1).GetBoundMethod();
            return () => c("basicHud") - .05 * f("basicHud")
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1);
            return () => a("startTheMatch" === c.ExpInstVar() ?
                1 : 0, "gamecomplete_forward" === f.ExpInstVar() ? 1 : 0)
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHud") - 85
        },
        b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => c("basicHud") - 50
        }, () => 400, () => 500, () => 705, () => 410, b => {
            const c = b._GetNode(0).GetBoundMethod();
            return () => .95 * c("basicHud")
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => .7 * c.ExpObject() + f("basicHud")
        },
        b => {
            const c = b._GetNode(0);
            return () => "credits" === c.ExpInstVar() ? 1 : 0
        },
        b => {
            const c = b._GetNode(0),
                f = b._GetNode(1).GetBoundMethod();
            return () => 2 * c.ExpObject() + f("basicHud")
        }, () => "wrong_orient", () => "rewardAdPreload", () => "destroySkipButton", () => "c3: try to preload reward ad", () => "preloadRewardAd();", () => "rewardAdPreloadedOK", () => "c3: reward ad preloaded ok", () => "c3: reward ad not available, hide the button", b => {
            const c = b._GetNode(0);
            return () => 22 === c.ExpInstVar() ? 1 : 0
        }, () => "rewardAdPreloadError"
    ]
}
var module$str$c3runtime = {};
var module$str$__c3root__ = {};